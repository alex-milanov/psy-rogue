// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"5AHcD":[function(require,module,exports) {
var global = arguments[3];
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SECURE = false;
var HMR_ENV_HASH = "d6ea1d42532a7575";
var HMR_USE_SSE = false;
module.bundle.HMR_BUNDLE_ID = "ba60c367739bf03c";
"use strict";
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE, HMR_USE_SSE, chrome, browser, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: {|[string]: mixed|};
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
interface ExtensionContext {
  runtime: {|
    reload(): void,
    getURL(url: string): string;
    getManifest(): {manifest_version: number, ...};
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
declare var HMR_USE_SSE: boolean;
declare var chrome: ExtensionContext;
declare var browser: ExtensionContext;
declare var __parcel__import__: (string) => Promise<void>;
declare var __parcel__importScripts__: (string) => Promise<void>;
declare var globalThis: typeof self;
declare var ServiceWorkerGlobalScope: Object;
*/ var OVERLAY_ID = "__parcel__error__overlay__";
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData[moduleName],
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function(fn) {
            this._acceptCallbacks.push(fn || function() {});
        },
        dispose: function(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData[moduleName] = undefined;
}
module.bundle.Module = Module;
module.bundle.hotData = {};
var checkedAssets /*: {|[string]: boolean|} */ , assetsToDispose /*: Array<[ParcelRequire, string]> */ , assetsToAccept /*: Array<[ParcelRequire, string]> */ ;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf("http") === 0 ? location.hostname : "localhost");
}
function getPort() {
    return HMR_PORT || location.port;
}
// eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== "undefined") {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == "https:" && ![
        "localhost",
        "127.0.0.1",
        "0.0.0.0"
    ].includes(hostname) ? "wss" : "ws";
    var ws;
    if (HMR_USE_SSE) ws = new EventSource("/__parcel_hmr");
    else try {
        ws = new WebSocket(protocol + "://" + hostname + (port ? ":" + port : "") + "/");
    } catch (err) {
        if (err.message) console.error(err.message);
        ws = {};
    }
    // Web extension context
    var extCtx = typeof browser === "undefined" ? typeof chrome === "undefined" ? null : chrome : browser;
    // Safari doesn't support sourceURL in error stacks.
    // eval may also be disabled via CSP, so do a quick check.
    var supportsSourceURL = false;
    try {
        (0, eval)('throw new Error("test"); //# sourceURL=test.js');
    } catch (err) {
        supportsSourceURL = err.stack.includes("test.js");
    }
    // $FlowFixMe
    ws.onmessage = async function(event /*: {data: string, ...} */ ) {
        checkedAssets = {} /*: {|[string]: boolean|} */ ;
        assetsToAccept = [];
        assetsToDispose = [];
        var data /*: HMRMessage */  = JSON.parse(event.data);
        if (data.type === "update") {
            // Remove error overlay if there is one
            if (typeof document !== "undefined") removeErrorOverlay();
            let assets = data.assets.filter((asset)=>asset.envHash === HMR_ENV_HASH);
            // Handle HMR Update
            let handled = assets.every((asset)=>{
                return asset.type === "css" || asset.type === "js" && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear();
                // Dispatch custom event so other runtimes (e.g React Refresh) are aware.
                if (typeof window !== "undefined" && typeof CustomEvent !== "undefined") window.dispatchEvent(new CustomEvent("parcelhmraccept"));
                await hmrApplyUpdates(assets);
                // Dispose all old assets.
                let processedAssets = {} /*: {|[string]: boolean|} */ ;
                for(let i = 0; i < assetsToDispose.length; i++){
                    let id = assetsToDispose[i][1];
                    if (!processedAssets[id]) {
                        hmrDispose(assetsToDispose[i][0], id);
                        processedAssets[id] = true;
                    }
                }
                // Run accept callbacks. This will also re-execute other disposed assets in topological order.
                processedAssets = {};
                for(let i = 0; i < assetsToAccept.length; i++){
                    let id = assetsToAccept[i][1];
                    if (!processedAssets[id]) {
                        hmrAccept(assetsToAccept[i][0], id);
                        processedAssets[id] = true;
                    }
                }
            } else fullReload();
        }
        if (data.type === "error") {
            // Log parcel errors to console
            for (let ansiDiagnostic of data.diagnostics.ansi){
                let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                console.error("\uD83D\uDEA8 [parcel]: " + ansiDiagnostic.message + "\n" + stack + "\n\n" + ansiDiagnostic.hints.join("\n"));
            }
            if (typeof document !== "undefined") {
                // Render the fancy html overlay
                removeErrorOverlay();
                var overlay = createErrorOverlay(data.diagnostics.html);
                // $FlowFixMe
                document.body.appendChild(overlay);
            }
        }
    };
    if (ws instanceof WebSocket) {
        ws.onerror = function(e) {
            if (e.message) console.error(e.message);
        };
        ws.onclose = function() {
            console.warn("[parcel] \uD83D\uDEA8 Connection to the HMR server was lost");
        };
    }
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log("[parcel] \u2728 Error resolved");
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement("div");
    overlay.id = OVERLAY_ID;
    let errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    for (let diagnostic of diagnostics){
        let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame)=>{
            return `${p}
<a href="/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}" style="text-decoration: underline; color: #888" onclick="fetch(this.href); return false">${frame.location}</a>
${frame.code}`;
        }, "") : diagnostic.stack;
        errorHTML += `
      <div>
        <div style="font-size: 18px; font-weight: bold; margin-top: 20px;">
          \u{1F6A8} ${diagnostic.message}
        </div>
        <pre>${stack}</pre>
        <div>
          ${diagnostic.hints.map((hint)=>"<div>\uD83D\uDCA1 " + hint + "</div>").join("")}
        </div>
        ${diagnostic.documentation ? `<div>\u{1F4DD} <a style="color: violet" href="${diagnostic.documentation}" target="_blank">Learn more</a></div>` : ""}
      </div>
    `;
    }
    errorHTML += "</div>";
    overlay.innerHTML = errorHTML;
    return overlay;
}
function fullReload() {
    if ("reload" in location) location.reload();
    else if (extCtx && extCtx.runtime && extCtx.runtime.reload) extCtx.runtime.reload();
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var href = link.getAttribute("href");
    if (!href) return;
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute("href", // $FlowFixMe
    href.split("?")[0] + "?" + Date.now());
    // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href /*: string */  = links[i].getAttribute("href");
            var hostname = getHostname();
            var servedFromHMRServer = hostname === "localhost" ? new RegExp("^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):" + getPort()).test(href) : href.indexOf(hostname + ":" + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrDownload(asset) {
    if (asset.type === "js") {
        if (typeof document !== "undefined") {
            let script = document.createElement("script");
            script.src = asset.url + "?t=" + Date.now();
            if (asset.outputFormat === "esmodule") script.type = "module";
            return new Promise((resolve, reject)=>{
                var _document$head;
                script.onload = ()=>resolve(script);
                script.onerror = reject;
                (_document$head = document.head) === null || _document$head === void 0 || _document$head.appendChild(script);
            });
        } else if (typeof importScripts === "function") {
            // Worker scripts
            if (asset.outputFormat === "esmodule") return import(asset.url + "?t=" + Date.now());
            else return new Promise((resolve, reject)=>{
                try {
                    importScripts(asset.url + "?t=" + Date.now());
                    resolve();
                } catch (err) {
                    reject(err);
                }
            });
        }
    }
}
async function hmrApplyUpdates(assets) {
    global.parcelHotUpdate = Object.create(null);
    let scriptsToRemove;
    try {
        // If sourceURL comments aren't supported in eval, we need to load
        // the update from the dev server over HTTP so that stack traces
        // are correct in errors/logs. This is much slower than eval, so
        // we only do it if needed (currently just Safari).
        // https://bugs.webkit.org/show_bug.cgi?id=137297
        // This path is also taken if a CSP disallows eval.
        if (!supportsSourceURL) {
            let promises = assets.map((asset)=>{
                var _hmrDownload;
                return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch((err)=>{
                    // Web extension fix
                    if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3 && typeof ServiceWorkerGlobalScope != "undefined" && global instanceof ServiceWorkerGlobalScope) {
                        extCtx.runtime.reload();
                        return;
                    }
                    throw err;
                });
            });
            scriptsToRemove = await Promise.all(promises);
        }
        assets.forEach(function(asset) {
            hmrApply(module.bundle.root, asset);
        });
    } finally{
        delete global.parcelHotUpdate;
        if (scriptsToRemove) scriptsToRemove.forEach((script)=>{
            if (script) {
                var _document$head2;
                (_document$head2 = document.head) === null || _document$head2 === void 0 || _document$head2.removeChild(script);
            }
        });
    }
}
function hmrApply(bundle /*: ParcelRequire */ , asset /*:  HMRAsset */ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === "css") reloadCSS();
    else if (asset.type === "js") {
        let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                let oldDeps = modules[asset.id][1];
                for(let dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    let id = oldDeps[dep];
                    let parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            if (supportsSourceURL) // Global eval. We would use `new Function` here but browser
            // support for source maps is better with eval.
            (0, eval)(asset.output);
            // $FlowFixMe
            let fn = global.parcelHotUpdate[asset.id];
            modules[asset.id] = [
                fn,
                deps
            ];
        } else if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id) {
    let modules = bundle.modules;
    if (!modules) return;
    if (modules[id]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        let deps = modules[id][1];
        let orphans = [];
        for(let dep in deps){
            let parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        }
        // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id];
        delete bundle.cache[id];
        // Now delete the orphans.
        orphans.forEach((id)=>{
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id);
}
function hmrAcceptCheck(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
    // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    let parents = getParents(module.bundle.root, id);
    let accepted = false;
    while(parents.length > 0){
        let v = parents.shift();
        let a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else {
            // Otherwise, queue the parents in the next level upward.
            let p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push(...p);
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return true;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToDispose.push([
        bundle,
        id
    ]);
    if (!cached || cached.hot && cached.hot._acceptCallbacks.length) {
        assetsToAccept.push([
            bundle,
            id
        ]);
        return true;
    }
}
function hmrDispose(bundle /*: ParcelRequire */ , id /*: string */ ) {
    var cached = bundle.cache[id];
    bundle.hotData[id] = {};
    if (cached && cached.hot) cached.hot.data = bundle.hotData[id];
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData[id]);
    });
    delete bundle.cache[id];
}
function hmrAccept(bundle /*: ParcelRequire */ , id /*: string */ ) {
    // Execute the module.
    bundle(id);
    // Run the accept callbacks in the new version of the module.
    var cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) {
            assetsToAlsoAccept.forEach(function(a) {
                hmrDispose(a[0], a[1]);
            });
            // $FlowFixMe[method-unbinding]
            assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
        }
    });
}

},{}],"ebWYT":[function(require,module,exports) {
// lib
const { map, distinctUntilChanged } = require("6295082dc10ffab7");
// iblokz
const vdom = require("be3ba22bdbdef716");
const { obj, arr } = require("84a81e6e1cfcc506");
const { createState } = require("2ce56a28465047ff");
// actions and state
let actionsTree = require("fd6dd62d6ed239cb");
let { actions, state$ } = createState(actionsTree);
let ui = require("708dd545cf97b855");
let actions$;
// services
let scene = require("61a906e6c15865d9");
let viewport = require("9c1dd700a3dfbfe7");
let audio = require("857d912d3b1e9c60");
let control = require("a648e0b05c5a466f");
// hot reloading
if (module.hot) {
    // actions
    module.hot.accept("./actions", function() {
        actionsTree = require("fd6dd62d6ed239cb");
        const result = createState(actionsTree);
        actions = result.actions;
        // Trigger a re-render with current state
        // actions.stream.next({path: ['_reload'], payload: []});
        // Trigger a re-render
        actions.stream.next((state)=>state);
    });
    // ui
    module.hot.accept("./ui", function() {
        ui = require("708dd545cf97b855");
        // Trigger a re-render with current state
        // actions.stream.next({path: ['_reload'], payload: []});
        actions.stream.next((state)=>state);
    });
// services
// module.hot.accept("./services/scene", function() {
// 	// console.log(scene.unhook);
// 	scene.unhook();
// 	scene = require('./services/scene');
// 	scene.hook({state$, actions});
// 	actions.stream.next({path: ['_reload'], payload: []});
// });
// module.hot.accept("./services/viewport.js", function() {
// 	viewport.unhook();
// 	setTimeout(() => {
// 		viewport = require('./services/viewport.js');
// 		viewport.hook({state$, actions});
// 		actions.stream.next({path: ['_reload'], payload: []});
// 	});
// });
// module.hot.accept("./services/audio", function() {
// 	audio.unhook();
// 	setTimeout(() => {
// 		audio = require('./services/audio');
// 		audio.hook({state$, actions});
// 		actions.stream.next({path: ['_reload'], payload: []});
// 	});
// });
}
// Log actions for debugging
actions.stream.subscribe((action)=>{
    action.path && console.log(action.path.join("."), action.payload);
// console.log('Action:', action);
});
// logging
state$.pipe(map((state)=>obj.filter(state, (key)=>key !== "viewport")), distinctUntilChanged()).subscribe((state)=>console.log(state));
// services
scene.hook({
    state$,
    actions
});
viewport.hook({
    state$,
    actions
});
audio.hook({
    state$,
    actions
});
control.hook({
    state$,
    actions
});
// state -> ui
const ui$ = state$.pipe(map((state)=>ui({
        state,
        actions
    })));
vdom.patchStream(ui$, "#ui");

},{"6295082dc10ffab7":"1cs2r","be3ba22bdbdef716":"5SuSv","84a81e6e1cfcc506":"2lXuw","2ce56a28465047ff":"deOrm","fd6dd62d6ed239cb":"ccGLY","708dd545cf97b855":"5ppKY","61a906e6c15865d9":"7ia0b","9c1dd700a3dfbfe7":"jz7zu","857d912d3b1e9c60":"iNo8a","a648e0b05c5a466f":"6beJI"}],"1cs2r":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "audit", ()=>(0, _audit.audit));
parcelHelpers.export(exports, "auditTime", ()=>(0, _auditTime.auditTime));
parcelHelpers.export(exports, "buffer", ()=>(0, _buffer.buffer));
parcelHelpers.export(exports, "bufferCount", ()=>(0, _bufferCount.bufferCount));
parcelHelpers.export(exports, "bufferTime", ()=>(0, _bufferTime.bufferTime));
parcelHelpers.export(exports, "bufferToggle", ()=>(0, _bufferToggle.bufferToggle));
parcelHelpers.export(exports, "bufferWhen", ()=>(0, _bufferWhen.bufferWhen));
parcelHelpers.export(exports, "catchError", ()=>(0, _catchError.catchError));
parcelHelpers.export(exports, "combineAll", ()=>(0, _combineAll.combineAll));
parcelHelpers.export(exports, "combineLatestAll", ()=>(0, _combineLatestAll.combineLatestAll));
parcelHelpers.export(exports, "combineLatest", ()=>(0, _combineLatest.combineLatest));
parcelHelpers.export(exports, "combineLatestWith", ()=>(0, _combineLatestWith.combineLatestWith));
parcelHelpers.export(exports, "concat", ()=>(0, _concat.concat));
parcelHelpers.export(exports, "concatAll", ()=>(0, _concatAll.concatAll));
parcelHelpers.export(exports, "concatMap", ()=>(0, _concatMap.concatMap));
parcelHelpers.export(exports, "concatMapTo", ()=>(0, _concatMapTo.concatMapTo));
parcelHelpers.export(exports, "concatWith", ()=>(0, _concatWith.concatWith));
parcelHelpers.export(exports, "connect", ()=>(0, _connect.connect));
parcelHelpers.export(exports, "count", ()=>(0, _count.count));
parcelHelpers.export(exports, "debounce", ()=>(0, _debounce.debounce));
parcelHelpers.export(exports, "debounceTime", ()=>(0, _debounceTime.debounceTime));
parcelHelpers.export(exports, "defaultIfEmpty", ()=>(0, _defaultIfEmpty.defaultIfEmpty));
parcelHelpers.export(exports, "delay", ()=>(0, _delay.delay));
parcelHelpers.export(exports, "delayWhen", ()=>(0, _delayWhen.delayWhen));
parcelHelpers.export(exports, "dematerialize", ()=>(0, _dematerialize.dematerialize));
parcelHelpers.export(exports, "distinct", ()=>(0, _distinct.distinct));
parcelHelpers.export(exports, "distinctUntilChanged", ()=>(0, _distinctUntilChanged.distinctUntilChanged));
parcelHelpers.export(exports, "distinctUntilKeyChanged", ()=>(0, _distinctUntilKeyChanged.distinctUntilKeyChanged));
parcelHelpers.export(exports, "elementAt", ()=>(0, _elementAt.elementAt));
parcelHelpers.export(exports, "endWith", ()=>(0, _endWith.endWith));
parcelHelpers.export(exports, "every", ()=>(0, _every.every));
parcelHelpers.export(exports, "exhaust", ()=>(0, _exhaust.exhaust));
parcelHelpers.export(exports, "exhaustAll", ()=>(0, _exhaustAll.exhaustAll));
parcelHelpers.export(exports, "exhaustMap", ()=>(0, _exhaustMap.exhaustMap));
parcelHelpers.export(exports, "expand", ()=>(0, _expand.expand));
parcelHelpers.export(exports, "filter", ()=>(0, _filter.filter));
parcelHelpers.export(exports, "finalize", ()=>(0, _finalize.finalize));
parcelHelpers.export(exports, "find", ()=>(0, _find.find));
parcelHelpers.export(exports, "findIndex", ()=>(0, _findIndex.findIndex));
parcelHelpers.export(exports, "first", ()=>(0, _first.first));
parcelHelpers.export(exports, "groupBy", ()=>(0, _groupBy.groupBy));
parcelHelpers.export(exports, "ignoreElements", ()=>(0, _ignoreElements.ignoreElements));
parcelHelpers.export(exports, "isEmpty", ()=>(0, _isEmpty.isEmpty));
parcelHelpers.export(exports, "last", ()=>(0, _last.last));
parcelHelpers.export(exports, "map", ()=>(0, _map.map));
parcelHelpers.export(exports, "mapTo", ()=>(0, _mapTo.mapTo));
parcelHelpers.export(exports, "materialize", ()=>(0, _materialize.materialize));
parcelHelpers.export(exports, "max", ()=>(0, _max.max));
parcelHelpers.export(exports, "merge", ()=>(0, _merge.merge));
parcelHelpers.export(exports, "mergeAll", ()=>(0, _mergeAll.mergeAll));
parcelHelpers.export(exports, "flatMap", ()=>(0, _flatMap.flatMap));
parcelHelpers.export(exports, "mergeMap", ()=>(0, _mergeMap.mergeMap));
parcelHelpers.export(exports, "mergeMapTo", ()=>(0, _mergeMapTo.mergeMapTo));
parcelHelpers.export(exports, "mergeScan", ()=>(0, _mergeScan.mergeScan));
parcelHelpers.export(exports, "mergeWith", ()=>(0, _mergeWith.mergeWith));
parcelHelpers.export(exports, "min", ()=>(0, _min.min));
parcelHelpers.export(exports, "multicast", ()=>(0, _multicast.multicast));
parcelHelpers.export(exports, "observeOn", ()=>(0, _observeOn.observeOn));
parcelHelpers.export(exports, "onErrorResumeNext", ()=>(0, _onErrorResumeNextWith.onErrorResumeNext));
parcelHelpers.export(exports, "pairwise", ()=>(0, _pairwise.pairwise));
parcelHelpers.export(exports, "partition", ()=>(0, _partition.partition));
parcelHelpers.export(exports, "pluck", ()=>(0, _pluck.pluck));
parcelHelpers.export(exports, "publish", ()=>(0, _publish.publish));
parcelHelpers.export(exports, "publishBehavior", ()=>(0, _publishBehavior.publishBehavior));
parcelHelpers.export(exports, "publishLast", ()=>(0, _publishLast.publishLast));
parcelHelpers.export(exports, "publishReplay", ()=>(0, _publishReplay.publishReplay));
parcelHelpers.export(exports, "race", ()=>(0, _race.race));
parcelHelpers.export(exports, "raceWith", ()=>(0, _raceWith.raceWith));
parcelHelpers.export(exports, "reduce", ()=>(0, _reduce.reduce));
parcelHelpers.export(exports, "repeat", ()=>(0, _repeat.repeat));
parcelHelpers.export(exports, "repeatWhen", ()=>(0, _repeatWhen.repeatWhen));
parcelHelpers.export(exports, "retry", ()=>(0, _retry.retry));
parcelHelpers.export(exports, "retryWhen", ()=>(0, _retryWhen.retryWhen));
parcelHelpers.export(exports, "refCount", ()=>(0, _refCount.refCount));
parcelHelpers.export(exports, "sample", ()=>(0, _sample.sample));
parcelHelpers.export(exports, "sampleTime", ()=>(0, _sampleTime.sampleTime));
parcelHelpers.export(exports, "scan", ()=>(0, _scan.scan));
parcelHelpers.export(exports, "sequenceEqual", ()=>(0, _sequenceEqual.sequenceEqual));
parcelHelpers.export(exports, "share", ()=>(0, _share.share));
parcelHelpers.export(exports, "shareReplay", ()=>(0, _shareReplay.shareReplay));
parcelHelpers.export(exports, "single", ()=>(0, _single.single));
parcelHelpers.export(exports, "skip", ()=>(0, _skip.skip));
parcelHelpers.export(exports, "skipLast", ()=>(0, _skipLast.skipLast));
parcelHelpers.export(exports, "skipUntil", ()=>(0, _skipUntil.skipUntil));
parcelHelpers.export(exports, "skipWhile", ()=>(0, _skipWhile.skipWhile));
parcelHelpers.export(exports, "startWith", ()=>(0, _startWith.startWith));
parcelHelpers.export(exports, "subscribeOn", ()=>(0, _subscribeOn.subscribeOn));
parcelHelpers.export(exports, "switchAll", ()=>(0, _switchAll.switchAll));
parcelHelpers.export(exports, "switchMap", ()=>(0, _switchMap.switchMap));
parcelHelpers.export(exports, "switchMapTo", ()=>(0, _switchMapTo.switchMapTo));
parcelHelpers.export(exports, "switchScan", ()=>(0, _switchScan.switchScan));
parcelHelpers.export(exports, "take", ()=>(0, _take.take));
parcelHelpers.export(exports, "takeLast", ()=>(0, _takeLast.takeLast));
parcelHelpers.export(exports, "takeUntil", ()=>(0, _takeUntil.takeUntil));
parcelHelpers.export(exports, "takeWhile", ()=>(0, _takeWhile.takeWhile));
parcelHelpers.export(exports, "tap", ()=>(0, _tap.tap));
parcelHelpers.export(exports, "throttle", ()=>(0, _throttle.throttle));
parcelHelpers.export(exports, "throttleTime", ()=>(0, _throttleTime.throttleTime));
parcelHelpers.export(exports, "throwIfEmpty", ()=>(0, _throwIfEmpty.throwIfEmpty));
parcelHelpers.export(exports, "timeInterval", ()=>(0, _timeInterval.timeInterval));
parcelHelpers.export(exports, "timeout", ()=>(0, _timeout.timeout));
parcelHelpers.export(exports, "timeoutWith", ()=>(0, _timeoutWith.timeoutWith));
parcelHelpers.export(exports, "timestamp", ()=>(0, _timestamp.timestamp));
parcelHelpers.export(exports, "toArray", ()=>(0, _toArray.toArray));
parcelHelpers.export(exports, "window", ()=>(0, _window.window));
parcelHelpers.export(exports, "windowCount", ()=>(0, _windowCount.windowCount));
parcelHelpers.export(exports, "windowTime", ()=>(0, _windowTime.windowTime));
parcelHelpers.export(exports, "windowToggle", ()=>(0, _windowToggle.windowToggle));
parcelHelpers.export(exports, "windowWhen", ()=>(0, _windowWhen.windowWhen));
parcelHelpers.export(exports, "withLatestFrom", ()=>(0, _withLatestFrom.withLatestFrom));
parcelHelpers.export(exports, "zip", ()=>(0, _zip.zip));
parcelHelpers.export(exports, "zipAll", ()=>(0, _zipAll.zipAll));
parcelHelpers.export(exports, "zipWith", ()=>(0, _zipWith.zipWith));
var _audit = require("../internal/operators/audit");
var _auditTime = require("../internal/operators/auditTime");
var _buffer = require("../internal/operators/buffer");
var _bufferCount = require("../internal/operators/bufferCount");
var _bufferTime = require("../internal/operators/bufferTime");
var _bufferToggle = require("../internal/operators/bufferToggle");
var _bufferWhen = require("../internal/operators/bufferWhen");
var _catchError = require("../internal/operators/catchError");
var _combineAll = require("../internal/operators/combineAll");
var _combineLatestAll = require("../internal/operators/combineLatestAll");
var _combineLatest = require("../internal/operators/combineLatest");
var _combineLatestWith = require("../internal/operators/combineLatestWith");
var _concat = require("../internal/operators/concat");
var _concatAll = require("../internal/operators/concatAll");
var _concatMap = require("../internal/operators/concatMap");
var _concatMapTo = require("../internal/operators/concatMapTo");
var _concatWith = require("../internal/operators/concatWith");
var _connect = require("../internal/operators/connect");
var _count = require("../internal/operators/count");
var _debounce = require("../internal/operators/debounce");
var _debounceTime = require("../internal/operators/debounceTime");
var _defaultIfEmpty = require("../internal/operators/defaultIfEmpty");
var _delay = require("../internal/operators/delay");
var _delayWhen = require("../internal/operators/delayWhen");
var _dematerialize = require("../internal/operators/dematerialize");
var _distinct = require("../internal/operators/distinct");
var _distinctUntilChanged = require("../internal/operators/distinctUntilChanged");
var _distinctUntilKeyChanged = require("../internal/operators/distinctUntilKeyChanged");
var _elementAt = require("../internal/operators/elementAt");
var _endWith = require("../internal/operators/endWith");
var _every = require("../internal/operators/every");
var _exhaust = require("../internal/operators/exhaust");
var _exhaustAll = require("../internal/operators/exhaustAll");
var _exhaustMap = require("../internal/operators/exhaustMap");
var _expand = require("../internal/operators/expand");
var _filter = require("../internal/operators/filter");
var _finalize = require("../internal/operators/finalize");
var _find = require("../internal/operators/find");
var _findIndex = require("../internal/operators/findIndex");
var _first = require("../internal/operators/first");
var _groupBy = require("../internal/operators/groupBy");
var _ignoreElements = require("../internal/operators/ignoreElements");
var _isEmpty = require("../internal/operators/isEmpty");
var _last = require("../internal/operators/last");
var _map = require("../internal/operators/map");
var _mapTo = require("../internal/operators/mapTo");
var _materialize = require("../internal/operators/materialize");
var _max = require("../internal/operators/max");
var _merge = require("../internal/operators/merge");
var _mergeAll = require("../internal/operators/mergeAll");
var _flatMap = require("../internal/operators/flatMap");
var _mergeMap = require("../internal/operators/mergeMap");
var _mergeMapTo = require("../internal/operators/mergeMapTo");
var _mergeScan = require("../internal/operators/mergeScan");
var _mergeWith = require("../internal/operators/mergeWith");
var _min = require("../internal/operators/min");
var _multicast = require("../internal/operators/multicast");
var _observeOn = require("../internal/operators/observeOn");
var _onErrorResumeNextWith = require("../internal/operators/onErrorResumeNextWith");
var _pairwise = require("../internal/operators/pairwise");
var _partition = require("../internal/operators/partition");
var _pluck = require("../internal/operators/pluck");
var _publish = require("../internal/operators/publish");
var _publishBehavior = require("../internal/operators/publishBehavior");
var _publishLast = require("../internal/operators/publishLast");
var _publishReplay = require("../internal/operators/publishReplay");
var _race = require("../internal/operators/race");
var _raceWith = require("../internal/operators/raceWith");
var _reduce = require("../internal/operators/reduce");
var _repeat = require("../internal/operators/repeat");
var _repeatWhen = require("../internal/operators/repeatWhen");
var _retry = require("../internal/operators/retry");
var _retryWhen = require("../internal/operators/retryWhen");
var _refCount = require("../internal/operators/refCount");
var _sample = require("../internal/operators/sample");
var _sampleTime = require("../internal/operators/sampleTime");
var _scan = require("../internal/operators/scan");
var _sequenceEqual = require("../internal/operators/sequenceEqual");
var _share = require("../internal/operators/share");
var _shareReplay = require("../internal/operators/shareReplay");
var _single = require("../internal/operators/single");
var _skip = require("../internal/operators/skip");
var _skipLast = require("../internal/operators/skipLast");
var _skipUntil = require("../internal/operators/skipUntil");
var _skipWhile = require("../internal/operators/skipWhile");
var _startWith = require("../internal/operators/startWith");
var _subscribeOn = require("../internal/operators/subscribeOn");
var _switchAll = require("../internal/operators/switchAll");
var _switchMap = require("../internal/operators/switchMap");
var _switchMapTo = require("../internal/operators/switchMapTo");
var _switchScan = require("../internal/operators/switchScan");
var _take = require("../internal/operators/take");
var _takeLast = require("../internal/operators/takeLast");
var _takeUntil = require("../internal/operators/takeUntil");
var _takeWhile = require("../internal/operators/takeWhile");
var _tap = require("../internal/operators/tap");
var _throttle = require("../internal/operators/throttle");
var _throttleTime = require("../internal/operators/throttleTime");
var _throwIfEmpty = require("../internal/operators/throwIfEmpty");
var _timeInterval = require("../internal/operators/timeInterval");
var _timeout = require("../internal/operators/timeout");
var _timeoutWith = require("../internal/operators/timeoutWith");
var _timestamp = require("../internal/operators/timestamp");
var _toArray = require("../internal/operators/toArray");
var _window = require("../internal/operators/window");
var _windowCount = require("../internal/operators/windowCount");
var _windowTime = require("../internal/operators/windowTime");
var _windowToggle = require("../internal/operators/windowToggle");
var _windowWhen = require("../internal/operators/windowWhen");
var _withLatestFrom = require("../internal/operators/withLatestFrom");
var _zip = require("../internal/operators/zip");
var _zipAll = require("../internal/operators/zipAll");
var _zipWith = require("../internal/operators/zipWith");

},{"../internal/operators/audit":"dsTZY","../internal/operators/auditTime":"9Llvq","../internal/operators/buffer":"bBo8n","../internal/operators/bufferCount":"2YxsY","../internal/operators/bufferTime":"4R33k","../internal/operators/bufferToggle":"jNIZ7","../internal/operators/bufferWhen":"5GTvo","../internal/operators/catchError":"bW2OG","../internal/operators/combineAll":"7sph5","../internal/operators/combineLatestAll":"1RyF0","../internal/operators/combineLatest":"kMtrH","../internal/operators/combineLatestWith":"96hvT","../internal/operators/concat":"8l3w8","../internal/operators/concatAll":"3N9Cc","../internal/operators/concatMap":"emBSh","../internal/operators/concatMapTo":"38P3I","../internal/operators/concatWith":"YJ4oC","../internal/operators/connect":"9jLdy","../internal/operators/count":"124qG","../internal/operators/debounce":"7l4PC","../internal/operators/debounceTime":"h80NT","../internal/operators/defaultIfEmpty":"6uJJE","../internal/operators/delay":"2RJzO","../internal/operators/delayWhen":"eiopY","../internal/operators/dematerialize":"k3SZr","../internal/operators/distinct":"2TywC","../internal/operators/distinctUntilChanged":"iGfsr","../internal/operators/distinctUntilKeyChanged":"2sNVc","../internal/operators/elementAt":"fx5hJ","../internal/operators/endWith":"4nEYg","../internal/operators/every":"hswcw","../internal/operators/exhaust":"iJzIe","../internal/operators/exhaustAll":"03zkm","../internal/operators/exhaustMap":"cAFnx","../internal/operators/expand":"3dxNz","../internal/operators/filter":"aO3IO","../internal/operators/finalize":"LytCq","../internal/operators/find":"aaFa0","../internal/operators/findIndex":"k00hc","../internal/operators/first":"hPeew","../internal/operators/groupBy":"d3Tg3","../internal/operators/ignoreElements":"8RBST","../internal/operators/isEmpty":"h1hMH","../internal/operators/last":"kLaua","../internal/operators/map":"9Azp4","../internal/operators/mapTo":"7HUed","../internal/operators/materialize":"lo980","../internal/operators/max":"etLZh","../internal/operators/merge":"js5Fb","../internal/operators/mergeAll":"iRJ2C","../internal/operators/flatMap":"jWma1","../internal/operators/mergeMap":"5gFTr","../internal/operators/mergeMapTo":"frPgW","../internal/operators/mergeScan":"cAvb5","../internal/operators/mergeWith":"5WJFY","../internal/operators/min":"6h0L2","../internal/operators/multicast":"blOJd","../internal/operators/observeOn":"k6OlK","../internal/operators/onErrorResumeNextWith":"9hfb6","../internal/operators/pairwise":"5wANY","../internal/operators/partition":"j5v1J","../internal/operators/pluck":"imGUr","../internal/operators/publish":"8wOeK","../internal/operators/publishBehavior":"iwBWB","../internal/operators/publishLast":"3n4TK","../internal/operators/publishReplay":"gUWQi","../internal/operators/race":"bPlv5","../internal/operators/raceWith":"6cdfA","../internal/operators/reduce":"4kl4u","../internal/operators/repeat":"5UqpN","../internal/operators/repeatWhen":"gc3fv","../internal/operators/retry":"2tmUJ","../internal/operators/retryWhen":"22yAc","../internal/operators/refCount":"7oeFZ","../internal/operators/sample":"4UBOM","../internal/operators/sampleTime":"9b5UP","../internal/operators/scan":"hjpMh","../internal/operators/sequenceEqual":"2HeB5","../internal/operators/share":"9lnzR","../internal/operators/shareReplay":"3ApTz","../internal/operators/single":"6EvgU","../internal/operators/skip":"hBspj","../internal/operators/skipLast":"dV92A","../internal/operators/skipUntil":"hgUdx","../internal/operators/skipWhile":"iMGQR","../internal/operators/startWith":"4c0lY","../internal/operators/subscribeOn":"a8ffZ","../internal/operators/switchAll":"cnJCR","../internal/operators/switchMap":"1rRAL","../internal/operators/switchMapTo":"727dN","../internal/operators/switchScan":"cL6qq","../internal/operators/take":"94vX9","../internal/operators/takeLast":"967LC","../internal/operators/takeUntil":"1WaPV","../internal/operators/takeWhile":"WXp51","../internal/operators/tap":"gzncB","../internal/operators/throttle":"aqWV2","../internal/operators/throttleTime":"7zEuX","../internal/operators/throwIfEmpty":"9WNWd","../internal/operators/timeInterval":"i7v6u","../internal/operators/timeout":"4qfYk","../internal/operators/timeoutWith":"igxz4","../internal/operators/timestamp":"eP3KH","../internal/operators/toArray":"39VfS","../internal/operators/window":"5Cov0","../internal/operators/windowCount":"9lRUE","../internal/operators/windowTime":"9CZWM","../internal/operators/windowToggle":"9vCYU","../internal/operators/windowWhen":"73c43","../internal/operators/withLatestFrom":"8Yb0Y","../internal/operators/zip":"hN98m","../internal/operators/zipAll":"6o3EP","../internal/operators/zipWith":"5OH3O","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"dsTZY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "audit", ()=>audit);
var _lift = require("../util/lift");
var _innerFrom = require("../observable/innerFrom");
var _operatorSubscriber = require("./OperatorSubscriber");
function audit(durationSelector) {
    return (0, _lift.operate)(function(source, subscriber) {
        var hasValue = false;
        var lastValue = null;
        var durationSubscriber = null;
        var isComplete = false;
        var endDuration = function() {
            durationSubscriber === null || durationSubscriber === void 0 || durationSubscriber.unsubscribe();
            durationSubscriber = null;
            if (hasValue) {
                hasValue = false;
                var value = lastValue;
                lastValue = null;
                subscriber.next(value);
            }
            isComplete && subscriber.complete();
        };
        var cleanupDuration = function() {
            durationSubscriber = null;
            isComplete && subscriber.complete();
        };
        source.subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function(value) {
            hasValue = true;
            lastValue = value;
            if (!durationSubscriber) (0, _innerFrom.innerFrom)(durationSelector(value)).subscribe(durationSubscriber = (0, _operatorSubscriber.createOperatorSubscriber)(subscriber, endDuration, cleanupDuration));
        }, function() {
            isComplete = true;
            (!hasValue || !durationSubscriber || durationSubscriber.closed) && subscriber.complete();
        }));
    });
}

},{"../util/lift":"3IZjp","../observable/innerFrom":"6l3RX","./OperatorSubscriber":"hrKGc","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"3IZjp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "hasLift", ()=>hasLift);
parcelHelpers.export(exports, "operate", ()=>operate);
var _isFunction = require("./isFunction");
function hasLift(source) {
    return (0, _isFunction.isFunction)(source === null || source === void 0 ? void 0 : source.lift);
}
function operate(init) {
    return function(source) {
        if (hasLift(source)) return source.lift(function(liftedSource) {
            try {
                return init(liftedSource, this);
            } catch (err) {
                this.error(err);
            }
        });
        throw new TypeError("Unable to lift unknown Observable type");
    };
}

},{"./isFunction":"fpUct","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"fpUct":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isFunction", ()=>isFunction);
function isFunction(value) {
    return typeof value === "function";
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"bnxJ5":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, "__esModule", {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === "default" || key === "__esModule" || Object.prototype.hasOwnProperty.call(dest, key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"6l3RX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "innerFrom", ()=>innerFrom);
parcelHelpers.export(exports, "fromInteropObservable", ()=>fromInteropObservable);
parcelHelpers.export(exports, "fromArrayLike", ()=>fromArrayLike);
parcelHelpers.export(exports, "fromPromise", ()=>fromPromise);
parcelHelpers.export(exports, "fromIterable", ()=>fromIterable);
parcelHelpers.export(exports, "fromAsyncIterable", ()=>fromAsyncIterable);
parcelHelpers.export(exports, "fromReadableStreamLike", ()=>fromReadableStreamLike);
var _tslib = require("tslib");
var _isArrayLike = require("../util/isArrayLike");
var _isPromise = require("../util/isPromise");
var _observable = require("../Observable");
var _isInteropObservable = require("../util/isInteropObservable");
var _isAsyncIterable = require("../util/isAsyncIterable");
var _throwUnobservableError = require("../util/throwUnobservableError");
var _isIterable = require("../util/isIterable");
var _isReadableStreamLike = require("../util/isReadableStreamLike");
var _isFunction = require("../util/isFunction");
var _reportUnhandledError = require("../util/reportUnhandledError");
var _observable1 = require("../symbol/observable");
function innerFrom(input) {
    if (input instanceof (0, _observable.Observable)) return input;
    if (input != null) {
        if ((0, _isInteropObservable.isInteropObservable)(input)) return fromInteropObservable(input);
        if ((0, _isArrayLike.isArrayLike)(input)) return fromArrayLike(input);
        if ((0, _isPromise.isPromise)(input)) return fromPromise(input);
        if ((0, _isAsyncIterable.isAsyncIterable)(input)) return fromAsyncIterable(input);
        if ((0, _isIterable.isIterable)(input)) return fromIterable(input);
        if ((0, _isReadableStreamLike.isReadableStreamLike)(input)) return fromReadableStreamLike(input);
    }
    throw (0, _throwUnobservableError.createInvalidObservableTypeError)(input);
}
function fromInteropObservable(obj) {
    return new (0, _observable.Observable)(function(subscriber) {
        var obs = obj[0, _observable1.observable]();
        if ((0, _isFunction.isFunction)(obs.subscribe)) return obs.subscribe(subscriber);
        throw new TypeError("Provided object does not correctly implement Symbol.observable");
    });
}
function fromArrayLike(array) {
    return new (0, _observable.Observable)(function(subscriber) {
        for(var i = 0; i < array.length && !subscriber.closed; i++)subscriber.next(array[i]);
        subscriber.complete();
    });
}
function fromPromise(promise) {
    return new (0, _observable.Observable)(function(subscriber) {
        promise.then(function(value) {
            if (!subscriber.closed) {
                subscriber.next(value);
                subscriber.complete();
            }
        }, function(err) {
            return subscriber.error(err);
        }).then(null, (0, _reportUnhandledError.reportUnhandledError));
    });
}
function fromIterable(iterable) {
    return new (0, _observable.Observable)(function(subscriber) {
        var e_1, _a;
        try {
            for(var iterable_1 = (0, _tslib.__values)(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()){
                var value = iterable_1_1.value;
                subscriber.next(value);
                if (subscriber.closed) return;
            }
        } catch (e_1_1) {
            e_1 = {
                error: e_1_1
            };
        } finally{
            try {
                if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) _a.call(iterable_1);
            } finally{
                if (e_1) throw e_1.error;
            }
        }
        subscriber.complete();
    });
}
function fromAsyncIterable(asyncIterable) {
    return new (0, _observable.Observable)(function(subscriber) {
        process(asyncIterable, subscriber).catch(function(err) {
            return subscriber.error(err);
        });
    });
}
function fromReadableStreamLike(readableStream) {
    return fromAsyncIterable((0, _isReadableStreamLike.readableStreamLikeToAsyncGenerator)(readableStream));
}
function process(asyncIterable, subscriber) {
    var asyncIterable_1, asyncIterable_1_1;
    var e_2, _a;
    return (0, _tslib.__awaiter)(this, void 0, void 0, function() {
        var value, e_2_1;
        return (0, _tslib.__generator)(this, function(_b) {
            switch(_b.label){
                case 0:
                    _b.trys.push([
                        0,
                        5,
                        6,
                        11
                    ]);
                    asyncIterable_1 = (0, _tslib.__asyncValues)(asyncIterable);
                    _b.label = 1;
                case 1:
                    return [
                        4,
                        asyncIterable_1.next()
                    ];
                case 2:
                    if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done)) return [
                        3,
                        4
                    ];
                    value = asyncIterable_1_1.value;
                    subscriber.next(value);
                    if (subscriber.closed) return [
                        2
                    ];
                    _b.label = 3;
                case 3:
                    return [
                        3,
                        1
                    ];
                case 4:
                    return [
                        3,
                        11
                    ];
                case 5:
                    e_2_1 = _b.sent();
                    e_2 = {
                        error: e_2_1
                    };
                    return [
                        3,
                        11
                    ];
                case 6:
                    _b.trys.push([
                        6,
                        ,
                        9,
                        10
                    ]);
                    if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return))) return [
                        3,
                        8
                    ];
                    return [
                        4,
                        _a.call(asyncIterable_1)
                    ];
                case 7:
                    _b.sent();
                    _b.label = 8;
                case 8:
                    return [
                        3,
                        10
                    ];
                case 9:
                    if (e_2) throw e_2.error;
                    return [
                        7
                    ];
                case 10:
                    return [
                        7
                    ];
                case 11:
                    subscriber.complete();
                    return [
                        2
                    ];
            }
        });
    });
}

},{"tslib":"3gscj","../util/isArrayLike":"hj6kw","../util/isPromise":"iEil1","../Observable":"fo3d5","../util/isInteropObservable":"25cGg","../util/isAsyncIterable":"59WKk","../util/throwUnobservableError":"9JwHf","../util/isIterable":"lN5io","../util/isReadableStreamLike":"20hsf","../util/isFunction":"fpUct","../util/reportUnhandledError":"bkoKP","../symbol/observable":"jUYLN","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"3gscj":[function(require,module,exports) {
/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */ /* global Reflect, Promise, SuppressedError, Symbol, Iterator */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "__extends", ()=>__extends);
parcelHelpers.export(exports, "__assign", ()=>__assign);
parcelHelpers.export(exports, "__rest", ()=>__rest);
parcelHelpers.export(exports, "__decorate", ()=>__decorate);
parcelHelpers.export(exports, "__param", ()=>__param);
parcelHelpers.export(exports, "__esDecorate", ()=>__esDecorate);
parcelHelpers.export(exports, "__runInitializers", ()=>__runInitializers);
parcelHelpers.export(exports, "__propKey", ()=>__propKey);
parcelHelpers.export(exports, "__setFunctionName", ()=>__setFunctionName);
parcelHelpers.export(exports, "__metadata", ()=>__metadata);
parcelHelpers.export(exports, "__awaiter", ()=>__awaiter);
parcelHelpers.export(exports, "__generator", ()=>__generator);
parcelHelpers.export(exports, "__createBinding", ()=>__createBinding);
parcelHelpers.export(exports, "__exportStar", ()=>__exportStar);
parcelHelpers.export(exports, "__values", ()=>__values);
parcelHelpers.export(exports, "__read", ()=>__read);
/** @deprecated */ parcelHelpers.export(exports, "__spread", ()=>__spread);
/** @deprecated */ parcelHelpers.export(exports, "__spreadArrays", ()=>__spreadArrays);
parcelHelpers.export(exports, "__spreadArray", ()=>__spreadArray);
parcelHelpers.export(exports, "__await", ()=>__await);
parcelHelpers.export(exports, "__asyncGenerator", ()=>__asyncGenerator);
parcelHelpers.export(exports, "__asyncDelegator", ()=>__asyncDelegator);
parcelHelpers.export(exports, "__asyncValues", ()=>__asyncValues);
parcelHelpers.export(exports, "__makeTemplateObject", ()=>__makeTemplateObject);
parcelHelpers.export(exports, "__importStar", ()=>__importStar);
parcelHelpers.export(exports, "__importDefault", ()=>__importDefault);
parcelHelpers.export(exports, "__classPrivateFieldGet", ()=>__classPrivateFieldGet);
parcelHelpers.export(exports, "__classPrivateFieldSet", ()=>__classPrivateFieldSet);
parcelHelpers.export(exports, "__classPrivateFieldIn", ()=>__classPrivateFieldIn);
parcelHelpers.export(exports, "__addDisposableResource", ()=>__addDisposableResource);
parcelHelpers.export(exports, "__disposeResources", ()=>__disposeResources);
parcelHelpers.export(exports, "__rewriteRelativeImportExtension", ()=>__rewriteRelativeImportExtension);
var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || ({
        __proto__: []
    }) instanceof Array && function(d, b) {
        d.__proto__ = b;
    } || function(d, b) {
        for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };
    return extendStatics(d, b);
};
function __extends(d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
function __rest(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") {
        for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
}
function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
}
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) {
        if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
        return f;
    }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for(var i = decorators.length - 1; i >= 0; i--){
        var context = {};
        for(var p in contextIn)context[p] = p === "access" ? {} : contextIn[p];
        for(var p in contextIn.access)context.access[p] = contextIn.access[p];
        context.addInitializer = function(f) {
            if (done) throw new TypeError("Cannot add initializers after decoration has completed");
            extraInitializers.push(accept(f || null));
        };
        var result = (0, decorators[i])(kind === "accessor" ? {
            get: descriptor.get,
            set: descriptor.set
        } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        } else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
}
function __runInitializers(thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for(var i = 0; i < initializers.length; i++)value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    return useValue ? value : void 0;
}
function __propKey(x) {
    return typeof x === "symbol" ? x : "".concat(x);
}
function __setFunctionName(f, name, prefix) {
    if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
    return Object.defineProperty(f, "name", {
        configurable: true,
        value: prefix ? "".concat(prefix, " ", name) : name
    });
}
function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}
function __generator(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(g && (g = 0, op[0] && (_ = 0)), _)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
}
var __createBinding = Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
        enumerable: true,
        get: function() {
            return m[k];
        }
    };
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
};
function __exportStar(m, o) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}
function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
}
function __spread() {
    for(var ar = [], i = 0; i < arguments.length; i++)ar = ar.concat(__read(arguments[i]));
    return ar;
}
function __spreadArrays() {
    for(var s = 0, i = 0, il = arguments.length; i < il; i++)s += arguments[i].length;
    for(var r = Array(s), k = 0, i = 0; i < il; i++)for(var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)r[k] = a[j];
    return r;
}
function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) {
        for(var i = 0, l = from.length, ar; i < l; i++)if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}
function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
        return this;
    }, i;
    function awaitReturn(f) {
        return function(v) {
            return Promise.resolve(v).then(f, reject);
        };
    }
    function verb(n, f) {
        if (g[n]) {
            i[n] = function(v) {
                return new Promise(function(a, b) {
                    q.push([
                        n,
                        v,
                        a,
                        b
                    ]) > 1 || resume(n, v);
                });
            };
            if (f) i[n] = f(i[n]);
        }
    }
    function resume(n, v) {
        try {
            step(g[n](v));
        } catch (e) {
            settle(q[0][3], e);
        }
    }
    function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
        resume("next", value);
    }
    function reject(value) {
        resume("throw", value);
    }
    function settle(f, v) {
        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
    }
}
function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function(e) {
        throw e;
    }), verb("return"), i[Symbol.iterator] = function() {
        return this;
    }, i;
    function verb(n, f) {
        i[n] = o[n] ? function(v) {
            return (p = !p) ? {
                value: __await(o[n](v)),
                done: false
            } : f ? f(v) : v;
        } : f;
    }
}
function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
    }, i);
    function verb(n) {
        i[n] = o[n] && function(v) {
            return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
        };
    }
    function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v) {
            resolve({
                value: v,
                done: d
            });
        }, reject);
    }
}
function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) Object.defineProperty(cooked, "raw", {
        value: raw
    });
    else cooked.raw = raw;
    return cooked;
}
var __setModuleDefault = Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
};
var ownKeys = function(o) {
    ownKeys = Object.getOwnPropertyNames || function(o) {
        var ar = [];
        for(var k in o)if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
        return ar;
    };
    return ownKeys(o);
};
function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k = ownKeys(mod), i = 0; i < k.length; i++)if (k[i] !== "default") __createBinding(result, mod, k[i]);
    }
    __setModuleDefault(result, mod);
    return result;
}
function __importDefault(mod) {
    return mod && mod.__esModule ? mod : {
        default: mod
    };
}
function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldIn(state, receiver) {
    if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
    return typeof state === "function" ? receiver === state : state.has(receiver);
}
function __addDisposableResource(env, value, async) {
    if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
            if (async) inner = dispose;
        }
        if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
        if (inner) dispose = function() {
            try {
                inner.call(this);
            } catch (e) {
                return Promise.reject(e);
            }
        };
        env.stack.push({
            value: value,
            dispose: dispose,
            async: async
        });
    } else if (async) env.stack.push({
        async: true
    });
    return value;
}
var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};
function __disposeResources(env) {
    function fail(e) {
        env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
        env.hasError = true;
    }
    var r, s = 0;
    function next() {
        while(r = env.stack.pop())try {
            if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
            if (r.dispose) {
                var result = r.dispose.call(r.value);
                if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
                    fail(e);
                    return next();
                });
            } else s |= 1;
        } catch (e) {
            fail(e);
        }
        if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
        if (env.hasError) throw env.error;
    }
    return next();
}
function __rewriteRelativeImportExtension(path, preserveJsx) {
    if (typeof path === "string" && /^\.\.?\//.test(path)) return path.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(m, tsx, d, ext, cm) {
        return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : d + ext + "." + cm.toLowerCase() + "js";
    });
    return path;
}
exports.default = {
    __extends: __extends,
    __assign: __assign,
    __rest: __rest,
    __decorate: __decorate,
    __param: __param,
    __esDecorate: __esDecorate,
    __runInitializers: __runInitializers,
    __propKey: __propKey,
    __setFunctionName: __setFunctionName,
    __metadata: __metadata,
    __awaiter: __awaiter,
    __generator: __generator,
    __createBinding: __createBinding,
    __exportStar: __exportStar,
    __values: __values,
    __read: __read,
    __spread: __spread,
    __spreadArrays: __spreadArrays,
    __spreadArray: __spreadArray,
    __await: __await,
    __asyncGenerator: __asyncGenerator,
    __asyncDelegator: __asyncDelegator,
    __asyncValues: __asyncValues,
    __makeTemplateObject: __makeTemplateObject,
    __importStar: __importStar,
    __importDefault: __importDefault,
    __classPrivateFieldGet: __classPrivateFieldGet,
    __classPrivateFieldSet: __classPrivateFieldSet,
    __classPrivateFieldIn: __classPrivateFieldIn,
    __addDisposableResource: __addDisposableResource,
    __disposeResources: __disposeResources,
    __rewriteRelativeImportExtension: __rewriteRelativeImportExtension
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"hj6kw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isArrayLike", ()=>isArrayLike);
var isArrayLike = function(x) {
    return x && typeof x.length === "number" && typeof x !== "function";
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"iEil1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isPromise", ()=>isPromise);
var _isFunction = require("./isFunction");
function isPromise(value) {
    return (0, _isFunction.isFunction)(value === null || value === void 0 ? void 0 : value.then);
}

},{"./isFunction":"fpUct","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"fo3d5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Observable", ()=>Observable);
var _subscriber = require("./Subscriber");
var _subscription = require("./Subscription");
var _observable = require("./symbol/observable");
var _pipe = require("./util/pipe");
var _config = require("./config");
var _isFunction = require("./util/isFunction");
var _errorContext = require("./util/errorContext");
var Observable = function() {
    function Observable(subscribe) {
        if (subscribe) this._subscribe = subscribe;
    }
    Observable.prototype.lift = function(operator) {
        var observable = new Observable();
        observable.source = this;
        observable.operator = operator;
        return observable;
    };
    Observable.prototype.subscribe = function(observerOrNext, error, complete) {
        var _this = this;
        var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new (0, _subscriber.SafeSubscriber)(observerOrNext, error, complete);
        (0, _errorContext.errorContext)(function() {
            var _a = _this, operator = _a.operator, source = _a.source;
            subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
        });
        return subscriber;
    };
    Observable.prototype._trySubscribe = function(sink) {
        try {
            return this._subscribe(sink);
        } catch (err) {
            sink.error(err);
        }
    };
    Observable.prototype.forEach = function(next, promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function(resolve, reject) {
            var subscriber = new (0, _subscriber.SafeSubscriber)({
                next: function(value) {
                    try {
                        next(value);
                    } catch (err) {
                        reject(err);
                        subscriber.unsubscribe();
                    }
                },
                error: reject,
                complete: resolve
            });
            _this.subscribe(subscriber);
        });
    };
    Observable.prototype._subscribe = function(subscriber) {
        var _a;
        return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
    };
    Observable.prototype[0, _observable.observable] = function() {
        return this;
    };
    Observable.prototype.pipe = function() {
        var operations = [];
        for(var _i = 0; _i < arguments.length; _i++)operations[_i] = arguments[_i];
        return (0, _pipe.pipeFromArray)(operations)(this);
    };
    Observable.prototype.toPromise = function(promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function(resolve, reject) {
            var value;
            _this.subscribe(function(x) {
                return value = x;
            }, function(err) {
                return reject(err);
            }, function() {
                return resolve(value);
            });
        });
    };
    Observable.create = function(subscribe) {
        return new Observable(subscribe);
    };
    return Observable;
}();
function getPromiseCtor(promiseCtor) {
    var _a;
    return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : (0, _config.config).Promise) !== null && _a !== void 0 ? _a : Promise;
}
function isObserver(value) {
    return value && (0, _isFunction.isFunction)(value.next) && (0, _isFunction.isFunction)(value.error) && (0, _isFunction.isFunction)(value.complete);
}
function isSubscriber(value) {
    return value && value instanceof (0, _subscriber.Subscriber) || isObserver(value) && (0, _subscription.isSubscription)(value);
}

},{"./Subscriber":"8Btbx","./Subscription":"gzL8W","./symbol/observable":"jUYLN","./util/pipe":"3zAKH","./config":"ktLZa","./util/isFunction":"fpUct","./util/errorContext":"jEFyy","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"8Btbx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Subscriber", ()=>Subscriber);
parcelHelpers.export(exports, "SafeSubscriber", ()=>SafeSubscriber);
parcelHelpers.export(exports, "EMPTY_OBSERVER", ()=>EMPTY_OBSERVER);
var _tslib = require("tslib");
var _isFunction = require("./util/isFunction");
var _subscription = require("./Subscription");
var _config = require("./config");
var _reportUnhandledError = require("./util/reportUnhandledError");
var _noop = require("./util/noop");
var _notificationFactories = require("./NotificationFactories");
var _timeoutProvider = require("./scheduler/timeoutProvider");
var _errorContext = require("./util/errorContext");
var Subscriber = function(_super) {
    (0, _tslib.__extends)(Subscriber, _super);
    function Subscriber(destination) {
        var _this = _super.call(this) || this;
        _this.isStopped = false;
        if (destination) {
            _this.destination = destination;
            if ((0, _subscription.isSubscription)(destination)) destination.add(_this);
        } else _this.destination = EMPTY_OBSERVER;
        return _this;
    }
    Subscriber.create = function(next, error, complete) {
        return new SafeSubscriber(next, error, complete);
    };
    Subscriber.prototype.next = function(value) {
        if (this.isStopped) handleStoppedNotification((0, _notificationFactories.nextNotification)(value), this);
        else this._next(value);
    };
    Subscriber.prototype.error = function(err) {
        if (this.isStopped) handleStoppedNotification((0, _notificationFactories.errorNotification)(err), this);
        else {
            this.isStopped = true;
            this._error(err);
        }
    };
    Subscriber.prototype.complete = function() {
        if (this.isStopped) handleStoppedNotification((0, _notificationFactories.COMPLETE_NOTIFICATION), this);
        else {
            this.isStopped = true;
            this._complete();
        }
    };
    Subscriber.prototype.unsubscribe = function() {
        if (!this.closed) {
            this.isStopped = true;
            _super.prototype.unsubscribe.call(this);
            this.destination = null;
        }
    };
    Subscriber.prototype._next = function(value) {
        this.destination.next(value);
    };
    Subscriber.prototype._error = function(err) {
        try {
            this.destination.error(err);
        } finally{
            this.unsubscribe();
        }
    };
    Subscriber.prototype._complete = function() {
        try {
            this.destination.complete();
        } finally{
            this.unsubscribe();
        }
    };
    return Subscriber;
}((0, _subscription.Subscription));
var _bind = Function.prototype.bind;
function bind(fn, thisArg) {
    return _bind.call(fn, thisArg);
}
var ConsumerObserver = function() {
    function ConsumerObserver(partialObserver) {
        this.partialObserver = partialObserver;
    }
    ConsumerObserver.prototype.next = function(value) {
        var partialObserver = this.partialObserver;
        if (partialObserver.next) try {
            partialObserver.next(value);
        } catch (error) {
            handleUnhandledError(error);
        }
    };
    ConsumerObserver.prototype.error = function(err) {
        var partialObserver = this.partialObserver;
        if (partialObserver.error) try {
            partialObserver.error(err);
        } catch (error) {
            handleUnhandledError(error);
        }
        else handleUnhandledError(err);
    };
    ConsumerObserver.prototype.complete = function() {
        var partialObserver = this.partialObserver;
        if (partialObserver.complete) try {
            partialObserver.complete();
        } catch (error) {
            handleUnhandledError(error);
        }
    };
    return ConsumerObserver;
}();
var SafeSubscriber = function(_super) {
    (0, _tslib.__extends)(SafeSubscriber, _super);
    function SafeSubscriber(observerOrNext, error, complete) {
        var _this = _super.call(this) || this;
        var partialObserver;
        if ((0, _isFunction.isFunction)(observerOrNext) || !observerOrNext) partialObserver = {
            next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : undefined,
            error: error !== null && error !== void 0 ? error : undefined,
            complete: complete !== null && complete !== void 0 ? complete : undefined
        };
        else {
            var context_1;
            if (_this && (0, _config.config).useDeprecatedNextContext) {
                context_1 = Object.create(observerOrNext);
                context_1.unsubscribe = function() {
                    return _this.unsubscribe();
                };
                partialObserver = {
                    next: observerOrNext.next && bind(observerOrNext.next, context_1),
                    error: observerOrNext.error && bind(observerOrNext.error, context_1),
                    complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
                };
            } else partialObserver = observerOrNext;
        }
        _this.destination = new ConsumerObserver(partialObserver);
        return _this;
    }
    return SafeSubscriber;
}(Subscriber);
function handleUnhandledError(error) {
    if ((0, _config.config).useDeprecatedSynchronousErrorHandling) (0, _errorContext.captureError)(error);
    else (0, _reportUnhandledError.reportUnhandledError)(error);
}
function defaultErrorHandler(err) {
    throw err;
}
function handleStoppedNotification(notification, subscriber) {
    var onStoppedNotification = (0, _config.config).onStoppedNotification;
    onStoppedNotification && (0, _timeoutProvider.timeoutProvider).setTimeout(function() {
        return onStoppedNotification(notification, subscriber);
    });
}
var EMPTY_OBSERVER = {
    closed: true,
    next: (0, _noop.noop),
    error: defaultErrorHandler,
    complete: (0, _noop.noop)
};

},{"tslib":"3gscj","./util/isFunction":"fpUct","./Subscription":"gzL8W","./config":"ktLZa","./util/reportUnhandledError":"bkoKP","./util/noop":"f1sCb","./NotificationFactories":"kuqr1","./scheduler/timeoutProvider":"1fms4","./util/errorContext":"jEFyy","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"gzL8W":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Subscription", ()=>Subscription);
parcelHelpers.export(exports, "EMPTY_SUBSCRIPTION", ()=>EMPTY_SUBSCRIPTION);
parcelHelpers.export(exports, "isSubscription", ()=>isSubscription);
var _tslib = require("tslib");
var _isFunction = require("./util/isFunction");
var _unsubscriptionError = require("./util/UnsubscriptionError");
var _arrRemove = require("./util/arrRemove");
var Subscription = function() {
    function Subscription(initialTeardown) {
        this.initialTeardown = initialTeardown;
        this.closed = false;
        this._parentage = null;
        this._finalizers = null;
    }
    Subscription.prototype.unsubscribe = function() {
        var e_1, _a, e_2, _b;
        var errors;
        if (!this.closed) {
            this.closed = true;
            var _parentage = this._parentage;
            if (_parentage) {
                this._parentage = null;
                if (Array.isArray(_parentage)) try {
                    for(var _parentage_1 = (0, _tslib.__values)(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()){
                        var parent_1 = _parentage_1_1.value;
                        parent_1.remove(this);
                    }
                } catch (e_1_1) {
                    e_1 = {
                        error: e_1_1
                    };
                } finally{
                    try {
                        if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return)) _a.call(_parentage_1);
                    } finally{
                        if (e_1) throw e_1.error;
                    }
                }
                else _parentage.remove(this);
            }
            var initialFinalizer = this.initialTeardown;
            if ((0, _isFunction.isFunction)(initialFinalizer)) try {
                initialFinalizer();
            } catch (e) {
                errors = e instanceof (0, _unsubscriptionError.UnsubscriptionError) ? e.errors : [
                    e
                ];
            }
            var _finalizers = this._finalizers;
            if (_finalizers) {
                this._finalizers = null;
                try {
                    for(var _finalizers_1 = (0, _tslib.__values)(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()){
                        var finalizer = _finalizers_1_1.value;
                        try {
                            execFinalizer(finalizer);
                        } catch (err) {
                            errors = errors !== null && errors !== void 0 ? errors : [];
                            if (err instanceof (0, _unsubscriptionError.UnsubscriptionError)) errors = (0, _tslib.__spreadArray)((0, _tslib.__spreadArray)([], (0, _tslib.__read)(errors)), (0, _tslib.__read)(err.errors));
                            else errors.push(err);
                        }
                    }
                } catch (e_2_1) {
                    e_2 = {
                        error: e_2_1
                    };
                } finally{
                    try {
                        if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return)) _b.call(_finalizers_1);
                    } finally{
                        if (e_2) throw e_2.error;
                    }
                }
            }
            if (errors) throw new (0, _unsubscriptionError.UnsubscriptionError)(errors);
        }
    };
    Subscription.prototype.add = function(teardown) {
        var _a;
        if (teardown && teardown !== this) {
            if (this.closed) execFinalizer(teardown);
            else {
                if (teardown instanceof Subscription) {
                    if (teardown.closed || teardown._hasParent(this)) return;
                    teardown._addParent(this);
                }
                (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
            }
        }
    };
    Subscription.prototype._hasParent = function(parent) {
        var _parentage = this._parentage;
        return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
    };
    Subscription.prototype._addParent = function(parent) {
        var _parentage = this._parentage;
        this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [
            _parentage,
            parent
        ] : parent;
    };
    Subscription.prototype._removeParent = function(parent) {
        var _parentage = this._parentage;
        if (_parentage === parent) this._parentage = null;
        else if (Array.isArray(_parentage)) (0, _arrRemove.arrRemove)(_parentage, parent);
    };
    Subscription.prototype.remove = function(teardown) {
        var _finalizers = this._finalizers;
        _finalizers && (0, _arrRemove.arrRemove)(_finalizers, teardown);
        if (teardown instanceof Subscription) teardown._removeParent(this);
    };
    Subscription.EMPTY = function() {
        var empty = new Subscription();
        empty.closed = true;
        return empty;
    }();
    return Subscription;
}();
var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
function isSubscription(value) {
    return value instanceof Subscription || value && "closed" in value && (0, _isFunction.isFunction)(value.remove) && (0, _isFunction.isFunction)(value.add) && (0, _isFunction.isFunction)(value.unsubscribe);
}
function execFinalizer(finalizer) {
    if ((0, _isFunction.isFunction)(finalizer)) finalizer();
    else finalizer.unsubscribe();
}

},{"tslib":"3gscj","./util/isFunction":"fpUct","./util/UnsubscriptionError":"ja0ti","./util/arrRemove":"4LjhZ","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"ja0ti":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "UnsubscriptionError", ()=>UnsubscriptionError);
var _createErrorClass = require("./createErrorClass");
var UnsubscriptionError = (0, _createErrorClass.createErrorClass)(function(_super) {
    return function UnsubscriptionErrorImpl(errors) {
        _super(this);
        this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i) {
            return i + 1 + ") " + err.toString();
        }).join("\n  ") : "";
        this.name = "UnsubscriptionError";
        this.errors = errors;
    };
});

},{"./createErrorClass":"1JmLg","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"1JmLg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createErrorClass", ()=>createErrorClass);
function createErrorClass(createImpl) {
    var _super = function(instance) {
        Error.call(instance);
        instance.stack = new Error().stack;
    };
    var ctorFunc = createImpl(_super);
    ctorFunc.prototype = Object.create(Error.prototype);
    ctorFunc.prototype.constructor = ctorFunc;
    return ctorFunc;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"4LjhZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "arrRemove", ()=>arrRemove);
function arrRemove(arr, item) {
    if (arr) {
        var index = arr.indexOf(item);
        0 <= index && arr.splice(index, 1);
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"ktLZa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "config", ()=>config);
var config = {
    onUnhandledError: null,
    onStoppedNotification: null,
    Promise: undefined,
    useDeprecatedSynchronousErrorHandling: false,
    useDeprecatedNextContext: false
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"bkoKP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "reportUnhandledError", ()=>reportUnhandledError);
var _config = require("../config");
var _timeoutProvider = require("../scheduler/timeoutProvider");
function reportUnhandledError(err) {
    (0, _timeoutProvider.timeoutProvider).setTimeout(function() {
        var onUnhandledError = (0, _config.config).onUnhandledError;
        if (onUnhandledError) onUnhandledError(err);
        else throw err;
    });
}

},{"../config":"ktLZa","../scheduler/timeoutProvider":"1fms4","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"1fms4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "timeoutProvider", ()=>timeoutProvider);
var _tslib = require("tslib");
var timeoutProvider = {
    setTimeout: function(handler, timeout) {
        var args = [];
        for(var _i = 2; _i < arguments.length; _i++)args[_i - 2] = arguments[_i];
        var delegate = timeoutProvider.delegate;
        if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) return delegate.setTimeout.apply(delegate, (0, _tslib.__spreadArray)([
            handler,
            timeout
        ], (0, _tslib.__read)(args)));
        return setTimeout.apply(void 0, (0, _tslib.__spreadArray)([
            handler,
            timeout
        ], (0, _tslib.__read)(args)));
    },
    clearTimeout: function(handle) {
        var delegate = timeoutProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
    },
    delegate: undefined
};

},{"tslib":"3gscj","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"f1sCb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "noop", ()=>noop);
function noop() {}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"kuqr1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "COMPLETE_NOTIFICATION", ()=>COMPLETE_NOTIFICATION);
parcelHelpers.export(exports, "errorNotification", ()=>errorNotification);
parcelHelpers.export(exports, "nextNotification", ()=>nextNotification);
parcelHelpers.export(exports, "createNotification", ()=>createNotification);
var COMPLETE_NOTIFICATION = function() {
    return createNotification("C", undefined, undefined);
}();
function errorNotification(error) {
    return createNotification("E", undefined, error);
}
function nextNotification(value) {
    return createNotification("N", value, undefined);
}
function createNotification(kind, value, error) {
    return {
        kind: kind,
        value: value,
        error: error
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"jEFyy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "errorContext", ()=>errorContext);
parcelHelpers.export(exports, "captureError", ()=>captureError);
var _config = require("../config");
var context = null;
function errorContext(cb) {
    if ((0, _config.config).useDeprecatedSynchronousErrorHandling) {
        var isRoot = !context;
        if (isRoot) context = {
            errorThrown: false,
            error: null
        };
        cb();
        if (isRoot) {
            var _a = context, errorThrown = _a.errorThrown, error = _a.error;
            context = null;
            if (errorThrown) throw error;
        }
    } else cb();
}
function captureError(err) {
    if ((0, _config.config).useDeprecatedSynchronousErrorHandling && context) {
        context.errorThrown = true;
        context.error = err;
    }
}

},{"../config":"ktLZa","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"jUYLN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "observable", ()=>observable);
var observable = function() {
    return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"3zAKH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "pipe", ()=>pipe);
parcelHelpers.export(exports, "pipeFromArray", ()=>pipeFromArray);
var _identity = require("./identity");
function pipe() {
    var fns = [];
    for(var _i = 0; _i < arguments.length; _i++)fns[_i] = arguments[_i];
    return pipeFromArray(fns);
}
function pipeFromArray(fns) {
    if (fns.length === 0) return 0, _identity.identity;
    if (fns.length === 1) return fns[0];
    return function piped(input) {
        return fns.reduce(function(prev, fn) {
            return fn(prev);
        }, input);
    };
}

},{"./identity":"d03yr","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"d03yr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "identity", ()=>identity);
function identity(x) {
    return x;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"25cGg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isInteropObservable", ()=>isInteropObservable);
var _observable = require("../symbol/observable");
var _isFunction = require("./isFunction");
function isInteropObservable(input) {
    return (0, _isFunction.isFunction)(input[0, _observable.observable]);
}

},{"../symbol/observable":"jUYLN","./isFunction":"fpUct","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"59WKk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isAsyncIterable", ()=>isAsyncIterable);
var _isFunction = require("./isFunction");
function isAsyncIterable(obj) {
    return Symbol.asyncIterator && (0, _isFunction.isFunction)(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
}

},{"./isFunction":"fpUct","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"9JwHf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createInvalidObservableTypeError", ()=>createInvalidObservableTypeError);
function createInvalidObservableTypeError(input) {
    return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"lN5io":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isIterable", ()=>isIterable);
var _iterator = require("../symbol/iterator");
var _isFunction = require("./isFunction");
function isIterable(input) {
    return (0, _isFunction.isFunction)(input === null || input === void 0 ? void 0 : input[0, _iterator.iterator]);
}

},{"../symbol/iterator":"9h2ux","./isFunction":"fpUct","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"9h2ux":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getSymbolIterator", ()=>getSymbolIterator);
parcelHelpers.export(exports, "iterator", ()=>iterator);
function getSymbolIterator() {
    if (typeof Symbol !== "function" || !Symbol.iterator) return "@@iterator";
    return Symbol.iterator;
}
var iterator = getSymbolIterator();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"20hsf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "readableStreamLikeToAsyncGenerator", ()=>readableStreamLikeToAsyncGenerator);
parcelHelpers.export(exports, "isReadableStreamLike", ()=>isReadableStreamLike);
var _tslib = require("tslib");
var _isFunction = require("./isFunction");
function readableStreamLikeToAsyncGenerator(readableStream) {
    return (0, _tslib.__asyncGenerator)(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
        var reader, _a, value, done;
        return (0, _tslib.__generator)(this, function(_b) {
            switch(_b.label){
                case 0:
                    reader = readableStream.getReader();
                    _b.label = 1;
                case 1:
                    _b.trys.push([
                        1,
                        ,
                        9,
                        10
                    ]);
                    _b.label = 2;
                case 2:
                    return [
                        4,
                        (0, _tslib.__await)(reader.read())
                    ];
                case 3:
                    _a = _b.sent(), value = _a.value, done = _a.done;
                    if (!done) return [
                        3,
                        5
                    ];
                    return [
                        4,
                        (0, _tslib.__await)(void 0)
                    ];
                case 4:
                    return [
                        2,
                        _b.sent()
                    ];
                case 5:
                    return [
                        4,
                        (0, _tslib.__await)(value)
                    ];
                case 6:
                    return [
                        4,
                        _b.sent()
                    ];
                case 7:
                    _b.sent();
                    return [
                        3,
                        2
                    ];
                case 8:
                    return [
                        3,
                        10
                    ];
                case 9:
                    reader.releaseLock();
                    return [
                        7
                    ];
                case 10:
                    return [
                        2
                    ];
            }
        });
    });
}
function isReadableStreamLike(obj) {
    return (0, _isFunction.isFunction)(obj === null || obj === void 0 ? void 0 : obj.getReader);
}

},{"tslib":"3gscj","./isFunction":"fpUct","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"hrKGc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createOperatorSubscriber", ()=>createOperatorSubscriber);
parcelHelpers.export(exports, "OperatorSubscriber", ()=>OperatorSubscriber);
var _tslib = require("tslib");
var _subscriber = require("../Subscriber");
function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
    return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
}
var OperatorSubscriber = function(_super) {
    (0, _tslib.__extends)(OperatorSubscriber, _super);
    function OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
        var _this = _super.call(this, destination) || this;
        _this.onFinalize = onFinalize;
        _this.shouldUnsubscribe = shouldUnsubscribe;
        _this._next = onNext ? function(value) {
            try {
                onNext(value);
            } catch (err) {
                destination.error(err);
            }
        } : _super.prototype._next;
        _this._error = onError ? function(err) {
            try {
                onError(err);
            } catch (err) {
                destination.error(err);
            } finally{
                this.unsubscribe();
            }
        } : _super.prototype._error;
        _this._complete = onComplete ? function() {
            try {
                onComplete();
            } catch (err) {
                destination.error(err);
            } finally{
                this.unsubscribe();
            }
        } : _super.prototype._complete;
        return _this;
    }
    OperatorSubscriber.prototype.unsubscribe = function() {
        var _a;
        if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
            var closed_1 = this.closed;
            _super.prototype.unsubscribe.call(this);
            !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 || _a.call(this));
        }
    };
    return OperatorSubscriber;
}((0, _subscriber.Subscriber));

},{"tslib":"3gscj","../Subscriber":"8Btbx","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"9Llvq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "auditTime", ()=>auditTime);
var _async = require("../scheduler/async");
var _audit = require("./audit");
var _timer = require("../observable/timer");
function auditTime(duration, scheduler) {
    if (scheduler === void 0) scheduler = (0, _async.asyncScheduler);
    return (0, _audit.audit)(function() {
        return (0, _timer.timer)(duration, scheduler);
    });
}

},{"../scheduler/async":"eIZ5a","./audit":"dsTZY","../observable/timer":"EANJK","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"eIZ5a":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "asyncScheduler", ()=>asyncScheduler);
parcelHelpers.export(exports, "async", ()=>async);
var _asyncAction = require("./AsyncAction");
var _asyncScheduler = require("./AsyncScheduler");
var asyncScheduler = new (0, _asyncScheduler.AsyncScheduler)((0, _asyncAction.AsyncAction));
var async = asyncScheduler;

},{"./AsyncAction":"bh2bi","./AsyncScheduler":"21exO","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"bh2bi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AsyncAction", ()=>AsyncAction);
var _tslib = require("tslib");
var _action = require("./Action");
var _intervalProvider = require("./intervalProvider");
var _arrRemove = require("../util/arrRemove");
var AsyncAction = function(_super) {
    (0, _tslib.__extends)(AsyncAction, _super);
    function AsyncAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.pending = false;
        return _this;
    }
    AsyncAction.prototype.schedule = function(state, delay) {
        var _a;
        if (delay === void 0) delay = 0;
        if (this.closed) return this;
        this.state = state;
        var id = this.id;
        var scheduler = this.scheduler;
        if (id != null) this.id = this.recycleAsyncId(scheduler, id, delay);
        this.pending = true;
        this.delay = delay;
        this.id = (_a = this.id) !== null && _a !== void 0 ? _a : this.requestAsyncId(scheduler, this.id, delay);
        return this;
    };
    AsyncAction.prototype.requestAsyncId = function(scheduler, _id, delay) {
        if (delay === void 0) delay = 0;
        return (0, _intervalProvider.intervalProvider).setInterval(scheduler.flush.bind(scheduler, this), delay);
    };
    AsyncAction.prototype.recycleAsyncId = function(_scheduler, id, delay) {
        if (delay === void 0) delay = 0;
        if (delay != null && this.delay === delay && this.pending === false) return id;
        if (id != null) (0, _intervalProvider.intervalProvider).clearInterval(id);
        return undefined;
    };
    AsyncAction.prototype.execute = function(state, delay) {
        if (this.closed) return new Error("executing a cancelled action");
        this.pending = false;
        var error = this._execute(state, delay);
        if (error) return error;
        else if (this.pending === false && this.id != null) this.id = this.recycleAsyncId(this.scheduler, this.id, null);
    };
    AsyncAction.prototype._execute = function(state, _delay) {
        var errored = false;
        var errorValue;
        try {
            this.work(state);
        } catch (e) {
            errored = true;
            errorValue = e ? e : new Error("Scheduled action threw falsy error");
        }
        if (errored) {
            this.unsubscribe();
            return errorValue;
        }
    };
    AsyncAction.prototype.unsubscribe = function() {
        if (!this.closed) {
            var _a = this, id = _a.id, scheduler = _a.scheduler;
            var actions = scheduler.actions;
            this.work = this.state = this.scheduler = null;
            this.pending = false;
            (0, _arrRemove.arrRemove)(actions, this);
            if (id != null) this.id = this.recycleAsyncId(scheduler, id, null);
            this.delay = null;
            _super.prototype.unsubscribe.call(this);
        }
    };
    return AsyncAction;
}((0, _action.Action));

},{"tslib":"3gscj","./Action":"FY0pH","./intervalProvider":"iT7jt","../util/arrRemove":"4LjhZ","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"FY0pH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Action", ()=>Action);
var _tslib = require("tslib");
var _subscription = require("../Subscription");
var Action = function(_super) {
    (0, _tslib.__extends)(Action, _super);
    function Action(scheduler, work) {
        return _super.call(this) || this;
    }
    Action.prototype.schedule = function(state, delay) {
        if (delay === void 0) delay = 0;
        return this;
    };
    return Action;
}((0, _subscription.Subscription));

},{"tslib":"3gscj","../Subscription":"gzL8W","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"iT7jt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "intervalProvider", ()=>intervalProvider);
var _tslib = require("tslib");
var intervalProvider = {
    setInterval: function(handler, timeout) {
        var args = [];
        for(var _i = 2; _i < arguments.length; _i++)args[_i - 2] = arguments[_i];
        var delegate = intervalProvider.delegate;
        if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) return delegate.setInterval.apply(delegate, (0, _tslib.__spreadArray)([
            handler,
            timeout
        ], (0, _tslib.__read)(args)));
        return setInterval.apply(void 0, (0, _tslib.__spreadArray)([
            handler,
            timeout
        ], (0, _tslib.__read)(args)));
    },
    clearInterval: function(handle) {
        var delegate = intervalProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
    },
    delegate: undefined
};

},{"tslib":"3gscj","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"21exO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AsyncScheduler", ()=>AsyncScheduler);
var _tslib = require("tslib");
var _scheduler = require("../Scheduler");
var AsyncScheduler = function(_super) {
    (0, _tslib.__extends)(AsyncScheduler, _super);
    function AsyncScheduler(SchedulerAction, now) {
        if (now === void 0) now = (0, _scheduler.Scheduler).now;
        var _this = _super.call(this, SchedulerAction, now) || this;
        _this.actions = [];
        _this._active = false;
        return _this;
    }
    AsyncScheduler.prototype.flush = function(action) {
        var actions = this.actions;
        if (this._active) {
            actions.push(action);
            return;
        }
        var error;
        this._active = true;
        do {
            if (error = action.execute(action.state, action.delay)) break;
        }while (action = actions.shift());
        this._active = false;
        if (error) {
            while(action = actions.shift())action.unsubscribe();
            throw error;
        }
    };
    return AsyncScheduler;
}((0, _scheduler.Scheduler));

},{"tslib":"3gscj","../Scheduler":"fKhmo","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"fKhmo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Scheduler", ()=>Scheduler);
var _dateTimestampProvider = require("./scheduler/dateTimestampProvider");
var Scheduler = function() {
    function Scheduler(schedulerActionCtor, now) {
        if (now === void 0) now = Scheduler.now;
        this.schedulerActionCtor = schedulerActionCtor;
        this.now = now;
    }
    Scheduler.prototype.schedule = function(work, delay, state) {
        if (delay === void 0) delay = 0;
        return new this.schedulerActionCtor(this, work).schedule(state, delay);
    };
    Scheduler.now = (0, _dateTimestampProvider.dateTimestampProvider).now;
    return Scheduler;
}();

},{"./scheduler/dateTimestampProvider":"eoTcW","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"eoTcW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "dateTimestampProvider", ()=>dateTimestampProvider);
var dateTimestampProvider = {
    now: function() {
        return (dateTimestampProvider.delegate || Date).now();
    },
    delegate: undefined
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"EANJK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "timer", ()=>timer);
var _observable = require("../Observable");
var _async = require("../scheduler/async");
var _isScheduler = require("../util/isScheduler");
var _isDate = require("../util/isDate");
function timer(dueTime, intervalOrScheduler, scheduler) {
    if (dueTime === void 0) dueTime = 0;
    if (scheduler === void 0) scheduler = (0, _async.async);
    var intervalDuration = -1;
    if (intervalOrScheduler != null) {
        if ((0, _isScheduler.isScheduler)(intervalOrScheduler)) scheduler = intervalOrScheduler;
        else intervalDuration = intervalOrScheduler;
    }
    return new (0, _observable.Observable)(function(subscriber) {
        var due = (0, _isDate.isValidDate)(dueTime) ? +dueTime - scheduler.now() : dueTime;
        if (due < 0) due = 0;
        var n = 0;
        return scheduler.schedule(function() {
            if (!subscriber.closed) {
                subscriber.next(n++);
                if (0 <= intervalDuration) this.schedule(undefined, intervalDuration);
                else subscriber.complete();
            }
        }, due);
    });
}

},{"../Observable":"fo3d5","../scheduler/async":"eIZ5a","../util/isScheduler":"bIVeo","../util/isDate":"lsVk7","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"bIVeo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isScheduler", ()=>isScheduler);
var _isFunction = require("./isFunction");
function isScheduler(value) {
    return value && (0, _isFunction.isFunction)(value.schedule);
}

},{"./isFunction":"fpUct","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"lsVk7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isValidDate", ()=>isValidDate);
function isValidDate(value) {
    return value instanceof Date && !isNaN(value);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"bBo8n":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "buffer", ()=>buffer);
var _lift = require("../util/lift");
var _noop = require("../util/noop");
var _operatorSubscriber = require("./OperatorSubscriber");
var _innerFrom = require("../observable/innerFrom");
function buffer(closingNotifier) {
    return (0, _lift.operate)(function(source, subscriber) {
        var currentBuffer = [];
        source.subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function(value) {
            return currentBuffer.push(value);
        }, function() {
            subscriber.next(currentBuffer);
            subscriber.complete();
        }));
        (0, _innerFrom.innerFrom)(closingNotifier).subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function() {
            var b = currentBuffer;
            currentBuffer = [];
            subscriber.next(b);
        }, (0, _noop.noop)));
        return function() {
            currentBuffer = null;
        };
    });
}

},{"../util/lift":"3IZjp","../util/noop":"f1sCb","./OperatorSubscriber":"hrKGc","../observable/innerFrom":"6l3RX","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"2YxsY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "bufferCount", ()=>bufferCount);
var _tslib = require("tslib");
var _lift = require("../util/lift");
var _operatorSubscriber = require("./OperatorSubscriber");
var _arrRemove = require("../util/arrRemove");
function bufferCount(bufferSize, startBufferEvery) {
    if (startBufferEvery === void 0) startBufferEvery = null;
    startBufferEvery = startBufferEvery !== null && startBufferEvery !== void 0 ? startBufferEvery : bufferSize;
    return (0, _lift.operate)(function(source, subscriber) {
        var buffers = [];
        var count = 0;
        source.subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function(value) {
            var e_1, _a, e_2, _b;
            var toEmit = null;
            if (count++ % startBufferEvery === 0) buffers.push([]);
            try {
                for(var buffers_1 = (0, _tslib.__values)(buffers), buffers_1_1 = buffers_1.next(); !buffers_1_1.done; buffers_1_1 = buffers_1.next()){
                    var buffer = buffers_1_1.value;
                    buffer.push(value);
                    if (bufferSize <= buffer.length) {
                        toEmit = toEmit !== null && toEmit !== void 0 ? toEmit : [];
                        toEmit.push(buffer);
                    }
                }
            } catch (e_1_1) {
                e_1 = {
                    error: e_1_1
                };
            } finally{
                try {
                    if (buffers_1_1 && !buffers_1_1.done && (_a = buffers_1.return)) _a.call(buffers_1);
                } finally{
                    if (e_1) throw e_1.error;
                }
            }
            if (toEmit) try {
                for(var toEmit_1 = (0, _tslib.__values)(toEmit), toEmit_1_1 = toEmit_1.next(); !toEmit_1_1.done; toEmit_1_1 = toEmit_1.next()){
                    var buffer = toEmit_1_1.value;
                    (0, _arrRemove.arrRemove)(buffers, buffer);
                    subscriber.next(buffer);
                }
            } catch (e_2_1) {
                e_2 = {
                    error: e_2_1
                };
            } finally{
                try {
                    if (toEmit_1_1 && !toEmit_1_1.done && (_b = toEmit_1.return)) _b.call(toEmit_1);
                } finally{
                    if (e_2) throw e_2.error;
                }
            }
        }, function() {
            var e_3, _a;
            try {
                for(var buffers_2 = (0, _tslib.__values)(buffers), buffers_2_1 = buffers_2.next(); !buffers_2_1.done; buffers_2_1 = buffers_2.next()){
                    var buffer = buffers_2_1.value;
                    subscriber.next(buffer);
                }
            } catch (e_3_1) {
                e_3 = {
                    error: e_3_1
                };
            } finally{
                try {
                    if (buffers_2_1 && !buffers_2_1.done && (_a = buffers_2.return)) _a.call(buffers_2);
                } finally{
                    if (e_3) throw e_3.error;
                }
            }
            subscriber.complete();
        }, undefined, function() {
            buffers = null;
        }));
    });
}

},{"tslib":"3gscj","../util/lift":"3IZjp","./OperatorSubscriber":"hrKGc","../util/arrRemove":"4LjhZ","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"4R33k":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "bufferTime", ()=>bufferTime);
var _tslib = require("tslib");
var _subscription = require("../Subscription");
var _lift = require("../util/lift");
var _operatorSubscriber = require("./OperatorSubscriber");
var _arrRemove = require("../util/arrRemove");
var _async = require("../scheduler/async");
var _args = require("../util/args");
var _executeSchedule = require("../util/executeSchedule");
function bufferTime(bufferTimeSpan) {
    var _a, _b;
    var otherArgs = [];
    for(var _i = 1; _i < arguments.length; _i++)otherArgs[_i - 1] = arguments[_i];
    var scheduler = (_a = (0, _args.popScheduler)(otherArgs)) !== null && _a !== void 0 ? _a : (0, _async.asyncScheduler);
    var bufferCreationInterval = (_b = otherArgs[0]) !== null && _b !== void 0 ? _b : null;
    var maxBufferSize = otherArgs[1] || Infinity;
    return (0, _lift.operate)(function(source, subscriber) {
        var bufferRecords = [];
        var restartOnEmit = false;
        var emit = function(record) {
            var buffer = record.buffer, subs = record.subs;
            subs.unsubscribe();
            (0, _arrRemove.arrRemove)(bufferRecords, record);
            subscriber.next(buffer);
            restartOnEmit && startBuffer();
        };
        var startBuffer = function() {
            if (bufferRecords) {
                var subs = new (0, _subscription.Subscription)();
                subscriber.add(subs);
                var buffer = [];
                var record_1 = {
                    buffer: buffer,
                    subs: subs
                };
                bufferRecords.push(record_1);
                (0, _executeSchedule.executeSchedule)(subs, scheduler, function() {
                    return emit(record_1);
                }, bufferTimeSpan);
            }
        };
        if (bufferCreationInterval !== null && bufferCreationInterval >= 0) (0, _executeSchedule.executeSchedule)(subscriber, scheduler, startBuffer, bufferCreationInterval, true);
        else restartOnEmit = true;
        startBuffer();
        var bufferTimeSubscriber = (0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function(value) {
            var e_1, _a;
            var recordsCopy = bufferRecords.slice();
            try {
                for(var recordsCopy_1 = (0, _tslib.__values)(recordsCopy), recordsCopy_1_1 = recordsCopy_1.next(); !recordsCopy_1_1.done; recordsCopy_1_1 = recordsCopy_1.next()){
                    var record = recordsCopy_1_1.value;
                    var buffer = record.buffer;
                    buffer.push(value);
                    maxBufferSize <= buffer.length && emit(record);
                }
            } catch (e_1_1) {
                e_1 = {
                    error: e_1_1
                };
            } finally{
                try {
                    if (recordsCopy_1_1 && !recordsCopy_1_1.done && (_a = recordsCopy_1.return)) _a.call(recordsCopy_1);
                } finally{
                    if (e_1) throw e_1.error;
                }
            }
        }, function() {
            while(bufferRecords === null || bufferRecords === void 0 ? void 0 : bufferRecords.length)subscriber.next(bufferRecords.shift().buffer);
            bufferTimeSubscriber === null || bufferTimeSubscriber === void 0 || bufferTimeSubscriber.unsubscribe();
            subscriber.complete();
            subscriber.unsubscribe();
        }, undefined, function() {
            return bufferRecords = null;
        });
        source.subscribe(bufferTimeSubscriber);
    });
}

},{"tslib":"3gscj","../Subscription":"gzL8W","../util/lift":"3IZjp","./OperatorSubscriber":"hrKGc","../util/arrRemove":"4LjhZ","../scheduler/async":"eIZ5a","../util/args":"ccsng","../util/executeSchedule":"4ayy2","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"ccsng":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "popResultSelector", ()=>popResultSelector);
parcelHelpers.export(exports, "popScheduler", ()=>popScheduler);
parcelHelpers.export(exports, "popNumber", ()=>popNumber);
var _isFunction = require("./isFunction");
var _isScheduler = require("./isScheduler");
function last(arr) {
    return arr[arr.length - 1];
}
function popResultSelector(args) {
    return (0, _isFunction.isFunction)(last(args)) ? args.pop() : undefined;
}
function popScheduler(args) {
    return (0, _isScheduler.isScheduler)(last(args)) ? args.pop() : undefined;
}
function popNumber(args, defaultValue) {
    return typeof last(args) === "number" ? args.pop() : defaultValue;
}

},{"./isFunction":"fpUct","./isScheduler":"bIVeo","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"4ayy2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "executeSchedule", ()=>executeSchedule);
function executeSchedule(parentSubscription, scheduler, work, delay, repeat) {
    if (delay === void 0) delay = 0;
    if (repeat === void 0) repeat = false;
    var scheduleSubscription = scheduler.schedule(function() {
        work();
        if (repeat) parentSubscription.add(this.schedule(null, delay));
        else this.unsubscribe();
    }, delay);
    parentSubscription.add(scheduleSubscription);
    if (!repeat) return scheduleSubscription;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"jNIZ7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "bufferToggle", ()=>bufferToggle);
var _tslib = require("tslib");
var _subscription = require("../Subscription");
var _lift = require("../util/lift");
var _innerFrom = require("../observable/innerFrom");
var _operatorSubscriber = require("./OperatorSubscriber");
var _noop = require("../util/noop");
var _arrRemove = require("../util/arrRemove");
function bufferToggle(openings, closingSelector) {
    return (0, _lift.operate)(function(source, subscriber) {
        var buffers = [];
        (0, _innerFrom.innerFrom)(openings).subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function(openValue) {
            var buffer = [];
            buffers.push(buffer);
            var closingSubscription = new (0, _subscription.Subscription)();
            var emitBuffer = function() {
                (0, _arrRemove.arrRemove)(buffers, buffer);
                subscriber.next(buffer);
                closingSubscription.unsubscribe();
            };
            closingSubscription.add((0, _innerFrom.innerFrom)(closingSelector(openValue)).subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, emitBuffer, (0, _noop.noop))));
        }, (0, _noop.noop)));
        source.subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function(value) {
            var e_1, _a;
            try {
                for(var buffers_1 = (0, _tslib.__values)(buffers), buffers_1_1 = buffers_1.next(); !buffers_1_1.done; buffers_1_1 = buffers_1.next()){
                    var buffer = buffers_1_1.value;
                    buffer.push(value);
                }
            } catch (e_1_1) {
                e_1 = {
                    error: e_1_1
                };
            } finally{
                try {
                    if (buffers_1_1 && !buffers_1_1.done && (_a = buffers_1.return)) _a.call(buffers_1);
                } finally{
                    if (e_1) throw e_1.error;
                }
            }
        }, function() {
            while(buffers.length > 0)subscriber.next(buffers.shift());
            subscriber.complete();
        }));
    });
}

},{"tslib":"3gscj","../Subscription":"gzL8W","../util/lift":"3IZjp","../observable/innerFrom":"6l3RX","./OperatorSubscriber":"hrKGc","../util/noop":"f1sCb","../util/arrRemove":"4LjhZ","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"5GTvo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "bufferWhen", ()=>bufferWhen);
var _lift = require("../util/lift");
var _noop = require("../util/noop");
var _operatorSubscriber = require("./OperatorSubscriber");
var _innerFrom = require("../observable/innerFrom");
function bufferWhen(closingSelector) {
    return (0, _lift.operate)(function(source, subscriber) {
        var buffer = null;
        var closingSubscriber = null;
        var openBuffer = function() {
            closingSubscriber === null || closingSubscriber === void 0 || closingSubscriber.unsubscribe();
            var b = buffer;
            buffer = [];
            b && subscriber.next(b);
            (0, _innerFrom.innerFrom)(closingSelector()).subscribe(closingSubscriber = (0, _operatorSubscriber.createOperatorSubscriber)(subscriber, openBuffer, (0, _noop.noop)));
        };
        openBuffer();
        source.subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function(value) {
            return buffer === null || buffer === void 0 ? void 0 : buffer.push(value);
        }, function() {
            buffer && subscriber.next(buffer);
            subscriber.complete();
        }, undefined, function() {
            return buffer = closingSubscriber = null;
        }));
    });
}

},{"../util/lift":"3IZjp","../util/noop":"f1sCb","./OperatorSubscriber":"hrKGc","../observable/innerFrom":"6l3RX","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"bW2OG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "catchError", ()=>catchError);
var _innerFrom = require("../observable/innerFrom");
var _operatorSubscriber = require("./OperatorSubscriber");
var _lift = require("../util/lift");
function catchError(selector) {
    return (0, _lift.operate)(function(source, subscriber) {
        var innerSub = null;
        var syncUnsub = false;
        var handledResult;
        innerSub = source.subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, undefined, undefined, function(err) {
            handledResult = (0, _innerFrom.innerFrom)(selector(err, catchError(selector)(source)));
            if (innerSub) {
                innerSub.unsubscribe();
                innerSub = null;
                handledResult.subscribe(subscriber);
            } else syncUnsub = true;
        }));
        if (syncUnsub) {
            innerSub.unsubscribe();
            innerSub = null;
            handledResult.subscribe(subscriber);
        }
    });
}

},{"../observable/innerFrom":"6l3RX","./OperatorSubscriber":"hrKGc","../util/lift":"3IZjp","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"7sph5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "combineAll", ()=>combineAll);
var _combineLatestAll = require("./combineLatestAll");
var combineAll = (0, _combineLatestAll.combineLatestAll);

},{"./combineLatestAll":"1RyF0","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"1RyF0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "combineLatestAll", ()=>combineLatestAll);
var _combineLatest = require("../observable/combineLatest");
var _joinAllInternals = require("./joinAllInternals");
function combineLatestAll(project) {
    return (0, _joinAllInternals.joinAllInternals)((0, _combineLatest.combineLatest), project);
}

},{"../observable/combineLatest":"8WwIf","./joinAllInternals":"cDD5p","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"8WwIf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "combineLatest", ()=>combineLatest);
parcelHelpers.export(exports, "combineLatestInit", ()=>combineLatestInit);
var _observable = require("../Observable");
var _argsArgArrayOrObject = require("../util/argsArgArrayOrObject");
var _from = require("./from");
var _identity = require("../util/identity");
var _mapOneOrManyArgs = require("../util/mapOneOrManyArgs");
var _args = require("../util/args");
var _createObject = require("../util/createObject");
var _operatorSubscriber = require("../operators/OperatorSubscriber");
var _executeSchedule = require("../util/executeSchedule");
function combineLatest() {
    var args = [];
    for(var _i = 0; _i < arguments.length; _i++)args[_i] = arguments[_i];
    var scheduler = (0, _args.popScheduler)(args);
    var resultSelector = (0, _args.popResultSelector)(args);
    var _a = (0, _argsArgArrayOrObject.argsArgArrayOrObject)(args), observables = _a.args, keys = _a.keys;
    if (observables.length === 0) return (0, _from.from)([], scheduler);
    var result = new (0, _observable.Observable)(combineLatestInit(observables, scheduler, keys ? function(values) {
        return (0, _createObject.createObject)(keys, values);
    } : (0, _identity.identity)));
    return resultSelector ? result.pipe((0, _mapOneOrManyArgs.mapOneOrManyArgs)(resultSelector)) : result;
}
function combineLatestInit(observables, scheduler, valueTransform) {
    if (valueTransform === void 0) valueTransform = (0, _identity.identity);
    return function(subscriber) {
        maybeSchedule(scheduler, function() {
            var length = observables.length;
            var values = new Array(length);
            var active = length;
            var remainingFirstValues = length;
            var _loop_1 = function(i) {
                maybeSchedule(scheduler, function() {
                    var source = (0, _from.from)(observables[i], scheduler);
                    var hasFirstValue = false;
                    source.subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function(value) {
                        values[i] = value;
                        if (!hasFirstValue) {
                            hasFirstValue = true;
                            remainingFirstValues--;
                        }
                        if (!remainingFirstValues) subscriber.next(valueTransform(values.slice()));
                    }, function() {
                        if (!--active) subscriber.complete();
                    }));
                }, subscriber);
            };
            for(var i = 0; i < length; i++)_loop_1(i);
        }, subscriber);
    };
}
function maybeSchedule(scheduler, execute, subscription) {
    if (scheduler) (0, _executeSchedule.executeSchedule)(subscription, scheduler, execute);
    else execute();
}

},{"../Observable":"fo3d5","../util/argsArgArrayOrObject":"9A3xN","./from":"aDpqg","../util/identity":"d03yr","../util/mapOneOrManyArgs":"hyphn","../util/args":"ccsng","../util/createObject":"cbhvC","../operators/OperatorSubscriber":"hrKGc","../util/executeSchedule":"4ayy2","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"9A3xN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "argsArgArrayOrObject", ()=>argsArgArrayOrObject);
var isArray = Array.isArray;
var getPrototypeOf = Object.getPrototypeOf, objectProto = Object.prototype, getKeys = Object.keys;
function argsArgArrayOrObject(args) {
    if (args.length === 1) {
        var first_1 = args[0];
        if (isArray(first_1)) return {
            args: first_1,
            keys: null
        };
        if (isPOJO(first_1)) {
            var keys = getKeys(first_1);
            return {
                args: keys.map(function(key) {
                    return first_1[key];
                }),
                keys: keys
            };
        }
    }
    return {
        args: args,
        keys: null
    };
}
function isPOJO(obj) {
    return obj && typeof obj === "object" && getPrototypeOf(obj) === objectProto;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"aDpqg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "from", ()=>from);
var _scheduled = require("../scheduled/scheduled");
var _innerFrom = require("./innerFrom");
function from(input, scheduler) {
    return scheduler ? (0, _scheduled.scheduled)(input, scheduler) : (0, _innerFrom.innerFrom)(input);
}

},{"../scheduled/scheduled":"eaKb6","./innerFrom":"6l3RX","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"eaKb6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "scheduled", ()=>scheduled);
var _scheduleObservable = require("./scheduleObservable");
var _schedulePromise = require("./schedulePromise");
var _scheduleArray = require("./scheduleArray");
var _scheduleIterable = require("./scheduleIterable");
var _scheduleAsyncIterable = require("./scheduleAsyncIterable");
var _isInteropObservable = require("../util/isInteropObservable");
var _isPromise = require("../util/isPromise");
var _isArrayLike = require("../util/isArrayLike");
var _isIterable = require("../util/isIterable");
var _isAsyncIterable = require("../util/isAsyncIterable");
var _throwUnobservableError = require("../util/throwUnobservableError");
var _isReadableStreamLike = require("../util/isReadableStreamLike");
var _scheduleReadableStreamLike = require("./scheduleReadableStreamLike");
function scheduled(input, scheduler) {
    if (input != null) {
        if ((0, _isInteropObservable.isInteropObservable)(input)) return (0, _scheduleObservable.scheduleObservable)(input, scheduler);
        if ((0, _isArrayLike.isArrayLike)(input)) return (0, _scheduleArray.scheduleArray)(input, scheduler);
        if ((0, _isPromise.isPromise)(input)) return (0, _schedulePromise.schedulePromise)(input, scheduler);
        if ((0, _isAsyncIterable.isAsyncIterable)(input)) return (0, _scheduleAsyncIterable.scheduleAsyncIterable)(input, scheduler);
        if ((0, _isIterable.isIterable)(input)) return (0, _scheduleIterable.scheduleIterable)(input, scheduler);
        if ((0, _isReadableStreamLike.isReadableStreamLike)(input)) return (0, _scheduleReadableStreamLike.scheduleReadableStreamLike)(input, scheduler);
    }
    throw (0, _throwUnobservableError.createInvalidObservableTypeError)(input);
}

},{"./scheduleObservable":"klzro","./schedulePromise":"THIPZ","./scheduleArray":"mRDc5","./scheduleIterable":"6PmK2","./scheduleAsyncIterable":"9Kcjd","../util/isInteropObservable":"25cGg","../util/isPromise":"iEil1","../util/isArrayLike":"hj6kw","../util/isIterable":"lN5io","../util/isAsyncIterable":"59WKk","../util/throwUnobservableError":"9JwHf","../util/isReadableStreamLike":"20hsf","./scheduleReadableStreamLike":"hkneP","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"klzro":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "scheduleObservable", ()=>scheduleObservable);
var _innerFrom = require("../observable/innerFrom");
var _observeOn = require("../operators/observeOn");
var _subscribeOn = require("../operators/subscribeOn");
function scheduleObservable(input, scheduler) {
    return (0, _innerFrom.innerFrom)(input).pipe((0, _subscribeOn.subscribeOn)(scheduler), (0, _observeOn.observeOn)(scheduler));
}

},{"../observable/innerFrom":"6l3RX","../operators/observeOn":"k6OlK","../operators/subscribeOn":"a8ffZ","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"k6OlK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "observeOn", ()=>observeOn);
var _executeSchedule = require("../util/executeSchedule");
var _lift = require("../util/lift");
var _operatorSubscriber = require("./OperatorSubscriber");
function observeOn(scheduler, delay) {
    if (delay === void 0) delay = 0;
    return (0, _lift.operate)(function(source, subscriber) {
        source.subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function(value) {
            return (0, _executeSchedule.executeSchedule)(subscriber, scheduler, function() {
                return subscriber.next(value);
            }, delay);
        }, function() {
            return (0, _executeSchedule.executeSchedule)(subscriber, scheduler, function() {
                return subscriber.complete();
            }, delay);
        }, function(err) {
            return (0, _executeSchedule.executeSchedule)(subscriber, scheduler, function() {
                return subscriber.error(err);
            }, delay);
        }));
    });
}

},{"../util/executeSchedule":"4ayy2","../util/lift":"3IZjp","./OperatorSubscriber":"hrKGc","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"a8ffZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "subscribeOn", ()=>subscribeOn);
var _lift = require("../util/lift");
function subscribeOn(scheduler, delay) {
    if (delay === void 0) delay = 0;
    return (0, _lift.operate)(function(source, subscriber) {
        subscriber.add(scheduler.schedule(function() {
            return source.subscribe(subscriber);
        }, delay));
    });
}

},{"../util/lift":"3IZjp","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"THIPZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "schedulePromise", ()=>schedulePromise);
var _innerFrom = require("../observable/innerFrom");
var _observeOn = require("../operators/observeOn");
var _subscribeOn = require("../operators/subscribeOn");
function schedulePromise(input, scheduler) {
    return (0, _innerFrom.innerFrom)(input).pipe((0, _subscribeOn.subscribeOn)(scheduler), (0, _observeOn.observeOn)(scheduler));
}

},{"../observable/innerFrom":"6l3RX","../operators/observeOn":"k6OlK","../operators/subscribeOn":"a8ffZ","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"mRDc5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "scheduleArray", ()=>scheduleArray);
var _observable = require("../Observable");
function scheduleArray(input, scheduler) {
    return new (0, _observable.Observable)(function(subscriber) {
        var i = 0;
        return scheduler.schedule(function() {
            if (i === input.length) subscriber.complete();
            else {
                subscriber.next(input[i++]);
                if (!subscriber.closed) this.schedule();
            }
        });
    });
}

},{"../Observable":"fo3d5","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"6PmK2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "scheduleIterable", ()=>scheduleIterable);
var _observable = require("../Observable");
var _iterator = require("../symbol/iterator");
var _isFunction = require("../util/isFunction");
var _executeSchedule = require("../util/executeSchedule");
function scheduleIterable(input, scheduler) {
    return new (0, _observable.Observable)(function(subscriber) {
        var iterator;
        (0, _executeSchedule.executeSchedule)(subscriber, scheduler, function() {
            iterator = input[0, _iterator.iterator]();
            (0, _executeSchedule.executeSchedule)(subscriber, scheduler, function() {
                var _a;
                var value;
                var done;
                try {
                    _a = iterator.next(), value = _a.value, done = _a.done;
                } catch (err) {
                    subscriber.error(err);
                    return;
                }
                if (done) subscriber.complete();
                else subscriber.next(value);
            }, 0, true);
        });
        return function() {
            return (0, _isFunction.isFunction)(iterator === null || iterator === void 0 ? void 0 : iterator.return) && iterator.return();
        };
    });
}

},{"../Observable":"fo3d5","../symbol/iterator":"9h2ux","../util/isFunction":"fpUct","../util/executeSchedule":"4ayy2","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"9Kcjd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "scheduleAsyncIterable", ()=>scheduleAsyncIterable);
var _observable = require("../Observable");
var _executeSchedule = require("../util/executeSchedule");
function scheduleAsyncIterable(input, scheduler) {
    if (!input) throw new Error("Iterable cannot be null");
    return new (0, _observable.Observable)(function(subscriber) {
        (0, _executeSchedule.executeSchedule)(subscriber, scheduler, function() {
            var iterator = input[Symbol.asyncIterator]();
            (0, _executeSchedule.executeSchedule)(subscriber, scheduler, function() {
                iterator.next().then(function(result) {
                    if (result.done) subscriber.complete();
                    else subscriber.next(result.value);
                });
            }, 0, true);
        });
    });
}

},{"../Observable":"fo3d5","../util/executeSchedule":"4ayy2","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"hkneP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "scheduleReadableStreamLike", ()=>scheduleReadableStreamLike);
var _scheduleAsyncIterable = require("./scheduleAsyncIterable");
var _isReadableStreamLike = require("../util/isReadableStreamLike");
function scheduleReadableStreamLike(input, scheduler) {
    return (0, _scheduleAsyncIterable.scheduleAsyncIterable)((0, _isReadableStreamLike.readableStreamLikeToAsyncGenerator)(input), scheduler);
}

},{"./scheduleAsyncIterable":"9Kcjd","../util/isReadableStreamLike":"20hsf","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"hyphn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mapOneOrManyArgs", ()=>mapOneOrManyArgs);
var _tslib = require("tslib");
var _map = require("../operators/map");
var isArray = Array.isArray;
function callOrApply(fn, args) {
    return isArray(args) ? fn.apply(void 0, (0, _tslib.__spreadArray)([], (0, _tslib.__read)(args))) : fn(args);
}
function mapOneOrManyArgs(fn) {
    return (0, _map.map)(function(args) {
        return callOrApply(fn, args);
    });
}

},{"tslib":"3gscj","../operators/map":"9Azp4","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"9Azp4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "map", ()=>map);
var _lift = require("../util/lift");
var _operatorSubscriber = require("./OperatorSubscriber");
function map(project, thisArg) {
    return (0, _lift.operate)(function(source, subscriber) {
        var index = 0;
        source.subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function(value) {
            subscriber.next(project.call(thisArg, value, index++));
        }));
    });
}

},{"../util/lift":"3IZjp","./OperatorSubscriber":"hrKGc","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"cbhvC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createObject", ()=>createObject);
function createObject(keys, values) {
    return keys.reduce(function(result, key, i) {
        return result[key] = values[i], result;
    }, {});
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"cDD5p":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "joinAllInternals", ()=>joinAllInternals);
var _identity = require("../util/identity");
var _mapOneOrManyArgs = require("../util/mapOneOrManyArgs");
var _pipe = require("../util/pipe");
var _mergeMap = require("./mergeMap");
var _toArray = require("./toArray");
function joinAllInternals(joinFn, project) {
    return (0, _pipe.pipe)((0, _toArray.toArray)(), (0, _mergeMap.mergeMap)(function(sources) {
        return joinFn(sources);
    }), project ? (0, _mapOneOrManyArgs.mapOneOrManyArgs)(project) : (0, _identity.identity));
}

},{"../util/identity":"d03yr","../util/mapOneOrManyArgs":"hyphn","../util/pipe":"3zAKH","./mergeMap":"5gFTr","./toArray":"39VfS","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"5gFTr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mergeMap", ()=>mergeMap);
var _map = require("./map");
var _innerFrom = require("../observable/innerFrom");
var _lift = require("../util/lift");
var _mergeInternals = require("./mergeInternals");
var _isFunction = require("../util/isFunction");
function mergeMap(project, resultSelector, concurrent) {
    if (concurrent === void 0) concurrent = Infinity;
    if ((0, _isFunction.isFunction)(resultSelector)) return mergeMap(function(a, i) {
        return (0, _map.map)(function(b, ii) {
            return resultSelector(a, b, i, ii);
        })((0, _innerFrom.innerFrom)(project(a, i)));
    }, concurrent);
    else if (typeof resultSelector === "number") concurrent = resultSelector;
    return (0, _lift.operate)(function(source, subscriber) {
        return (0, _mergeInternals.mergeInternals)(source, subscriber, project, concurrent);
    });
}

},{"./map":"9Azp4","../observable/innerFrom":"6l3RX","../util/lift":"3IZjp","./mergeInternals":"437Ap","../util/isFunction":"fpUct","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"437Ap":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mergeInternals", ()=>mergeInternals);
var _innerFrom = require("../observable/innerFrom");
var _executeSchedule = require("../util/executeSchedule");
var _operatorSubscriber = require("./OperatorSubscriber");
function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {
    var buffer = [];
    var active = 0;
    var index = 0;
    var isComplete = false;
    var checkComplete = function() {
        if (isComplete && !buffer.length && !active) subscriber.complete();
    };
    var outerNext = function(value) {
        return active < concurrent ? doInnerSub(value) : buffer.push(value);
    };
    var doInnerSub = function(value) {
        expand && subscriber.next(value);
        active++;
        var innerComplete = false;
        (0, _innerFrom.innerFrom)(project(value, index++)).subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function(innerValue) {
            onBeforeNext === null || onBeforeNext === void 0 || onBeforeNext(innerValue);
            if (expand) outerNext(innerValue);
            else subscriber.next(innerValue);
        }, function() {
            innerComplete = true;
        }, undefined, function() {
            if (innerComplete) try {
                active--;
                var _loop_1 = function() {
                    var bufferedValue = buffer.shift();
                    if (innerSubScheduler) (0, _executeSchedule.executeSchedule)(subscriber, innerSubScheduler, function() {
                        return doInnerSub(bufferedValue);
                    });
                    else doInnerSub(bufferedValue);
                };
                while(buffer.length && active < concurrent)_loop_1();
                checkComplete();
            } catch (err) {
                subscriber.error(err);
            }
        }));
    };
    source.subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, outerNext, function() {
        isComplete = true;
        checkComplete();
    }));
    return function() {
        additionalFinalizer === null || additionalFinalizer === void 0 || additionalFinalizer();
    };
}

},{"../observable/innerFrom":"6l3RX","../util/executeSchedule":"4ayy2","./OperatorSubscriber":"hrKGc","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"39VfS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "toArray", ()=>toArray);
var _reduce = require("./reduce");
var _lift = require("../util/lift");
var arrReducer = function(arr, value) {
    return arr.push(value), arr;
};
function toArray() {
    return (0, _lift.operate)(function(source, subscriber) {
        (0, _reduce.reduce)(arrReducer, [])(source).subscribe(subscriber);
    });
}

},{"./reduce":"4kl4u","../util/lift":"3IZjp","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"4kl4u":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "reduce", ()=>reduce);
var _scanInternals = require("./scanInternals");
var _lift = require("../util/lift");
function reduce(accumulator, seed) {
    return (0, _lift.operate)((0, _scanInternals.scanInternals)(accumulator, seed, arguments.length >= 2, false, true));
}

},{"./scanInternals":"jLfgH","../util/lift":"3IZjp","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"jLfgH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "scanInternals", ()=>scanInternals);
var _operatorSubscriber = require("./OperatorSubscriber");
function scanInternals(accumulator, seed, hasSeed, emitOnNext, emitBeforeComplete) {
    return function(source, subscriber) {
        var hasState = hasSeed;
        var state = seed;
        var index = 0;
        source.subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function(value) {
            var i = index++;
            state = hasState ? accumulator(state, value, i) : (hasState = true, value);
            emitOnNext && subscriber.next(state);
        }, emitBeforeComplete && function() {
            hasState && subscriber.next(state);
            subscriber.complete();
        }));
    };
}

},{"./OperatorSubscriber":"hrKGc","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"kMtrH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "combineLatest", ()=>combineLatest);
var _tslib = require("tslib");
var _combineLatest = require("../observable/combineLatest");
var _lift = require("../util/lift");
var _argsOrArgArray = require("../util/argsOrArgArray");
var _mapOneOrManyArgs = require("../util/mapOneOrManyArgs");
var _pipe = require("../util/pipe");
var _args = require("../util/args");
function combineLatest() {
    var args = [];
    for(var _i = 0; _i < arguments.length; _i++)args[_i] = arguments[_i];
    var resultSelector = (0, _args.popResultSelector)(args);
    return resultSelector ? (0, _pipe.pipe)(combineLatest.apply(void 0, (0, _tslib.__spreadArray)([], (0, _tslib.__read)(args))), (0, _mapOneOrManyArgs.mapOneOrManyArgs)(resultSelector)) : (0, _lift.operate)(function(source, subscriber) {
        (0, _combineLatest.combineLatestInit)((0, _tslib.__spreadArray)([
            source
        ], (0, _tslib.__read)((0, _argsOrArgArray.argsOrArgArray)(args))))(subscriber);
    });
}

},{"tslib":"3gscj","../observable/combineLatest":"8WwIf","../util/lift":"3IZjp","../util/argsOrArgArray":"9KARg","../util/mapOneOrManyArgs":"hyphn","../util/pipe":"3zAKH","../util/args":"ccsng","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"9KARg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "argsOrArgArray", ()=>argsOrArgArray);
var isArray = Array.isArray;
function argsOrArgArray(args) {
    return args.length === 1 && isArray(args[0]) ? args[0] : args;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"96hvT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "combineLatestWith", ()=>combineLatestWith);
var _tslib = require("tslib");
var _combineLatest = require("./combineLatest");
function combineLatestWith() {
    var otherSources = [];
    for(var _i = 0; _i < arguments.length; _i++)otherSources[_i] = arguments[_i];
    return (0, _combineLatest.combineLatest).apply(void 0, (0, _tslib.__spreadArray)([], (0, _tslib.__read)(otherSources)));
}

},{"tslib":"3gscj","./combineLatest":"kMtrH","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"8l3w8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "concat", ()=>concat);
var _tslib = require("tslib");
var _lift = require("../util/lift");
var _concatAll = require("./concatAll");
var _args = require("../util/args");
var _from = require("../observable/from");
function concat() {
    var args = [];
    for(var _i = 0; _i < arguments.length; _i++)args[_i] = arguments[_i];
    var scheduler = (0, _args.popScheduler)(args);
    return (0, _lift.operate)(function(source, subscriber) {
        (0, _concatAll.concatAll)()((0, _from.from)((0, _tslib.__spreadArray)([
            source
        ], (0, _tslib.__read)(args)), scheduler)).subscribe(subscriber);
    });
}

},{"tslib":"3gscj","../util/lift":"3IZjp","./concatAll":"3N9Cc","../util/args":"ccsng","../observable/from":"aDpqg","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"3N9Cc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "concatAll", ()=>concatAll);
var _mergeAll = require("./mergeAll");
function concatAll() {
    return (0, _mergeAll.mergeAll)(1);
}

},{"./mergeAll":"iRJ2C","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"iRJ2C":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mergeAll", ()=>mergeAll);
var _mergeMap = require("./mergeMap");
var _identity = require("../util/identity");
function mergeAll(concurrent) {
    if (concurrent === void 0) concurrent = Infinity;
    return (0, _mergeMap.mergeMap)((0, _identity.identity), concurrent);
}

},{"./mergeMap":"5gFTr","../util/identity":"d03yr","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"emBSh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "concatMap", ()=>concatMap);
var _mergeMap = require("./mergeMap");
var _isFunction = require("../util/isFunction");
function concatMap(project, resultSelector) {
    return (0, _isFunction.isFunction)(resultSelector) ? (0, _mergeMap.mergeMap)(project, resultSelector, 1) : (0, _mergeMap.mergeMap)(project, 1);
}

},{"./mergeMap":"5gFTr","../util/isFunction":"fpUct","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"38P3I":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "concatMapTo", ()=>concatMapTo);
var _concatMap = require("./concatMap");
var _isFunction = require("../util/isFunction");
function concatMapTo(innerObservable, resultSelector) {
    return (0, _isFunction.isFunction)(resultSelector) ? (0, _concatMap.concatMap)(function() {
        return innerObservable;
    }, resultSelector) : (0, _concatMap.concatMap)(function() {
        return innerObservable;
    });
}

},{"./concatMap":"emBSh","../util/isFunction":"fpUct","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"YJ4oC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "concatWith", ()=>concatWith);
var _tslib = require("tslib");
var _concat = require("./concat");
function concatWith() {
    var otherSources = [];
    for(var _i = 0; _i < arguments.length; _i++)otherSources[_i] = arguments[_i];
    return (0, _concat.concat).apply(void 0, (0, _tslib.__spreadArray)([], (0, _tslib.__read)(otherSources)));
}

},{"tslib":"3gscj","./concat":"8l3w8","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"9jLdy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "connect", ()=>connect);
var _subject = require("../Subject");
var _innerFrom = require("../observable/innerFrom");
var _lift = require("../util/lift");
var _fromSubscribable = require("../observable/fromSubscribable");
var DEFAULT_CONFIG = {
    connector: function() {
        return new (0, _subject.Subject)();
    }
};
function connect(selector, config) {
    if (config === void 0) config = DEFAULT_CONFIG;
    var connector = config.connector;
    return (0, _lift.operate)(function(source, subscriber) {
        var subject = connector();
        (0, _innerFrom.innerFrom)(selector((0, _fromSubscribable.fromSubscribable)(subject))).subscribe(subscriber);
        subscriber.add(source.subscribe(subject));
    });
}

},{"../Subject":"2sXGH","../observable/innerFrom":"6l3RX","../util/lift":"3IZjp","../observable/fromSubscribable":"jLVOq","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"2sXGH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Subject", ()=>Subject);
parcelHelpers.export(exports, "AnonymousSubject", ()=>AnonymousSubject);
var _tslib = require("tslib");
var _observable = require("./Observable");
var _subscription = require("./Subscription");
var _objectUnsubscribedError = require("./util/ObjectUnsubscribedError");
var _arrRemove = require("./util/arrRemove");
var _errorContext = require("./util/errorContext");
var Subject = function(_super) {
    (0, _tslib.__extends)(Subject, _super);
    function Subject() {
        var _this = _super.call(this) || this;
        _this.closed = false;
        _this.currentObservers = null;
        _this.observers = [];
        _this.isStopped = false;
        _this.hasError = false;
        _this.thrownError = null;
        return _this;
    }
    Subject.prototype.lift = function(operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
    };
    Subject.prototype._throwIfClosed = function() {
        if (this.closed) throw new (0, _objectUnsubscribedError.ObjectUnsubscribedError)();
    };
    Subject.prototype.next = function(value) {
        var _this = this;
        (0, _errorContext.errorContext)(function() {
            var e_1, _a;
            _this._throwIfClosed();
            if (!_this.isStopped) {
                if (!_this.currentObservers) _this.currentObservers = Array.from(_this.observers);
                try {
                    for(var _b = (0, _tslib.__values)(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()){
                        var observer = _c.value;
                        observer.next(value);
                    }
                } catch (e_1_1) {
                    e_1 = {
                        error: e_1_1
                    };
                } finally{
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    } finally{
                        if (e_1) throw e_1.error;
                    }
                }
            }
        });
    };
    Subject.prototype.error = function(err) {
        var _this = this;
        (0, _errorContext.errorContext)(function() {
            _this._throwIfClosed();
            if (!_this.isStopped) {
                _this.hasError = _this.isStopped = true;
                _this.thrownError = err;
                var observers = _this.observers;
                while(observers.length)observers.shift().error(err);
            }
        });
    };
    Subject.prototype.complete = function() {
        var _this = this;
        (0, _errorContext.errorContext)(function() {
            _this._throwIfClosed();
            if (!_this.isStopped) {
                _this.isStopped = true;
                var observers = _this.observers;
                while(observers.length)observers.shift().complete();
            }
        });
    };
    Subject.prototype.unsubscribe = function() {
        this.isStopped = this.closed = true;
        this.observers = this.currentObservers = null;
    };
    Object.defineProperty(Subject.prototype, "observed", {
        get: function() {
            var _a;
            return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
        },
        enumerable: false,
        configurable: true
    });
    Subject.prototype._trySubscribe = function(subscriber) {
        this._throwIfClosed();
        return _super.prototype._trySubscribe.call(this, subscriber);
    };
    Subject.prototype._subscribe = function(subscriber) {
        this._throwIfClosed();
        this._checkFinalizedStatuses(subscriber);
        return this._innerSubscribe(subscriber);
    };
    Subject.prototype._innerSubscribe = function(subscriber) {
        var _this = this;
        var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
        if (hasError || isStopped) return 0, _subscription.EMPTY_SUBSCRIPTION;
        this.currentObservers = null;
        observers.push(subscriber);
        return new (0, _subscription.Subscription)(function() {
            _this.currentObservers = null;
            (0, _arrRemove.arrRemove)(observers, subscriber);
        });
    };
    Subject.prototype._checkFinalizedStatuses = function(subscriber) {
        var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
        if (hasError) subscriber.error(thrownError);
        else if (isStopped) subscriber.complete();
    };
    Subject.prototype.asObservable = function() {
        var observable = new (0, _observable.Observable)();
        observable.source = this;
        return observable;
    };
    Subject.create = function(destination, source) {
        return new AnonymousSubject(destination, source);
    };
    return Subject;
}((0, _observable.Observable));
var AnonymousSubject = function(_super) {
    (0, _tslib.__extends)(AnonymousSubject, _super);
    function AnonymousSubject(destination, source) {
        var _this = _super.call(this) || this;
        _this.destination = destination;
        _this.source = source;
        return _this;
    }
    AnonymousSubject.prototype.next = function(value) {
        var _a, _b;
        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 || _b.call(_a, value);
    };
    AnonymousSubject.prototype.error = function(err) {
        var _a, _b;
        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 || _b.call(_a, err);
    };
    AnonymousSubject.prototype.complete = function() {
        var _a, _b;
        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 || _b.call(_a);
    };
    AnonymousSubject.prototype._subscribe = function(subscriber) {
        var _a, _b;
        return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : (0, _subscription.EMPTY_SUBSCRIPTION);
    };
    return AnonymousSubject;
}(Subject);

},{"tslib":"3gscj","./Observable":"fo3d5","./Subscription":"gzL8W","./util/ObjectUnsubscribedError":"1aQ9y","./util/arrRemove":"4LjhZ","./util/errorContext":"jEFyy","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"1aQ9y":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ObjectUnsubscribedError", ()=>ObjectUnsubscribedError);
var _createErrorClass = require("./createErrorClass");
var ObjectUnsubscribedError = (0, _createErrorClass.createErrorClass)(function(_super) {
    return function ObjectUnsubscribedErrorImpl() {
        _super(this);
        this.name = "ObjectUnsubscribedError";
        this.message = "object unsubscribed";
    };
});

},{"./createErrorClass":"1JmLg","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"jLVOq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "fromSubscribable", ()=>fromSubscribable);
var _observable = require("../Observable");
function fromSubscribable(subscribable) {
    return new (0, _observable.Observable)(function(subscriber) {
        return subscribable.subscribe(subscriber);
    });
}

},{"../Observable":"fo3d5","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"124qG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "count", ()=>count);
var _reduce = require("./reduce");
function count(predicate) {
    return (0, _reduce.reduce)(function(total, value, i) {
        return !predicate || predicate(value, i) ? total + 1 : total;
    }, 0);
}

},{"./reduce":"4kl4u","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"7l4PC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "debounce", ()=>debounce);
var _lift = require("../util/lift");
var _noop = require("../util/noop");
var _operatorSubscriber = require("./OperatorSubscriber");
var _innerFrom = require("../observable/innerFrom");
function debounce(durationSelector) {
    return (0, _lift.operate)(function(source, subscriber) {
        var hasValue = false;
        var lastValue = null;
        var durationSubscriber = null;
        var emit = function() {
            durationSubscriber === null || durationSubscriber === void 0 || durationSubscriber.unsubscribe();
            durationSubscriber = null;
            if (hasValue) {
                hasValue = false;
                var value = lastValue;
                lastValue = null;
                subscriber.next(value);
            }
        };
        source.subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function(value) {
            durationSubscriber === null || durationSubscriber === void 0 || durationSubscriber.unsubscribe();
            hasValue = true;
            lastValue = value;
            durationSubscriber = (0, _operatorSubscriber.createOperatorSubscriber)(subscriber, emit, (0, _noop.noop));
            (0, _innerFrom.innerFrom)(durationSelector(value)).subscribe(durationSubscriber);
        }, function() {
            emit();
            subscriber.complete();
        }, undefined, function() {
            lastValue = durationSubscriber = null;
        }));
    });
}

},{"../util/lift":"3IZjp","../util/noop":"f1sCb","./OperatorSubscriber":"hrKGc","../observable/innerFrom":"6l3RX","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"h80NT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "debounceTime", ()=>debounceTime);
var _async = require("../scheduler/async");
var _lift = require("../util/lift");
var _operatorSubscriber = require("./OperatorSubscriber");
function debounceTime(dueTime, scheduler) {
    if (scheduler === void 0) scheduler = (0, _async.asyncScheduler);
    return (0, _lift.operate)(function(source, subscriber) {
        var activeTask = null;
        var lastValue = null;
        var lastTime = null;
        var emit = function() {
            if (activeTask) {
                activeTask.unsubscribe();
                activeTask = null;
                var value = lastValue;
                lastValue = null;
                subscriber.next(value);
            }
        };
        function emitWhenIdle() {
            var targetTime = lastTime + dueTime;
            var now = scheduler.now();
            if (now < targetTime) {
                activeTask = this.schedule(undefined, targetTime - now);
                subscriber.add(activeTask);
                return;
            }
            emit();
        }
        source.subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function(value) {
            lastValue = value;
            lastTime = scheduler.now();
            if (!activeTask) {
                activeTask = scheduler.schedule(emitWhenIdle, dueTime);
                subscriber.add(activeTask);
            }
        }, function() {
            emit();
            subscriber.complete();
        }, undefined, function() {
            lastValue = activeTask = null;
        }));
    });
}

},{"../scheduler/async":"eIZ5a","../util/lift":"3IZjp","./OperatorSubscriber":"hrKGc","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"6uJJE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "defaultIfEmpty", ()=>defaultIfEmpty);
var _lift = require("../util/lift");
var _operatorSubscriber = require("./OperatorSubscriber");
function defaultIfEmpty(defaultValue) {
    return (0, _lift.operate)(function(source, subscriber) {
        var hasValue = false;
        source.subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function(value) {
            hasValue = true;
            subscriber.next(value);
        }, function() {
            if (!hasValue) subscriber.next(defaultValue);
            subscriber.complete();
        }));
    });
}

},{"../util/lift":"3IZjp","./OperatorSubscriber":"hrKGc","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"2RJzO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "delay", ()=>delay);
var _async = require("../scheduler/async");
var _delayWhen = require("./delayWhen");
var _timer = require("../observable/timer");
function delay(due, scheduler) {
    if (scheduler === void 0) scheduler = (0, _async.asyncScheduler);
    var duration = (0, _timer.timer)(due, scheduler);
    return (0, _delayWhen.delayWhen)(function() {
        return duration;
    });
}

},{"../scheduler/async":"eIZ5a","./delayWhen":"eiopY","../observable/timer":"EANJK","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"eiopY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "delayWhen", ()=>delayWhen);
var _concat = require("../observable/concat");
var _take = require("./take");
var _ignoreElements = require("./ignoreElements");
var _mapTo = require("./mapTo");
var _mergeMap = require("./mergeMap");
var _innerFrom = require("../observable/innerFrom");
function delayWhen(delayDurationSelector, subscriptionDelay) {
    if (subscriptionDelay) return function(source) {
        return (0, _concat.concat)(subscriptionDelay.pipe((0, _take.take)(1), (0, _ignoreElements.ignoreElements)()), source.pipe(delayWhen(delayDurationSelector)));
    };
    return (0, _mergeMap.mergeMap)(function(value, index) {
        return (0, _innerFrom.innerFrom)(delayDurationSelector(value, index)).pipe((0, _take.take)(1), (0, _mapTo.mapTo)(value));
    });
}

},{"../observable/concat":"1H86H","./take":"94vX9","./ignoreElements":"8RBST","./mapTo":"7HUed","./mergeMap":"5gFTr","../observable/innerFrom":"6l3RX","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"1H86H":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "concat", ()=>concat);
var _concatAll = require("../operators/concatAll");
var _args = require("../util/args");
var _from = require("./from");
function concat() {
    var args = [];
    for(var _i = 0; _i < arguments.length; _i++)args[_i] = arguments[_i];
    return (0, _concatAll.concatAll)()((0, _from.from)(args, (0, _args.popScheduler)(args)));
}

},{"../operators/concatAll":"3N9Cc","../util/args":"ccsng","./from":"aDpqg","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"94vX9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "take", ()=>take);
var _empty = require("../observable/empty");
var _lift = require("../util/lift");
var _operatorSubscriber = require("./OperatorSubscriber");
function take(count) {
    return count <= 0 ? function() {
        return 0, _empty.EMPTY;
    } : (0, _lift.operate)(function(source, subscriber) {
        var seen = 0;
        source.subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function(value) {
            if (++seen <= count) {
                subscriber.next(value);
                if (count <= seen) subscriber.complete();
            }
        }));
    });
}

},{"../observable/empty":"hZmJU","../util/lift":"3IZjp","./OperatorSubscriber":"hrKGc","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"hZmJU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EMPTY", ()=>EMPTY);
parcelHelpers.export(exports, "empty", ()=>empty);
var _observable = require("../Observable");
var EMPTY = new (0, _observable.Observable)(function(subscriber) {
    return subscriber.complete();
});
function empty(scheduler) {
    return scheduler ? emptyScheduled(scheduler) : EMPTY;
}
function emptyScheduled(scheduler) {
    return new (0, _observable.Observable)(function(subscriber) {
        return scheduler.schedule(function() {
            return subscriber.complete();
        });
    });
}

},{"../Observable":"fo3d5","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"8RBST":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ignoreElements", ()=>ignoreElements);
var _lift = require("../util/lift");
var _operatorSubscriber = require("./OperatorSubscriber");
var _noop = require("../util/noop");
function ignoreElements() {
    return (0, _lift.operate)(function(source, subscriber) {
        source.subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, (0, _noop.noop)));
    });
}

},{"../util/lift":"3IZjp","./OperatorSubscriber":"hrKGc","../util/noop":"f1sCb","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"7HUed":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mapTo", ()=>mapTo);
var _map = require("./map");
function mapTo(value) {
    return (0, _map.map)(function() {
        return value;
    });
}

},{"./map":"9Azp4","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"k3SZr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "dematerialize", ()=>dematerialize);
var _notification = require("../Notification");
var _lift = require("../util/lift");
var _operatorSubscriber = require("./OperatorSubscriber");
function dematerialize() {
    return (0, _lift.operate)(function(source, subscriber) {
        source.subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function(notification) {
            return (0, _notification.observeNotification)(notification, subscriber);
        }));
    });
}

},{"../Notification":"asXck","../util/lift":"3IZjp","./OperatorSubscriber":"hrKGc","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"asXck":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "NotificationKind", ()=>NotificationKind);
parcelHelpers.export(exports, "Notification", ()=>Notification);
parcelHelpers.export(exports, "observeNotification", ()=>observeNotification);
var _empty = require("./observable/empty");
var _of = require("./observable/of");
var _throwError = require("./observable/throwError");
var _isFunction = require("./util/isFunction");
var NotificationKind;
(function(NotificationKind) {
    NotificationKind["NEXT"] = "N";
    NotificationKind["ERROR"] = "E";
    NotificationKind["COMPLETE"] = "C";
})(NotificationKind || (NotificationKind = {}));
var Notification = function() {
    function Notification(kind, value, error) {
        this.kind = kind;
        this.value = value;
        this.error = error;
        this.hasValue = kind === "N";
    }
    Notification.prototype.observe = function(observer) {
        return observeNotification(this, observer);
    };
    Notification.prototype.do = function(nextHandler, errorHandler, completeHandler) {
        var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
        return kind === "N" ? nextHandler === null || nextHandler === void 0 ? void 0 : nextHandler(value) : kind === "E" ? errorHandler === null || errorHandler === void 0 ? void 0 : errorHandler(error) : completeHandler === null || completeHandler === void 0 ? void 0 : completeHandler();
    };
    Notification.prototype.accept = function(nextOrObserver, error, complete) {
        var _a;
        return (0, _isFunction.isFunction)((_a = nextOrObserver) === null || _a === void 0 ? void 0 : _a.next) ? this.observe(nextOrObserver) : this.do(nextOrObserver, error, complete);
    };
    Notification.prototype.toObservable = function() {
        var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
        var result = kind === "N" ? (0, _of.of)(value) : kind === "E" ? (0, _throwError.throwError)(function() {
            return error;
        }) : kind === "C" ? (0, _empty.EMPTY) : 0;
        if (!result) throw new TypeError("Unexpected notification kind " + kind);
        return result;
    };
    Notification.createNext = function(value) {
        return new Notification("N", value);
    };
    Notification.createError = function(err) {
        return new Notification("E", undefined, err);
    };
    Notification.createComplete = function() {
        return Notification.completeNotification;
    };
    Notification.completeNotification = new Notification("C");
    return Notification;
}();
function observeNotification(notification, observer) {
    var _a, _b, _c;
    var _d = notification, kind = _d.kind, value = _d.value, error = _d.error;
    if (typeof kind !== "string") throw new TypeError('Invalid notification, missing "kind"');
    kind === "N" ? (_a = observer.next) === null || _a === void 0 || _a.call(observer, value) : kind === "E" ? (_b = observer.error) === null || _b === void 0 || _b.call(observer, error) : (_c = observer.complete) === null || _c === void 0 || _c.call(observer);
}

},{"./observable/empty":"hZmJU","./observable/of":"aBNUD","./observable/throwError":"aZftO","./util/isFunction":"fpUct","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"aBNUD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "of", ()=>of);
var _args = require("../util/args");
var _from = require("./from");
function of() {
    var args = [];
    for(var _i = 0; _i < arguments.length; _i++)args[_i] = arguments[_i];
    var scheduler = (0, _args.popScheduler)(args);
    return (0, _from.from)(args, scheduler);
}

},{"../util/args":"ccsng","./from":"aDpqg","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"aZftO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "throwError", ()=>throwError);
var _observable = require("../Observable");
var _isFunction = require("../util/isFunction");
function throwError(errorOrErrorFactory, scheduler) {
    var errorFactory = (0, _isFunction.isFunction)(errorOrErrorFactory) ? errorOrErrorFactory : function() {
        return errorOrErrorFactory;
    };
    var init = function(subscriber) {
        return subscriber.error(errorFactory());
    };
    return new (0, _observable.Observable)(scheduler ? function(subscriber) {
        return scheduler.schedule(init, 0, subscriber);
    } : init);
}

},{"../Observable":"fo3d5","../util/isFunction":"fpUct","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"2TywC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "distinct", ()=>distinct);
var _lift = require("../util/lift");
var _operatorSubscriber = require("./OperatorSubscriber");
var _noop = require("../util/noop");
var _innerFrom = require("../observable/innerFrom");
function distinct(keySelector, flushes) {
    return (0, _lift.operate)(function(source, subscriber) {
        var distinctKeys = new Set();
        source.subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function(value) {
            var key = keySelector ? keySelector(value) : value;
            if (!distinctKeys.has(key)) {
                distinctKeys.add(key);
                subscriber.next(value);
            }
        }));
        flushes && (0, _innerFrom.innerFrom)(flushes).subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function() {
            return distinctKeys.clear();
        }, (0, _noop.noop)));
    });
}

},{"../util/lift":"3IZjp","./OperatorSubscriber":"hrKGc","../util/noop":"f1sCb","../observable/innerFrom":"6l3RX","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"iGfsr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "distinctUntilChanged", ()=>distinctUntilChanged);
var _identity = require("../util/identity");
var _lift = require("../util/lift");
var _operatorSubscriber = require("./OperatorSubscriber");
function distinctUntilChanged(comparator, keySelector) {
    if (keySelector === void 0) keySelector = (0, _identity.identity);
    comparator = comparator !== null && comparator !== void 0 ? comparator : defaultCompare;
    return (0, _lift.operate)(function(source, subscriber) {
        var previousKey;
        var first = true;
        source.subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function(value) {
            var currentKey = keySelector(value);
            if (first || !comparator(previousKey, currentKey)) {
                first = false;
                previousKey = currentKey;
                subscriber.next(value);
            }
        }));
    });
}
function defaultCompare(a, b) {
    return a === b;
}

},{"../util/identity":"d03yr","../util/lift":"3IZjp","./OperatorSubscriber":"hrKGc","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"2sNVc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "distinctUntilKeyChanged", ()=>distinctUntilKeyChanged);
var _distinctUntilChanged = require("./distinctUntilChanged");
function distinctUntilKeyChanged(key, compare) {
    return (0, _distinctUntilChanged.distinctUntilChanged)(function(x, y) {
        return compare ? compare(x[key], y[key]) : x[key] === y[key];
    });
}

},{"./distinctUntilChanged":"iGfsr","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"fx5hJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "elementAt", ()=>elementAt);
var _argumentOutOfRangeError = require("../util/ArgumentOutOfRangeError");
var _filter = require("./filter");
var _throwIfEmpty = require("./throwIfEmpty");
var _defaultIfEmpty = require("./defaultIfEmpty");
var _take = require("./take");
function elementAt(index, defaultValue) {
    if (index < 0) throw new (0, _argumentOutOfRangeError.ArgumentOutOfRangeError)();
    var hasDefaultValue = arguments.length >= 2;
    return function(source) {
        return source.pipe((0, _filter.filter)(function(v, i) {
            return i === index;
        }), (0, _take.take)(1), hasDefaultValue ? (0, _defaultIfEmpty.defaultIfEmpty)(defaultValue) : (0, _throwIfEmpty.throwIfEmpty)(function() {
            return new (0, _argumentOutOfRangeError.ArgumentOutOfRangeError)();
        }));
    };
}

},{"../util/ArgumentOutOfRangeError":"lkbeq","./filter":"aO3IO","./throwIfEmpty":"9WNWd","./defaultIfEmpty":"6uJJE","./take":"94vX9","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"lkbeq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ArgumentOutOfRangeError", ()=>ArgumentOutOfRangeError);
var _createErrorClass = require("./createErrorClass");
var ArgumentOutOfRangeError = (0, _createErrorClass.createErrorClass)(function(_super) {
    return function ArgumentOutOfRangeErrorImpl() {
        _super(this);
        this.name = "ArgumentOutOfRangeError";
        this.message = "argument out of range";
    };
});

},{"./createErrorClass":"1JmLg","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"aO3IO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filter", ()=>filter);
var _lift = require("../util/lift");
var _operatorSubscriber = require("./OperatorSubscriber");
function filter(predicate, thisArg) {
    return (0, _lift.operate)(function(source, subscriber) {
        var index = 0;
        source.subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function(value) {
            return predicate.call(thisArg, value, index++) && subscriber.next(value);
        }));
    });
}

},{"../util/lift":"3IZjp","./OperatorSubscriber":"hrKGc","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"9WNWd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "throwIfEmpty", ()=>throwIfEmpty);
var _emptyError = require("../util/EmptyError");
var _lift = require("../util/lift");
var _operatorSubscriber = require("./OperatorSubscriber");
function throwIfEmpty(errorFactory) {
    if (errorFactory === void 0) errorFactory = defaultErrorFactory;
    return (0, _lift.operate)(function(source, subscriber) {
        var hasValue = false;
        source.subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function(value) {
            hasValue = true;
            subscriber.next(value);
        }, function() {
            return hasValue ? subscriber.complete() : subscriber.error(errorFactory());
        }));
    });
}
function defaultErrorFactory() {
    return new (0, _emptyError.EmptyError)();
}

},{"../util/EmptyError":"Mm8dB","../util/lift":"3IZjp","./OperatorSubscriber":"hrKGc","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"Mm8dB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EmptyError", ()=>EmptyError);
var _createErrorClass = require("./createErrorClass");
var EmptyError = (0, _createErrorClass.createErrorClass)(function(_super) {
    return function EmptyErrorImpl() {
        _super(this);
        this.name = "EmptyError";
        this.message = "no elements in sequence";
    };
});

},{"./createErrorClass":"1JmLg","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"4nEYg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "endWith", ()=>endWith);
var _tslib = require("tslib");
var _concat = require("../observable/concat");
var _of = require("../observable/of");
function endWith() {
    var values = [];
    for(var _i = 0; _i < arguments.length; _i++)values[_i] = arguments[_i];
    return function(source) {
        return (0, _concat.concat)(source, (0, _of.of).apply(void 0, (0, _tslib.__spreadArray)([], (0, _tslib.__read)(values))));
    };
}

},{"tslib":"3gscj","../observable/concat":"1H86H","../observable/of":"aBNUD","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"hswcw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "every", ()=>every);
var _lift = require("../util/lift");
var _operatorSubscriber = require("./OperatorSubscriber");
function every(predicate, thisArg) {
    return (0, _lift.operate)(function(source, subscriber) {
        var index = 0;
        source.subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function(value) {
            if (!predicate.call(thisArg, value, index++, source)) {
                subscriber.next(false);
                subscriber.complete();
            }
        }, function() {
            subscriber.next(true);
            subscriber.complete();
        }));
    });
}

},{"../util/lift":"3IZjp","./OperatorSubscriber":"hrKGc","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"iJzIe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "exhaust", ()=>exhaust);
var _exhaustAll = require("./exhaustAll");
var exhaust = (0, _exhaustAll.exhaustAll);

},{"./exhaustAll":"03zkm","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"03zkm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "exhaustAll", ()=>exhaustAll);
var _exhaustMap = require("./exhaustMap");
var _identity = require("../util/identity");
function exhaustAll() {
    return (0, _exhaustMap.exhaustMap)((0, _identity.identity));
}

},{"./exhaustMap":"cAFnx","../util/identity":"d03yr","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"cAFnx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "exhaustMap", ()=>exhaustMap);
var _map = require("./map");
var _innerFrom = require("../observable/innerFrom");
var _lift = require("../util/lift");
var _operatorSubscriber = require("./OperatorSubscriber");
function exhaustMap(project, resultSelector) {
    if (resultSelector) return function(source) {
        return source.pipe(exhaustMap(function(a, i) {
            return (0, _innerFrom.innerFrom)(project(a, i)).pipe((0, _map.map)(function(b, ii) {
                return resultSelector(a, b, i, ii);
            }));
        }));
    };
    return (0, _lift.operate)(function(source, subscriber) {
        var index = 0;
        var innerSub = null;
        var isComplete = false;
        source.subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function(outerValue) {
            if (!innerSub) {
                innerSub = (0, _operatorSubscriber.createOperatorSubscriber)(subscriber, undefined, function() {
                    innerSub = null;
                    isComplete && subscriber.complete();
                });
                (0, _innerFrom.innerFrom)(project(outerValue, index++)).subscribe(innerSub);
            }
        }, function() {
            isComplete = true;
            !innerSub && subscriber.complete();
        }));
    });
}

},{"./map":"9Azp4","../observable/innerFrom":"6l3RX","../util/lift":"3IZjp","./OperatorSubscriber":"hrKGc","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"3dxNz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "expand", ()=>expand);
var _lift = require("../util/lift");
var _mergeInternals = require("./mergeInternals");
function expand(project, concurrent, scheduler) {
    if (concurrent === void 0) concurrent = Infinity;
    concurrent = (concurrent || 0) < 1 ? Infinity : concurrent;
    return (0, _lift.operate)(function(source, subscriber) {
        return (0, _mergeInternals.mergeInternals)(source, subscriber, project, concurrent, undefined, true, scheduler);
    });
}

},{"../util/lift":"3IZjp","./mergeInternals":"437Ap","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"LytCq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "finalize", ()=>finalize);
var _lift = require("../util/lift");
function finalize(callback) {
    return (0, _lift.operate)(function(source, subscriber) {
        try {
            source.subscribe(subscriber);
        } finally{
            subscriber.add(callback);
        }
    });
}

},{"../util/lift":"3IZjp","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"aaFa0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "find", ()=>find);
parcelHelpers.export(exports, "createFind", ()=>createFind);
var _lift = require("../util/lift");
var _operatorSubscriber = require("./OperatorSubscriber");
function find(predicate, thisArg) {
    return (0, _lift.operate)(createFind(predicate, thisArg, "value"));
}
function createFind(predicate, thisArg, emit) {
    var findIndex = emit === "index";
    return function(source, subscriber) {
        var index = 0;
        source.subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function(value) {
            var i = index++;
            if (predicate.call(thisArg, value, i, source)) {
                subscriber.next(findIndex ? i : value);
                subscriber.complete();
            }
        }, function() {
            subscriber.next(findIndex ? -1 : undefined);
            subscriber.complete();
        }));
    };
}

},{"../util/lift":"3IZjp","./OperatorSubscriber":"hrKGc","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"k00hc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "findIndex", ()=>findIndex);
var _lift = require("../util/lift");
var _find = require("./find");
function findIndex(predicate, thisArg) {
    return (0, _lift.operate)((0, _find.createFind)(predicate, thisArg, "index"));
}

},{"../util/lift":"3IZjp","./find":"aaFa0","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"hPeew":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "first", ()=>first);
var _emptyError = require("../util/EmptyError");
var _filter = require("./filter");
var _take = require("./take");
var _defaultIfEmpty = require("./defaultIfEmpty");
var _throwIfEmpty = require("./throwIfEmpty");
var _identity = require("../util/identity");
function first(predicate, defaultValue) {
    var hasDefaultValue = arguments.length >= 2;
    return function(source) {
        return source.pipe(predicate ? (0, _filter.filter)(function(v, i) {
            return predicate(v, i, source);
        }) : (0, _identity.identity), (0, _take.take)(1), hasDefaultValue ? (0, _defaultIfEmpty.defaultIfEmpty)(defaultValue) : (0, _throwIfEmpty.throwIfEmpty)(function() {
            return new (0, _emptyError.EmptyError)();
        }));
    };
}

},{"../util/EmptyError":"Mm8dB","./filter":"aO3IO","./take":"94vX9","./defaultIfEmpty":"6uJJE","./throwIfEmpty":"9WNWd","../util/identity":"d03yr","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"d3Tg3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "groupBy", ()=>groupBy);
var _observable = require("../Observable");
var _innerFrom = require("../observable/innerFrom");
var _subject = require("../Subject");
var _lift = require("../util/lift");
var _operatorSubscriber = require("./OperatorSubscriber");
function groupBy(keySelector, elementOrOptions, duration, connector) {
    return (0, _lift.operate)(function(source, subscriber) {
        var element;
        if (!elementOrOptions || typeof elementOrOptions === "function") element = elementOrOptions;
        else duration = elementOrOptions.duration, element = elementOrOptions.element, connector = elementOrOptions.connector;
        var groups = new Map();
        var notify = function(cb) {
            groups.forEach(cb);
            cb(subscriber);
        };
        var handleError = function(err) {
            return notify(function(consumer) {
                return consumer.error(err);
            });
        };
        var activeGroups = 0;
        var teardownAttempted = false;
        var groupBySourceSubscriber = new (0, _operatorSubscriber.OperatorSubscriber)(subscriber, function(value) {
            try {
                var key_1 = keySelector(value);
                var group_1 = groups.get(key_1);
                if (!group_1) {
                    groups.set(key_1, group_1 = connector ? connector() : new (0, _subject.Subject)());
                    var grouped = createGroupedObservable(key_1, group_1);
                    subscriber.next(grouped);
                    if (duration) {
                        var durationSubscriber_1 = (0, _operatorSubscriber.createOperatorSubscriber)(group_1, function() {
                            group_1.complete();
                            durationSubscriber_1 === null || durationSubscriber_1 === void 0 || durationSubscriber_1.unsubscribe();
                        }, undefined, undefined, function() {
                            return groups.delete(key_1);
                        });
                        groupBySourceSubscriber.add((0, _innerFrom.innerFrom)(duration(grouped)).subscribe(durationSubscriber_1));
                    }
                }
                group_1.next(element ? element(value) : value);
            } catch (err) {
                handleError(err);
            }
        }, function() {
            return notify(function(consumer) {
                return consumer.complete();
            });
        }, handleError, function() {
            return groups.clear();
        }, function() {
            teardownAttempted = true;
            return activeGroups === 0;
        });
        source.subscribe(groupBySourceSubscriber);
        function createGroupedObservable(key, groupSubject) {
            var result = new (0, _observable.Observable)(function(groupSubscriber) {
                activeGroups++;
                var innerSub = groupSubject.subscribe(groupSubscriber);
                return function() {
                    innerSub.unsubscribe();
                    --activeGroups === 0 && teardownAttempted && groupBySourceSubscriber.unsubscribe();
                };
            });
            result.key = key;
            return result;
        }
    });
}

},{"../Observable":"fo3d5","../observable/innerFrom":"6l3RX","../Subject":"2sXGH","../util/lift":"3IZjp","./OperatorSubscriber":"hrKGc","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"h1hMH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isEmpty", ()=>isEmpty);
var _lift = require("../util/lift");
var _operatorSubscriber = require("./OperatorSubscriber");
function isEmpty() {
    return (0, _lift.operate)(function(source, subscriber) {
        source.subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function() {
            subscriber.next(false);
            subscriber.complete();
        }, function() {
            subscriber.next(true);
            subscriber.complete();
        }));
    });
}

},{"../util/lift":"3IZjp","./OperatorSubscriber":"hrKGc","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"kLaua":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "last", ()=>last);
var _emptyError = require("../util/EmptyError");
var _filter = require("./filter");
var _takeLast = require("./takeLast");
var _throwIfEmpty = require("./throwIfEmpty");
var _defaultIfEmpty = require("./defaultIfEmpty");
var _identity = require("../util/identity");
function last(predicate, defaultValue) {
    var hasDefaultValue = arguments.length >= 2;
    return function(source) {
        return source.pipe(predicate ? (0, _filter.filter)(function(v, i) {
            return predicate(v, i, source);
        }) : (0, _identity.identity), (0, _takeLast.takeLast)(1), hasDefaultValue ? (0, _defaultIfEmpty.defaultIfEmpty)(defaultValue) : (0, _throwIfEmpty.throwIfEmpty)(function() {
            return new (0, _emptyError.EmptyError)();
        }));
    };
}

},{"../util/EmptyError":"Mm8dB","./filter":"aO3IO","./takeLast":"967LC","./throwIfEmpty":"9WNWd","./defaultIfEmpty":"6uJJE","../util/identity":"d03yr","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"967LC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "takeLast", ()=>takeLast);
var _tslib = require("tslib");
var _empty = require("../observable/empty");
var _lift = require("../util/lift");
var _operatorSubscriber = require("./OperatorSubscriber");
function takeLast(count) {
    return count <= 0 ? function() {
        return 0, _empty.EMPTY;
    } : (0, _lift.operate)(function(source, subscriber) {
        var buffer = [];
        source.subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function(value) {
            buffer.push(value);
            count < buffer.length && buffer.shift();
        }, function() {
            var e_1, _a;
            try {
                for(var buffer_1 = (0, _tslib.__values)(buffer), buffer_1_1 = buffer_1.next(); !buffer_1_1.done; buffer_1_1 = buffer_1.next()){
                    var value = buffer_1_1.value;
                    subscriber.next(value);
                }
            } catch (e_1_1) {
                e_1 = {
                    error: e_1_1
                };
            } finally{
                try {
                    if (buffer_1_1 && !buffer_1_1.done && (_a = buffer_1.return)) _a.call(buffer_1);
                } finally{
                    if (e_1) throw e_1.error;
                }
            }
            subscriber.complete();
        }, undefined, function() {
            buffer = null;
        }));
    });
}

},{"tslib":"3gscj","../observable/empty":"hZmJU","../util/lift":"3IZjp","./OperatorSubscriber":"hrKGc","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"lo980":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "materialize", ()=>materialize);
var _notification = require("../Notification");
var _lift = require("../util/lift");
var _operatorSubscriber = require("./OperatorSubscriber");
function materialize() {
    return (0, _lift.operate)(function(source, subscriber) {
        source.subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function(value) {
            subscriber.next((0, _notification.Notification).createNext(value));
        }, function() {
            subscriber.next((0, _notification.Notification).createComplete());
            subscriber.complete();
        }, function(err) {
            subscriber.next((0, _notification.Notification).createError(err));
            subscriber.complete();
        }));
    });
}

},{"../Notification":"asXck","../util/lift":"3IZjp","./OperatorSubscriber":"hrKGc","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"etLZh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "max", ()=>max);
var _reduce = require("./reduce");
var _isFunction = require("../util/isFunction");
function max(comparer) {
    return (0, _reduce.reduce)((0, _isFunction.isFunction)(comparer) ? function(x, y) {
        return comparer(x, y) > 0 ? x : y;
    } : function(x, y) {
        return x > y ? x : y;
    });
}

},{"./reduce":"4kl4u","../util/isFunction":"fpUct","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"js5Fb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "merge", ()=>merge);
var _tslib = require("tslib");
var _lift = require("../util/lift");
var _mergeAll = require("./mergeAll");
var _args = require("../util/args");
var _from = require("../observable/from");
function merge() {
    var args = [];
    for(var _i = 0; _i < arguments.length; _i++)args[_i] = arguments[_i];
    var scheduler = (0, _args.popScheduler)(args);
    var concurrent = (0, _args.popNumber)(args, Infinity);
    return (0, _lift.operate)(function(source, subscriber) {
        (0, _mergeAll.mergeAll)(concurrent)((0, _from.from)((0, _tslib.__spreadArray)([
            source
        ], (0, _tslib.__read)(args)), scheduler)).subscribe(subscriber);
    });
}

},{"tslib":"3gscj","../util/lift":"3IZjp","./mergeAll":"iRJ2C","../util/args":"ccsng","../observable/from":"aDpqg","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"jWma1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "flatMap", ()=>flatMap);
var _mergeMap = require("./mergeMap");
var flatMap = (0, _mergeMap.mergeMap);

},{"./mergeMap":"5gFTr","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"frPgW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mergeMapTo", ()=>mergeMapTo);
var _mergeMap = require("./mergeMap");
var _isFunction = require("../util/isFunction");
function mergeMapTo(innerObservable, resultSelector, concurrent) {
    if (concurrent === void 0) concurrent = Infinity;
    if ((0, _isFunction.isFunction)(resultSelector)) return (0, _mergeMap.mergeMap)(function() {
        return innerObservable;
    }, resultSelector, concurrent);
    if (typeof resultSelector === "number") concurrent = resultSelector;
    return (0, _mergeMap.mergeMap)(function() {
        return innerObservable;
    }, concurrent);
}

},{"./mergeMap":"5gFTr","../util/isFunction":"fpUct","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"cAvb5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mergeScan", ()=>mergeScan);
var _lift = require("../util/lift");
var _mergeInternals = require("./mergeInternals");
function mergeScan(accumulator, seed, concurrent) {
    if (concurrent === void 0) concurrent = Infinity;
    return (0, _lift.operate)(function(source, subscriber) {
        var state = seed;
        return (0, _mergeInternals.mergeInternals)(source, subscriber, function(value, index) {
            return accumulator(state, value, index);
        }, concurrent, function(value) {
            state = value;
        }, false, undefined, function() {
            return state = null;
        });
    });
}

},{"../util/lift":"3IZjp","./mergeInternals":"437Ap","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"5WJFY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mergeWith", ()=>mergeWith);
var _tslib = require("tslib");
var _merge = require("./merge");
function mergeWith() {
    var otherSources = [];
    for(var _i = 0; _i < arguments.length; _i++)otherSources[_i] = arguments[_i];
    return (0, _merge.merge).apply(void 0, (0, _tslib.__spreadArray)([], (0, _tslib.__read)(otherSources)));
}

},{"tslib":"3gscj","./merge":"js5Fb","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"6h0L2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "min", ()=>min);
var _reduce = require("./reduce");
var _isFunction = require("../util/isFunction");
function min(comparer) {
    return (0, _reduce.reduce)((0, _isFunction.isFunction)(comparer) ? function(x, y) {
        return comparer(x, y) < 0 ? x : y;
    } : function(x, y) {
        return x < y ? x : y;
    });
}

},{"./reduce":"4kl4u","../util/isFunction":"fpUct","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"blOJd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "multicast", ()=>multicast);
var _connectableObservable = require("../observable/ConnectableObservable");
var _isFunction = require("../util/isFunction");
var _connect = require("./connect");
function multicast(subjectOrSubjectFactory, selector) {
    var subjectFactory = (0, _isFunction.isFunction)(subjectOrSubjectFactory) ? subjectOrSubjectFactory : function() {
        return subjectOrSubjectFactory;
    };
    if ((0, _isFunction.isFunction)(selector)) return (0, _connect.connect)(selector, {
        connector: subjectFactory
    });
    return function(source) {
        return new (0, _connectableObservable.ConnectableObservable)(source, subjectFactory);
    };
}

},{"../observable/ConnectableObservable":"41ArE","../util/isFunction":"fpUct","./connect":"9jLdy","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"41ArE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ConnectableObservable", ()=>ConnectableObservable);
var _tslib = require("tslib");
var _observable = require("../Observable");
var _subscription = require("../Subscription");
var _refCount = require("../operators/refCount");
var _operatorSubscriber = require("../operators/OperatorSubscriber");
var _lift = require("../util/lift");
var ConnectableObservable = function(_super) {
    (0, _tslib.__extends)(ConnectableObservable, _super);
    function ConnectableObservable(source, subjectFactory) {
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.subjectFactory = subjectFactory;
        _this._subject = null;
        _this._refCount = 0;
        _this._connection = null;
        if ((0, _lift.hasLift)(source)) _this.lift = source.lift;
        return _this;
    }
    ConnectableObservable.prototype._subscribe = function(subscriber) {
        return this.getSubject().subscribe(subscriber);
    };
    ConnectableObservable.prototype.getSubject = function() {
        var subject = this._subject;
        if (!subject || subject.isStopped) this._subject = this.subjectFactory();
        return this._subject;
    };
    ConnectableObservable.prototype._teardown = function() {
        this._refCount = 0;
        var _connection = this._connection;
        this._subject = this._connection = null;
        _connection === null || _connection === void 0 || _connection.unsubscribe();
    };
    ConnectableObservable.prototype.connect = function() {
        var _this = this;
        var connection = this._connection;
        if (!connection) {
            connection = this._connection = new (0, _subscription.Subscription)();
            var subject_1 = this.getSubject();
            connection.add(this.source.subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subject_1, undefined, function() {
                _this._teardown();
                subject_1.complete();
            }, function(err) {
                _this._teardown();
                subject_1.error(err);
            }, function() {
                return _this._teardown();
            })));
            if (connection.closed) {
                this._connection = null;
                connection = (0, _subscription.Subscription).EMPTY;
            }
        }
        return connection;
    };
    ConnectableObservable.prototype.refCount = function() {
        return (0, _refCount.refCount)()(this);
    };
    return ConnectableObservable;
}((0, _observable.Observable));

},{"tslib":"3gscj","../Observable":"fo3d5","../Subscription":"gzL8W","../operators/refCount":"7oeFZ","../operators/OperatorSubscriber":"hrKGc","../util/lift":"3IZjp","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"7oeFZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "refCount", ()=>refCount);
var _lift = require("../util/lift");
var _operatorSubscriber = require("./OperatorSubscriber");
function refCount() {
    return (0, _lift.operate)(function(source, subscriber) {
        var connection = null;
        source._refCount++;
        var refCounter = (0, _operatorSubscriber.createOperatorSubscriber)(subscriber, undefined, undefined, undefined, function() {
            if (!source || source._refCount <= 0 || 0 < --source._refCount) {
                connection = null;
                return;
            }
            var sharedConnection = source._connection;
            var conn = connection;
            connection = null;
            if (sharedConnection && (!conn || sharedConnection === conn)) sharedConnection.unsubscribe();
            subscriber.unsubscribe();
        });
        source.subscribe(refCounter);
        if (!refCounter.closed) connection = source.connect();
    });
}

},{"../util/lift":"3IZjp","./OperatorSubscriber":"hrKGc","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"9hfb6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "onErrorResumeNextWith", ()=>onErrorResumeNextWith);
parcelHelpers.export(exports, "onErrorResumeNext", ()=>onErrorResumeNext);
var _tslib = require("tslib");
var _argsOrArgArray = require("../util/argsOrArgArray");
var _onErrorResumeNext = require("../observable/onErrorResumeNext");
function onErrorResumeNextWith() {
    var sources = [];
    for(var _i = 0; _i < arguments.length; _i++)sources[_i] = arguments[_i];
    var nextSources = (0, _argsOrArgArray.argsOrArgArray)(sources);
    return function(source) {
        return (0, _onErrorResumeNext.onErrorResumeNext).apply(void 0, (0, _tslib.__spreadArray)([
            source
        ], (0, _tslib.__read)(nextSources)));
    };
}
var onErrorResumeNext = onErrorResumeNextWith;

},{"tslib":"3gscj","../util/argsOrArgArray":"9KARg","../observable/onErrorResumeNext":"5MRy1","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"5MRy1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "onErrorResumeNext", ()=>onErrorResumeNext);
var _observable = require("../Observable");
var _argsOrArgArray = require("../util/argsOrArgArray");
var _operatorSubscriber = require("../operators/OperatorSubscriber");
var _noop = require("../util/noop");
var _innerFrom = require("./innerFrom");
function onErrorResumeNext() {
    var sources = [];
    for(var _i = 0; _i < arguments.length; _i++)sources[_i] = arguments[_i];
    var nextSources = (0, _argsOrArgArray.argsOrArgArray)(sources);
    return new (0, _observable.Observable)(function(subscriber) {
        var sourceIndex = 0;
        var subscribeNext = function() {
            if (sourceIndex < nextSources.length) {
                var nextSource = void 0;
                try {
                    nextSource = (0, _innerFrom.innerFrom)(nextSources[sourceIndex++]);
                } catch (err) {
                    subscribeNext();
                    return;
                }
                var innerSubscriber = new (0, _operatorSubscriber.OperatorSubscriber)(subscriber, undefined, (0, _noop.noop), (0, _noop.noop));
                nextSource.subscribe(innerSubscriber);
                innerSubscriber.add(subscribeNext);
            } else subscriber.complete();
        };
        subscribeNext();
    });
}

},{"../Observable":"fo3d5","../util/argsOrArgArray":"9KARg","../operators/OperatorSubscriber":"hrKGc","../util/noop":"f1sCb","./innerFrom":"6l3RX","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"5wANY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "pairwise", ()=>pairwise);
var _lift = require("../util/lift");
var _operatorSubscriber = require("./OperatorSubscriber");
function pairwise() {
    return (0, _lift.operate)(function(source, subscriber) {
        var prev;
        var hasPrev = false;
        source.subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function(value) {
            var p = prev;
            prev = value;
            hasPrev && subscriber.next([
                p,
                value
            ]);
            hasPrev = true;
        }));
    });
}

},{"../util/lift":"3IZjp","./OperatorSubscriber":"hrKGc","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"j5v1J":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "partition", ()=>partition);
var _not = require("../util/not");
var _filter = require("./filter");
function partition(predicate, thisArg) {
    return function(source) {
        return [
            (0, _filter.filter)(predicate, thisArg)(source),
            (0, _filter.filter)((0, _not.not)(predicate, thisArg))(source)
        ];
    };
}

},{"../util/not":"3Dalz","./filter":"aO3IO","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"3Dalz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "not", ()=>not);
function not(pred, thisArg) {
    return function(value, index) {
        return !pred.call(thisArg, value, index);
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"imGUr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "pluck", ()=>pluck);
var _map = require("./map");
function pluck() {
    var properties = [];
    for(var _i = 0; _i < arguments.length; _i++)properties[_i] = arguments[_i];
    var length = properties.length;
    if (length === 0) throw new Error("list of properties cannot be empty.");
    return (0, _map.map)(function(x) {
        var currentProp = x;
        for(var i = 0; i < length; i++){
            var p = currentProp === null || currentProp === void 0 ? void 0 : currentProp[properties[i]];
            if (typeof p !== "undefined") currentProp = p;
            else return undefined;
        }
        return currentProp;
    });
}

},{"./map":"9Azp4","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"8wOeK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "publish", ()=>publish);
var _subject = require("../Subject");
var _multicast = require("./multicast");
var _connect = require("./connect");
function publish(selector) {
    return selector ? function(source) {
        return (0, _connect.connect)(selector)(source);
    } : function(source) {
        return (0, _multicast.multicast)(new (0, _subject.Subject)())(source);
    };
}

},{"../Subject":"2sXGH","./multicast":"blOJd","./connect":"9jLdy","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"iwBWB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "publishBehavior", ()=>publishBehavior);
var _behaviorSubject = require("../BehaviorSubject");
var _connectableObservable = require("../observable/ConnectableObservable");
function publishBehavior(initialValue) {
    return function(source) {
        var subject = new (0, _behaviorSubject.BehaviorSubject)(initialValue);
        return new (0, _connectableObservable.ConnectableObservable)(source, function() {
            return subject;
        });
    };
}

},{"../BehaviorSubject":"h9Spf","../observable/ConnectableObservable":"41ArE","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"h9Spf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BehaviorSubject", ()=>BehaviorSubject);
var _tslib = require("tslib");
var _subject = require("./Subject");
var BehaviorSubject = function(_super) {
    (0, _tslib.__extends)(BehaviorSubject, _super);
    function BehaviorSubject(_value) {
        var _this = _super.call(this) || this;
        _this._value = _value;
        return _this;
    }
    Object.defineProperty(BehaviorSubject.prototype, "value", {
        get: function() {
            return this.getValue();
        },
        enumerable: false,
        configurable: true
    });
    BehaviorSubject.prototype._subscribe = function(subscriber) {
        var subscription = _super.prototype._subscribe.call(this, subscriber);
        !subscription.closed && subscriber.next(this._value);
        return subscription;
    };
    BehaviorSubject.prototype.getValue = function() {
        var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;
        if (hasError) throw thrownError;
        this._throwIfClosed();
        return _value;
    };
    BehaviorSubject.prototype.next = function(value) {
        _super.prototype.next.call(this, this._value = value);
    };
    return BehaviorSubject;
}((0, _subject.Subject));

},{"tslib":"3gscj","./Subject":"2sXGH","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"3n4TK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "publishLast", ()=>publishLast);
var _asyncSubject = require("../AsyncSubject");
var _connectableObservable = require("../observable/ConnectableObservable");
function publishLast() {
    return function(source) {
        var subject = new (0, _asyncSubject.AsyncSubject)();
        return new (0, _connectableObservable.ConnectableObservable)(source, function() {
            return subject;
        });
    };
}

},{"../AsyncSubject":"OiSrp","../observable/ConnectableObservable":"41ArE","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"OiSrp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AsyncSubject", ()=>AsyncSubject);
var _tslib = require("tslib");
var _subject = require("./Subject");
var AsyncSubject = function(_super) {
    (0, _tslib.__extends)(AsyncSubject, _super);
    function AsyncSubject() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._value = null;
        _this._hasValue = false;
        _this._isComplete = false;
        return _this;
    }
    AsyncSubject.prototype._checkFinalizedStatuses = function(subscriber) {
        var _a = this, hasError = _a.hasError, _hasValue = _a._hasValue, _value = _a._value, thrownError = _a.thrownError, isStopped = _a.isStopped, _isComplete = _a._isComplete;
        if (hasError) subscriber.error(thrownError);
        else if (isStopped || _isComplete) {
            _hasValue && subscriber.next(_value);
            subscriber.complete();
        }
    };
    AsyncSubject.prototype.next = function(value) {
        if (!this.isStopped) {
            this._value = value;
            this._hasValue = true;
        }
    };
    AsyncSubject.prototype.complete = function() {
        var _a = this, _hasValue = _a._hasValue, _value = _a._value, _isComplete = _a._isComplete;
        if (!_isComplete) {
            this._isComplete = true;
            _hasValue && _super.prototype.next.call(this, _value);
            _super.prototype.complete.call(this);
        }
    };
    return AsyncSubject;
}((0, _subject.Subject));

},{"tslib":"3gscj","./Subject":"2sXGH","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"gUWQi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "publishReplay", ()=>publishReplay);
var _replaySubject = require("../ReplaySubject");
var _multicast = require("./multicast");
var _isFunction = require("../util/isFunction");
function publishReplay(bufferSize, windowTime, selectorOrScheduler, timestampProvider) {
    if (selectorOrScheduler && !(0, _isFunction.isFunction)(selectorOrScheduler)) timestampProvider = selectorOrScheduler;
    var selector = (0, _isFunction.isFunction)(selectorOrScheduler) ? selectorOrScheduler : undefined;
    return function(source) {
        return (0, _multicast.multicast)(new (0, _replaySubject.ReplaySubject)(bufferSize, windowTime, timestampProvider), selector)(source);
    };
}

},{"../ReplaySubject":"e5koN","./multicast":"blOJd","../util/isFunction":"fpUct","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"e5koN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ReplaySubject", ()=>ReplaySubject);
var _tslib = require("tslib");
var _subject = require("./Subject");
var _dateTimestampProvider = require("./scheduler/dateTimestampProvider");
var ReplaySubject = function(_super) {
    (0, _tslib.__extends)(ReplaySubject, _super);
    function ReplaySubject(_bufferSize, _windowTime, _timestampProvider) {
        if (_bufferSize === void 0) _bufferSize = Infinity;
        if (_windowTime === void 0) _windowTime = Infinity;
        if (_timestampProvider === void 0) _timestampProvider = (0, _dateTimestampProvider.dateTimestampProvider);
        var _this = _super.call(this) || this;
        _this._bufferSize = _bufferSize;
        _this._windowTime = _windowTime;
        _this._timestampProvider = _timestampProvider;
        _this._buffer = [];
        _this._infiniteTimeWindow = true;
        _this._infiniteTimeWindow = _windowTime === Infinity;
        _this._bufferSize = Math.max(1, _bufferSize);
        _this._windowTime = Math.max(1, _windowTime);
        return _this;
    }
    ReplaySubject.prototype.next = function(value) {
        var _a = this, isStopped = _a.isStopped, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow, _timestampProvider = _a._timestampProvider, _windowTime = _a._windowTime;
        if (!isStopped) {
            _buffer.push(value);
            !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
        }
        this._trimBuffer();
        _super.prototype.next.call(this, value);
    };
    ReplaySubject.prototype._subscribe = function(subscriber) {
        this._throwIfClosed();
        this._trimBuffer();
        var subscription = this._innerSubscribe(subscriber);
        var _a = this, _infiniteTimeWindow = _a._infiniteTimeWindow, _buffer = _a._buffer;
        var copy = _buffer.slice();
        for(var i = 0; i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2)subscriber.next(copy[i]);
        this._checkFinalizedStatuses(subscriber);
        return subscription;
    };
    ReplaySubject.prototype._trimBuffer = function() {
        var _a = this, _bufferSize = _a._bufferSize, _timestampProvider = _a._timestampProvider, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow;
        var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
        _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
        if (!_infiniteTimeWindow) {
            var now = _timestampProvider.now();
            var last = 0;
            for(var i = 1; i < _buffer.length && _buffer[i] <= now; i += 2)last = i;
            last && _buffer.splice(0, last + 1);
        }
    };
    return ReplaySubject;
}((0, _subject.Subject));

},{"tslib":"3gscj","./Subject":"2sXGH","./scheduler/dateTimestampProvider":"eoTcW","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"bPlv5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "race", ()=>race);
var _tslib = require("tslib");
var _argsOrArgArray = require("../util/argsOrArgArray");
var _raceWith = require("./raceWith");
function race() {
    var args = [];
    for(var _i = 0; _i < arguments.length; _i++)args[_i] = arguments[_i];
    return (0, _raceWith.raceWith).apply(void 0, (0, _tslib.__spreadArray)([], (0, _tslib.__read)((0, _argsOrArgArray.argsOrArgArray)(args))));
}

},{"tslib":"3gscj","../util/argsOrArgArray":"9KARg","./raceWith":"6cdfA","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"6cdfA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "raceWith", ()=>raceWith);
var _tslib = require("tslib");
var _race = require("../observable/race");
var _lift = require("../util/lift");
var _identity = require("../util/identity");
function raceWith() {
    var otherSources = [];
    for(var _i = 0; _i < arguments.length; _i++)otherSources[_i] = arguments[_i];
    return !otherSources.length ? (0, _identity.identity) : (0, _lift.operate)(function(source, subscriber) {
        (0, _race.raceInit)((0, _tslib.__spreadArray)([
            source
        ], (0, _tslib.__read)(otherSources)))(subscriber);
    });
}

},{"tslib":"3gscj","../observable/race":"cv60P","../util/lift":"3IZjp","../util/identity":"d03yr","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"cv60P":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "race", ()=>race);
parcelHelpers.export(exports, "raceInit", ()=>raceInit);
var _observable = require("../Observable");
var _innerFrom = require("./innerFrom");
var _argsOrArgArray = require("../util/argsOrArgArray");
var _operatorSubscriber = require("../operators/OperatorSubscriber");
function race() {
    var sources = [];
    for(var _i = 0; _i < arguments.length; _i++)sources[_i] = arguments[_i];
    sources = (0, _argsOrArgArray.argsOrArgArray)(sources);
    return sources.length === 1 ? (0, _innerFrom.innerFrom)(sources[0]) : new (0, _observable.Observable)(raceInit(sources));
}
function raceInit(sources) {
    return function(subscriber) {
        var subscriptions = [];
        var _loop_1 = function(i) {
            subscriptions.push((0, _innerFrom.innerFrom)(sources[i]).subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function(value) {
                if (subscriptions) {
                    for(var s = 0; s < subscriptions.length; s++)s !== i && subscriptions[s].unsubscribe();
                    subscriptions = null;
                }
                subscriber.next(value);
            })));
        };
        for(var i = 0; subscriptions && !subscriber.closed && i < sources.length; i++)_loop_1(i);
    };
}

},{"../Observable":"fo3d5","./innerFrom":"6l3RX","../util/argsOrArgArray":"9KARg","../operators/OperatorSubscriber":"hrKGc","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"5UqpN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "repeat", ()=>repeat);
var _empty = require("../observable/empty");
var _lift = require("../util/lift");
var _operatorSubscriber = require("./OperatorSubscriber");
var _innerFrom = require("../observable/innerFrom");
var _timer = require("../observable/timer");
function repeat(countOrConfig) {
    var _a;
    var count = Infinity;
    var delay;
    if (countOrConfig != null) {
        if (typeof countOrConfig === "object") _a = countOrConfig.count, count = _a === void 0 ? Infinity : _a, delay = countOrConfig.delay;
        else count = countOrConfig;
    }
    return count <= 0 ? function() {
        return 0, _empty.EMPTY;
    } : (0, _lift.operate)(function(source, subscriber) {
        var soFar = 0;
        var sourceSub;
        var resubscribe = function() {
            sourceSub === null || sourceSub === void 0 || sourceSub.unsubscribe();
            sourceSub = null;
            if (delay != null) {
                var notifier = typeof delay === "number" ? (0, _timer.timer)(delay) : (0, _innerFrom.innerFrom)(delay(soFar));
                var notifierSubscriber_1 = (0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function() {
                    notifierSubscriber_1.unsubscribe();
                    subscribeToSource();
                });
                notifier.subscribe(notifierSubscriber_1);
            } else subscribeToSource();
        };
        var subscribeToSource = function() {
            var syncUnsub = false;
            sourceSub = source.subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, undefined, function() {
                if (++soFar < count) {
                    if (sourceSub) resubscribe();
                    else syncUnsub = true;
                } else subscriber.complete();
            }));
            if (syncUnsub) resubscribe();
        };
        subscribeToSource();
    });
}

},{"../observable/empty":"hZmJU","../util/lift":"3IZjp","./OperatorSubscriber":"hrKGc","../observable/innerFrom":"6l3RX","../observable/timer":"EANJK","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"gc3fv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "repeatWhen", ()=>repeatWhen);
var _innerFrom = require("../observable/innerFrom");
var _subject = require("../Subject");
var _lift = require("../util/lift");
var _operatorSubscriber = require("./OperatorSubscriber");
function repeatWhen(notifier) {
    return (0, _lift.operate)(function(source, subscriber) {
        var innerSub;
        var syncResub = false;
        var completions$;
        var isNotifierComplete = false;
        var isMainComplete = false;
        var checkComplete = function() {
            return isMainComplete && isNotifierComplete && (subscriber.complete(), true);
        };
        var getCompletionSubject = function() {
            if (!completions$) {
                completions$ = new (0, _subject.Subject)();
                (0, _innerFrom.innerFrom)(notifier(completions$)).subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function() {
                    if (innerSub) subscribeForRepeatWhen();
                    else syncResub = true;
                }, function() {
                    isNotifierComplete = true;
                    checkComplete();
                }));
            }
            return completions$;
        };
        var subscribeForRepeatWhen = function() {
            isMainComplete = false;
            innerSub = source.subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, undefined, function() {
                isMainComplete = true;
                !checkComplete() && getCompletionSubject().next();
            }));
            if (syncResub) {
                innerSub.unsubscribe();
                innerSub = null;
                syncResub = false;
                subscribeForRepeatWhen();
            }
        };
        subscribeForRepeatWhen();
    });
}

},{"../observable/innerFrom":"6l3RX","../Subject":"2sXGH","../util/lift":"3IZjp","./OperatorSubscriber":"hrKGc","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"2tmUJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "retry", ()=>retry);
var _lift = require("../util/lift");
var _operatorSubscriber = require("./OperatorSubscriber");
var _identity = require("../util/identity");
var _timer = require("../observable/timer");
var _innerFrom = require("../observable/innerFrom");
function retry(configOrCount) {
    if (configOrCount === void 0) configOrCount = Infinity;
    var config;
    if (configOrCount && typeof configOrCount === "object") config = configOrCount;
    else config = {
        count: configOrCount
    };
    var _a = config.count, count = _a === void 0 ? Infinity : _a, delay = config.delay, _b = config.resetOnSuccess, resetOnSuccess = _b === void 0 ? false : _b;
    return count <= 0 ? (0, _identity.identity) : (0, _lift.operate)(function(source, subscriber) {
        var soFar = 0;
        var innerSub;
        var subscribeForRetry = function() {
            var syncUnsub = false;
            innerSub = source.subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function(value) {
                if (resetOnSuccess) soFar = 0;
                subscriber.next(value);
            }, undefined, function(err) {
                if (soFar++ < count) {
                    var resub_1 = function() {
                        if (innerSub) {
                            innerSub.unsubscribe();
                            innerSub = null;
                            subscribeForRetry();
                        } else syncUnsub = true;
                    };
                    if (delay != null) {
                        var notifier = typeof delay === "number" ? (0, _timer.timer)(delay) : (0, _innerFrom.innerFrom)(delay(err, soFar));
                        var notifierSubscriber_1 = (0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function() {
                            notifierSubscriber_1.unsubscribe();
                            resub_1();
                        }, function() {
                            subscriber.complete();
                        });
                        notifier.subscribe(notifierSubscriber_1);
                    } else resub_1();
                } else subscriber.error(err);
            }));
            if (syncUnsub) {
                innerSub.unsubscribe();
                innerSub = null;
                subscribeForRetry();
            }
        };
        subscribeForRetry();
    });
}

},{"../util/lift":"3IZjp","./OperatorSubscriber":"hrKGc","../util/identity":"d03yr","../observable/timer":"EANJK","../observable/innerFrom":"6l3RX","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"22yAc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "retryWhen", ()=>retryWhen);
var _innerFrom = require("../observable/innerFrom");
var _subject = require("../Subject");
var _lift = require("../util/lift");
var _operatorSubscriber = require("./OperatorSubscriber");
function retryWhen(notifier) {
    return (0, _lift.operate)(function(source, subscriber) {
        var innerSub;
        var syncResub = false;
        var errors$;
        var subscribeForRetryWhen = function() {
            innerSub = source.subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, undefined, undefined, function(err) {
                if (!errors$) {
                    errors$ = new (0, _subject.Subject)();
                    (0, _innerFrom.innerFrom)(notifier(errors$)).subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function() {
                        return innerSub ? subscribeForRetryWhen() : syncResub = true;
                    }));
                }
                if (errors$) errors$.next(err);
            }));
            if (syncResub) {
                innerSub.unsubscribe();
                innerSub = null;
                syncResub = false;
                subscribeForRetryWhen();
            }
        };
        subscribeForRetryWhen();
    });
}

},{"../observable/innerFrom":"6l3RX","../Subject":"2sXGH","../util/lift":"3IZjp","./OperatorSubscriber":"hrKGc","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"4UBOM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "sample", ()=>sample);
var _innerFrom = require("../observable/innerFrom");
var _lift = require("../util/lift");
var _noop = require("../util/noop");
var _operatorSubscriber = require("./OperatorSubscriber");
function sample(notifier) {
    return (0, _lift.operate)(function(source, subscriber) {
        var hasValue = false;
        var lastValue = null;
        source.subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function(value) {
            hasValue = true;
            lastValue = value;
        }));
        (0, _innerFrom.innerFrom)(notifier).subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function() {
            if (hasValue) {
                hasValue = false;
                var value = lastValue;
                lastValue = null;
                subscriber.next(value);
            }
        }, (0, _noop.noop)));
    });
}

},{"../observable/innerFrom":"6l3RX","../util/lift":"3IZjp","../util/noop":"f1sCb","./OperatorSubscriber":"hrKGc","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"9b5UP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "sampleTime", ()=>sampleTime);
var _async = require("../scheduler/async");
var _sample = require("./sample");
var _interval = require("../observable/interval");
function sampleTime(period, scheduler) {
    if (scheduler === void 0) scheduler = (0, _async.asyncScheduler);
    return (0, _sample.sample)((0, _interval.interval)(period, scheduler));
}

},{"../scheduler/async":"eIZ5a","./sample":"4UBOM","../observable/interval":"ebQRx","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"ebQRx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "interval", ()=>interval);
var _async = require("../scheduler/async");
var _timer = require("./timer");
function interval(period, scheduler) {
    if (period === void 0) period = 0;
    if (scheduler === void 0) scheduler = (0, _async.asyncScheduler);
    if (period < 0) period = 0;
    return (0, _timer.timer)(period, period, scheduler);
}

},{"../scheduler/async":"eIZ5a","./timer":"EANJK","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"hjpMh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "scan", ()=>scan);
var _lift = require("../util/lift");
var _scanInternals = require("./scanInternals");
function scan(accumulator, seed) {
    return (0, _lift.operate)((0, _scanInternals.scanInternals)(accumulator, seed, arguments.length >= 2, true));
}

},{"../util/lift":"3IZjp","./scanInternals":"jLfgH","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"2HeB5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "sequenceEqual", ()=>sequenceEqual);
var _lift = require("../util/lift");
var _operatorSubscriber = require("./OperatorSubscriber");
var _innerFrom = require("../observable/innerFrom");
function sequenceEqual(compareTo, comparator) {
    if (comparator === void 0) comparator = function(a, b) {
        return a === b;
    };
    return (0, _lift.operate)(function(source, subscriber) {
        var aState = createState();
        var bState = createState();
        var emit = function(isEqual) {
            subscriber.next(isEqual);
            subscriber.complete();
        };
        var createSubscriber = function(selfState, otherState) {
            var sequenceEqualSubscriber = (0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function(a) {
                var buffer = otherState.buffer, complete = otherState.complete;
                if (buffer.length === 0) complete ? emit(false) : selfState.buffer.push(a);
                else !comparator(a, buffer.shift()) && emit(false);
            }, function() {
                selfState.complete = true;
                var complete = otherState.complete, buffer = otherState.buffer;
                complete && emit(buffer.length === 0);
                sequenceEqualSubscriber === null || sequenceEqualSubscriber === void 0 || sequenceEqualSubscriber.unsubscribe();
            });
            return sequenceEqualSubscriber;
        };
        source.subscribe(createSubscriber(aState, bState));
        (0, _innerFrom.innerFrom)(compareTo).subscribe(createSubscriber(bState, aState));
    });
}
function createState() {
    return {
        buffer: [],
        complete: false
    };
}

},{"../util/lift":"3IZjp","./OperatorSubscriber":"hrKGc","../observable/innerFrom":"6l3RX","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"9lnzR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "share", ()=>share);
var _tslib = require("tslib");
var _innerFrom = require("../observable/innerFrom");
var _subject = require("../Subject");
var _subscriber = require("../Subscriber");
var _lift = require("../util/lift");
function share(options) {
    if (options === void 0) options = {};
    var _a = options.connector, connector = _a === void 0 ? function() {
        return new (0, _subject.Subject)();
    } : _a, _b = options.resetOnError, resetOnError = _b === void 0 ? true : _b, _c = options.resetOnComplete, resetOnComplete = _c === void 0 ? true : _c, _d = options.resetOnRefCountZero, resetOnRefCountZero = _d === void 0 ? true : _d;
    return function(wrapperSource) {
        var connection;
        var resetConnection;
        var subject;
        var refCount = 0;
        var hasCompleted = false;
        var hasErrored = false;
        var cancelReset = function() {
            resetConnection === null || resetConnection === void 0 || resetConnection.unsubscribe();
            resetConnection = undefined;
        };
        var reset = function() {
            cancelReset();
            connection = subject = undefined;
            hasCompleted = hasErrored = false;
        };
        var resetAndUnsubscribe = function() {
            var conn = connection;
            reset();
            conn === null || conn === void 0 || conn.unsubscribe();
        };
        return (0, _lift.operate)(function(source, subscriber) {
            refCount++;
            if (!hasErrored && !hasCompleted) cancelReset();
            var dest = subject = subject !== null && subject !== void 0 ? subject : connector();
            subscriber.add(function() {
                refCount--;
                if (refCount === 0 && !hasErrored && !hasCompleted) resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);
            });
            dest.subscribe(subscriber);
            if (!connection && refCount > 0) {
                connection = new (0, _subscriber.SafeSubscriber)({
                    next: function(value) {
                        return dest.next(value);
                    },
                    error: function(err) {
                        hasErrored = true;
                        cancelReset();
                        resetConnection = handleReset(reset, resetOnError, err);
                        dest.error(err);
                    },
                    complete: function() {
                        hasCompleted = true;
                        cancelReset();
                        resetConnection = handleReset(reset, resetOnComplete);
                        dest.complete();
                    }
                });
                (0, _innerFrom.innerFrom)(source).subscribe(connection);
            }
        })(wrapperSource);
    };
}
function handleReset(reset, on) {
    var args = [];
    for(var _i = 2; _i < arguments.length; _i++)args[_i - 2] = arguments[_i];
    if (on === true) {
        reset();
        return;
    }
    if (on === false) return;
    var onSubscriber = new (0, _subscriber.SafeSubscriber)({
        next: function() {
            onSubscriber.unsubscribe();
            reset();
        }
    });
    return (0, _innerFrom.innerFrom)(on.apply(void 0, (0, _tslib.__spreadArray)([], (0, _tslib.__read)(args)))).subscribe(onSubscriber);
}

},{"tslib":"3gscj","../observable/innerFrom":"6l3RX","../Subject":"2sXGH","../Subscriber":"8Btbx","../util/lift":"3IZjp","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"3ApTz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "shareReplay", ()=>shareReplay);
var _replaySubject = require("../ReplaySubject");
var _share = require("./share");
function shareReplay(configOrBufferSize, windowTime, scheduler) {
    var _a, _b, _c;
    var bufferSize;
    var refCount = false;
    if (configOrBufferSize && typeof configOrBufferSize === "object") _a = configOrBufferSize.bufferSize, bufferSize = _a === void 0 ? Infinity : _a, _b = configOrBufferSize.windowTime, windowTime = _b === void 0 ? Infinity : _b, _c = configOrBufferSize.refCount, refCount = _c === void 0 ? false : _c, scheduler = configOrBufferSize.scheduler;
    else bufferSize = configOrBufferSize !== null && configOrBufferSize !== void 0 ? configOrBufferSize : Infinity;
    return (0, _share.share)({
        connector: function() {
            return new (0, _replaySubject.ReplaySubject)(bufferSize, windowTime, scheduler);
        },
        resetOnError: true,
        resetOnComplete: false,
        resetOnRefCountZero: refCount
    });
}

},{"../ReplaySubject":"e5koN","./share":"9lnzR","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"6EvgU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "single", ()=>single);
var _emptyError = require("../util/EmptyError");
var _sequenceError = require("../util/SequenceError");
var _notFoundError = require("../util/NotFoundError");
var _lift = require("../util/lift");
var _operatorSubscriber = require("./OperatorSubscriber");
function single(predicate) {
    return (0, _lift.operate)(function(source, subscriber) {
        var hasValue = false;
        var singleValue;
        var seenValue = false;
        var index = 0;
        source.subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function(value) {
            seenValue = true;
            if (!predicate || predicate(value, index++, source)) {
                hasValue && subscriber.error(new (0, _sequenceError.SequenceError)("Too many matching values"));
                hasValue = true;
                singleValue = value;
            }
        }, function() {
            if (hasValue) {
                subscriber.next(singleValue);
                subscriber.complete();
            } else subscriber.error(seenValue ? new (0, _notFoundError.NotFoundError)("No matching values") : new (0, _emptyError.EmptyError)());
        }));
    });
}

},{"../util/EmptyError":"Mm8dB","../util/SequenceError":"bapUn","../util/NotFoundError":"aVTD3","../util/lift":"3IZjp","./OperatorSubscriber":"hrKGc","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"bapUn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SequenceError", ()=>SequenceError);
var _createErrorClass = require("./createErrorClass");
var SequenceError = (0, _createErrorClass.createErrorClass)(function(_super) {
    return function SequenceErrorImpl(message) {
        _super(this);
        this.name = "SequenceError";
        this.message = message;
    };
});

},{"./createErrorClass":"1JmLg","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"aVTD3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "NotFoundError", ()=>NotFoundError);
var _createErrorClass = require("./createErrorClass");
var NotFoundError = (0, _createErrorClass.createErrorClass)(function(_super) {
    return function NotFoundErrorImpl(message) {
        _super(this);
        this.name = "NotFoundError";
        this.message = message;
    };
});

},{"./createErrorClass":"1JmLg","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"hBspj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "skip", ()=>skip);
var _filter = require("./filter");
function skip(count) {
    return (0, _filter.filter)(function(_, index) {
        return count <= index;
    });
}

},{"./filter":"aO3IO","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"dV92A":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "skipLast", ()=>skipLast);
var _identity = require("../util/identity");
var _lift = require("../util/lift");
var _operatorSubscriber = require("./OperatorSubscriber");
function skipLast(skipCount) {
    return skipCount <= 0 ? (0, _identity.identity) : (0, _lift.operate)(function(source, subscriber) {
        var ring = new Array(skipCount);
        var seen = 0;
        source.subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function(value) {
            var valueIndex = seen++;
            if (valueIndex < skipCount) ring[valueIndex] = value;
            else {
                var index = valueIndex % skipCount;
                var oldValue = ring[index];
                ring[index] = value;
                subscriber.next(oldValue);
            }
        }));
        return function() {
            ring = null;
        };
    });
}

},{"../util/identity":"d03yr","../util/lift":"3IZjp","./OperatorSubscriber":"hrKGc","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"hgUdx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "skipUntil", ()=>skipUntil);
var _lift = require("../util/lift");
var _operatorSubscriber = require("./OperatorSubscriber");
var _innerFrom = require("../observable/innerFrom");
var _noop = require("../util/noop");
function skipUntil(notifier) {
    return (0, _lift.operate)(function(source, subscriber) {
        var taking = false;
        var skipSubscriber = (0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function() {
            skipSubscriber === null || skipSubscriber === void 0 || skipSubscriber.unsubscribe();
            taking = true;
        }, (0, _noop.noop));
        (0, _innerFrom.innerFrom)(notifier).subscribe(skipSubscriber);
        source.subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function(value) {
            return taking && subscriber.next(value);
        }));
    });
}

},{"../util/lift":"3IZjp","./OperatorSubscriber":"hrKGc","../observable/innerFrom":"6l3RX","../util/noop":"f1sCb","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"iMGQR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "skipWhile", ()=>skipWhile);
var _lift = require("../util/lift");
var _operatorSubscriber = require("./OperatorSubscriber");
function skipWhile(predicate) {
    return (0, _lift.operate)(function(source, subscriber) {
        var taking = false;
        var index = 0;
        source.subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function(value) {
            return (taking || (taking = !predicate(value, index++))) && subscriber.next(value);
        }));
    });
}

},{"../util/lift":"3IZjp","./OperatorSubscriber":"hrKGc","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"4c0lY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "startWith", ()=>startWith);
var _concat = require("../observable/concat");
var _args = require("../util/args");
var _lift = require("../util/lift");
function startWith() {
    var values = [];
    for(var _i = 0; _i < arguments.length; _i++)values[_i] = arguments[_i];
    var scheduler = (0, _args.popScheduler)(values);
    return (0, _lift.operate)(function(source, subscriber) {
        (scheduler ? (0, _concat.concat)(values, source, scheduler) : (0, _concat.concat)(values, source)).subscribe(subscriber);
    });
}

},{"../observable/concat":"1H86H","../util/args":"ccsng","../util/lift":"3IZjp","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"cnJCR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "switchAll", ()=>switchAll);
var _switchMap = require("./switchMap");
var _identity = require("../util/identity");
function switchAll() {
    return (0, _switchMap.switchMap)((0, _identity.identity));
}

},{"./switchMap":"1rRAL","../util/identity":"d03yr","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"1rRAL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "switchMap", ()=>switchMap);
var _innerFrom = require("../observable/innerFrom");
var _lift = require("../util/lift");
var _operatorSubscriber = require("./OperatorSubscriber");
function switchMap(project, resultSelector) {
    return (0, _lift.operate)(function(source, subscriber) {
        var innerSubscriber = null;
        var index = 0;
        var isComplete = false;
        var checkComplete = function() {
            return isComplete && !innerSubscriber && subscriber.complete();
        };
        source.subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function(value) {
            innerSubscriber === null || innerSubscriber === void 0 || innerSubscriber.unsubscribe();
            var innerIndex = 0;
            var outerIndex = index++;
            (0, _innerFrom.innerFrom)(project(value, outerIndex)).subscribe(innerSubscriber = (0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function(innerValue) {
                return subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue);
            }, function() {
                innerSubscriber = null;
                checkComplete();
            }));
        }, function() {
            isComplete = true;
            checkComplete();
        }));
    });
}

},{"../observable/innerFrom":"6l3RX","../util/lift":"3IZjp","./OperatorSubscriber":"hrKGc","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"727dN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "switchMapTo", ()=>switchMapTo);
var _switchMap = require("./switchMap");
var _isFunction = require("../util/isFunction");
function switchMapTo(innerObservable, resultSelector) {
    return (0, _isFunction.isFunction)(resultSelector) ? (0, _switchMap.switchMap)(function() {
        return innerObservable;
    }, resultSelector) : (0, _switchMap.switchMap)(function() {
        return innerObservable;
    });
}

},{"./switchMap":"1rRAL","../util/isFunction":"fpUct","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"cL6qq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "switchScan", ()=>switchScan);
var _switchMap = require("./switchMap");
var _lift = require("../util/lift");
function switchScan(accumulator, seed) {
    return (0, _lift.operate)(function(source, subscriber) {
        var state = seed;
        (0, _switchMap.switchMap)(function(value, index) {
            return accumulator(state, value, index);
        }, function(_, innerValue) {
            return state = innerValue, innerValue;
        })(source).subscribe(subscriber);
        return function() {
            state = null;
        };
    });
}

},{"./switchMap":"1rRAL","../util/lift":"3IZjp","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"1WaPV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "takeUntil", ()=>takeUntil);
var _lift = require("../util/lift");
var _operatorSubscriber = require("./OperatorSubscriber");
var _innerFrom = require("../observable/innerFrom");
var _noop = require("../util/noop");
function takeUntil(notifier) {
    return (0, _lift.operate)(function(source, subscriber) {
        (0, _innerFrom.innerFrom)(notifier).subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function() {
            return subscriber.complete();
        }, (0, _noop.noop)));
        !subscriber.closed && source.subscribe(subscriber);
    });
}

},{"../util/lift":"3IZjp","./OperatorSubscriber":"hrKGc","../observable/innerFrom":"6l3RX","../util/noop":"f1sCb","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"WXp51":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "takeWhile", ()=>takeWhile);
var _lift = require("../util/lift");
var _operatorSubscriber = require("./OperatorSubscriber");
function takeWhile(predicate, inclusive) {
    if (inclusive === void 0) inclusive = false;
    return (0, _lift.operate)(function(source, subscriber) {
        var index = 0;
        source.subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function(value) {
            var result = predicate(value, index++);
            (result || inclusive) && subscriber.next(value);
            !result && subscriber.complete();
        }));
    });
}

},{"../util/lift":"3IZjp","./OperatorSubscriber":"hrKGc","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"gzncB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "tap", ()=>tap);
var _isFunction = require("../util/isFunction");
var _lift = require("../util/lift");
var _operatorSubscriber = require("./OperatorSubscriber");
var _identity = require("../util/identity");
function tap(observerOrNext, error, complete) {
    var tapObserver = (0, _isFunction.isFunction)(observerOrNext) || error || complete ? {
        next: observerOrNext,
        error: error,
        complete: complete
    } : observerOrNext;
    return tapObserver ? (0, _lift.operate)(function(source, subscriber) {
        var _a;
        (_a = tapObserver.subscribe) === null || _a === void 0 || _a.call(tapObserver);
        var isUnsub = true;
        source.subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function(value) {
            var _a;
            (_a = tapObserver.next) === null || _a === void 0 || _a.call(tapObserver, value);
            subscriber.next(value);
        }, function() {
            var _a;
            isUnsub = false;
            (_a = tapObserver.complete) === null || _a === void 0 || _a.call(tapObserver);
            subscriber.complete();
        }, function(err) {
            var _a;
            isUnsub = false;
            (_a = tapObserver.error) === null || _a === void 0 || _a.call(tapObserver, err);
            subscriber.error(err);
        }, function() {
            var _a, _b;
            if (isUnsub) (_a = tapObserver.unsubscribe) === null || _a === void 0 || _a.call(tapObserver);
            (_b = tapObserver.finalize) === null || _b === void 0 || _b.call(tapObserver);
        }));
    }) : (0, _identity.identity);
}

},{"../util/isFunction":"fpUct","../util/lift":"3IZjp","./OperatorSubscriber":"hrKGc","../util/identity":"d03yr","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"aqWV2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "throttle", ()=>throttle);
var _lift = require("../util/lift");
var _operatorSubscriber = require("./OperatorSubscriber");
var _innerFrom = require("../observable/innerFrom");
function throttle(durationSelector, config) {
    return (0, _lift.operate)(function(source, subscriber) {
        var _a = config !== null && config !== void 0 ? config : {}, _b = _a.leading, leading = _b === void 0 ? true : _b, _c = _a.trailing, trailing = _c === void 0 ? false : _c;
        var hasValue = false;
        var sendValue = null;
        var throttled = null;
        var isComplete = false;
        var endThrottling = function() {
            throttled === null || throttled === void 0 || throttled.unsubscribe();
            throttled = null;
            if (trailing) {
                send();
                isComplete && subscriber.complete();
            }
        };
        var cleanupThrottling = function() {
            throttled = null;
            isComplete && subscriber.complete();
        };
        var startThrottle = function(value) {
            return throttled = (0, _innerFrom.innerFrom)(durationSelector(value)).subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, endThrottling, cleanupThrottling));
        };
        var send = function() {
            if (hasValue) {
                hasValue = false;
                var value = sendValue;
                sendValue = null;
                subscriber.next(value);
                !isComplete && startThrottle(value);
            }
        };
        source.subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function(value) {
            hasValue = true;
            sendValue = value;
            !(throttled && !throttled.closed) && (leading ? send() : startThrottle(value));
        }, function() {
            isComplete = true;
            !(trailing && hasValue && throttled && !throttled.closed) && subscriber.complete();
        }));
    });
}

},{"../util/lift":"3IZjp","./OperatorSubscriber":"hrKGc","../observable/innerFrom":"6l3RX","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"7zEuX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "throttleTime", ()=>throttleTime);
var _async = require("../scheduler/async");
var _throttle = require("./throttle");
var _timer = require("../observable/timer");
function throttleTime(duration, scheduler, config) {
    if (scheduler === void 0) scheduler = (0, _async.asyncScheduler);
    var duration$ = (0, _timer.timer)(duration, scheduler);
    return (0, _throttle.throttle)(function() {
        return duration$;
    }, config);
}

},{"../scheduler/async":"eIZ5a","./throttle":"aqWV2","../observable/timer":"EANJK","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"i7v6u":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "timeInterval", ()=>timeInterval);
parcelHelpers.export(exports, "TimeInterval", ()=>TimeInterval);
var _async = require("../scheduler/async");
var _lift = require("../util/lift");
var _operatorSubscriber = require("./OperatorSubscriber");
function timeInterval(scheduler) {
    if (scheduler === void 0) scheduler = (0, _async.asyncScheduler);
    return (0, _lift.operate)(function(source, subscriber) {
        var last = scheduler.now();
        source.subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function(value) {
            var now = scheduler.now();
            var interval = now - last;
            last = now;
            subscriber.next(new TimeInterval(value, interval));
        }));
    });
}
var TimeInterval = function() {
    function TimeInterval(value, interval) {
        this.value = value;
        this.interval = interval;
    }
    return TimeInterval;
}();

},{"../scheduler/async":"eIZ5a","../util/lift":"3IZjp","./OperatorSubscriber":"hrKGc","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"4qfYk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TimeoutError", ()=>TimeoutError);
parcelHelpers.export(exports, "timeout", ()=>timeout);
var _async = require("../scheduler/async");
var _isDate = require("../util/isDate");
var _lift = require("../util/lift");
var _innerFrom = require("../observable/innerFrom");
var _createErrorClass = require("../util/createErrorClass");
var _operatorSubscriber = require("./OperatorSubscriber");
var _executeSchedule = require("../util/executeSchedule");
var TimeoutError = (0, _createErrorClass.createErrorClass)(function(_super) {
    return function TimeoutErrorImpl(info) {
        if (info === void 0) info = null;
        _super(this);
        this.message = "Timeout has occurred";
        this.name = "TimeoutError";
        this.info = info;
    };
});
function timeout(config, schedulerArg) {
    var _a = (0, _isDate.isValidDate)(config) ? {
        first: config
    } : typeof config === "number" ? {
        each: config
    } : config, first = _a.first, each = _a.each, _b = _a.with, _with = _b === void 0 ? timeoutErrorFactory : _b, _c = _a.scheduler, scheduler = _c === void 0 ? schedulerArg !== null && schedulerArg !== void 0 ? schedulerArg : (0, _async.asyncScheduler) : _c, _d = _a.meta, meta = _d === void 0 ? null : _d;
    if (first == null && each == null) throw new TypeError("No timeout provided.");
    return (0, _lift.operate)(function(source, subscriber) {
        var originalSourceSubscription;
        var timerSubscription;
        var lastValue = null;
        var seen = 0;
        var startTimer = function(delay) {
            timerSubscription = (0, _executeSchedule.executeSchedule)(subscriber, scheduler, function() {
                try {
                    originalSourceSubscription.unsubscribe();
                    (0, _innerFrom.innerFrom)(_with({
                        meta: meta,
                        lastValue: lastValue,
                        seen: seen
                    })).subscribe(subscriber);
                } catch (err) {
                    subscriber.error(err);
                }
            }, delay);
        };
        originalSourceSubscription = source.subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function(value) {
            timerSubscription === null || timerSubscription === void 0 || timerSubscription.unsubscribe();
            seen++;
            subscriber.next(lastValue = value);
            each > 0 && startTimer(each);
        }, undefined, undefined, function() {
            if (!(timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.closed)) timerSubscription === null || timerSubscription === void 0 || timerSubscription.unsubscribe();
            lastValue = null;
        }));
        !seen && startTimer(first != null ? typeof first === "number" ? first : +first - scheduler.now() : each);
    });
}
function timeoutErrorFactory(info) {
    throw new TimeoutError(info);
}

},{"../scheduler/async":"eIZ5a","../util/isDate":"lsVk7","../util/lift":"3IZjp","../observable/innerFrom":"6l3RX","../util/createErrorClass":"1JmLg","./OperatorSubscriber":"hrKGc","../util/executeSchedule":"4ayy2","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"igxz4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "timeoutWith", ()=>timeoutWith);
var _async = require("../scheduler/async");
var _isDate = require("../util/isDate");
var _timeout = require("./timeout");
function timeoutWith(due, withObservable, scheduler) {
    var first;
    var each;
    var _with;
    scheduler = scheduler !== null && scheduler !== void 0 ? scheduler : (0, _async.async);
    if ((0, _isDate.isValidDate)(due)) first = due;
    else if (typeof due === "number") each = due;
    if (withObservable) _with = function() {
        return withObservable;
    };
    else throw new TypeError("No observable provided to switch to");
    if (first == null && each == null) throw new TypeError("No timeout provided.");
    return (0, _timeout.timeout)({
        first: first,
        each: each,
        scheduler: scheduler,
        with: _with
    });
}

},{"../scheduler/async":"eIZ5a","../util/isDate":"lsVk7","./timeout":"4qfYk","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"eP3KH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "timestamp", ()=>timestamp);
var _dateTimestampProvider = require("../scheduler/dateTimestampProvider");
var _map = require("./map");
function timestamp(timestampProvider) {
    if (timestampProvider === void 0) timestampProvider = (0, _dateTimestampProvider.dateTimestampProvider);
    return (0, _map.map)(function(value) {
        return {
            value: value,
            timestamp: timestampProvider.now()
        };
    });
}

},{"../scheduler/dateTimestampProvider":"eoTcW","./map":"9Azp4","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"5Cov0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "window", ()=>window);
var _subject = require("../Subject");
var _lift = require("../util/lift");
var _operatorSubscriber = require("./OperatorSubscriber");
var _noop = require("../util/noop");
var _innerFrom = require("../observable/innerFrom");
function window(windowBoundaries) {
    return (0, _lift.operate)(function(source, subscriber) {
        var windowSubject = new (0, _subject.Subject)();
        subscriber.next(windowSubject.asObservable());
        var errorHandler = function(err) {
            windowSubject.error(err);
            subscriber.error(err);
        };
        source.subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function(value) {
            return windowSubject === null || windowSubject === void 0 ? void 0 : windowSubject.next(value);
        }, function() {
            windowSubject.complete();
            subscriber.complete();
        }, errorHandler));
        (0, _innerFrom.innerFrom)(windowBoundaries).subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function() {
            windowSubject.complete();
            subscriber.next(windowSubject = new (0, _subject.Subject)());
        }, (0, _noop.noop), errorHandler));
        return function() {
            windowSubject === null || windowSubject === void 0 || windowSubject.unsubscribe();
            windowSubject = null;
        };
    });
}

},{"../Subject":"2sXGH","../util/lift":"3IZjp","./OperatorSubscriber":"hrKGc","../util/noop":"f1sCb","../observable/innerFrom":"6l3RX","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"9lRUE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "windowCount", ()=>windowCount);
var _tslib = require("tslib");
var _subject = require("../Subject");
var _lift = require("../util/lift");
var _operatorSubscriber = require("./OperatorSubscriber");
function windowCount(windowSize, startWindowEvery) {
    if (startWindowEvery === void 0) startWindowEvery = 0;
    var startEvery = startWindowEvery > 0 ? startWindowEvery : windowSize;
    return (0, _lift.operate)(function(source, subscriber) {
        var windows = [
            new (0, _subject.Subject)()
        ];
        var starts = [];
        var count = 0;
        subscriber.next(windows[0].asObservable());
        source.subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function(value) {
            var e_1, _a;
            try {
                for(var windows_1 = (0, _tslib.__values)(windows), windows_1_1 = windows_1.next(); !windows_1_1.done; windows_1_1 = windows_1.next()){
                    var window_1 = windows_1_1.value;
                    window_1.next(value);
                }
            } catch (e_1_1) {
                e_1 = {
                    error: e_1_1
                };
            } finally{
                try {
                    if (windows_1_1 && !windows_1_1.done && (_a = windows_1.return)) _a.call(windows_1);
                } finally{
                    if (e_1) throw e_1.error;
                }
            }
            var c = count - windowSize + 1;
            if (c >= 0 && c % startEvery === 0) windows.shift().complete();
            if (++count % startEvery === 0) {
                var window_2 = new (0, _subject.Subject)();
                windows.push(window_2);
                subscriber.next(window_2.asObservable());
            }
        }, function() {
            while(windows.length > 0)windows.shift().complete();
            subscriber.complete();
        }, function(err) {
            while(windows.length > 0)windows.shift().error(err);
            subscriber.error(err);
        }, function() {
            starts = null;
            windows = null;
        }));
    });
}

},{"tslib":"3gscj","../Subject":"2sXGH","../util/lift":"3IZjp","./OperatorSubscriber":"hrKGc","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"9CZWM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "windowTime", ()=>windowTime);
var _subject = require("../Subject");
var _async = require("../scheduler/async");
var _subscription = require("../Subscription");
var _lift = require("../util/lift");
var _operatorSubscriber = require("./OperatorSubscriber");
var _arrRemove = require("../util/arrRemove");
var _args = require("../util/args");
var _executeSchedule = require("../util/executeSchedule");
function windowTime(windowTimeSpan) {
    var _a, _b;
    var otherArgs = [];
    for(var _i = 1; _i < arguments.length; _i++)otherArgs[_i - 1] = arguments[_i];
    var scheduler = (_a = (0, _args.popScheduler)(otherArgs)) !== null && _a !== void 0 ? _a : (0, _async.asyncScheduler);
    var windowCreationInterval = (_b = otherArgs[0]) !== null && _b !== void 0 ? _b : null;
    var maxWindowSize = otherArgs[1] || Infinity;
    return (0, _lift.operate)(function(source, subscriber) {
        var windowRecords = [];
        var restartOnClose = false;
        var closeWindow = function(record) {
            var window = record.window, subs = record.subs;
            window.complete();
            subs.unsubscribe();
            (0, _arrRemove.arrRemove)(windowRecords, record);
            restartOnClose && startWindow();
        };
        var startWindow = function() {
            if (windowRecords) {
                var subs = new (0, _subscription.Subscription)();
                subscriber.add(subs);
                var window_1 = new (0, _subject.Subject)();
                var record_1 = {
                    window: window_1,
                    subs: subs,
                    seen: 0
                };
                windowRecords.push(record_1);
                subscriber.next(window_1.asObservable());
                (0, _executeSchedule.executeSchedule)(subs, scheduler, function() {
                    return closeWindow(record_1);
                }, windowTimeSpan);
            }
        };
        if (windowCreationInterval !== null && windowCreationInterval >= 0) (0, _executeSchedule.executeSchedule)(subscriber, scheduler, startWindow, windowCreationInterval, true);
        else restartOnClose = true;
        startWindow();
        var loop = function(cb) {
            return windowRecords.slice().forEach(cb);
        };
        var terminate = function(cb) {
            loop(function(_a) {
                var window = _a.window;
                return cb(window);
            });
            cb(subscriber);
            subscriber.unsubscribe();
        };
        source.subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function(value) {
            loop(function(record) {
                record.window.next(value);
                maxWindowSize <= ++record.seen && closeWindow(record);
            });
        }, function() {
            return terminate(function(consumer) {
                return consumer.complete();
            });
        }, function(err) {
            return terminate(function(consumer) {
                return consumer.error(err);
            });
        }));
        return function() {
            windowRecords = null;
        };
    });
}

},{"../Subject":"2sXGH","../scheduler/async":"eIZ5a","../Subscription":"gzL8W","../util/lift":"3IZjp","./OperatorSubscriber":"hrKGc","../util/arrRemove":"4LjhZ","../util/args":"ccsng","../util/executeSchedule":"4ayy2","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"9vCYU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "windowToggle", ()=>windowToggle);
var _tslib = require("tslib");
var _subject = require("../Subject");
var _subscription = require("../Subscription");
var _lift = require("../util/lift");
var _innerFrom = require("../observable/innerFrom");
var _operatorSubscriber = require("./OperatorSubscriber");
var _noop = require("../util/noop");
var _arrRemove = require("../util/arrRemove");
function windowToggle(openings, closingSelector) {
    return (0, _lift.operate)(function(source, subscriber) {
        var windows = [];
        var handleError = function(err) {
            while(0 < windows.length)windows.shift().error(err);
            subscriber.error(err);
        };
        (0, _innerFrom.innerFrom)(openings).subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function(openValue) {
            var window = new (0, _subject.Subject)();
            windows.push(window);
            var closingSubscription = new (0, _subscription.Subscription)();
            var closeWindow = function() {
                (0, _arrRemove.arrRemove)(windows, window);
                window.complete();
                closingSubscription.unsubscribe();
            };
            var closingNotifier;
            try {
                closingNotifier = (0, _innerFrom.innerFrom)(closingSelector(openValue));
            } catch (err) {
                handleError(err);
                return;
            }
            subscriber.next(window.asObservable());
            closingSubscription.add(closingNotifier.subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, closeWindow, (0, _noop.noop), handleError)));
        }, (0, _noop.noop)));
        source.subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function(value) {
            var e_1, _a;
            var windowsCopy = windows.slice();
            try {
                for(var windowsCopy_1 = (0, _tslib.__values)(windowsCopy), windowsCopy_1_1 = windowsCopy_1.next(); !windowsCopy_1_1.done; windowsCopy_1_1 = windowsCopy_1.next()){
                    var window_1 = windowsCopy_1_1.value;
                    window_1.next(value);
                }
            } catch (e_1_1) {
                e_1 = {
                    error: e_1_1
                };
            } finally{
                try {
                    if (windowsCopy_1_1 && !windowsCopy_1_1.done && (_a = windowsCopy_1.return)) _a.call(windowsCopy_1);
                } finally{
                    if (e_1) throw e_1.error;
                }
            }
        }, function() {
            while(0 < windows.length)windows.shift().complete();
            subscriber.complete();
        }, handleError, function() {
            while(0 < windows.length)windows.shift().unsubscribe();
        }));
    });
}

},{"tslib":"3gscj","../Subject":"2sXGH","../Subscription":"gzL8W","../util/lift":"3IZjp","../observable/innerFrom":"6l3RX","./OperatorSubscriber":"hrKGc","../util/noop":"f1sCb","../util/arrRemove":"4LjhZ","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"73c43":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "windowWhen", ()=>windowWhen);
var _subject = require("../Subject");
var _lift = require("../util/lift");
var _operatorSubscriber = require("./OperatorSubscriber");
var _innerFrom = require("../observable/innerFrom");
function windowWhen(closingSelector) {
    return (0, _lift.operate)(function(source, subscriber) {
        var window;
        var closingSubscriber;
        var handleError = function(err) {
            window.error(err);
            subscriber.error(err);
        };
        var openWindow = function() {
            closingSubscriber === null || closingSubscriber === void 0 || closingSubscriber.unsubscribe();
            window === null || window === void 0 || window.complete();
            window = new (0, _subject.Subject)();
            subscriber.next(window.asObservable());
            var closingNotifier;
            try {
                closingNotifier = (0, _innerFrom.innerFrom)(closingSelector());
            } catch (err) {
                handleError(err);
                return;
            }
            closingNotifier.subscribe(closingSubscriber = (0, _operatorSubscriber.createOperatorSubscriber)(subscriber, openWindow, openWindow, handleError));
        };
        openWindow();
        source.subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function(value) {
            return window.next(value);
        }, function() {
            window.complete();
            subscriber.complete();
        }, handleError, function() {
            closingSubscriber === null || closingSubscriber === void 0 || closingSubscriber.unsubscribe();
            window = null;
        }));
    });
}

},{"../Subject":"2sXGH","../util/lift":"3IZjp","./OperatorSubscriber":"hrKGc","../observable/innerFrom":"6l3RX","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"8Yb0Y":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "withLatestFrom", ()=>withLatestFrom);
var _tslib = require("tslib");
var _lift = require("../util/lift");
var _operatorSubscriber = require("./OperatorSubscriber");
var _innerFrom = require("../observable/innerFrom");
var _identity = require("../util/identity");
var _noop = require("../util/noop");
var _args = require("../util/args");
function withLatestFrom() {
    var inputs = [];
    for(var _i = 0; _i < arguments.length; _i++)inputs[_i] = arguments[_i];
    var project = (0, _args.popResultSelector)(inputs);
    return (0, _lift.operate)(function(source, subscriber) {
        var len = inputs.length;
        var otherValues = new Array(len);
        var hasValue = inputs.map(function() {
            return false;
        });
        var ready = false;
        var _loop_1 = function(i) {
            (0, _innerFrom.innerFrom)(inputs[i]).subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function(value) {
                otherValues[i] = value;
                if (!ready && !hasValue[i]) {
                    hasValue[i] = true;
                    (ready = hasValue.every((0, _identity.identity))) && (hasValue = null);
                }
            }, (0, _noop.noop)));
        };
        for(var i = 0; i < len; i++)_loop_1(i);
        source.subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function(value) {
            if (ready) {
                var values = (0, _tslib.__spreadArray)([
                    value
                ], (0, _tslib.__read)(otherValues));
                subscriber.next(project ? project.apply(void 0, (0, _tslib.__spreadArray)([], (0, _tslib.__read)(values))) : values);
            }
        }));
    });
}

},{"tslib":"3gscj","../util/lift":"3IZjp","./OperatorSubscriber":"hrKGc","../observable/innerFrom":"6l3RX","../util/identity":"d03yr","../util/noop":"f1sCb","../util/args":"ccsng","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"hN98m":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "zip", ()=>zip);
var _tslib = require("tslib");
var _zip = require("../observable/zip");
var _lift = require("../util/lift");
function zip() {
    var sources = [];
    for(var _i = 0; _i < arguments.length; _i++)sources[_i] = arguments[_i];
    return (0, _lift.operate)(function(source, subscriber) {
        (0, _zip.zip).apply(void 0, (0, _tslib.__spreadArray)([
            source
        ], (0, _tslib.__read)(sources))).subscribe(subscriber);
    });
}

},{"tslib":"3gscj","../observable/zip":"8sk2Y","../util/lift":"3IZjp","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"8sk2Y":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "zip", ()=>zip);
var _tslib = require("tslib");
var _observable = require("../Observable");
var _innerFrom = require("./innerFrom");
var _argsOrArgArray = require("../util/argsOrArgArray");
var _empty = require("./empty");
var _operatorSubscriber = require("../operators/OperatorSubscriber");
var _args = require("../util/args");
function zip() {
    var args = [];
    for(var _i = 0; _i < arguments.length; _i++)args[_i] = arguments[_i];
    var resultSelector = (0, _args.popResultSelector)(args);
    var sources = (0, _argsOrArgArray.argsOrArgArray)(args);
    return sources.length ? new (0, _observable.Observable)(function(subscriber) {
        var buffers = sources.map(function() {
            return [];
        });
        var completed = sources.map(function() {
            return false;
        });
        subscriber.add(function() {
            buffers = completed = null;
        });
        var _loop_1 = function(sourceIndex) {
            (0, _innerFrom.innerFrom)(sources[sourceIndex]).subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function(value) {
                buffers[sourceIndex].push(value);
                if (buffers.every(function(buffer) {
                    return buffer.length;
                })) {
                    var result = buffers.map(function(buffer) {
                        return buffer.shift();
                    });
                    subscriber.next(resultSelector ? resultSelector.apply(void 0, (0, _tslib.__spreadArray)([], (0, _tslib.__read)(result))) : result);
                    if (buffers.some(function(buffer, i) {
                        return !buffer.length && completed[i];
                    })) subscriber.complete();
                }
            }, function() {
                completed[sourceIndex] = true;
                !buffers[sourceIndex].length && subscriber.complete();
            }));
        };
        for(var sourceIndex = 0; !subscriber.closed && sourceIndex < sources.length; sourceIndex++)_loop_1(sourceIndex);
        return function() {
            buffers = completed = null;
        };
    }) : (0, _empty.EMPTY);
}

},{"tslib":"3gscj","../Observable":"fo3d5","./innerFrom":"6l3RX","../util/argsOrArgArray":"9KARg","./empty":"hZmJU","../operators/OperatorSubscriber":"hrKGc","../util/args":"ccsng","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"6o3EP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "zipAll", ()=>zipAll);
var _zip = require("../observable/zip");
var _joinAllInternals = require("./joinAllInternals");
function zipAll(project) {
    return (0, _joinAllInternals.joinAllInternals)((0, _zip.zip), project);
}

},{"../observable/zip":"8sk2Y","./joinAllInternals":"cDD5p","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"5OH3O":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "zipWith", ()=>zipWith);
var _tslib = require("tslib");
var _zip = require("./zip");
function zipWith() {
    var otherInputs = [];
    for(var _i = 0; _i < arguments.length; _i++)otherInputs[_i] = arguments[_i];
    return (0, _zip.zip).apply(void 0, (0, _tslib.__spreadArray)([], (0, _tslib.__read)(otherInputs)));
}

},{"tslib":"3gscj","./zip":"hN98m","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"5SuSv":[function(require,module,exports) {
/**
 * @module iblokz-snabbdom-helpers
 * @description Snabbdom virtual DOM helpers with hyperscript syntax sugar
 * @version 2.0.0
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "patch", ()=>patch);
parcelHelpers.export(exports, "patchStream", ()=>patchStream);
// Export h function and patch utilities
parcelHelpers.export(exports, "h", ()=>(0, _snabbdom.h));
parcelHelpers.export(exports, "a", ()=>a);
parcelHelpers.export(exports, "abbr", ()=>abbr);
parcelHelpers.export(exports, "address", ()=>address);
parcelHelpers.export(exports, "area", ()=>area);
parcelHelpers.export(exports, "article", ()=>article);
parcelHelpers.export(exports, "aside", ()=>aside);
parcelHelpers.export(exports, "audio", ()=>audio);
parcelHelpers.export(exports, "b", ()=>b);
parcelHelpers.export(exports, "base", ()=>base);
parcelHelpers.export(exports, "bdi", ()=>bdi);
parcelHelpers.export(exports, "bdo", ()=>bdo);
parcelHelpers.export(exports, "blockquote", ()=>blockquote);
parcelHelpers.export(exports, "body", ()=>body);
parcelHelpers.export(exports, "br", ()=>br);
parcelHelpers.export(exports, "button", ()=>button);
parcelHelpers.export(exports, "canvas", ()=>canvas);
parcelHelpers.export(exports, "caption", ()=>caption);
parcelHelpers.export(exports, "cite", ()=>cite);
parcelHelpers.export(exports, "code", ()=>code);
parcelHelpers.export(exports, "col", ()=>col);
parcelHelpers.export(exports, "colgroup", ()=>colgroup);
parcelHelpers.export(exports, "data", ()=>data);
parcelHelpers.export(exports, "datalist", ()=>datalist);
parcelHelpers.export(exports, "dd", ()=>dd);
parcelHelpers.export(exports, "del", ()=>del);
parcelHelpers.export(exports, "details", ()=>details);
parcelHelpers.export(exports, "dfn", ()=>dfn);
parcelHelpers.export(exports, "dialog", ()=>dialog);
parcelHelpers.export(exports, "div", ()=>div);
parcelHelpers.export(exports, "dl", ()=>dl);
parcelHelpers.export(exports, "dt", ()=>dt);
parcelHelpers.export(exports, "em", ()=>em);
parcelHelpers.export(exports, "embed", ()=>embed);
parcelHelpers.export(exports, "fieldset", ()=>fieldset);
parcelHelpers.export(exports, "figcaption", ()=>figcaption);
parcelHelpers.export(exports, "figure", ()=>figure);
parcelHelpers.export(exports, "footer", ()=>footer);
parcelHelpers.export(exports, "form", ()=>form);
parcelHelpers.export(exports, "h1", ()=>h1);
parcelHelpers.export(exports, "h2", ()=>h2);
parcelHelpers.export(exports, "h3", ()=>h3);
parcelHelpers.export(exports, "h4", ()=>h4);
parcelHelpers.export(exports, "h5", ()=>h5);
parcelHelpers.export(exports, "h6", ()=>h6);
parcelHelpers.export(exports, "head", ()=>head);
parcelHelpers.export(exports, "header", ()=>header);
parcelHelpers.export(exports, "hgroup", ()=>hgroup);
parcelHelpers.export(exports, "hr", ()=>hr);
parcelHelpers.export(exports, "html", ()=>html);
parcelHelpers.export(exports, "i", ()=>i);
parcelHelpers.export(exports, "iframe", ()=>iframe);
parcelHelpers.export(exports, "img", ()=>img);
parcelHelpers.export(exports, "input", ()=>input);
parcelHelpers.export(exports, "ins", ()=>ins);
parcelHelpers.export(exports, "kbd", ()=>kbd);
parcelHelpers.export(exports, "label", ()=>label);
parcelHelpers.export(exports, "legend", ()=>legend);
parcelHelpers.export(exports, "li", ()=>li);
parcelHelpers.export(exports, "link", ()=>link);
parcelHelpers.export(exports, "main", ()=>main);
parcelHelpers.export(exports, "map", ()=>map);
parcelHelpers.export(exports, "mark", ()=>mark);
parcelHelpers.export(exports, "menu", ()=>menu);
parcelHelpers.export(exports, "meta", ()=>meta);
parcelHelpers.export(exports, "meter", ()=>meter);
parcelHelpers.export(exports, "nav", ()=>nav);
parcelHelpers.export(exports, "noscript", ()=>noscript);
parcelHelpers.export(exports, "object", ()=>object);
parcelHelpers.export(exports, "ol", ()=>ol);
parcelHelpers.export(exports, "optgroup", ()=>optgroup);
parcelHelpers.export(exports, "option", ()=>option);
parcelHelpers.export(exports, "output", ()=>output);
parcelHelpers.export(exports, "p", ()=>p);
parcelHelpers.export(exports, "picture", ()=>picture);
parcelHelpers.export(exports, "pre", ()=>pre);
parcelHelpers.export(exports, "progress", ()=>progress);
parcelHelpers.export(exports, "q", ()=>q);
parcelHelpers.export(exports, "rp", ()=>rp);
parcelHelpers.export(exports, "rt", ()=>rt);
parcelHelpers.export(exports, "ruby", ()=>ruby);
parcelHelpers.export(exports, "s", ()=>s);
parcelHelpers.export(exports, "samp", ()=>samp);
parcelHelpers.export(exports, "script", ()=>script);
parcelHelpers.export(exports, "search", ()=>search);
parcelHelpers.export(exports, "section", ()=>section);
parcelHelpers.export(exports, "select", ()=>select);
parcelHelpers.export(exports, "slot", ()=>slot);
parcelHelpers.export(exports, "small", ()=>small);
parcelHelpers.export(exports, "source", ()=>source);
parcelHelpers.export(exports, "span", ()=>span);
parcelHelpers.export(exports, "strong", ()=>strong);
parcelHelpers.export(exports, "style", ()=>style);
parcelHelpers.export(exports, "sub", ()=>sub);
parcelHelpers.export(exports, "summary", ()=>summary);
parcelHelpers.export(exports, "sup", ()=>sup);
parcelHelpers.export(exports, "table", ()=>table);
parcelHelpers.export(exports, "tbody", ()=>tbody);
parcelHelpers.export(exports, "td", ()=>td);
parcelHelpers.export(exports, "template", ()=>template);
parcelHelpers.export(exports, "textarea", ()=>textarea);
parcelHelpers.export(exports, "tfoot", ()=>tfoot);
parcelHelpers.export(exports, "th", ()=>th);
parcelHelpers.export(exports, "thead", ()=>thead);
parcelHelpers.export(exports, "time", ()=>time);
parcelHelpers.export(exports, "title", ()=>title);
parcelHelpers.export(exports, "tr", ()=>tr);
parcelHelpers.export(exports, "track", ()=>track);
parcelHelpers.export(exports, "u", ()=>u);
parcelHelpers.export(exports, "ul", ()=>ul);
parcelHelpers.export(exports, "video", ()=>video);
parcelHelpers.export(exports, "wbr", ()=>wbr);
var _snabbdom = require("snabbdom");
var _operators = require("rxjs/operators");
var _htmlTags = require("html-tags");
var _htmlTagsDefault = parcelHelpers.interopDefault(_htmlTags);
var _attrsJs = require("./util/attrs.js");
const patch = (0, _snabbdom.init)([
    (0, _snabbdom.classModule),
    (0, _snabbdom.propsModule),
    (0, _snabbdom.attributesModule),
    (0, _snabbdom.styleModule),
    (0, _snabbdom.eventListenersModule // attaches event listeners
    )
]);
const patchStream = (stream, dom)=>{
    dom = typeof dom === "string" ? document.querySelector(dom) : dom;
    return stream.pipe((0, _operators.scan)((vnode, newVnode)=>patch(vnode, newVnode), dom)).subscribe();
};
/**
 * Generate hyperscript helper functions for all HTML tags
 */ const hyperHelpers = (0, _htmlTagsDefault.default).reduce((o, tag)=>{
    o[tag] = function() {
        return [
            Array.from(arguments)
        ].map(_attrsJs.process).map((args)=>// is the first argument a selector
            args[0] && typeof args[0] === "string" && args[0].match(/^(\.|#)[a-zA-Z\-_0-9]+/ig) ? [].concat(tag + args[0], args.slice(1)) : [
                tag
            ].concat(args)).map((args)=>(0, _snabbdom.h).apply(this, args)).pop();
    };
    return o;
}, {});
const { a, abbr, address, area, article, aside, audio, b, base, bdi, bdo, blockquote, body, br, button, canvas, caption, cite, code, col, colgroup, data, datalist, dd, del, details, dfn, dialog, div, dl, dt, em, embed, fieldset, figcaption, figure, footer, form, h1, h2, h3, h4, h5, h6, head, header, hgroup, hr, html, i, iframe, img, input, ins, kbd, label, legend, li, link, main, map, mark, menu, meta, meter, nav, noscript, object, ol, optgroup, option, output, p, picture, pre, progress, q, rp, rt, ruby, s, samp, script, search, section, select, slot, small, source, span, strong, style, sub, summary, sup, table, tbody, td, template, textarea, tfoot, th, thead, time, title, tr, track, u, ul, video, wbr } = hyperHelpers;

},{"snabbdom":"c0XMd","rxjs/operators":"1cs2r","html-tags":"8VrtO","./util/attrs.js":"RP9zE","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"c0XMd":[function(require,module,exports) {
// core
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "htmlDomApi", ()=>(0, _htmldomapiJs.htmlDomApi));
parcelHelpers.export(exports, "init", ()=>(0, _initJs.init));
parcelHelpers.export(exports, "thunk", ()=>(0, _thunkJs.thunk));
parcelHelpers.export(exports, "vnode", ()=>(0, _vnodeJs.vnode));
// helpers
parcelHelpers.export(exports, "attachTo", ()=>(0, _attachtoJs.attachTo));
parcelHelpers.export(exports, "array", ()=>(0, _isJs.array));
parcelHelpers.export(exports, "primitive", ()=>(0, _isJs.primitive));
parcelHelpers.export(exports, "toVNode", ()=>(0, _tovnodeJs.toVNode));
parcelHelpers.export(exports, "h", ()=>(0, _hJs.h));
parcelHelpers.export(exports, "fragment", ()=>(0, _hJs.fragment));
// modules
parcelHelpers.export(exports, "attributesModule", ()=>(0, _attributesJs.attributesModule));
parcelHelpers.export(exports, "classModule", ()=>(0, _classJs.classModule));
parcelHelpers.export(exports, "datasetModule", ()=>(0, _datasetJs.datasetModule));
parcelHelpers.export(exports, "eventListenersModule", ()=>(0, _eventlistenersJs.eventListenersModule));
parcelHelpers.export(exports, "propsModule", ()=>(0, _propsJs.propsModule));
parcelHelpers.export(exports, "styleModule", ()=>(0, _styleJs.styleModule));
// JSX
parcelHelpers.export(exports, "jsx", ()=>(0, _jsxJs.jsx));
parcelHelpers.export(exports, "Fragment", ()=>(0, _jsxJs.Fragment));
var _htmldomapiJs = require("./htmldomapi.js");
var _initJs = require("./init.js");
var _thunkJs = require("./thunk.js");
var _vnodeJs = require("./vnode.js");
var _attachtoJs = require("./helpers/attachto.js");
var _isJs = require("./is.js");
var _tovnodeJs = require("./tovnode.js");
var _hJs = require("./h.js");
// types
var _hooksJs = require("./hooks.js");
parcelHelpers.exportAll(_hooksJs, exports);
var _attributesJs = require("./modules/attributes.js");
var _classJs = require("./modules/class.js");
var _datasetJs = require("./modules/dataset.js");
var _eventlistenersJs = require("./modules/eventlisteners.js");
var _propsJs = require("./modules/props.js");
var _styleJs = require("./modules/style.js");
var _jsxJs = require("./jsx.js");

},{"./htmldomapi.js":false,"./init.js":"5bCMA","./thunk.js":false,"./vnode.js":false,"./helpers/attachto.js":false,"./is.js":false,"./tovnode.js":false,"./h.js":"4xy5O","./hooks.js":false,"./modules/attributes.js":"50DlE","./modules/class.js":"kpayU","./modules/dataset.js":false,"./modules/eventlisteners.js":"6v3w6","./modules/props.js":"cie0z","./modules/style.js":"hlRHx","./jsx.js":false,"@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"hohJx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "htmlDomApi", ()=>htmlDomApi);
function createElement(tagName, options) {
    return document.createElement(tagName, options);
}
function createElementNS(namespaceURI, qualifiedName, options) {
    return document.createElementNS(namespaceURI, qualifiedName, options);
}
function createDocumentFragment() {
    return parseFragment(document.createDocumentFragment());
}
function createTextNode(text) {
    return document.createTextNode(text);
}
function createComment(text) {
    return document.createComment(text);
}
function insertBefore(parentNode, newNode, referenceNode) {
    if (isDocumentFragment(parentNode)) {
        let node = parentNode;
        while(node && isDocumentFragment(node)){
            const fragment = parseFragment(node);
            node = fragment.parent;
        }
        parentNode = node !== null && node !== void 0 ? node : parentNode;
    }
    if (isDocumentFragment(newNode)) newNode = parseFragment(newNode, parentNode);
    if (referenceNode && isDocumentFragment(referenceNode)) referenceNode = parseFragment(referenceNode).firstChildNode;
    parentNode.insertBefore(newNode, referenceNode);
}
function removeChild(node, child) {
    node.removeChild(child);
}
function appendChild(node, child) {
    if (isDocumentFragment(child)) child = parseFragment(child, node);
    node.appendChild(child);
}
function parentNode(node) {
    if (isDocumentFragment(node)) {
        while(node && isDocumentFragment(node)){
            const fragment = parseFragment(node);
            node = fragment.parent;
        }
        return node !== null && node !== void 0 ? node : null;
    }
    return node.parentNode;
}
function nextSibling(node) {
    var _a;
    if (isDocumentFragment(node)) {
        const fragment = parseFragment(node);
        const parent = parentNode(fragment);
        if (parent && fragment.lastChildNode) {
            const children = Array.from(parent.childNodes);
            const index = children.indexOf(fragment.lastChildNode);
            return (_a = children[index + 1]) !== null && _a !== void 0 ? _a : null;
        }
        return null;
    }
    return node.nextSibling;
}
function tagName(elm) {
    return elm.tagName;
}
function setTextContent(node, text) {
    node.textContent = text;
}
function getTextContent(node) {
    return node.textContent;
}
function isElement(node) {
    return node.nodeType === 1;
}
function isText(node) {
    return node.nodeType === 3;
}
function isComment(node) {
    return node.nodeType === 8;
}
function isDocumentFragment(node) {
    return node.nodeType === 11;
}
function parseFragment(fragmentNode, parentNode) {
    var _a, _b, _c;
    const fragment = fragmentNode;
    (_a = fragment.parent) !== null && _a !== void 0 ? _a : fragment.parent = parentNode !== null && parentNode !== void 0 ? parentNode : null;
    (_b = fragment.firstChildNode) !== null && _b !== void 0 ? _b : fragment.firstChildNode = fragmentNode.firstChild;
    (_c = fragment.lastChildNode) !== null && _c !== void 0 ? _c : fragment.lastChildNode = fragmentNode.lastChild;
    return fragment;
}
const htmlDomApi = {
    createElement,
    createElementNS,
    createTextNode,
    createDocumentFragment,
    createComment,
    insertBefore,
    removeChild,
    appendChild,
    parentNode,
    nextSibling,
    tagName,
    setTextContent,
    getTextContent,
    isElement,
    isText,
    isComment,
    isDocumentFragment
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"5bCMA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "init", ()=>init);
var _vnodeJs = require("./vnode.js");
var _isJs = require("./is.js");
var _htmldomapiJs = require("./htmldomapi.js");
const emptyNode = (0, _vnodeJs.vnode)("", {}, [], undefined, undefined);
function sameVnode(vnode1, vnode2) {
    var _a, _b;
    const isSameKey = vnode1.key === vnode2.key;
    const isSameIs = ((_a = vnode1.data) === null || _a === void 0 ? void 0 : _a.is) === ((_b = vnode2.data) === null || _b === void 0 ? void 0 : _b.is);
    const isSameSel = vnode1.sel === vnode2.sel;
    const isSameTextOrFragment = !vnode1.sel && vnode1.sel === vnode2.sel ? typeof vnode1.text === typeof vnode2.text : true;
    return isSameSel && isSameKey && isSameIs && isSameTextOrFragment;
}
/**
 * @todo Remove this function when the document fragment is considered stable.
 */ function documentFragmentIsNotSupported() {
    throw new Error("The document fragment is not supported on this platform.");
}
function isElement(api, vnode) {
    return api.isElement(vnode);
}
function isDocumentFragment(api, vnode) {
    return api.isDocumentFragment(vnode);
}
function createKeyToOldIdx(children, beginIdx, endIdx) {
    var _a;
    const map = {};
    for(let i = beginIdx; i <= endIdx; ++i){
        const key = (_a = children[i]) === null || _a === void 0 ? void 0 : _a.key;
        if (key !== undefined) map[key] = i;
    }
    return map;
}
const hooks = [
    "create",
    "update",
    "remove",
    "destroy",
    "pre",
    "post"
];
function init(modules, domApi, options) {
    const cbs = {
        create: [],
        update: [],
        remove: [],
        destroy: [],
        pre: [],
        post: []
    };
    const api = domApi !== undefined ? domApi : (0, _htmldomapiJs.htmlDomApi);
    for (const hook of hooks)for (const module of modules){
        const currentHook = module[hook];
        if (currentHook !== undefined) cbs[hook].push(currentHook);
    }
    function emptyNodeAt(elm) {
        const id = elm.id ? "#" + elm.id : "";
        // elm.className doesn't return a string when elm is an SVG element inside a shadowRoot.
        // https://stackoverflow.com/questions/29454340/detecting-classname-of-svganimatedstring
        const classes = elm.getAttribute("class");
        const c = classes ? "." + classes.split(" ").join(".") : "";
        return (0, _vnodeJs.vnode)(api.tagName(elm).toLowerCase() + id + c, {}, [], undefined, elm);
    }
    function emptyDocumentFragmentAt(frag) {
        return (0, _vnodeJs.vnode)(undefined, {}, [], undefined, frag);
    }
    function createRmCb(childElm, listeners) {
        return function rmCb() {
            if (--listeners === 0) {
                const parent = api.parentNode(childElm);
                if (parent !== null) api.removeChild(parent, childElm);
            }
        };
    }
    function createElm(vnode, insertedVnodeQueue) {
        var _a, _b, _c, _d, _e;
        let i;
        const data = vnode.data;
        const hook = data === null || data === void 0 ? void 0 : data.hook;
        (_a = hook === null || hook === void 0 ? void 0 : hook.init) === null || _a === void 0 || _a.call(hook, vnode);
        const children = vnode.children;
        const sel = vnode.sel;
        if (sel === "!") {
            (_b = vnode.text) !== null && _b !== void 0 ? _b : vnode.text = "";
            vnode.elm = api.createComment(vnode.text);
        } else if (sel === "") // textNode has no selector
        vnode.elm = api.createTextNode(vnode.text);
        else if (sel !== undefined) {
            // Parse selector
            const hashIdx = sel.indexOf("#");
            const dotIdx = sel.indexOf(".", hashIdx);
            const hash = hashIdx > 0 ? hashIdx : sel.length;
            const dot = dotIdx > 0 ? dotIdx : sel.length;
            const tag = hashIdx !== -1 || dotIdx !== -1 ? sel.slice(0, Math.min(hash, dot)) : sel;
            const ns = data === null || data === void 0 ? void 0 : data.ns;
            const elm = ns === undefined ? api.createElement(tag, data) : api.createElementNS(ns, tag, data);
            vnode.elm = elm;
            if (hash < dot) elm.setAttribute("id", sel.slice(hash + 1, dot));
            if (dotIdx > 0) elm.setAttribute("class", sel.slice(dot + 1).replace(/\./g, " "));
            for(i = 0; i < cbs.create.length; ++i)cbs.create[i](emptyNode, vnode);
            if (_isJs.primitive(vnode.text) && (!_isJs.array(children) || children.length === 0)) // allow h1 and similar nodes to be created w/ text and empty child list
            api.appendChild(elm, api.createTextNode(vnode.text));
            if (_isJs.array(children)) for(i = 0; i < children.length; ++i){
                const ch = children[i];
                if (ch != null) api.appendChild(elm, createElm(ch, insertedVnodeQueue));
            }
            if (hook !== undefined) {
                (_c = hook.create) === null || _c === void 0 || _c.call(hook, emptyNode, vnode);
                if (hook.insert !== undefined) insertedVnodeQueue.push(vnode);
            }
        } else if (((_d = options === null || options === void 0 ? void 0 : options.experimental) === null || _d === void 0 ? void 0 : _d.fragments) && vnode.children) {
            vnode.elm = ((_e = api.createDocumentFragment) !== null && _e !== void 0 ? _e : documentFragmentIsNotSupported)();
            for(i = 0; i < cbs.create.length; ++i)cbs.create[i](emptyNode, vnode);
            for(i = 0; i < vnode.children.length; ++i){
                const ch = vnode.children[i];
                if (ch != null) api.appendChild(vnode.elm, createElm(ch, insertedVnodeQueue));
            }
        } else vnode.elm = api.createTextNode(vnode.text);
        return vnode.elm;
    }
    function addVnodes(parentElm, before, vnodes, startIdx, endIdx, insertedVnodeQueue) {
        for(; startIdx <= endIdx; ++startIdx){
            const ch = vnodes[startIdx];
            if (ch != null) api.insertBefore(parentElm, createElm(ch, insertedVnodeQueue), before);
        }
    }
    function invokeDestroyHook(vnode) {
        var _a, _b;
        const data = vnode.data;
        if (data !== undefined) {
            (_b = (_a = data === null || data === void 0 ? void 0 : data.hook) === null || _a === void 0 ? void 0 : _a.destroy) === null || _b === void 0 || _b.call(_a, vnode);
            for(let i = 0; i < cbs.destroy.length; ++i)cbs.destroy[i](vnode);
            if (vnode.children !== undefined) for(let j = 0; j < vnode.children.length; ++j){
                const child = vnode.children[j];
                if (child != null && typeof child !== "string") invokeDestroyHook(child);
            }
        }
    }
    function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
        var _a, _b;
        for(; startIdx <= endIdx; ++startIdx){
            let listeners;
            const ch = vnodes[startIdx];
            if (ch != null) {
                if (ch.sel !== undefined) {
                    invokeDestroyHook(ch);
                    listeners = cbs.remove.length + 1;
                    const rm = createRmCb(ch.elm, listeners);
                    for(let i = 0; i < cbs.remove.length; ++i)cbs.remove[i](ch, rm);
                    const removeHook = (_b = (_a = ch === null || ch === void 0 ? void 0 : ch.data) === null || _a === void 0 ? void 0 : _a.hook) === null || _b === void 0 ? void 0 : _b.remove;
                    if (removeHook !== undefined) removeHook(ch, rm);
                    else rm();
                } else if (ch.children) {
                    // Fragment node
                    invokeDestroyHook(ch);
                    removeVnodes(parentElm, ch.children, 0, ch.children.length - 1);
                } else // Text node
                api.removeChild(parentElm, ch.elm);
            }
        }
    }
    function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue) {
        let oldStartIdx = 0;
        let newStartIdx = 0;
        let oldEndIdx = oldCh.length - 1;
        let oldStartVnode = oldCh[0];
        let oldEndVnode = oldCh[oldEndIdx];
        let newEndIdx = newCh.length - 1;
        let newStartVnode = newCh[0];
        let newEndVnode = newCh[newEndIdx];
        let oldKeyToIdx;
        let idxInOld;
        let elmToMove;
        let before;
        while(oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx){
            if (oldStartVnode == null) oldStartVnode = oldCh[++oldStartIdx]; // Vnode might have been moved left
            else if (oldEndVnode == null) oldEndVnode = oldCh[--oldEndIdx];
            else if (newStartVnode == null) newStartVnode = newCh[++newStartIdx];
            else if (newEndVnode == null) newEndVnode = newCh[--newEndIdx];
            else if (sameVnode(oldStartVnode, newStartVnode)) {
                patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
                oldStartVnode = oldCh[++oldStartIdx];
                newStartVnode = newCh[++newStartIdx];
            } else if (sameVnode(oldEndVnode, newEndVnode)) {
                patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
                oldEndVnode = oldCh[--oldEndIdx];
                newEndVnode = newCh[--newEndIdx];
            } else if (sameVnode(oldStartVnode, newEndVnode)) {
                // Vnode moved right
                patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
                api.insertBefore(parentElm, oldStartVnode.elm, api.nextSibling(oldEndVnode.elm));
                oldStartVnode = oldCh[++oldStartIdx];
                newEndVnode = newCh[--newEndIdx];
            } else if (sameVnode(oldEndVnode, newStartVnode)) {
                // Vnode moved left
                patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
                api.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
                oldEndVnode = oldCh[--oldEndIdx];
                newStartVnode = newCh[++newStartIdx];
            } else {
                if (oldKeyToIdx === undefined) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
                idxInOld = oldKeyToIdx[newStartVnode.key];
                if (idxInOld === undefined) {
                    // `newStartVnode` is new, create and insert it in beginning
                    api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);
                    newStartVnode = newCh[++newStartIdx];
                } else if (oldKeyToIdx[newEndVnode.key] === undefined) {
                    // `newEndVnode` is new, create and insert it in the end
                    api.insertBefore(parentElm, createElm(newEndVnode, insertedVnodeQueue), api.nextSibling(oldEndVnode.elm));
                    newEndVnode = newCh[--newEndIdx];
                } else {
                    // Neither of the new endpoints are new vnodes, so we make progress by
                    // moving `newStartVnode` into position
                    elmToMove = oldCh[idxInOld];
                    if (elmToMove.sel !== newStartVnode.sel) api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);
                    else {
                        patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
                        oldCh[idxInOld] = undefined;
                        api.insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);
                    }
                    newStartVnode = newCh[++newStartIdx];
                }
            }
        }
        if (newStartIdx <= newEndIdx) {
            before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].elm;
            addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
        }
        if (oldStartIdx <= oldEndIdx) removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
    }
    function patchVnode(oldVnode, vnode, insertedVnodeQueue) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const hook = (_a = vnode.data) === null || _a === void 0 ? void 0 : _a.hook;
        (_b = hook === null || hook === void 0 ? void 0 : hook.prepatch) === null || _b === void 0 || _b.call(hook, oldVnode, vnode);
        const elm = vnode.elm = oldVnode.elm;
        if (oldVnode === vnode) return;
        if (vnode.data !== undefined || vnode.text !== undefined && vnode.text !== oldVnode.text) {
            (_c = vnode.data) !== null && _c !== void 0 ? _c : vnode.data = {};
            (_d = oldVnode.data) !== null && _d !== void 0 ? _d : oldVnode.data = {};
            for(let i = 0; i < cbs.update.length; ++i)cbs.update[i](oldVnode, vnode);
            (_g = (_f = (_e = vnode.data) === null || _e === void 0 ? void 0 : _e.hook) === null || _f === void 0 ? void 0 : _f.update) === null || _g === void 0 || _g.call(_f, oldVnode, vnode);
        }
        const oldCh = oldVnode.children;
        const ch = vnode.children;
        if (vnode.text === undefined) {
            if (oldCh !== undefined && ch !== undefined) {
                if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue);
            } else if (ch !== undefined) {
                if (oldVnode.text !== undefined) api.setTextContent(elm, "");
                addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
            } else if (oldCh !== undefined) removeVnodes(elm, oldCh, 0, oldCh.length - 1);
            else if (oldVnode.text !== undefined) api.setTextContent(elm, "");
        } else if (oldVnode.text !== vnode.text) {
            if (oldCh !== undefined) removeVnodes(elm, oldCh, 0, oldCh.length - 1);
            api.setTextContent(elm, vnode.text);
        }
        (_h = hook === null || hook === void 0 ? void 0 : hook.postpatch) === null || _h === void 0 || _h.call(hook, oldVnode, vnode);
    }
    return function patch(oldVnode, vnode) {
        let i, elm, parent;
        const insertedVnodeQueue = [];
        for(i = 0; i < cbs.pre.length; ++i)cbs.pre[i]();
        if (isElement(api, oldVnode)) oldVnode = emptyNodeAt(oldVnode);
        else if (isDocumentFragment(api, oldVnode)) oldVnode = emptyDocumentFragmentAt(oldVnode);
        if (sameVnode(oldVnode, vnode)) patchVnode(oldVnode, vnode, insertedVnodeQueue);
        else {
            elm = oldVnode.elm;
            parent = api.parentNode(elm);
            createElm(vnode, insertedVnodeQueue);
            if (parent !== null) {
                api.insertBefore(parent, vnode.elm, api.nextSibling(elm));
                removeVnodes(parent, [
                    oldVnode
                ], 0, 0);
            }
        }
        for(i = 0; i < insertedVnodeQueue.length; ++i)insertedVnodeQueue[i].data.hook.insert(insertedVnodeQueue[i]);
        for(i = 0; i < cbs.post.length; ++i)cbs.post[i]();
        return vnode;
    };
}

},{"./vnode.js":"4j6zh","./is.js":"8W8aV","./htmldomapi.js":"hohJx","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"4j6zh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "vnode", ()=>vnode);
function vnode(sel, data, children, text, elm) {
    const key = data === undefined ? undefined : data.key;
    return {
        sel,
        data,
        children,
        text,
        elm,
        key
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"8W8aV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "array", ()=>array);
parcelHelpers.export(exports, "primitive", ()=>primitive);
const array = Array.isArray;
function primitive(s) {
    return typeof s === "string" || typeof s === "number" || s instanceof String || s instanceof Number;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"4xy5O":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "addNS", ()=>addNS);
parcelHelpers.export(exports, "h", ()=>h);
/**
 * @experimental
 */ parcelHelpers.export(exports, "fragment", ()=>fragment);
var _vnodeJs = require("./vnode.js");
var _isJs = require("./is.js");
function addNS(data, children, sel) {
    data.ns = "http://www.w3.org/2000/svg";
    if (sel !== "foreignObject" && children !== undefined) for(let i = 0; i < children.length; ++i){
        const child = children[i];
        if (typeof child === "string") continue;
        const childData = child.data;
        if (childData !== undefined) addNS(childData, child.children, child.sel);
    }
}
function h(sel, b, c) {
    let data = {};
    let children;
    let text;
    let i;
    if (c !== undefined) {
        if (b !== null) data = b;
        if (_isJs.array(c)) children = c;
        else if (_isJs.primitive(c)) text = c.toString();
        else if (c && c.sel) children = [
            c
        ];
    } else if (b !== undefined && b !== null) {
        if (_isJs.array(b)) children = b;
        else if (_isJs.primitive(b)) text = b.toString();
        else if (b && b.sel) children = [
            b
        ];
        else data = b;
    }
    if (children !== undefined) {
        for(i = 0; i < children.length; ++i)if (_isJs.primitive(children[i])) children[i] = (0, _vnodeJs.vnode)(undefined, undefined, undefined, children[i], undefined);
    }
    if (sel.startsWith("svg") && (sel.length === 3 || sel[3] === "." || sel[3] === "#")) addNS(data, children, sel);
    return (0, _vnodeJs.vnode)(sel, data, children, text, undefined);
}
function fragment(children) {
    let c;
    let text;
    if (_isJs.array(children)) c = children;
    else if (_isJs.primitive(c)) text = children;
    else if (c && c.sel) c = [
        children
    ];
    if (c !== undefined) {
        for(let i = 0; i < c.length; ++i)if (_isJs.primitive(c[i])) c[i] = (0, _vnodeJs.vnode)(undefined, undefined, undefined, c[i], undefined);
    }
    return (0, _vnodeJs.vnode)(undefined, {}, c, text, undefined);
}

},{"./vnode.js":"4j6zh","./is.js":"8W8aV","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"50DlE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "attributesModule", ()=>attributesModule);
const xlinkNS = "http://www.w3.org/1999/xlink";
const xmlnsNS = "http://www.w3.org/2000/xmlns/";
const xmlNS = "http://www.w3.org/XML/1998/namespace";
const colonChar = 58;
const xChar = 120;
const mChar = 109;
function updateAttrs(oldVnode, vnode) {
    let key;
    const elm = vnode.elm;
    let oldAttrs = oldVnode.data.attrs;
    let attrs = vnode.data.attrs;
    if (!oldAttrs && !attrs) return;
    if (oldAttrs === attrs) return;
    oldAttrs = oldAttrs || {};
    attrs = attrs || {};
    // update modified attributes, add new attributes
    for(key in attrs){
        const cur = attrs[key];
        const old = oldAttrs[key];
        if (old !== cur) {
            if (cur === true) elm.setAttribute(key, "");
            else if (cur === false) elm.removeAttribute(key);
            else {
                if (key.charCodeAt(0) !== xChar) elm.setAttribute(key, cur);
                else if (key.charCodeAt(3) === colonChar) // Assume xml namespace
                elm.setAttributeNS(xmlNS, key, cur);
                else if (key.charCodeAt(5) === colonChar) // Assume 'xmlns' or 'xlink' namespace
                key.charCodeAt(1) === mChar ? elm.setAttributeNS(xmlnsNS, key, cur) : elm.setAttributeNS(xlinkNS, key, cur);
                else elm.setAttribute(key, cur);
            }
        }
    }
    // remove removed attributes
    // use `in` operator since the previous `for` iteration uses it (.i.e. add even attributes with undefined value)
    // the other option is to remove all attributes with value == undefined
    for(key in oldAttrs)if (!(key in attrs)) elm.removeAttribute(key);
}
const attributesModule = {
    create: updateAttrs,
    update: updateAttrs
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"kpayU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "classModule", ()=>classModule);
function updateClass(oldVnode, vnode) {
    let cur;
    let name;
    const elm = vnode.elm;
    let oldClass = oldVnode.data.class;
    let klass = vnode.data.class;
    if (!oldClass && !klass) return;
    if (oldClass === klass) return;
    oldClass = oldClass || {};
    klass = klass || {};
    for(name in oldClass)if (oldClass[name] && !Object.prototype.hasOwnProperty.call(klass, name)) // was `true` and now not provided
    elm.classList.remove(name);
    for(name in klass){
        cur = klass[name];
        if (cur !== oldClass[name]) elm.classList[cur ? "add" : "remove"](name);
    }
}
const classModule = {
    create: updateClass,
    update: updateClass
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"6v3w6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "eventListenersModule", ()=>eventListenersModule);
function invokeHandler(handler, vnode, event) {
    if (typeof handler === "function") // call function handler
    handler.call(vnode, event, vnode);
    else if (typeof handler === "object") // call multiple handlers
    for(let i = 0; i < handler.length; i++)invokeHandler(handler[i], vnode, event);
}
function handleEvent(event, vnode) {
    const name = event.type;
    const on = vnode.data.on;
    // call event handler(s) if exists
    if (on && on[name]) invokeHandler(on[name], vnode, event);
}
function createListener() {
    return function handler(event) {
        handleEvent(event, handler.vnode);
    };
}
function updateEventListeners(oldVnode, vnode) {
    const oldOn = oldVnode.data.on;
    const oldListener = oldVnode.listener;
    const oldElm = oldVnode.elm;
    const on = vnode && vnode.data.on;
    const elm = vnode && vnode.elm;
    let name;
    // optimization for reused immutable handlers
    if (oldOn === on) return;
    // remove existing listeners which no longer used
    if (oldOn && oldListener) {
        // if element changed or deleted we remove all existing listeners unconditionally
        if (!on) for(name in oldOn)// remove listener if element was changed or existing listeners removed
        oldElm.removeEventListener(name, oldListener, false);
        else {
            for(name in oldOn)// remove listener if existing listener removed
            if (!on[name]) oldElm.removeEventListener(name, oldListener, false);
        }
    }
    // add new listeners which has not already attached
    if (on) {
        // reuse existing listener or create new
        const listener = vnode.listener = oldVnode.listener || createListener();
        // update vnode for listener
        listener.vnode = vnode;
        // if element changed or added we add all needed listeners unconditionally
        if (!oldOn) for(name in on)// add listener if element was changed or new listeners added
        elm.addEventListener(name, listener, false);
        else {
            for(name in on)// add listener if new listener added
            if (!oldOn[name]) elm.addEventListener(name, listener, false);
        }
    }
}
const eventListenersModule = {
    create: updateEventListeners,
    update: updateEventListeners,
    destroy: updateEventListeners
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"cie0z":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "propsModule", ()=>propsModule);
function updateProps(oldVnode, vnode) {
    let key;
    let cur;
    let old;
    const elm = vnode.elm;
    let oldProps = oldVnode.data.props;
    let props = vnode.data.props;
    if (!oldProps && !props) return;
    if (oldProps === props) return;
    oldProps = oldProps || {};
    props = props || {};
    for(key in props){
        cur = props[key];
        old = oldProps[key];
        if (old !== cur && (key !== "value" || elm[key] !== cur)) elm[key] = cur;
    }
}
const propsModule = {
    create: updateProps,
    update: updateProps
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"hlRHx":[function(require,module,exports) {
// Binding `requestAnimationFrame` like this fixes a bug in IE/Edge. See #360 and #409.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "styleModule", ()=>styleModule);
const raf = typeof (window === null || window === void 0 ? void 0 : window.requestAnimationFrame) === "function" ? window.requestAnimationFrame.bind(window) : setTimeout;
const nextFrame = (fn)=>{
    raf(()=>{
        raf(fn);
    });
};
let reflowForced = false;
function setNextFrame(obj, prop, val) {
    nextFrame(()=>{
        obj[prop] = val;
    });
}
function updateStyle(oldVnode, vnode) {
    let cur;
    let name;
    const elm = vnode.elm;
    let oldStyle = oldVnode.data.style;
    let style = vnode.data.style;
    if (!oldStyle && !style) return;
    if (oldStyle === style) return;
    oldStyle = oldStyle || {};
    style = style || {};
    const oldHasDel = "delayed" in oldStyle;
    for(name in oldStyle)if (!(name in style)) {
        if (name[0] === "-" && name[1] === "-") elm.style.removeProperty(name);
        else elm.style[name] = "";
    }
    for(name in style){
        cur = style[name];
        if (name === "delayed" && style.delayed) for(const name2 in style.delayed){
            cur = style.delayed[name2];
            if (!oldHasDel || cur !== oldStyle.delayed[name2]) setNextFrame(elm.style, name2, cur);
        }
        else if (name !== "remove" && cur !== oldStyle[name]) {
            if (name[0] === "-" && name[1] === "-") elm.style.setProperty(name, cur);
            else elm.style[name] = cur;
        }
    }
}
function applyDestroyStyle(vnode) {
    let style;
    let name;
    const elm = vnode.elm;
    const s = vnode.data.style;
    if (!s || !(style = s.destroy)) return;
    for(name in style)elm.style[name] = style[name];
}
function applyRemoveStyle(vnode, rm) {
    const s = vnode.data.style;
    if (!s || !s.remove) {
        rm();
        return;
    }
    if (!reflowForced) {
        // eslint-disable-next-line @typescript-eslint/no-unused-expressions
        vnode.elm.offsetLeft;
        reflowForced = true;
    }
    let name;
    const elm = vnode.elm;
    let i = 0;
    const style = s.remove;
    let amount = 0;
    const applied = [];
    for(name in style){
        applied.push(name);
        elm.style[name] = style[name];
    }
    const compStyle = getComputedStyle(elm);
    const props = compStyle["transition-property"].split(", ");
    for(; i < props.length; ++i)if (applied.indexOf(props[i]) !== -1) amount++;
    elm.addEventListener("transitionend", (ev)=>{
        if (ev.target === elm) --amount;
        if (amount === 0) rm();
    });
}
function forceReflow() {
    reflowForced = false;
}
const styleModule = {
    pre: forceReflow,
    create: updateStyle,
    update: updateStyle,
    destroy: applyDestroyStyle,
    remove: applyRemoveStyle
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"8VrtO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>(0, _htmlTagsJsonDefault.default));
parcelHelpers.export(exports, "voidHtmlTags", ()=>(0, _htmlTagsVoidJsonDefault.default));
var _htmlTagsJson = require("./html-tags.json");
var _htmlTagsJsonDefault = parcelHelpers.interopDefault(_htmlTagsJson);
var _htmlTagsVoidJson = require("./html-tags-void.json");
var _htmlTagsVoidJsonDefault = parcelHelpers.interopDefault(_htmlTagsVoidJson);

},{"./html-tags.json":"kk0yb","./html-tags-void.json":false,"@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"kk0yb":[function(require,module,exports) {
module.exports = JSON.parse('["a","abbr","address","area","article","aside","audio","b","base","bdi","bdo","blockquote","body","br","button","canvas","caption","cite","code","col","colgroup","data","datalist","dd","del","details","dfn","dialog","div","dl","dt","em","embed","fieldset","figcaption","figure","footer","form","h1","h2","h3","h4","h5","h6","head","header","hgroup","hr","html","i","iframe","img","input","ins","kbd","label","legend","li","link","main","map","mark","math","menu","meta","meter","nav","noscript","object","ol","optgroup","option","output","p","picture","pre","progress","q","rp","rt","ruby","s","samp","script","search","section","select","selectedcontent","slot","small","source","span","strong","style","sub","summary","sup","svg","table","tbody","td","template","textarea","tfoot","th","thead","time","title","tr","track","u","ul","var","video","wbr"]');

},{}],"RP9zE":[function(require,module,exports) {
/**
 * Attribute utilities for snabbdom helpers
 * @module util/attrs
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "strParse", ()=>strParse);
parcelHelpers.export(exports, "process", ()=>process);
var _iblokzData = require("iblokz-data");
/**
 * Parse string values to appropriate types
 * @param {string} s - String to parse
 * @return {number|boolean|string} Parsed value
 */ const strParse = (s)=>s.match(/^[0-9]+$/) ? parseInt(s, 10) : s.match(/^[0-9.]+$/) ? parseFloat(s) : s === "true" ? true : s === "false" ? false : s;
/**
 * Process hyperscript arguments with attribute selector support
 * @param {Array} args - Arguments to process
 * @return {Array} Processed arguments
 * @example
 * process(['[name="john"]']) // => [{attrs: {name: 'john'}}]
 */ const process = (args)=>{
    let newArgs = args.slice();
    let selector = newArgs[0] && typeof newArgs[0] === "string" && newArgs[0] || "";
    if (selector !== "") newArgs = newArgs.slice(1);
    const attrRegExp = /\[[a-z\-0-9]+=("[^"]+"|'[^']+'|[0-9.]+|true|false|[^\]^=^"^']+)\]/ig;
    let attrs = selector && selector.match(attrRegExp);
    selector = selector.replace(attrRegExp, "");
    attrs = attrs && attrs.map && attrs.map((c)=>c.replace(/[[\]("|')]/g, "").split("=")).reduce((o, attr)=>(0, _iblokzData.obj).patch(o, attr[0], strParse(attr[1])), {}) || {};
    if (attrs && Object.keys(attrs).length > 0) {
        if (!newArgs[0] || newArgs[0] && typeof newArgs[0] === "object" && !(newArgs[0] instanceof Array)) {
            attrs = Object.assign({}, newArgs[0] && newArgs[0].attrs || {}, attrs);
            newArgs[0] = Object.assign({}, newArgs[0] || {}, {
                attrs
            });
        } else newArgs = [
            {
                attrs
            }
        ].concat(newArgs);
    }
    if (selector !== "") newArgs = [
        selector
    ].concat(newArgs);
    return newArgs;
};

},{"iblokz-data":"2lXuw","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"2lXuw":[function(require,module,exports) {
/**
 * @module iblokz-data
 * @description Immutable data manipulation utilities for JavaScript
 * @version 1.5.0
 */ /**
 * Object utilities for immutable operations
 * @type {Object}
 */ const obj = require("9d028e555516c9b5");
/**
 * Array utilities for immutable operations
 * @type {Object}
 */ const arr = require("2e80c6e901a3a799");
/**
 * String manipulation utilities
 * @type {Object}
 */ const str = require("251226eaf295ab8d");
/**
 * Function composition utilities
 * @type {Object}
 */ const fn = require("6c0e10d310582782");
module.exports = {
    obj,
    arr,
    str,
    fn
};

},{"9d028e555516c9b5":"82fEt","2e80c6e901a3a799":"6aCjb","251226eaf295ab8d":"4YcZp","6c0e10d310582782":"faTHh"}],"82fEt":[function(require,module,exports) {
"use strict";
/**
 * Creates an object with a single key-value pair.
 * @param {string} k - The key
 * @param {*} v - The value
 * @returns {Object} An object with the single key-value pair
 * @example
 * keyValue('name', 'John') // => { name: 'John' }
 */ const keyValue = (k, v)=>({
        [k]: v
    });
/**
 * Checks if a value is a plain object literal (not an array, null, or other object type).
 * @param {*} o - The value to check
 * @returns {boolean} True if the value is a plain object literal
 * @example
 * isLiteral({}) // => true
 * isLiteral([]) // => false
 * isLiteral(null) // => false
 */ const isLiteral = (o)=>typeof o === "object" && o !== null && o.constructor === Object;
/**
 * Creates a shallow clone of an object, preserving its prototype.
 * @param {Object} o - The object to clone
 * @returns {Object} A shallow clone of the object
 * @example
 * const obj = { a: 1, b: 2 };
 * const cloned = clone(obj);
 * cloned.a = 3;
 * console.log(obj.a) // => 1 (original unchanged)
 */ const clone = (o)=>Object.assign(Object.create(Object.getPrototypeOf(o) || {}), o);
/**
 * Gets a nested value from an object using a path.
 * @param {Object} o - The source object
 * @param {string|Array<string>} p - The path (string key or array of keys for nested access)
 * @returns {*} The value at the path, or undefined if not found
 * @example
 * sub({ a: { b: { c: 1 } } }, ['a', 'b', 'c']) // => 1
 * sub({ a: 1 }, 'a') // => 1
 * sub({ a: 1 }, 'b') // => undefined
 */ const sub = (o, p)=>o === undefined || o === null ? undefined : p instanceof Array ? p.length > 1 ? sub(o[p[0]], p.slice(1)) : o[p[0]] : o[p];
/**
 * Immutably updates a value in an object at a given path.
 * For nested paths, creates intermediate objects as needed.
 * If the value at the path is a literal object and v is also a literal object, they are merged.
 * @param {Object} o - The source object
 * @param {string|Array<string>} k - The path (string key or array of keys for nested updates)
 * @param {*} v - The value to set
 * @returns {Object} A new object with the value updated at the path
 * @example
 * patch({ a: 1 }, 'b', 2) // => { a: 1, b: 2 }
 * patch({ a: { b: 1 } }, ['a', 'c'], 2) // => { a: { b: 1, c: 2 } }
 * patch({ a: { b: 1 } }, 'a', { c: 2 }) // => { a: { b: 1, c: 2 } } (merged)
 */ const patch = (o, k, v)=>Object.assign(clone(o), k instanceof Array ? keyValue(k[0], k.length > 1 ? patch(o[k[0]] || {}, k.slice(1), v) : isLiteral(o[k[0]]) && Object.assign(clone(o[k[0]]), v) || v) : keyValue(k, isLiteral(o[k]) && Object.assign(clone(o[k]), v) || v));
/**
 * Reduces an object to a single value by iterating over its keys.
 * Similar to Array.reduce, but for objects.
 * @param {Object} o - The object to reduce
 * @param {Function} reduceFn - The reducer function (accumulator, key, value, index, originalObject) => newAccumulator
 * @param {*} [initial] - The initial accumulator value (defaults to first property value)
 * @returns {*} The final accumulated value
 * @example
 * reduce({ a: 1, b: 2, c: 3 }, (sum, key, val) => sum + val, 0) // => 6
 */ const reduce = (o, reduceFn, initial)=>Object.keys(o).reduce((accumulator, key, index)=>reduceFn(accumulator, key, o[key], index, o), typeof initial === "undefined" ? o[Object.keys(o)[0]] // to confirm with the array reduce spec in this case the firts property is used
     : initial);
/**
 * Immutably maps over an object's values.
 * @param {Object} o - The source object
 * @param {Function} mapFn - The mapping function (key, value, index, originalObject) => newValue
 * @returns {Object} A new object with mapped values
 * @example
 * map({ a: 1, b: 2 }, (k, v) => v * 2) // => { a: 2, b: 4 }
 */ const map = (o, mapFn)=>reduce(o, (o2, key, value, index)=>patch(o2, key, mapFn(key, value, index, o)), {});
/**
 * Immutably filters an object's properties based on a predicate.
 * @param {Object} o - The source object
 * @param {Function} filterFn - The filter predicate (key, value, index, originalObject) => boolean
 * @returns {Object} A new object with only properties that pass the predicate
 * @example
 * filter({ a: 1, b: 2, c: 3 }, (k, v) => v > 1) // => { b: 2, c: 3 }
 */ const filter = (o, filterFn)=>reduce(o, (o2, key, value, index)=>filterFn(key, value, index, o) ? patch(o2, key, value) : o2, {});
/**
 * Recursively traverses an object tree and applies a function to leaf values.
 * Non-literal values (primitives, arrays, etc.) are transformed by the function.
 * @param {Object} tree - The object tree to traverse
 * @param {Function} fn - The function to apply to leaf values (key, value, index, parent) => newValue
 * @returns {Object} A new object tree with transformed leaf values
 * @example
 * traverse({ a: { b: 1 }, c: 2 }, (k, v) => v * 2) // => { a: { b: 2 }, c: 4 }
 */ const traverse = (tree, fn)=>Object.keys(tree).reduce((o, key, index)=>patch(o, key, isLiteral(tree[key]) ? traverse(tree[key], fn) : fn(key, tree[key], index, tree)), {});
/**
 * Chains multiple method calls on an object.
 * @param {Object} o - The object to call methods on
 * @param {Array<Array>} chain - Array of [methodName, ...args] tuples
 * @returns {*} The result of the final method call
 * @example
 * chainCall([1, 2, 3], [['map', x => x * 2], ['filter', x => x > 2]]) // => [4, 6]
 */ const chainCall = (o, chain)=>chain.reduce((o, [prop, ...args])=>o[prop](...args), o);
/**
 * Pattern matching utility that returns a value based on matching a value to cases.
 * Supports nested array paths for partial matching and a 'default' case.
 * @param {*} value - The value to match (can be a string, array path, etc.)
 * @param {Object} cases - Object with cases to match against (supports 'default' key)
 * @returns {*} The matched case value, or false if no match
 * @example
 * _switch('a', { a: 1, b: 2, default: 0 }) // => 1
 * _switch('c', { a: 1, b: 2, default: 0 }) // => 0
 * _switch(['a', 'b'], { a: { b: 1 } }) // => 1
 */ const _switch = (value, cases)=>sub(cases, value) && sub(cases, value)["default"] || sub(cases, value) || value instanceof Array && value.length > 1 && _switch(value.slice(0, value.length - 1), cases) || cases["default"] || false;
module.exports = {
    keyValue,
    isLiteral,
    clone,
    sub,
    patch,
    reduce,
    map,
    filter,
    traverse,
    chainCall,
    switch: _switch
};

},{}],"6aCjb":[function(require,module,exports) {
"use strict";
/**
 * Immutably adds an item to an array (returns a new array).
 * @param {Array} arr - The source array
 * @param {*} item - The item to add
 * @returns {Array} A new array with the item added at the end
 * @example
 * add([1, 2, 3], 4) // => [1, 2, 3, 4]
 */ const add = (arr, item)=>[].concat(arr, [
        item
    ]);
/**
 * Immutably removes the first occurrence of an item from an array.
 * If the item is not found, returns the original array.
 * @param {Array} arr - The source array
 * @param {*} item - The item to remove
 * @returns {Array} A new array with the item removed, or the original array if not found
 * @example
 * remove([1, 2, 3, 2], 2) // => [1, 3, 2]
 * remove([1, 2, 3], 4) // => [1, 2, 3]
 */ const remove = (arr, item)=>arr.indexOf(item) > -1 ? [].concat(arr.slice(0, arr.indexOf(item)), arr.slice(arr.indexOf(item) + 1)) : arr;
/**
 * Immutably toggles an item in an array (adds if not present, removes if present).
 * @param {Array} arr - The source array
 * @param {*} item - The item to toggle
 * @returns {Array} A new array with the item toggled
 * @example
 * toggle([1, 2, 3], 2) // => [1, 3]
 * toggle([1, 2, 3], 4) // => [1, 2, 3, 4]
 */ const toggle = (arr, item)=>arr.indexOf(item) > -1 ? remove(arr, item) : add(arr, item);
/**
 * Checks if an array or comma-separated string contains an element.
 * @param {Array|string} a - The array or comma-separated string to check
 * @param {*} el - The element to look for
 * @returns {boolean} True if the element is found, false otherwise
 * @example
 * contains([1, 2, 3], 2) // => true
 * contains('a,b,c', 'b') // => true
 * contains([1, 2, 3], 4) // => false
 */ const contains = (a, el)=>[].concat(typeof a === "string" && a.split(",") || a instanceof Array && a || []).indexOf(el) > -1;
module.exports = {
    add,
    remove,
    toggle,
    contains
};

},{}],"4YcZp":[function(require,module,exports) {
"use strict";
/**
 * Capitalizes the first character of a string.
 * @param {string} chunk - The string to capitalize
 * @returns {string} The capitalized string
 * @example
 * capitalize('hello') // => 'Hello'
 */ const capitalize = (chunk)=>chunk.charAt(0).toUpperCase() + chunk.slice(1);
/**
 * Converts a string to camelCase from a delimited format.
 * @param {string} str - The string to convert
 * @param {string} [glue='_'] - The delimiter to split on
 * @returns {string} The camelCase string
 * @example
 * toCamelCase('hello_world') // => 'helloWorld'
 * toCamelCase('hello-world', '-') // => 'helloWorld'
 */ const toCamelCase = (str, glue = "_")=>str.split(glue).map((chunk, i)=>i === 0 ? chunk : capitalize(chunk)).join("");
/**
 * Converts a camelCase string to a delimited format.
 * @param {string} str - The camelCase string to convert
 * @param {string} [glue='_'] - The delimiter to use
 * @returns {string} The delimited string in lowercase
 * @example
 * fromCamelCase('helloWorld') // => 'hello_world'
 * fromCamelCase('helloWorld', '-') // => 'hello-world'
 */ const fromCamelCase = (str, glue = "_")=>str.replace(/([A-Z])/g, " $1").split(" ").map((chunk)=>chunk.toLowerCase()).join(glue);
/**
 * Converts a singular word to its plural form (basic English rules).
 * @param {string} str - The singular word
 * @returns {string} The plural form
 * @example
 * singularToPlural('category') // => 'categories'
 * singularToPlural('user') // => 'users'
 */ const singularToPlural = (str)=>str.replace(/y$/, "ie").concat("s");
/**
 * Converts a plural word to its singular form (basic English rules).
 * @param {string} str - The plural word
 * @returns {string} The singular form
 * @example
 * pluralToSingular('categories') // => 'category'
 * pluralToSingular('users') // => 'user'
 */ const pluralToSingular = (str)=>str.replace(/ies$/, "y").replace(/s$/, "");
/**
 * Converts a string to a document ID format (typically used for database foreign keys).
 * @param {string} str - The string to convert
 * @param {string} [glue='_'] - The delimiter in the input string
 * @param {string} [suffix='Id'] - The suffix to append
 * @param {string} [prefix=''] - The prefix to prepend
 * @returns {string} The document ID string
 * @example
 * toDocumentId('user_roles') // => 'userRoleId'
 * toDocumentId('categories', '_', 'ID', 'ref') // => 'refCategoryID'
 */ const toDocumentId = (str, glue = "_", suffix = "Id", prefix = "")=>prefix.concat(pluralToSingular(toCamelCase(str, glue)), suffix);
module.exports = {
    capitalize,
    toCamelCase,
    fromCamelCase,
    singularToPlural,
    pluralToSingular,
    toDocumentId
};

},{}],"faTHh":[function(require,module,exports) {
"use strict";
const obj = require("6196cf6f240c7377");
/**
 * Creates a left-to-right function composition pipeline.
 * The first function can accept multiple arguments; the remaining functions must be unary.
 * @param {Function} a - The first function in the pipeline (can accept multiple arguments)
 * @param {...Function} fns - The remaining functions to pipe through (each takes one argument)
 * @returns {Function} A function that passes the result through each function from left to right
 * @example
 * const addOne = x => x + 1;
 * const double = x => x * 2;
 * const addOneThenDouble = pipe(addOne, double);
 * addOneThenDouble(3) // => 8 (3 + 1 = 4, 4 * 2 = 8)
 */ const pipe = (a, ...fns)=>(...args)=>fns.reduce((res, fn)=>fn(res), a(...args));
/**
 * Creates a right-to-left function composition.
 * The rightmost function can accept multiple arguments; the remaining functions must be unary.
 * @param {...Function} fns - Functions to compose (executed right to left)
 * @returns {Function} A function that passes the result through each function from right to left
 * @example
 * const addOne = x => x + 1;
 * const double = x => x * 2;
 * const doubleThenAddOne = compose(addOne, double);
 * doubleThenAddOne(3) // => 7 (3 * 2 = 6, 6 + 1 = 7)
 */ const compose = (...fns)=>pipe(fns.slice(-1).pop(), ...fns.reverse().slice(1));
// switch for backwards compatibility
module.exports = {
    compose,
    pipe,
    switch: obj.switch
};

},{"6196cf6f240c7377":"82fEt"}],"deOrm":[function(require,module,exports) {
/**
 * @module iblokz-state
 * @description Lightweight state management utilities for JavaScript
 * @version 1.0.1
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "dispatch", ()=>(0, _coreJs.dispatch));
parcelHelpers.export(exports, "collect", ()=>(0, _coreJs.collect));
parcelHelpers.export(exports, "init", ()=>(0, _coreJs.init));
parcelHelpers.export(exports, "storage", ()=>_storageJs);
parcelHelpers.export(exports, "adapt", ()=>(0, _adaptJs.adapt));
parcelHelpers.export(exports, "attach", ()=>(0, _adaptJs.attach));
parcelHelpers.export(exports, "createState", ()=>(0, _adaptJs.createState));
var _coreJs = require("./lib/core.js");
var _storageJs = require("./lib/storage.js");
var _adaptJs = require("./lib/adapt.js");

},{"./lib/core.js":"eNXlu","./lib/storage.js":"epvLh","./lib/adapt.js":"cGtnI","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"eNXlu":[function(require,module,exports) {
/**
 * State Machine
 * @module core
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "dispatch", ()=>dispatch);
parcelHelpers.export(exports, "collect", ()=>collect);
parcelHelpers.export(exports, "init", ()=>init);
var _rxjs = require("rxjs");
var _storageJs = require("./storage.js");
const dispatch = (change, namespace = "state.changes")=>document.dispatchEvent(new CustomEvent(namespace, {
        detail: change
    }));
const collect = (namespace = "state.changes")=>(0, _rxjs.fromEvent)(document, namespace).pipe((0, _rxjs.map)((ev)=>ev.detail));
const init = (initial = {}, namespace = "state.changes", storage = null)=>{
    const storageInstance = (0, _storageJs.init)(storage);
    const initialState = storageInstance ? storageInstance.get(namespace, initial) : initial;
    const state$ = new (0, _rxjs.BehaviorSubject)(initialState);
    storageInstance && state$.subscribe((state)=>{
        storageInstance.set(namespace, state);
    });
    collect(namespace).pipe((0, _rxjs.startWith)(()=>initialState), (0, _rxjs.scan)((state, change)=>change(state), {})).subscribe(state$);
    return state$;
};

},{"rxjs":"hWUVi","./storage.js":"epvLh","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"hWUVi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Observable", ()=>(0, _observable.Observable));
parcelHelpers.export(exports, "ConnectableObservable", ()=>(0, _connectableObservable.ConnectableObservable));
parcelHelpers.export(exports, "observable", ()=>(0, _observable1.observable));
parcelHelpers.export(exports, "animationFrames", ()=>(0, _animationFrames.animationFrames));
parcelHelpers.export(exports, "Subject", ()=>(0, _subject.Subject));
parcelHelpers.export(exports, "BehaviorSubject", ()=>(0, _behaviorSubject.BehaviorSubject));
parcelHelpers.export(exports, "ReplaySubject", ()=>(0, _replaySubject.ReplaySubject));
parcelHelpers.export(exports, "AsyncSubject", ()=>(0, _asyncSubject.AsyncSubject));
parcelHelpers.export(exports, "asap", ()=>(0, _asap.asap));
parcelHelpers.export(exports, "asapScheduler", ()=>(0, _asap.asapScheduler));
parcelHelpers.export(exports, "async", ()=>(0, _async.async));
parcelHelpers.export(exports, "asyncScheduler", ()=>(0, _async.asyncScheduler));
parcelHelpers.export(exports, "queue", ()=>(0, _queue.queue));
parcelHelpers.export(exports, "queueScheduler", ()=>(0, _queue.queueScheduler));
parcelHelpers.export(exports, "animationFrame", ()=>(0, _animationFrame.animationFrame));
parcelHelpers.export(exports, "animationFrameScheduler", ()=>(0, _animationFrame.animationFrameScheduler));
parcelHelpers.export(exports, "VirtualTimeScheduler", ()=>(0, _virtualTimeScheduler.VirtualTimeScheduler));
parcelHelpers.export(exports, "VirtualAction", ()=>(0, _virtualTimeScheduler.VirtualAction));
parcelHelpers.export(exports, "Scheduler", ()=>(0, _scheduler.Scheduler));
parcelHelpers.export(exports, "Subscription", ()=>(0, _subscription.Subscription));
parcelHelpers.export(exports, "Subscriber", ()=>(0, _subscriber.Subscriber));
parcelHelpers.export(exports, "Notification", ()=>(0, _notification.Notification));
parcelHelpers.export(exports, "NotificationKind", ()=>(0, _notification.NotificationKind));
parcelHelpers.export(exports, "pipe", ()=>(0, _pipe.pipe));
parcelHelpers.export(exports, "noop", ()=>(0, _noop.noop));
parcelHelpers.export(exports, "identity", ()=>(0, _identity.identity));
parcelHelpers.export(exports, "isObservable", ()=>(0, _isObservable.isObservable));
parcelHelpers.export(exports, "lastValueFrom", ()=>(0, _lastValueFrom.lastValueFrom));
parcelHelpers.export(exports, "firstValueFrom", ()=>(0, _firstValueFrom.firstValueFrom));
parcelHelpers.export(exports, "ArgumentOutOfRangeError", ()=>(0, _argumentOutOfRangeError.ArgumentOutOfRangeError));
parcelHelpers.export(exports, "EmptyError", ()=>(0, _emptyError.EmptyError));
parcelHelpers.export(exports, "NotFoundError", ()=>(0, _notFoundError.NotFoundError));
parcelHelpers.export(exports, "ObjectUnsubscribedError", ()=>(0, _objectUnsubscribedError.ObjectUnsubscribedError));
parcelHelpers.export(exports, "SequenceError", ()=>(0, _sequenceError.SequenceError));
parcelHelpers.export(exports, "TimeoutError", ()=>(0, _timeout.TimeoutError));
parcelHelpers.export(exports, "UnsubscriptionError", ()=>(0, _unsubscriptionError.UnsubscriptionError));
parcelHelpers.export(exports, "bindCallback", ()=>(0, _bindCallback.bindCallback));
parcelHelpers.export(exports, "bindNodeCallback", ()=>(0, _bindNodeCallback.bindNodeCallback));
parcelHelpers.export(exports, "combineLatest", ()=>(0, _combineLatest.combineLatest));
parcelHelpers.export(exports, "concat", ()=>(0, _concat.concat));
parcelHelpers.export(exports, "connectable", ()=>(0, _connectable.connectable));
parcelHelpers.export(exports, "defer", ()=>(0, _defer.defer));
parcelHelpers.export(exports, "empty", ()=>(0, _empty.empty));
parcelHelpers.export(exports, "forkJoin", ()=>(0, _forkJoin.forkJoin));
parcelHelpers.export(exports, "from", ()=>(0, _from.from));
parcelHelpers.export(exports, "fromEvent", ()=>(0, _fromEvent.fromEvent));
parcelHelpers.export(exports, "fromEventPattern", ()=>(0, _fromEventPattern.fromEventPattern));
parcelHelpers.export(exports, "generate", ()=>(0, _generate.generate));
parcelHelpers.export(exports, "iif", ()=>(0, _iif.iif));
parcelHelpers.export(exports, "interval", ()=>(0, _interval.interval));
parcelHelpers.export(exports, "merge", ()=>(0, _merge.merge));
parcelHelpers.export(exports, "never", ()=>(0, _never.never));
parcelHelpers.export(exports, "of", ()=>(0, _of.of));
parcelHelpers.export(exports, "onErrorResumeNext", ()=>(0, _onErrorResumeNext.onErrorResumeNext));
parcelHelpers.export(exports, "pairs", ()=>(0, _pairs.pairs));
parcelHelpers.export(exports, "partition", ()=>(0, _partition.partition));
parcelHelpers.export(exports, "race", ()=>(0, _race.race));
parcelHelpers.export(exports, "range", ()=>(0, _range.range));
parcelHelpers.export(exports, "throwError", ()=>(0, _throwError.throwError));
parcelHelpers.export(exports, "timer", ()=>(0, _timer.timer));
parcelHelpers.export(exports, "using", ()=>(0, _using.using));
parcelHelpers.export(exports, "zip", ()=>(0, _zip.zip));
parcelHelpers.export(exports, "scheduled", ()=>(0, _scheduled.scheduled));
parcelHelpers.export(exports, "EMPTY", ()=>(0, _empty.EMPTY));
parcelHelpers.export(exports, "NEVER", ()=>(0, _never.NEVER));
parcelHelpers.export(exports, "config", ()=>(0, _config.config));
parcelHelpers.export(exports, "audit", ()=>(0, _audit.audit));
parcelHelpers.export(exports, "auditTime", ()=>(0, _auditTime.auditTime));
parcelHelpers.export(exports, "buffer", ()=>(0, _buffer.buffer));
parcelHelpers.export(exports, "bufferCount", ()=>(0, _bufferCount.bufferCount));
parcelHelpers.export(exports, "bufferTime", ()=>(0, _bufferTime.bufferTime));
parcelHelpers.export(exports, "bufferToggle", ()=>(0, _bufferToggle.bufferToggle));
parcelHelpers.export(exports, "bufferWhen", ()=>(0, _bufferWhen.bufferWhen));
parcelHelpers.export(exports, "catchError", ()=>(0, _catchError.catchError));
parcelHelpers.export(exports, "combineAll", ()=>(0, _combineAll.combineAll));
parcelHelpers.export(exports, "combineLatestAll", ()=>(0, _combineLatestAll.combineLatestAll));
parcelHelpers.export(exports, "combineLatestWith", ()=>(0, _combineLatestWith.combineLatestWith));
parcelHelpers.export(exports, "concatAll", ()=>(0, _concatAll.concatAll));
parcelHelpers.export(exports, "concatMap", ()=>(0, _concatMap.concatMap));
parcelHelpers.export(exports, "concatMapTo", ()=>(0, _concatMapTo.concatMapTo));
parcelHelpers.export(exports, "concatWith", ()=>(0, _concatWith.concatWith));
parcelHelpers.export(exports, "connect", ()=>(0, _connect.connect));
parcelHelpers.export(exports, "count", ()=>(0, _count.count));
parcelHelpers.export(exports, "debounce", ()=>(0, _debounce.debounce));
parcelHelpers.export(exports, "debounceTime", ()=>(0, _debounceTime.debounceTime));
parcelHelpers.export(exports, "defaultIfEmpty", ()=>(0, _defaultIfEmpty.defaultIfEmpty));
parcelHelpers.export(exports, "delay", ()=>(0, _delay.delay));
parcelHelpers.export(exports, "delayWhen", ()=>(0, _delayWhen.delayWhen));
parcelHelpers.export(exports, "dematerialize", ()=>(0, _dematerialize.dematerialize));
parcelHelpers.export(exports, "distinct", ()=>(0, _distinct.distinct));
parcelHelpers.export(exports, "distinctUntilChanged", ()=>(0, _distinctUntilChanged.distinctUntilChanged));
parcelHelpers.export(exports, "distinctUntilKeyChanged", ()=>(0, _distinctUntilKeyChanged.distinctUntilKeyChanged));
parcelHelpers.export(exports, "elementAt", ()=>(0, _elementAt.elementAt));
parcelHelpers.export(exports, "endWith", ()=>(0, _endWith.endWith));
parcelHelpers.export(exports, "every", ()=>(0, _every.every));
parcelHelpers.export(exports, "exhaust", ()=>(0, _exhaust.exhaust));
parcelHelpers.export(exports, "exhaustAll", ()=>(0, _exhaustAll.exhaustAll));
parcelHelpers.export(exports, "exhaustMap", ()=>(0, _exhaustMap.exhaustMap));
parcelHelpers.export(exports, "expand", ()=>(0, _expand.expand));
parcelHelpers.export(exports, "filter", ()=>(0, _filter.filter));
parcelHelpers.export(exports, "finalize", ()=>(0, _finalize.finalize));
parcelHelpers.export(exports, "find", ()=>(0, _find.find));
parcelHelpers.export(exports, "findIndex", ()=>(0, _findIndex.findIndex));
parcelHelpers.export(exports, "first", ()=>(0, _first.first));
parcelHelpers.export(exports, "groupBy", ()=>(0, _groupBy.groupBy));
parcelHelpers.export(exports, "ignoreElements", ()=>(0, _ignoreElements.ignoreElements));
parcelHelpers.export(exports, "isEmpty", ()=>(0, _isEmpty.isEmpty));
parcelHelpers.export(exports, "last", ()=>(0, _last.last));
parcelHelpers.export(exports, "map", ()=>(0, _map.map));
parcelHelpers.export(exports, "mapTo", ()=>(0, _mapTo.mapTo));
parcelHelpers.export(exports, "materialize", ()=>(0, _materialize.materialize));
parcelHelpers.export(exports, "max", ()=>(0, _max.max));
parcelHelpers.export(exports, "mergeAll", ()=>(0, _mergeAll.mergeAll));
parcelHelpers.export(exports, "flatMap", ()=>(0, _flatMap.flatMap));
parcelHelpers.export(exports, "mergeMap", ()=>(0, _mergeMap.mergeMap));
parcelHelpers.export(exports, "mergeMapTo", ()=>(0, _mergeMapTo.mergeMapTo));
parcelHelpers.export(exports, "mergeScan", ()=>(0, _mergeScan.mergeScan));
parcelHelpers.export(exports, "mergeWith", ()=>(0, _mergeWith.mergeWith));
parcelHelpers.export(exports, "min", ()=>(0, _min.min));
parcelHelpers.export(exports, "multicast", ()=>(0, _multicast.multicast));
parcelHelpers.export(exports, "observeOn", ()=>(0, _observeOn.observeOn));
parcelHelpers.export(exports, "onErrorResumeNextWith", ()=>(0, _onErrorResumeNextWith.onErrorResumeNextWith));
parcelHelpers.export(exports, "pairwise", ()=>(0, _pairwise.pairwise));
parcelHelpers.export(exports, "pluck", ()=>(0, _pluck.pluck));
parcelHelpers.export(exports, "publish", ()=>(0, _publish.publish));
parcelHelpers.export(exports, "publishBehavior", ()=>(0, _publishBehavior.publishBehavior));
parcelHelpers.export(exports, "publishLast", ()=>(0, _publishLast.publishLast));
parcelHelpers.export(exports, "publishReplay", ()=>(0, _publishReplay.publishReplay));
parcelHelpers.export(exports, "raceWith", ()=>(0, _raceWith.raceWith));
parcelHelpers.export(exports, "reduce", ()=>(0, _reduce.reduce));
parcelHelpers.export(exports, "repeat", ()=>(0, _repeat.repeat));
parcelHelpers.export(exports, "repeatWhen", ()=>(0, _repeatWhen.repeatWhen));
parcelHelpers.export(exports, "retry", ()=>(0, _retry.retry));
parcelHelpers.export(exports, "retryWhen", ()=>(0, _retryWhen.retryWhen));
parcelHelpers.export(exports, "refCount", ()=>(0, _refCount.refCount));
parcelHelpers.export(exports, "sample", ()=>(0, _sample.sample));
parcelHelpers.export(exports, "sampleTime", ()=>(0, _sampleTime.sampleTime));
parcelHelpers.export(exports, "scan", ()=>(0, _scan.scan));
parcelHelpers.export(exports, "sequenceEqual", ()=>(0, _sequenceEqual.sequenceEqual));
parcelHelpers.export(exports, "share", ()=>(0, _share.share));
parcelHelpers.export(exports, "shareReplay", ()=>(0, _shareReplay.shareReplay));
parcelHelpers.export(exports, "single", ()=>(0, _single.single));
parcelHelpers.export(exports, "skip", ()=>(0, _skip.skip));
parcelHelpers.export(exports, "skipLast", ()=>(0, _skipLast.skipLast));
parcelHelpers.export(exports, "skipUntil", ()=>(0, _skipUntil.skipUntil));
parcelHelpers.export(exports, "skipWhile", ()=>(0, _skipWhile.skipWhile));
parcelHelpers.export(exports, "startWith", ()=>(0, _startWith.startWith));
parcelHelpers.export(exports, "subscribeOn", ()=>(0, _subscribeOn.subscribeOn));
parcelHelpers.export(exports, "switchAll", ()=>(0, _switchAll.switchAll));
parcelHelpers.export(exports, "switchMap", ()=>(0, _switchMap.switchMap));
parcelHelpers.export(exports, "switchMapTo", ()=>(0, _switchMapTo.switchMapTo));
parcelHelpers.export(exports, "switchScan", ()=>(0, _switchScan.switchScan));
parcelHelpers.export(exports, "take", ()=>(0, _take.take));
parcelHelpers.export(exports, "takeLast", ()=>(0, _takeLast.takeLast));
parcelHelpers.export(exports, "takeUntil", ()=>(0, _takeUntil.takeUntil));
parcelHelpers.export(exports, "takeWhile", ()=>(0, _takeWhile.takeWhile));
parcelHelpers.export(exports, "tap", ()=>(0, _tap.tap));
parcelHelpers.export(exports, "throttle", ()=>(0, _throttle.throttle));
parcelHelpers.export(exports, "throttleTime", ()=>(0, _throttleTime.throttleTime));
parcelHelpers.export(exports, "throwIfEmpty", ()=>(0, _throwIfEmpty.throwIfEmpty));
parcelHelpers.export(exports, "timeInterval", ()=>(0, _timeInterval.timeInterval));
parcelHelpers.export(exports, "timeout", ()=>(0, _timeout.timeout));
parcelHelpers.export(exports, "timeoutWith", ()=>(0, _timeoutWith.timeoutWith));
parcelHelpers.export(exports, "timestamp", ()=>(0, _timestamp.timestamp));
parcelHelpers.export(exports, "toArray", ()=>(0, _toArray.toArray));
parcelHelpers.export(exports, "window", ()=>(0, _window.window));
parcelHelpers.export(exports, "windowCount", ()=>(0, _windowCount.windowCount));
parcelHelpers.export(exports, "windowTime", ()=>(0, _windowTime.windowTime));
parcelHelpers.export(exports, "windowToggle", ()=>(0, _windowToggle.windowToggle));
parcelHelpers.export(exports, "windowWhen", ()=>(0, _windowWhen.windowWhen));
parcelHelpers.export(exports, "withLatestFrom", ()=>(0, _withLatestFrom.withLatestFrom));
parcelHelpers.export(exports, "zipAll", ()=>(0, _zipAll.zipAll));
parcelHelpers.export(exports, "zipWith", ()=>(0, _zipWith.zipWith));
var _observable = require("./internal/Observable");
var _connectableObservable = require("./internal/observable/ConnectableObservable");
var _observable1 = require("./internal/symbol/observable");
var _animationFrames = require("./internal/observable/dom/animationFrames");
var _subject = require("./internal/Subject");
var _behaviorSubject = require("./internal/BehaviorSubject");
var _replaySubject = require("./internal/ReplaySubject");
var _asyncSubject = require("./internal/AsyncSubject");
var _asap = require("./internal/scheduler/asap");
var _async = require("./internal/scheduler/async");
var _queue = require("./internal/scheduler/queue");
var _animationFrame = require("./internal/scheduler/animationFrame");
var _virtualTimeScheduler = require("./internal/scheduler/VirtualTimeScheduler");
var _scheduler = require("./internal/Scheduler");
var _subscription = require("./internal/Subscription");
var _subscriber = require("./internal/Subscriber");
var _notification = require("./internal/Notification");
var _pipe = require("./internal/util/pipe");
var _noop = require("./internal/util/noop");
var _identity = require("./internal/util/identity");
var _isObservable = require("./internal/util/isObservable");
var _lastValueFrom = require("./internal/lastValueFrom");
var _firstValueFrom = require("./internal/firstValueFrom");
var _argumentOutOfRangeError = require("./internal/util/ArgumentOutOfRangeError");
var _emptyError = require("./internal/util/EmptyError");
var _notFoundError = require("./internal/util/NotFoundError");
var _objectUnsubscribedError = require("./internal/util/ObjectUnsubscribedError");
var _sequenceError = require("./internal/util/SequenceError");
var _timeout = require("./internal/operators/timeout");
var _unsubscriptionError = require("./internal/util/UnsubscriptionError");
var _bindCallback = require("./internal/observable/bindCallback");
var _bindNodeCallback = require("./internal/observable/bindNodeCallback");
var _combineLatest = require("./internal/observable/combineLatest");
var _concat = require("./internal/observable/concat");
var _connectable = require("./internal/observable/connectable");
var _defer = require("./internal/observable/defer");
var _empty = require("./internal/observable/empty");
var _forkJoin = require("./internal/observable/forkJoin");
var _from = require("./internal/observable/from");
var _fromEvent = require("./internal/observable/fromEvent");
var _fromEventPattern = require("./internal/observable/fromEventPattern");
var _generate = require("./internal/observable/generate");
var _iif = require("./internal/observable/iif");
var _interval = require("./internal/observable/interval");
var _merge = require("./internal/observable/merge");
var _never = require("./internal/observable/never");
var _of = require("./internal/observable/of");
var _onErrorResumeNext = require("./internal/observable/onErrorResumeNext");
var _pairs = require("./internal/observable/pairs");
var _partition = require("./internal/observable/partition");
var _race = require("./internal/observable/race");
var _range = require("./internal/observable/range");
var _throwError = require("./internal/observable/throwError");
var _timer = require("./internal/observable/timer");
var _using = require("./internal/observable/using");
var _zip = require("./internal/observable/zip");
var _scheduled = require("./internal/scheduled/scheduled");
var _types = require("./internal/types");
parcelHelpers.exportAll(_types, exports);
var _config = require("./internal/config");
var _audit = require("./internal/operators/audit");
var _auditTime = require("./internal/operators/auditTime");
var _buffer = require("./internal/operators/buffer");
var _bufferCount = require("./internal/operators/bufferCount");
var _bufferTime = require("./internal/operators/bufferTime");
var _bufferToggle = require("./internal/operators/bufferToggle");
var _bufferWhen = require("./internal/operators/bufferWhen");
var _catchError = require("./internal/operators/catchError");
var _combineAll = require("./internal/operators/combineAll");
var _combineLatestAll = require("./internal/operators/combineLatestAll");
var _combineLatestWith = require("./internal/operators/combineLatestWith");
var _concatAll = require("./internal/operators/concatAll");
var _concatMap = require("./internal/operators/concatMap");
var _concatMapTo = require("./internal/operators/concatMapTo");
var _concatWith = require("./internal/operators/concatWith");
var _connect = require("./internal/operators/connect");
var _count = require("./internal/operators/count");
var _debounce = require("./internal/operators/debounce");
var _debounceTime = require("./internal/operators/debounceTime");
var _defaultIfEmpty = require("./internal/operators/defaultIfEmpty");
var _delay = require("./internal/operators/delay");
var _delayWhen = require("./internal/operators/delayWhen");
var _dematerialize = require("./internal/operators/dematerialize");
var _distinct = require("./internal/operators/distinct");
var _distinctUntilChanged = require("./internal/operators/distinctUntilChanged");
var _distinctUntilKeyChanged = require("./internal/operators/distinctUntilKeyChanged");
var _elementAt = require("./internal/operators/elementAt");
var _endWith = require("./internal/operators/endWith");
var _every = require("./internal/operators/every");
var _exhaust = require("./internal/operators/exhaust");
var _exhaustAll = require("./internal/operators/exhaustAll");
var _exhaustMap = require("./internal/operators/exhaustMap");
var _expand = require("./internal/operators/expand");
var _filter = require("./internal/operators/filter");
var _finalize = require("./internal/operators/finalize");
var _find = require("./internal/operators/find");
var _findIndex = require("./internal/operators/findIndex");
var _first = require("./internal/operators/first");
var _groupBy = require("./internal/operators/groupBy");
var _ignoreElements = require("./internal/operators/ignoreElements");
var _isEmpty = require("./internal/operators/isEmpty");
var _last = require("./internal/operators/last");
var _map = require("./internal/operators/map");
var _mapTo = require("./internal/operators/mapTo");
var _materialize = require("./internal/operators/materialize");
var _max = require("./internal/operators/max");
var _mergeAll = require("./internal/operators/mergeAll");
var _flatMap = require("./internal/operators/flatMap");
var _mergeMap = require("./internal/operators/mergeMap");
var _mergeMapTo = require("./internal/operators/mergeMapTo");
var _mergeScan = require("./internal/operators/mergeScan");
var _mergeWith = require("./internal/operators/mergeWith");
var _min = require("./internal/operators/min");
var _multicast = require("./internal/operators/multicast");
var _observeOn = require("./internal/operators/observeOn");
var _onErrorResumeNextWith = require("./internal/operators/onErrorResumeNextWith");
var _pairwise = require("./internal/operators/pairwise");
var _pluck = require("./internal/operators/pluck");
var _publish = require("./internal/operators/publish");
var _publishBehavior = require("./internal/operators/publishBehavior");
var _publishLast = require("./internal/operators/publishLast");
var _publishReplay = require("./internal/operators/publishReplay");
var _raceWith = require("./internal/operators/raceWith");
var _reduce = require("./internal/operators/reduce");
var _repeat = require("./internal/operators/repeat");
var _repeatWhen = require("./internal/operators/repeatWhen");
var _retry = require("./internal/operators/retry");
var _retryWhen = require("./internal/operators/retryWhen");
var _refCount = require("./internal/operators/refCount");
var _sample = require("./internal/operators/sample");
var _sampleTime = require("./internal/operators/sampleTime");
var _scan = require("./internal/operators/scan");
var _sequenceEqual = require("./internal/operators/sequenceEqual");
var _share = require("./internal/operators/share");
var _shareReplay = require("./internal/operators/shareReplay");
var _single = require("./internal/operators/single");
var _skip = require("./internal/operators/skip");
var _skipLast = require("./internal/operators/skipLast");
var _skipUntil = require("./internal/operators/skipUntil");
var _skipWhile = require("./internal/operators/skipWhile");
var _startWith = require("./internal/operators/startWith");
var _subscribeOn = require("./internal/operators/subscribeOn");
var _switchAll = require("./internal/operators/switchAll");
var _switchMap = require("./internal/operators/switchMap");
var _switchMapTo = require("./internal/operators/switchMapTo");
var _switchScan = require("./internal/operators/switchScan");
var _take = require("./internal/operators/take");
var _takeLast = require("./internal/operators/takeLast");
var _takeUntil = require("./internal/operators/takeUntil");
var _takeWhile = require("./internal/operators/takeWhile");
var _tap = require("./internal/operators/tap");
var _throttle = require("./internal/operators/throttle");
var _throttleTime = require("./internal/operators/throttleTime");
var _throwIfEmpty = require("./internal/operators/throwIfEmpty");
var _timeInterval = require("./internal/operators/timeInterval");
var _timeoutWith = require("./internal/operators/timeoutWith");
var _timestamp = require("./internal/operators/timestamp");
var _toArray = require("./internal/operators/toArray");
var _window = require("./internal/operators/window");
var _windowCount = require("./internal/operators/windowCount");
var _windowTime = require("./internal/operators/windowTime");
var _windowToggle = require("./internal/operators/windowToggle");
var _windowWhen = require("./internal/operators/windowWhen");
var _withLatestFrom = require("./internal/operators/withLatestFrom");
var _zipAll = require("./internal/operators/zipAll");
var _zipWith = require("./internal/operators/zipWith");

},{"./internal/Observable":"fo3d5","./internal/observable/ConnectableObservable":"41ArE","./internal/symbol/observable":"jUYLN","./internal/observable/dom/animationFrames":"gYXzY","./internal/Subject":"2sXGH","./internal/BehaviorSubject":"h9Spf","./internal/ReplaySubject":"e5koN","./internal/AsyncSubject":"OiSrp","./internal/scheduler/asap":"56Tql","./internal/scheduler/async":"eIZ5a","./internal/scheduler/queue":"6Pe89","./internal/scheduler/animationFrame":"eevc4","./internal/scheduler/VirtualTimeScheduler":"b1kNo","./internal/Scheduler":"fKhmo","./internal/Subscription":"gzL8W","./internal/Subscriber":"8Btbx","./internal/Notification":"asXck","./internal/util/pipe":"3zAKH","./internal/util/noop":"f1sCb","./internal/util/identity":"d03yr","./internal/util/isObservable":"3SwB4","./internal/lastValueFrom":"4HT8s","./internal/firstValueFrom":"dp9uD","./internal/util/ArgumentOutOfRangeError":"lkbeq","./internal/util/EmptyError":"Mm8dB","./internal/util/NotFoundError":"aVTD3","./internal/util/ObjectUnsubscribedError":"1aQ9y","./internal/util/SequenceError":"bapUn","./internal/operators/timeout":"4qfYk","./internal/util/UnsubscriptionError":"ja0ti","./internal/observable/bindCallback":"aRaIB","./internal/observable/bindNodeCallback":"hSPjv","./internal/observable/combineLatest":"8WwIf","./internal/observable/concat":"1H86H","./internal/observable/connectable":"74yQE","./internal/observable/defer":"6EJGM","./internal/observable/empty":"hZmJU","./internal/observable/forkJoin":"eDKqm","./internal/observable/from":"aDpqg","./internal/observable/fromEvent":"50QZb","./internal/observable/fromEventPattern":"eBJF7","./internal/observable/generate":"jcVt2","./internal/observable/iif":"ivP4Y","./internal/observable/interval":"ebQRx","./internal/observable/merge":"kC1O0","./internal/observable/never":"1MmPf","./internal/observable/of":"aBNUD","./internal/observable/onErrorResumeNext":"5MRy1","./internal/observable/pairs":"1Qy9x","./internal/observable/partition":"hybZ0","./internal/observable/race":"cv60P","./internal/observable/range":"aoXnJ","./internal/observable/throwError":"aZftO","./internal/observable/timer":"EANJK","./internal/observable/using":"6IeTN","./internal/observable/zip":"8sk2Y","./internal/scheduled/scheduled":"eaKb6","./internal/types":"2hC1b","./internal/config":"ktLZa","./internal/operators/audit":"dsTZY","./internal/operators/auditTime":"9Llvq","./internal/operators/buffer":"bBo8n","./internal/operators/bufferCount":"2YxsY","./internal/operators/bufferTime":"4R33k","./internal/operators/bufferToggle":"jNIZ7","./internal/operators/bufferWhen":"5GTvo","./internal/operators/catchError":"bW2OG","./internal/operators/combineAll":"7sph5","./internal/operators/combineLatestAll":"1RyF0","./internal/operators/combineLatestWith":"96hvT","./internal/operators/concatAll":"3N9Cc","./internal/operators/concatMap":"emBSh","./internal/operators/concatMapTo":"38P3I","./internal/operators/concatWith":"YJ4oC","./internal/operators/connect":"9jLdy","./internal/operators/count":"124qG","./internal/operators/debounce":"7l4PC","./internal/operators/debounceTime":"h80NT","./internal/operators/defaultIfEmpty":"6uJJE","./internal/operators/delay":"2RJzO","./internal/operators/delayWhen":"eiopY","./internal/operators/dematerialize":"k3SZr","./internal/operators/distinct":"2TywC","./internal/operators/distinctUntilChanged":"iGfsr","./internal/operators/distinctUntilKeyChanged":"2sNVc","./internal/operators/elementAt":"fx5hJ","./internal/operators/endWith":"4nEYg","./internal/operators/every":"hswcw","./internal/operators/exhaust":"iJzIe","./internal/operators/exhaustAll":"03zkm","./internal/operators/exhaustMap":"cAFnx","./internal/operators/expand":"3dxNz","./internal/operators/filter":"aO3IO","./internal/operators/finalize":"LytCq","./internal/operators/find":"aaFa0","./internal/operators/findIndex":"k00hc","./internal/operators/first":"hPeew","./internal/operators/groupBy":"d3Tg3","./internal/operators/ignoreElements":"8RBST","./internal/operators/isEmpty":"h1hMH","./internal/operators/last":"kLaua","./internal/operators/map":"9Azp4","./internal/operators/mapTo":"7HUed","./internal/operators/materialize":"lo980","./internal/operators/max":"etLZh","./internal/operators/mergeAll":"iRJ2C","./internal/operators/flatMap":"jWma1","./internal/operators/mergeMap":"5gFTr","./internal/operators/mergeMapTo":"frPgW","./internal/operators/mergeScan":"cAvb5","./internal/operators/mergeWith":"5WJFY","./internal/operators/min":"6h0L2","./internal/operators/multicast":"blOJd","./internal/operators/observeOn":"k6OlK","./internal/operators/onErrorResumeNextWith":"9hfb6","./internal/operators/pairwise":"5wANY","./internal/operators/pluck":"imGUr","./internal/operators/publish":"8wOeK","./internal/operators/publishBehavior":"iwBWB","./internal/operators/publishLast":"3n4TK","./internal/operators/publishReplay":"gUWQi","./internal/operators/raceWith":"6cdfA","./internal/operators/reduce":"4kl4u","./internal/operators/repeat":"5UqpN","./internal/operators/repeatWhen":"gc3fv","./internal/operators/retry":"2tmUJ","./internal/operators/retryWhen":"22yAc","./internal/operators/refCount":"7oeFZ","./internal/operators/sample":"4UBOM","./internal/operators/sampleTime":"9b5UP","./internal/operators/scan":"hjpMh","./internal/operators/sequenceEqual":"2HeB5","./internal/operators/share":"9lnzR","./internal/operators/shareReplay":"3ApTz","./internal/operators/single":"6EvgU","./internal/operators/skip":"hBspj","./internal/operators/skipLast":"dV92A","./internal/operators/skipUntil":"hgUdx","./internal/operators/skipWhile":"iMGQR","./internal/operators/startWith":"4c0lY","./internal/operators/subscribeOn":"a8ffZ","./internal/operators/switchAll":"cnJCR","./internal/operators/switchMap":"1rRAL","./internal/operators/switchMapTo":"727dN","./internal/operators/switchScan":"cL6qq","./internal/operators/take":"94vX9","./internal/operators/takeLast":"967LC","./internal/operators/takeUntil":"1WaPV","./internal/operators/takeWhile":"WXp51","./internal/operators/tap":"gzncB","./internal/operators/throttle":"aqWV2","./internal/operators/throttleTime":"7zEuX","./internal/operators/throwIfEmpty":"9WNWd","./internal/operators/timeInterval":"i7v6u","./internal/operators/timeoutWith":"igxz4","./internal/operators/timestamp":"eP3KH","./internal/operators/toArray":"39VfS","./internal/operators/window":"5Cov0","./internal/operators/windowCount":"9lRUE","./internal/operators/windowTime":"9CZWM","./internal/operators/windowToggle":"9vCYU","./internal/operators/windowWhen":"73c43","./internal/operators/withLatestFrom":"8Yb0Y","./internal/operators/zipAll":"6o3EP","./internal/operators/zipWith":"5OH3O","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"gYXzY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "animationFrames", ()=>animationFrames);
var _observable = require("../../Observable");
var _performanceTimestampProvider = require("../../scheduler/performanceTimestampProvider");
var _animationFrameProvider = require("../../scheduler/animationFrameProvider");
function animationFrames(timestampProvider) {
    return timestampProvider ? animationFramesFactory(timestampProvider) : DEFAULT_ANIMATION_FRAMES;
}
function animationFramesFactory(timestampProvider) {
    return new (0, _observable.Observable)(function(subscriber) {
        var provider = timestampProvider || (0, _performanceTimestampProvider.performanceTimestampProvider);
        var start = provider.now();
        var id = 0;
        var run = function() {
            if (!subscriber.closed) id = (0, _animationFrameProvider.animationFrameProvider).requestAnimationFrame(function(timestamp) {
                id = 0;
                var now = provider.now();
                subscriber.next({
                    timestamp: timestampProvider ? now : timestamp,
                    elapsed: now - start
                });
                run();
            });
        };
        run();
        return function() {
            if (id) (0, _animationFrameProvider.animationFrameProvider).cancelAnimationFrame(id);
        };
    });
}
var DEFAULT_ANIMATION_FRAMES = animationFramesFactory();

},{"../../Observable":"fo3d5","../../scheduler/performanceTimestampProvider":"4Uw81","../../scheduler/animationFrameProvider":"dgi90","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"4Uw81":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "performanceTimestampProvider", ()=>performanceTimestampProvider);
var performanceTimestampProvider = {
    now: function() {
        return (performanceTimestampProvider.delegate || performance).now();
    },
    delegate: undefined
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"dgi90":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "animationFrameProvider", ()=>animationFrameProvider);
var _tslib = require("tslib");
var _subscription = require("../Subscription");
var animationFrameProvider = {
    schedule: function(callback) {
        var request = requestAnimationFrame;
        var cancel = cancelAnimationFrame;
        var delegate = animationFrameProvider.delegate;
        if (delegate) {
            request = delegate.requestAnimationFrame;
            cancel = delegate.cancelAnimationFrame;
        }
        var handle = request(function(timestamp) {
            cancel = undefined;
            callback(timestamp);
        });
        return new (0, _subscription.Subscription)(function() {
            return cancel === null || cancel === void 0 ? void 0 : cancel(handle);
        });
    },
    requestAnimationFrame: function() {
        var args = [];
        for(var _i = 0; _i < arguments.length; _i++)args[_i] = arguments[_i];
        var delegate = animationFrameProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.requestAnimationFrame) || requestAnimationFrame).apply(void 0, (0, _tslib.__spreadArray)([], (0, _tslib.__read)(args)));
    },
    cancelAnimationFrame: function() {
        var args = [];
        for(var _i = 0; _i < arguments.length; _i++)args[_i] = arguments[_i];
        var delegate = animationFrameProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.cancelAnimationFrame) || cancelAnimationFrame).apply(void 0, (0, _tslib.__spreadArray)([], (0, _tslib.__read)(args)));
    },
    delegate: undefined
};

},{"tslib":"3gscj","../Subscription":"gzL8W","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"56Tql":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "asapScheduler", ()=>asapScheduler);
parcelHelpers.export(exports, "asap", ()=>asap);
var _asapAction = require("./AsapAction");
var _asapScheduler = require("./AsapScheduler");
var asapScheduler = new (0, _asapScheduler.AsapScheduler)((0, _asapAction.AsapAction));
var asap = asapScheduler;

},{"./AsapAction":"2zbNz","./AsapScheduler":"7y7RO","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"2zbNz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AsapAction", ()=>AsapAction);
var _tslib = require("tslib");
var _asyncAction = require("./AsyncAction");
var _immediateProvider = require("./immediateProvider");
var AsapAction = function(_super) {
    (0, _tslib.__extends)(AsapAction, _super);
    function AsapAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
    }
    AsapAction.prototype.requestAsyncId = function(scheduler, id, delay) {
        if (delay === void 0) delay = 0;
        if (delay !== null && delay > 0) return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        scheduler.actions.push(this);
        return scheduler._scheduled || (scheduler._scheduled = (0, _immediateProvider.immediateProvider).setImmediate(scheduler.flush.bind(scheduler, undefined)));
    };
    AsapAction.prototype.recycleAsyncId = function(scheduler, id, delay) {
        var _a;
        if (delay === void 0) delay = 0;
        if (delay != null ? delay > 0 : this.delay > 0) return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
        var actions = scheduler.actions;
        if (id != null && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id) {
            (0, _immediateProvider.immediateProvider).clearImmediate(id);
            if (scheduler._scheduled === id) scheduler._scheduled = undefined;
        }
        return undefined;
    };
    return AsapAction;
}((0, _asyncAction.AsyncAction));

},{"tslib":"3gscj","./AsyncAction":"bh2bi","./immediateProvider":"epoGC","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"epoGC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "immediateProvider", ()=>immediateProvider);
var _tslib = require("tslib");
var _immediate = require("../util/Immediate");
var setImmediate = (0, _immediate.Immediate).setImmediate, clearImmediate = (0, _immediate.Immediate).clearImmediate;
var immediateProvider = {
    setImmediate: function() {
        var args = [];
        for(var _i = 0; _i < arguments.length; _i++)args[_i] = arguments[_i];
        var delegate = immediateProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.setImmediate) || setImmediate).apply(void 0, (0, _tslib.__spreadArray)([], (0, _tslib.__read)(args)));
    },
    clearImmediate: function(handle) {
        var delegate = immediateProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearImmediate) || clearImmediate)(handle);
    },
    delegate: undefined
};

},{"tslib":"3gscj","../util/Immediate":"2mKAy","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"2mKAy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Immediate", ()=>Immediate);
parcelHelpers.export(exports, "TestTools", ()=>TestTools);
var nextHandle = 1;
var resolved;
var activeHandles = {};
function findAndClearHandle(handle) {
    if (handle in activeHandles) {
        delete activeHandles[handle];
        return true;
    }
    return false;
}
var Immediate = {
    setImmediate: function(cb) {
        var handle = nextHandle++;
        activeHandles[handle] = true;
        if (!resolved) resolved = Promise.resolve();
        resolved.then(function() {
            return findAndClearHandle(handle) && cb();
        });
        return handle;
    },
    clearImmediate: function(handle) {
        findAndClearHandle(handle);
    }
};
var TestTools = {
    pending: function() {
        return Object.keys(activeHandles).length;
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"7y7RO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AsapScheduler", ()=>AsapScheduler);
var _tslib = require("tslib");
var _asyncScheduler = require("./AsyncScheduler");
var AsapScheduler = function(_super) {
    (0, _tslib.__extends)(AsapScheduler, _super);
    function AsapScheduler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AsapScheduler.prototype.flush = function(action) {
        this._active = true;
        var flushId = this._scheduled;
        this._scheduled = undefined;
        var actions = this.actions;
        var error;
        action = action || actions.shift();
        do {
            if (error = action.execute(action.state, action.delay)) break;
        }while ((action = actions[0]) && action.id === flushId && actions.shift());
        this._active = false;
        if (error) {
            while((action = actions[0]) && action.id === flushId && actions.shift())action.unsubscribe();
            throw error;
        }
    };
    return AsapScheduler;
}((0, _asyncScheduler.AsyncScheduler));

},{"tslib":"3gscj","./AsyncScheduler":"21exO","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"6Pe89":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "queueScheduler", ()=>queueScheduler);
parcelHelpers.export(exports, "queue", ()=>queue);
var _queueAction = require("./QueueAction");
var _queueScheduler = require("./QueueScheduler");
var queueScheduler = new (0, _queueScheduler.QueueScheduler)((0, _queueAction.QueueAction));
var queue = queueScheduler;

},{"./QueueAction":"dn0M8","./QueueScheduler":"dKkD0","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"dn0M8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "QueueAction", ()=>QueueAction);
var _tslib = require("tslib");
var _asyncAction = require("./AsyncAction");
var QueueAction = function(_super) {
    (0, _tslib.__extends)(QueueAction, _super);
    function QueueAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
    }
    QueueAction.prototype.schedule = function(state, delay) {
        if (delay === void 0) delay = 0;
        if (delay > 0) return _super.prototype.schedule.call(this, state, delay);
        this.delay = delay;
        this.state = state;
        this.scheduler.flush(this);
        return this;
    };
    QueueAction.prototype.execute = function(state, delay) {
        return delay > 0 || this.closed ? _super.prototype.execute.call(this, state, delay) : this._execute(state, delay);
    };
    QueueAction.prototype.requestAsyncId = function(scheduler, id, delay) {
        if (delay === void 0) delay = 0;
        if (delay != null && delay > 0 || delay == null && this.delay > 0) return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        scheduler.flush(this);
        return 0;
    };
    return QueueAction;
}((0, _asyncAction.AsyncAction));

},{"tslib":"3gscj","./AsyncAction":"bh2bi","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"dKkD0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "QueueScheduler", ()=>QueueScheduler);
var _tslib = require("tslib");
var _asyncScheduler = require("./AsyncScheduler");
var QueueScheduler = function(_super) {
    (0, _tslib.__extends)(QueueScheduler, _super);
    function QueueScheduler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return QueueScheduler;
}((0, _asyncScheduler.AsyncScheduler));

},{"tslib":"3gscj","./AsyncScheduler":"21exO","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"eevc4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "animationFrameScheduler", ()=>animationFrameScheduler);
parcelHelpers.export(exports, "animationFrame", ()=>animationFrame);
var _animationFrameAction = require("./AnimationFrameAction");
var _animationFrameScheduler = require("./AnimationFrameScheduler");
var animationFrameScheduler = new (0, _animationFrameScheduler.AnimationFrameScheduler)((0, _animationFrameAction.AnimationFrameAction));
var animationFrame = animationFrameScheduler;

},{"./AnimationFrameAction":"69hXH","./AnimationFrameScheduler":"itOZt","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"69hXH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AnimationFrameAction", ()=>AnimationFrameAction);
var _tslib = require("tslib");
var _asyncAction = require("./AsyncAction");
var _animationFrameProvider = require("./animationFrameProvider");
var AnimationFrameAction = function(_super) {
    (0, _tslib.__extends)(AnimationFrameAction, _super);
    function AnimationFrameAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
    }
    AnimationFrameAction.prototype.requestAsyncId = function(scheduler, id, delay) {
        if (delay === void 0) delay = 0;
        if (delay !== null && delay > 0) return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        scheduler.actions.push(this);
        return scheduler._scheduled || (scheduler._scheduled = (0, _animationFrameProvider.animationFrameProvider).requestAnimationFrame(function() {
            return scheduler.flush(undefined);
        }));
    };
    AnimationFrameAction.prototype.recycleAsyncId = function(scheduler, id, delay) {
        var _a;
        if (delay === void 0) delay = 0;
        if (delay != null ? delay > 0 : this.delay > 0) return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
        var actions = scheduler.actions;
        if (id != null && id === scheduler._scheduled && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id) {
            (0, _animationFrameProvider.animationFrameProvider).cancelAnimationFrame(id);
            scheduler._scheduled = undefined;
        }
        return undefined;
    };
    return AnimationFrameAction;
}((0, _asyncAction.AsyncAction));

},{"tslib":"3gscj","./AsyncAction":"bh2bi","./animationFrameProvider":"dgi90","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"itOZt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AnimationFrameScheduler", ()=>AnimationFrameScheduler);
var _tslib = require("tslib");
var _asyncScheduler = require("./AsyncScheduler");
var AnimationFrameScheduler = function(_super) {
    (0, _tslib.__extends)(AnimationFrameScheduler, _super);
    function AnimationFrameScheduler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AnimationFrameScheduler.prototype.flush = function(action) {
        this._active = true;
        var flushId;
        if (action) flushId = action.id;
        else {
            flushId = this._scheduled;
            this._scheduled = undefined;
        }
        var actions = this.actions;
        var error;
        action = action || actions.shift();
        do {
            if (error = action.execute(action.state, action.delay)) break;
        }while ((action = actions[0]) && action.id === flushId && actions.shift());
        this._active = false;
        if (error) {
            while((action = actions[0]) && action.id === flushId && actions.shift())action.unsubscribe();
            throw error;
        }
    };
    return AnimationFrameScheduler;
}((0, _asyncScheduler.AsyncScheduler));

},{"tslib":"3gscj","./AsyncScheduler":"21exO","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"b1kNo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VirtualTimeScheduler", ()=>VirtualTimeScheduler);
parcelHelpers.export(exports, "VirtualAction", ()=>VirtualAction);
var _tslib = require("tslib");
var _asyncAction = require("./AsyncAction");
var _subscription = require("../Subscription");
var _asyncScheduler = require("./AsyncScheduler");
var VirtualTimeScheduler = function(_super) {
    (0, _tslib.__extends)(VirtualTimeScheduler, _super);
    function VirtualTimeScheduler(schedulerActionCtor, maxFrames) {
        if (schedulerActionCtor === void 0) schedulerActionCtor = VirtualAction;
        if (maxFrames === void 0) maxFrames = Infinity;
        var _this = _super.call(this, schedulerActionCtor, function() {
            return _this.frame;
        }) || this;
        _this.maxFrames = maxFrames;
        _this.frame = 0;
        _this.index = -1;
        return _this;
    }
    VirtualTimeScheduler.prototype.flush = function() {
        var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
        var error;
        var action;
        while((action = actions[0]) && action.delay <= maxFrames){
            actions.shift();
            this.frame = action.delay;
            if (error = action.execute(action.state, action.delay)) break;
        }
        if (error) {
            while(action = actions.shift())action.unsubscribe();
            throw error;
        }
    };
    VirtualTimeScheduler.frameTimeFactor = 10;
    return VirtualTimeScheduler;
}((0, _asyncScheduler.AsyncScheduler));
var VirtualAction = function(_super) {
    (0, _tslib.__extends)(VirtualAction, _super);
    function VirtualAction(scheduler, work, index) {
        if (index === void 0) index = scheduler.index += 1;
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.index = index;
        _this.active = true;
        _this.index = scheduler.index = index;
        return _this;
    }
    VirtualAction.prototype.schedule = function(state, delay) {
        if (delay === void 0) delay = 0;
        if (Number.isFinite(delay)) {
            if (!this.id) return _super.prototype.schedule.call(this, state, delay);
            this.active = false;
            var action = new VirtualAction(this.scheduler, this.work);
            this.add(action);
            return action.schedule(state, delay);
        } else return (0, _subscription.Subscription).EMPTY;
    };
    VirtualAction.prototype.requestAsyncId = function(scheduler, id, delay) {
        if (delay === void 0) delay = 0;
        this.delay = scheduler.frame + delay;
        var actions = scheduler.actions;
        actions.push(this);
        actions.sort(VirtualAction.sortActions);
        return 1;
    };
    VirtualAction.prototype.recycleAsyncId = function(scheduler, id, delay) {
        if (delay === void 0) delay = 0;
        return undefined;
    };
    VirtualAction.prototype._execute = function(state, delay) {
        if (this.active === true) return _super.prototype._execute.call(this, state, delay);
    };
    VirtualAction.sortActions = function(a, b) {
        if (a.delay === b.delay) {
            if (a.index === b.index) return 0;
            else if (a.index > b.index) return 1;
            else return -1;
        } else if (a.delay > b.delay) return 1;
        else return -1;
    };
    return VirtualAction;
}((0, _asyncAction.AsyncAction));

},{"tslib":"3gscj","./AsyncAction":"bh2bi","../Subscription":"gzL8W","./AsyncScheduler":"21exO","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"3SwB4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isObservable", ()=>isObservable);
var _observable = require("../Observable");
var _isFunction = require("./isFunction");
function isObservable(obj) {
    return !!obj && (obj instanceof (0, _observable.Observable) || (0, _isFunction.isFunction)(obj.lift) && (0, _isFunction.isFunction)(obj.subscribe));
}

},{"../Observable":"fo3d5","./isFunction":"fpUct","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"4HT8s":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "lastValueFrom", ()=>lastValueFrom);
var _emptyError = require("./util/EmptyError");
function lastValueFrom(source, config) {
    var hasConfig = typeof config === "object";
    return new Promise(function(resolve, reject) {
        var _hasValue = false;
        var _value;
        source.subscribe({
            next: function(value) {
                _value = value;
                _hasValue = true;
            },
            error: reject,
            complete: function() {
                if (_hasValue) resolve(_value);
                else if (hasConfig) resolve(config.defaultValue);
                else reject(new (0, _emptyError.EmptyError)());
            }
        });
    });
}

},{"./util/EmptyError":"Mm8dB","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"dp9uD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "firstValueFrom", ()=>firstValueFrom);
var _emptyError = require("./util/EmptyError");
var _subscriber = require("./Subscriber");
function firstValueFrom(source, config) {
    var hasConfig = typeof config === "object";
    return new Promise(function(resolve, reject) {
        var subscriber = new (0, _subscriber.SafeSubscriber)({
            next: function(value) {
                resolve(value);
                subscriber.unsubscribe();
            },
            error: reject,
            complete: function() {
                if (hasConfig) resolve(config.defaultValue);
                else reject(new (0, _emptyError.EmptyError)());
            }
        });
        source.subscribe(subscriber);
    });
}

},{"./util/EmptyError":"Mm8dB","./Subscriber":"8Btbx","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"aRaIB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "bindCallback", ()=>bindCallback);
var _bindCallbackInternals = require("./bindCallbackInternals");
function bindCallback(callbackFunc, resultSelector, scheduler) {
    return (0, _bindCallbackInternals.bindCallbackInternals)(false, callbackFunc, resultSelector, scheduler);
}

},{"./bindCallbackInternals":"hv4ih","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"hv4ih":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "bindCallbackInternals", ()=>bindCallbackInternals);
var _tslib = require("tslib");
var _isScheduler = require("../util/isScheduler");
var _observable = require("../Observable");
var _subscribeOn = require("../operators/subscribeOn");
var _mapOneOrManyArgs = require("../util/mapOneOrManyArgs");
var _observeOn = require("../operators/observeOn");
var _asyncSubject = require("../AsyncSubject");
function bindCallbackInternals(isNodeStyle, callbackFunc, resultSelector, scheduler) {
    if (resultSelector) {
        if ((0, _isScheduler.isScheduler)(resultSelector)) scheduler = resultSelector;
        else return function() {
            var args = [];
            for(var _i = 0; _i < arguments.length; _i++)args[_i] = arguments[_i];
            return bindCallbackInternals(isNodeStyle, callbackFunc, scheduler).apply(this, args).pipe((0, _mapOneOrManyArgs.mapOneOrManyArgs)(resultSelector));
        };
    }
    if (scheduler) return function() {
        var args = [];
        for(var _i = 0; _i < arguments.length; _i++)args[_i] = arguments[_i];
        return bindCallbackInternals(isNodeStyle, callbackFunc).apply(this, args).pipe((0, _subscribeOn.subscribeOn)(scheduler), (0, _observeOn.observeOn)(scheduler));
    };
    return function() {
        var _this = this;
        var args = [];
        for(var _i = 0; _i < arguments.length; _i++)args[_i] = arguments[_i];
        var subject = new (0, _asyncSubject.AsyncSubject)();
        var uninitialized = true;
        return new (0, _observable.Observable)(function(subscriber) {
            var subs = subject.subscribe(subscriber);
            if (uninitialized) {
                uninitialized = false;
                var isAsync_1 = false;
                var isComplete_1 = false;
                callbackFunc.apply(_this, (0, _tslib.__spreadArray)((0, _tslib.__spreadArray)([], (0, _tslib.__read)(args)), [
                    function() {
                        var results = [];
                        for(var _i = 0; _i < arguments.length; _i++)results[_i] = arguments[_i];
                        if (isNodeStyle) {
                            var err = results.shift();
                            if (err != null) {
                                subject.error(err);
                                return;
                            }
                        }
                        subject.next(1 < results.length ? results : results[0]);
                        isComplete_1 = true;
                        if (isAsync_1) subject.complete();
                    }
                ]));
                if (isComplete_1) subject.complete();
                isAsync_1 = true;
            }
            return subs;
        });
    };
}

},{"tslib":"3gscj","../util/isScheduler":"bIVeo","../Observable":"fo3d5","../operators/subscribeOn":"a8ffZ","../util/mapOneOrManyArgs":"hyphn","../operators/observeOn":"k6OlK","../AsyncSubject":"OiSrp","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"hSPjv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "bindNodeCallback", ()=>bindNodeCallback);
var _bindCallbackInternals = require("./bindCallbackInternals");
function bindNodeCallback(callbackFunc, resultSelector, scheduler) {
    return (0, _bindCallbackInternals.bindCallbackInternals)(true, callbackFunc, resultSelector, scheduler);
}

},{"./bindCallbackInternals":"hv4ih","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"74yQE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "connectable", ()=>connectable);
var _subject = require("../Subject");
var _observable = require("../Observable");
var _defer = require("./defer");
var DEFAULT_CONFIG = {
    connector: function() {
        return new (0, _subject.Subject)();
    },
    resetOnDisconnect: true
};
function connectable(source, config) {
    if (config === void 0) config = DEFAULT_CONFIG;
    var connection = null;
    var connector = config.connector, _a = config.resetOnDisconnect, resetOnDisconnect = _a === void 0 ? true : _a;
    var subject = connector();
    var result = new (0, _observable.Observable)(function(subscriber) {
        return subject.subscribe(subscriber);
    });
    result.connect = function() {
        if (!connection || connection.closed) {
            connection = (0, _defer.defer)(function() {
                return source;
            }).subscribe(subject);
            if (resetOnDisconnect) connection.add(function() {
                return subject = connector();
            });
        }
        return connection;
    };
    return result;
}

},{"../Subject":"2sXGH","../Observable":"fo3d5","./defer":"6EJGM","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"6EJGM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "defer", ()=>defer);
var _observable = require("../Observable");
var _innerFrom = require("./innerFrom");
function defer(observableFactory) {
    return new (0, _observable.Observable)(function(subscriber) {
        (0, _innerFrom.innerFrom)(observableFactory()).subscribe(subscriber);
    });
}

},{"../Observable":"fo3d5","./innerFrom":"6l3RX","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"eDKqm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "forkJoin", ()=>forkJoin);
var _observable = require("../Observable");
var _argsArgArrayOrObject = require("../util/argsArgArrayOrObject");
var _innerFrom = require("./innerFrom");
var _args = require("../util/args");
var _operatorSubscriber = require("../operators/OperatorSubscriber");
var _mapOneOrManyArgs = require("../util/mapOneOrManyArgs");
var _createObject = require("../util/createObject");
function forkJoin() {
    var args = [];
    for(var _i = 0; _i < arguments.length; _i++)args[_i] = arguments[_i];
    var resultSelector = (0, _args.popResultSelector)(args);
    var _a = (0, _argsArgArrayOrObject.argsArgArrayOrObject)(args), sources = _a.args, keys = _a.keys;
    var result = new (0, _observable.Observable)(function(subscriber) {
        var length = sources.length;
        if (!length) {
            subscriber.complete();
            return;
        }
        var values = new Array(length);
        var remainingCompletions = length;
        var remainingEmissions = length;
        var _loop_1 = function(sourceIndex) {
            var hasValue = false;
            (0, _innerFrom.innerFrom)(sources[sourceIndex]).subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function(value) {
                if (!hasValue) {
                    hasValue = true;
                    remainingEmissions--;
                }
                values[sourceIndex] = value;
            }, function() {
                return remainingCompletions--;
            }, undefined, function() {
                if (!remainingCompletions || !hasValue) {
                    if (!remainingEmissions) subscriber.next(keys ? (0, _createObject.createObject)(keys, values) : values);
                    subscriber.complete();
                }
            }));
        };
        for(var sourceIndex = 0; sourceIndex < length; sourceIndex++)_loop_1(sourceIndex);
    });
    return resultSelector ? result.pipe((0, _mapOneOrManyArgs.mapOneOrManyArgs)(resultSelector)) : result;
}

},{"../Observable":"fo3d5","../util/argsArgArrayOrObject":"9A3xN","./innerFrom":"6l3RX","../util/args":"ccsng","../operators/OperatorSubscriber":"hrKGc","../util/mapOneOrManyArgs":"hyphn","../util/createObject":"cbhvC","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"50QZb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "fromEvent", ()=>fromEvent);
var _tslib = require("tslib");
var _innerFrom = require("../observable/innerFrom");
var _observable = require("../Observable");
var _mergeMap = require("../operators/mergeMap");
var _isArrayLike = require("../util/isArrayLike");
var _isFunction = require("../util/isFunction");
var _mapOneOrManyArgs = require("../util/mapOneOrManyArgs");
var nodeEventEmitterMethods = [
    "addListener",
    "removeListener"
];
var eventTargetMethods = [
    "addEventListener",
    "removeEventListener"
];
var jqueryMethods = [
    "on",
    "off"
];
function fromEvent(target, eventName, options, resultSelector) {
    if ((0, _isFunction.isFunction)(options)) {
        resultSelector = options;
        options = undefined;
    }
    if (resultSelector) return fromEvent(target, eventName, options).pipe((0, _mapOneOrManyArgs.mapOneOrManyArgs)(resultSelector));
    var _a = (0, _tslib.__read)(isEventTarget(target) ? eventTargetMethods.map(function(methodName) {
        return function(handler) {
            return target[methodName](eventName, handler, options);
        };
    }) : isNodeStyleEventEmitter(target) ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName)) : isJQueryStyleEventEmitter(target) ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName)) : [], 2), add = _a[0], remove = _a[1];
    if (!add) {
        if ((0, _isArrayLike.isArrayLike)(target)) return (0, _mergeMap.mergeMap)(function(subTarget) {
            return fromEvent(subTarget, eventName, options);
        })((0, _innerFrom.innerFrom)(target));
    }
    if (!add) throw new TypeError("Invalid event target");
    return new (0, _observable.Observable)(function(subscriber) {
        var handler = function() {
            var args = [];
            for(var _i = 0; _i < arguments.length; _i++)args[_i] = arguments[_i];
            return subscriber.next(1 < args.length ? args : args[0]);
        };
        add(handler);
        return function() {
            return remove(handler);
        };
    });
}
function toCommonHandlerRegistry(target, eventName) {
    return function(methodName) {
        return function(handler) {
            return target[methodName](eventName, handler);
        };
    };
}
function isNodeStyleEventEmitter(target) {
    return (0, _isFunction.isFunction)(target.addListener) && (0, _isFunction.isFunction)(target.removeListener);
}
function isJQueryStyleEventEmitter(target) {
    return (0, _isFunction.isFunction)(target.on) && (0, _isFunction.isFunction)(target.off);
}
function isEventTarget(target) {
    return (0, _isFunction.isFunction)(target.addEventListener) && (0, _isFunction.isFunction)(target.removeEventListener);
}

},{"tslib":"3gscj","../observable/innerFrom":"6l3RX","../Observable":"fo3d5","../operators/mergeMap":"5gFTr","../util/isArrayLike":"hj6kw","../util/isFunction":"fpUct","../util/mapOneOrManyArgs":"hyphn","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"eBJF7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "fromEventPattern", ()=>fromEventPattern);
var _observable = require("../Observable");
var _isFunction = require("../util/isFunction");
var _mapOneOrManyArgs = require("../util/mapOneOrManyArgs");
function fromEventPattern(addHandler, removeHandler, resultSelector) {
    if (resultSelector) return fromEventPattern(addHandler, removeHandler).pipe((0, _mapOneOrManyArgs.mapOneOrManyArgs)(resultSelector));
    return new (0, _observable.Observable)(function(subscriber) {
        var handler = function() {
            var e = [];
            for(var _i = 0; _i < arguments.length; _i++)e[_i] = arguments[_i];
            return subscriber.next(e.length === 1 ? e[0] : e);
        };
        var retValue = addHandler(handler);
        return (0, _isFunction.isFunction)(removeHandler) ? function() {
            return removeHandler(handler, retValue);
        } : undefined;
    });
}

},{"../Observable":"fo3d5","../util/isFunction":"fpUct","../util/mapOneOrManyArgs":"hyphn","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"jcVt2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "generate", ()=>generate);
var _tslib = require("tslib");
var _identity = require("../util/identity");
var _isScheduler = require("../util/isScheduler");
var _defer = require("./defer");
var _scheduleIterable = require("../scheduled/scheduleIterable");
function generate(initialStateOrOptions, condition, iterate, resultSelectorOrScheduler, scheduler) {
    var _a, _b;
    var resultSelector;
    var initialState;
    if (arguments.length === 1) _a = initialStateOrOptions, initialState = _a.initialState, condition = _a.condition, iterate = _a.iterate, _b = _a.resultSelector, resultSelector = _b === void 0 ? (0, _identity.identity) : _b, scheduler = _a.scheduler;
    else {
        initialState = initialStateOrOptions;
        if (!resultSelectorOrScheduler || (0, _isScheduler.isScheduler)(resultSelectorOrScheduler)) {
            resultSelector = (0, _identity.identity);
            scheduler = resultSelectorOrScheduler;
        } else resultSelector = resultSelectorOrScheduler;
    }
    function gen() {
        var state;
        return (0, _tslib.__generator)(this, function(_a) {
            switch(_a.label){
                case 0:
                    state = initialState;
                    _a.label = 1;
                case 1:
                    if (!(!condition || condition(state))) return [
                        3,
                        4
                    ];
                    return [
                        4,
                        resultSelector(state)
                    ];
                case 2:
                    _a.sent();
                    _a.label = 3;
                case 3:
                    state = iterate(state);
                    return [
                        3,
                        1
                    ];
                case 4:
                    return [
                        2
                    ];
            }
        });
    }
    return (0, _defer.defer)(scheduler ? function() {
        return (0, _scheduleIterable.scheduleIterable)(gen(), scheduler);
    } : gen);
}

},{"tslib":"3gscj","../util/identity":"d03yr","../util/isScheduler":"bIVeo","./defer":"6EJGM","../scheduled/scheduleIterable":"6PmK2","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"ivP4Y":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "iif", ()=>iif);
var _defer = require("./defer");
function iif(condition, trueResult, falseResult) {
    return (0, _defer.defer)(function() {
        return condition() ? trueResult : falseResult;
    });
}

},{"./defer":"6EJGM","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"kC1O0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "merge", ()=>merge);
var _mergeAll = require("../operators/mergeAll");
var _innerFrom = require("./innerFrom");
var _empty = require("./empty");
var _args = require("../util/args");
var _from = require("./from");
function merge() {
    var args = [];
    for(var _i = 0; _i < arguments.length; _i++)args[_i] = arguments[_i];
    var scheduler = (0, _args.popScheduler)(args);
    var concurrent = (0, _args.popNumber)(args, Infinity);
    var sources = args;
    return !sources.length ? (0, _empty.EMPTY) : sources.length === 1 ? (0, _innerFrom.innerFrom)(sources[0]) : (0, _mergeAll.mergeAll)(concurrent)((0, _from.from)(sources, scheduler));
}

},{"../operators/mergeAll":"iRJ2C","./innerFrom":"6l3RX","./empty":"hZmJU","../util/args":"ccsng","./from":"aDpqg","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"1MmPf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "NEVER", ()=>NEVER);
parcelHelpers.export(exports, "never", ()=>never);
var _observable = require("../Observable");
var _noop = require("../util/noop");
var NEVER = new (0, _observable.Observable)((0, _noop.noop));
function never() {
    return NEVER;
}

},{"../Observable":"fo3d5","../util/noop":"f1sCb","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"1Qy9x":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "pairs", ()=>pairs);
var _from = require("./from");
function pairs(obj, scheduler) {
    return (0, _from.from)(Object.entries(obj), scheduler);
}

},{"./from":"aDpqg","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"hybZ0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "partition", ()=>partition);
var _not = require("../util/not");
var _filter = require("../operators/filter");
var _innerFrom = require("./innerFrom");
function partition(source, predicate, thisArg) {
    return [
        (0, _filter.filter)(predicate, thisArg)((0, _innerFrom.innerFrom)(source)),
        (0, _filter.filter)((0, _not.not)(predicate, thisArg))((0, _innerFrom.innerFrom)(source))
    ];
}

},{"../util/not":"3Dalz","../operators/filter":"aO3IO","./innerFrom":"6l3RX","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"aoXnJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "range", ()=>range);
var _observable = require("../Observable");
var _empty = require("./empty");
function range(start, count, scheduler) {
    if (count == null) {
        count = start;
        start = 0;
    }
    if (count <= 0) return 0, _empty.EMPTY;
    var end = count + start;
    return new (0, _observable.Observable)(scheduler ? function(subscriber) {
        var n = start;
        return scheduler.schedule(function() {
            if (n < end) {
                subscriber.next(n++);
                this.schedule();
            } else subscriber.complete();
        });
    } : function(subscriber) {
        var n = start;
        while(n < end && !subscriber.closed)subscriber.next(n++);
        subscriber.complete();
    });
}

},{"../Observable":"fo3d5","./empty":"hZmJU","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"6IeTN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "using", ()=>using);
var _observable = require("../Observable");
var _innerFrom = require("./innerFrom");
var _empty = require("./empty");
function using(resourceFactory, observableFactory) {
    return new (0, _observable.Observable)(function(subscriber) {
        var resource = resourceFactory();
        var result = observableFactory(resource);
        var source = result ? (0, _innerFrom.innerFrom)(result) : (0, _empty.EMPTY);
        source.subscribe(subscriber);
        return function() {
            if (resource) resource.unsubscribe();
        };
    });
}

},{"../Observable":"fo3d5","./innerFrom":"6l3RX","./empty":"hZmJU","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"2hC1b":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"epvLh":[function(require,module,exports) {
/**
 * Storage utilities for localStorage/sessionStorage
 * @module storage
 */ /**
 * Get item from storage with JSON parsing
 * @memberof module:storage
 * @param {Storage} storage - localStorage or sessionStorage
 * @param {string} key - Storage key
 * @param {*} defaultValue - Default value if not found
 * @return {*} Parsed value or default
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "get", ()=>get);
parcelHelpers.export(exports, "set", ()=>set);
parcelHelpers.export(exports, "init", ()=>init);
const get = (storage, key, defaultValue)=>(storage.getItem(key) && JSON.parse(storage.getItem(key))) ?? defaultValue;
const set = (storage, key, value)=>storage.setItem(key, JSON.stringify(value));
const init = (storage)=>storage ? {
        storage,
        get: (key, defaultValue)=>get(storage, key, defaultValue),
        set: (key, value)=>set(storage, key, value)
    } : null;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"cGtnI":[function(require,module,exports) {
/**
 * Action tree adapter - converts action trees to auto-dispatching APIs
 * @module adapt
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "adapt", ()=>adapt);
parcelHelpers.export(exports, "attach", ()=>attach);
parcelHelpers.export(exports, "createState", ()=>createState);
var _rxjs = require("rxjs");
var _iblokzData = require("iblokz-data");
var _coreJs = require("./core.js");
/**
 * Check if value is a Promise
 * @private
 * @param {*} value - Value to check
 * @return {boolean} True if value is a Promise
 */ const isPromise = (value)=>value && typeof value.then === "function";
const adapt = (tree, namespace = "state.changes", path = [])=>{
    // Create stream for this level (root creates Subject, children reuse parent's)
    const stream = path.length === 0 ? new (0, _rxjs.Subject)() : null;
    const rootStream = stream || tree._rootStream;
    const adapted = Object.keys(tree).filter((key)=>key !== "initial" && key !== "_rootStream").reduce((acc, key)=>{
        const value = tree[key];
        // Handle functions - wrap to auto-dispatch
        if (typeof value === "function") acc[key] = function(...args) {
            // Call original function to get reducer
            const result = value(...args);
            // Handle async/Promise results
            const handleResult = (reducer)=>{
                // Dispatch the reducer
                (0, _coreJs.dispatch)(reducer, namespace);
                // Emit metadata to stream
                rootStream && rootStream.next({
                    path: [
                        ...path,
                        key
                    ],
                    payload: args,
                    reducer
                });
            };
            if (isPromise(result)) result.then(handleResult);
            else handleResult(result);
        };
        else if (value && typeof value === "object" && !Array.isArray(value)) {
            // Handle nested objects - recurse
            const nested = adapt({
                ...value,
                _rootStream: rootStream
            }, namespace, [
                ...path,
                key
            ]);
            // Merge nested initial into parent
            if (nested.initial) acc.initial = {
                ...acc.initial,
                [key]: nested.initial
            };
            acc[key] = nested;
        } else // Handle other values (primitives, arrays)
        acc[key] = value;
        return acc;
    }, {
        initial: tree.initial || {},
        ...stream ? {
            stream
        } : {}
    });
    return adapted;
};
const attach = (tree, path, node)=>{
    // Normalize path to array
    const pathArray = typeof path === "string" ? path.split(".") : path;
    // Get namespace from tree if available
    const namespace = tree._namespace || "state.changes";
    // Adapt the new node with the tree's root stream
    const adaptedNode = adapt({
        ...node,
        _rootStream: tree.stream
    }, namespace, pathArray);
    // Patch the tree and initial state using iblokz-data
    return {
        ...(0, _iblokzData.obj).patch(tree, pathArray, adaptedNode),
        initial: (0, _iblokzData.obj).patch(tree.initial, pathArray, adaptedNode.initial),
        stream: tree.stream,
        _namespace: namespace
    };
};
const createState = (tree, namespace = "state.changes", storage = null)=>{
    const actions = adapt(tree, namespace);
    // Store namespace for later use (e.g., with attach)
    actions._namespace = namespace;
    const state$ = (0, _coreJs.init)(actions.initial, namespace, storage);
    return {
        actions,
        state$
    };
};

},{"rxjs":"hWUVi","iblokz-data":"2lXuw","./core.js":"eNXlu","@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"ccGLY":[function(require,module,exports) {
"use strict";
const { obj, arr } = require("1c8a65d6e47c04ea");
// namespaces=
const counter = require("dc545a6d01575926");
const level = require("27175040b3258a34");
// initial
const initial = {
    camera: {
        distance: 60,
        range: {
            h: 360,
            hOffset: -180,
            v: 90,
            vOffset: -80
        },
        followPlayer: true
    },
    player: {
        position: [
            -10,
            0.2,
            35
        ],
        rotation: 180,
        crouching: false,
        combat: false,
        direction: [
            0,
            0
        ],
        force: 0
    },
    viewport: {
        screen: {
            width: 800,
            height: 600
        },
        mouse: {
            x: 0,
            y: 0,
            changeX: 0,
            changeY: 0,
            down: false
        }
    },
    controls: {
        on: true,
        camera: false
    }
};
// actions
const set = (key, value)=>(state)=>obj.patch(state, key, value);
const toggle = (key)=>(state)=>obj.patch(state, key, !obj.sub(state, key));
const arrToggle = (key, value)=>(state)=>obj.patch(state, key, arr.toggle(obj.sub(state, key), value));
const zoom = (amount)=>(state)=>obj.patch(state, "camera", {
            distance: state.camera.distance + amount
        });
const degreeToRadiant = (deg)=>Math.PI / (180 / deg);
const calcucalateAngle = (viewport, range)=>({
        x: viewport.mouse.x / viewport.screen.width * range.h + range.hOffset,
        y: viewport.mouse.y / viewport.screen.height * range.v + range.vOffset
    });
const move = (direction, force)=>(state)=>obj.patch(state, "player", {
            position: [
                state.player.position[0] + // front / back
                -Math.cos(degreeToRadiant(state.player.rotation + 45)) * direction[2] * force + Math.cos(degreeToRadiant(state.player.rotation - 45)) * direction[0] * force,
                state.player.position[1],
                state.player.position[2] + // front / back
                Math.sin(degreeToRadiant(state.player.rotation + 45)) * direction[2] * force + -Math.sin(degreeToRadiant(state.player.rotation - 45)) * direction[0] * force
            ]
        });
module.exports = {
    initial,
    counter,
    level,
    set,
    toggle,
    arrToggle,
    zoom,
    move
};

},{"1c8a65d6e47c04ea":"2lXuw","dc545a6d01575926":"6SQrn","27175040b3258a34":"daXoL"}],"6SQrn":[function(require,module,exports) {
"use strict";
// lib
const { obj } = require("ced435be652a83a5");
// initial state
const initial = {
    number: 0
};
// action
const set = (number)=>(state)=>obj.patch(state, "counter", {
            number
        });
const incr = ()=>(state)=>obj.patch(state, "counter", {
            number: state.counter.number + 1
        });
const decr = ()=>(state)=>obj.patch(state, "counter", {
            number: state.counter.number - 1
        });
module.exports = {
    initial,
    set,
    incr,
    decr
};

},{"ced435be652a83a5":"2lXuw"}],"daXoL":[function(require,module,exports) {
const initial = {
    map: [
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ],
        [
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1
        ],
        [
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1
        ],
        [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1
        ],
        [
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1
        ],
        [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ],
        [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ],
        [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ],
        [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ],
        [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ],
        [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ],
        [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ],
        [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ],
        [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ],
        [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ],
        [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    ],
    assets: [
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            4,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            1,
            0,
            0,
            0,
            2,
            0,
            0,
            0,
            2,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            4,
            0,
            0,
            0,
            0,
            0,
            4,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            2,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            4,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            4,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    ]
};
module.exports = {
    initial
};

},{}],"5ppKY":[function(require,module,exports) {
"use strict";
// dom
const { h1, h2, a, div, p, section, button, span, canvas, header, footer, audio } = require("8ff8f3c9a4ca8fd1");
// components
const controls = require("ebe9861ad7510f4d");
module.exports = ({ state, actions })=>section("#ui", [
        header([
            h1("Psy"),
            h2("Rogue")
        ]),
        section("#view3d"),
        footer([
            p("Click and drag to Rotate. Scroll to Zoom."),
            h2("User WASD keys to move, C to crouch")
        ]),
        div(".overlay"),
        controls({
            state,
            actions
        })
    ]);

},{"8ff8f3c9a4ca8fd1":"5SuSv","ebe9861ad7510f4d":"aZCbF"}],"aZCbF":[function(require,module,exports) {
"use strict";
// dom
const { header, h1, section, button, span, canvas, form, input, label, legend, fieldset, div, i } = require("50e7f413eccad82c");
// components
// const counter = require('./counter');
const { obj } = require("90e5952e7690b9fe");
const inputControl = ({ title, type, value, path }, actions)=>div([
        label({
            style: {
                paddingLeft: (path.length - 2) * 10 + "px"
            }
        }, title),
        input({
            attrs: {
                type
            },
            on: {
                input: (ev)=>actions.set(path, type === "number" ? parseFloat(ev.target.value) : ev.target.value)
            },
            props: {
                value
            }
        })
    ]);
const toggleControl = (path, value, actions)=>div(".toggle", {
        on: {
            click: ()=>actions.toggle(path)
        }
    }, [
        i(".fa", {
            class: {
                "fa-square-o": !value,
                "fa-check-square-o": value
            }
        }),
        path.slice(-1).pop()
    ]);
const parseFields = (data, path, actions)=>Object.keys(data).reduce((fields, field)=>[].concat(fields, obj.switch(typeof data[field], {
            default: ()=>inputControl({
                    title: field,
                    type: typeof data[field],
                    value: data[field],
                    path: [].concat(path, field)
                }, actions),
            object: ()=>div([].concat(label({
                    style: {
                        paddingLeft: (path.length - 1) * 10 + "px"
                    }
                }, field), parseFields(data[field], [].concat(path, field), actions))),
            boolean: ()=>toggleControl([].concat(path, field), data[field], actions)
        })()), []);
module.exports = ({ state, actions })=>form(".controls", [
        fieldset([].concat(legend({
            on: {
                click: ()=>actions.toggle([
                        "controls",
                        "camera"
                    ])
            }
        }, [
            i(".fa", {
                class: {
                    "fa-minus-square-o": state.controls.camera,
                    "fa-plus-square-o": !state.controls.camera
                }
            }),
            "Camera"
        ]), state.controls.camera && parseFields(state.camera, [
            "camera"
        ], actions) || [])),
        fieldset([
            legend("Viewport"),
            div(`Size: ${state.viewport.screen.width} x ${state.viewport.screen.height}`),
            div(`Mouse: ${state.viewport.mouse.x} x ${state.viewport.mouse.y}`)
        ]),
        fieldset([].concat(legend("Detection"), div(`Movement: ${state.player.force * 100}`), div(`Rotation: ${state.player.rotation.toFixed()}`), div(`Tile: ${parseInt((state.player.position[2] - 2.5) / 5 + state.level.map.length / 2, 10)} x ${parseInt((state.player.position[0] - 2.5) / 5 + state.level.map[0].length / 2, 10)}: ${[
            "grass",
            "pavement"
        ][state.level.map[parseInt((state.player.position[2] - 2.5) / 5 + state.level.map.length / 2, 10)][parseInt((state.player.position[0] - 2.5) / 5 + state.level.map[0].length / 2, 10)]]}`)))
    ]);

},{"50e7f413eccad82c":"5SuSv","90e5952e7690b9fe":"2lXuw"}],"7ia0b":[function(require,module,exports) {
"use strict";
// lib
const { interval, merge, of } = require("d9161c212f03c0c8");
const { map, filter, distinctUntilChanged, withLatestFrom, scan } = require("e9ab500b0da8be22");
// threejs
const THREE = require("262551039f9107c9");
window.THREE = window.THREE || THREE;
require("b69d19af197617c6");
const colladaLoader = require("cdbbfd8b1b2235b3");
const time = require("32c4a5a46759f75d");
const { obj, fn } = require("80e4bb2e83a5b838");
const level = require("7067a3244f17cf29");
const _camera = require("fd1cfc687e006d4b");
const _character = require("7b9f7365e4d326b");
const npcs = require("51947f3fbf55372c");
const init = ({ canvas, state })=>{
    let width = canvas.offsetWidth;
    let height = canvas.offsetHeight;
    // let camera = new THREE.PerspectiveCamera(70, width / height, 1, 1000);
    let camera = new THREE.PerspectiveCamera(45, width / height, 1, 1000);
    camera.position.z = 100;
    camera.position.y = 50;
    const scene = new THREE.Scene();
    // scene.add(new THREE.AmbientLight(0xcccccc, 0.1));
    // scene.add(new THREE.HemisphereLight(0x443333, 0x111122));
    // scene.add(new THREE.PointLight(0xffffff, 0.3));
    let dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.color.setHSL(0.1, 0, 0.1);
    dirLight.position.set(0.5, 1.5, -1);
    dirLight.position.multiplyScalar(30);
    dirLight.castShadow = true;
    dirLight.shadowCameraVisible = true;
    // var d = 200;
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.width = 1024;
    dirLight.shadow.mapSize.height = 1024;
    var d = 700;
    dirLight.shadow.camera.left = -d;
    dirLight.shadow.camera.right = d;
    dirLight.shadow.camera.top = d;
    dirLight.shadow.camera.bottom = -d;
    dirLight.shadow.camera.far = 2000;
    dirLight.shadow.bias = -0.001;
    scene.add(dirLight);
    let plane = false;
    let renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true
    });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(width, height);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    let effect = new THREE.OutlineEffect(renderer, {
        defaultThickness: 0.0005,
        defaultColor: new THREE.Color(`#1a2a7a`),
        defaultAlpha: 0.01
    });
    canvas.innerHTML = "";
    canvas.appendChild(renderer.domElement);
    level.init({
        scene,
        state
    });
    return {
        scene,
        light: false,
        renderer,
        effect,
        camera,
        canvas: renderer.domElement,
        plane
    };
};
let cameraAngle = {
    x: 45,
    y: 210
};
let mouse = false;
const render = ({ plane, scene, camera, effect, renderer, state, character, mixer, acts, guards })=>{
    // console.log(items);
    plane;
    camera = _camera.refresh({
        camera,
        state
    });
    _character.refresh({
        scene,
        character,
        mixer,
        acts,
        state,
        camera
    });
    if (guards) npcs.refresh({
        scene,
        guards,
        state
    });
    renderer.setSize(state.viewport.screen.width, state.viewport.screen.height);
    // renderer.setFaceCulling(0);
    // renderer.render(scene, camera);
    effect.render(scene, camera);
};
// const loadMap = (url, dim) => imageUtil.load(url)
// 	.map(image => imageUtil.getData(image, dim));
// .map(imageUtil.simplifyData);
let unhook = ()=>{};
let hook = ({ state$, actions })=>{
    let subs = [];
    const init$ = interval(100).pipe(map(()=>document.querySelector("#view3d")), distinctUntilChanged(), filter((el)=>el), withLatestFrom(state$, (canvas, state)=>({
            canvas,
            state
        })), map(({ canvas, state })=>()=>init({
                canvas,
                state
            })));
    const character$ = _character.init().pipe(map((data)=>(sceneState)=>{
            sceneState.scene.add(data.character);
            console.log(data.character);
            console.log(sceneState);
            return {
                ...sceneState,
                ...data
            };
        }));
    const npcs$ = npcs.init().pipe(map((guards)=>(sceneState)=>{
            console.log(guards);
            guards.forEach((guard)=>{
                sceneState.scene.add(guard.model);
            });
            console.log(sceneState);
            return {
                ...sceneState,
                guards
            };
        }));
    const sceneState$ = merge(init$, character$, npcs$).pipe(map((reducer)=>(console.log(reducer), reducer)), scan((sceneState, modify)=>modify(sceneState), {}));
    subs.push(time.frame().pipe(filter((dt, i)=>i % 2 === 0), withLatestFrom(sceneState$, state$, (dt, sceneState, state)=>({
            ...sceneState,
            state
        }))).subscribe(render));
    subs.push(()=>{
        console.log("cleaning up scene");
        let cleanupSub = of({}).pipe(withLatestFrom(sceneState$, (j, sceneState)=>sceneState)).subscribe(({ renderer })=>{
            renderer.dispose();
            cleanupSub.unsubscribe();
        });
    });
    unhook = ()=>{
        console.log(subs);
        subs.forEach((sub)=>sub.unsubscribe ? sub.unsubscribe() : sub());
    };
};
module.exports = {
    hook,
    unhook: ()=>unhook()
};

},{"d9161c212f03c0c8":"hWUVi","e9ab500b0da8be22":"1cs2r","262551039f9107c9":"5IrVb","b69d19af197617c6":"7g2Az","cdbbfd8b1b2235b3":"jdCb6","32c4a5a46759f75d":"1fT3w","80e4bb2e83a5b838":"2lXuw","7067a3244f17cf29":"2GmuD","fd1cfc687e006d4b":"izyq4","7b9f7365e4d326b":"7WKih","51947f3fbf55372c":"5tYyC"}],"5IrVb":[function(require,module,exports) {
// Polyfills
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "WebGLRenderTargetCube", ()=>WebGLRenderTargetCube);
parcelHelpers.export(exports, "WebGLRenderTarget", ()=>WebGLRenderTarget);
parcelHelpers.export(exports, "WebGLRenderer", ()=>WebGLRenderer);
parcelHelpers.export(exports, "ShaderLib", ()=>ShaderLib);
parcelHelpers.export(exports, "UniformsLib", ()=>UniformsLib);
parcelHelpers.export(exports, "UniformsUtils", ()=>UniformsUtils);
parcelHelpers.export(exports, "ShaderChunk", ()=>ShaderChunk);
parcelHelpers.export(exports, "FogExp2", ()=>FogExp2);
parcelHelpers.export(exports, "Fog", ()=>Fog);
parcelHelpers.export(exports, "Scene", ()=>Scene);
parcelHelpers.export(exports, "Sprite", ()=>Sprite);
parcelHelpers.export(exports, "LOD", ()=>LOD);
parcelHelpers.export(exports, "SkinnedMesh", ()=>SkinnedMesh);
parcelHelpers.export(exports, "Skeleton", ()=>Skeleton);
parcelHelpers.export(exports, "Bone", ()=>Bone);
parcelHelpers.export(exports, "Mesh", ()=>Mesh);
parcelHelpers.export(exports, "LineSegments", ()=>LineSegments);
parcelHelpers.export(exports, "LineLoop", ()=>LineLoop);
parcelHelpers.export(exports, "Line", ()=>Line);
parcelHelpers.export(exports, "Points", ()=>Points);
parcelHelpers.export(exports, "Group", ()=>Group);
parcelHelpers.export(exports, "VideoTexture", ()=>VideoTexture);
parcelHelpers.export(exports, "DataTexture", ()=>DataTexture);
parcelHelpers.export(exports, "DataTexture3D", ()=>DataTexture3D);
parcelHelpers.export(exports, "CompressedTexture", ()=>CompressedTexture);
parcelHelpers.export(exports, "CubeTexture", ()=>CubeTexture);
parcelHelpers.export(exports, "CanvasTexture", ()=>CanvasTexture);
parcelHelpers.export(exports, "DepthTexture", ()=>DepthTexture);
parcelHelpers.export(exports, "Texture", ()=>Texture);
parcelHelpers.export(exports, "AnimationLoader", ()=>AnimationLoader);
parcelHelpers.export(exports, "CompressedTextureLoader", ()=>CompressedTextureLoader);
parcelHelpers.export(exports, "DataTextureLoader", ()=>DataTextureLoader);
parcelHelpers.export(exports, "CubeTextureLoader", ()=>CubeTextureLoader);
parcelHelpers.export(exports, "TextureLoader", ()=>TextureLoader);
parcelHelpers.export(exports, "ObjectLoader", ()=>ObjectLoader);
parcelHelpers.export(exports, "MaterialLoader", ()=>MaterialLoader);
parcelHelpers.export(exports, "BufferGeometryLoader", ()=>BufferGeometryLoader);
parcelHelpers.export(exports, "DefaultLoadingManager", ()=>DefaultLoadingManager);
parcelHelpers.export(exports, "LoadingManager", ()=>LoadingManager);
parcelHelpers.export(exports, "ImageLoader", ()=>ImageLoader);
parcelHelpers.export(exports, "ImageBitmapLoader", ()=>ImageBitmapLoader);
parcelHelpers.export(exports, "FontLoader", ()=>FontLoader);
parcelHelpers.export(exports, "FileLoader", ()=>FileLoader);
parcelHelpers.export(exports, "Loader", ()=>Loader);
parcelHelpers.export(exports, "LoaderUtils", ()=>LoaderUtils);
parcelHelpers.export(exports, "Cache", ()=>Cache);
parcelHelpers.export(exports, "AudioLoader", ()=>AudioLoader);
parcelHelpers.export(exports, "SpotLightShadow", ()=>SpotLightShadow);
parcelHelpers.export(exports, "SpotLight", ()=>SpotLight);
parcelHelpers.export(exports, "PointLight", ()=>PointLight);
parcelHelpers.export(exports, "RectAreaLight", ()=>RectAreaLight);
parcelHelpers.export(exports, "HemisphereLight", ()=>HemisphereLight);
parcelHelpers.export(exports, "DirectionalLightShadow", ()=>DirectionalLightShadow);
parcelHelpers.export(exports, "DirectionalLight", ()=>DirectionalLight);
parcelHelpers.export(exports, "AmbientLight", ()=>AmbientLight);
parcelHelpers.export(exports, "LightShadow", ()=>LightShadow);
parcelHelpers.export(exports, "Light", ()=>Light);
parcelHelpers.export(exports, "StereoCamera", ()=>StereoCamera);
parcelHelpers.export(exports, "PerspectiveCamera", ()=>PerspectiveCamera);
parcelHelpers.export(exports, "OrthographicCamera", ()=>OrthographicCamera);
parcelHelpers.export(exports, "CubeCamera", ()=>CubeCamera);
parcelHelpers.export(exports, "ArrayCamera", ()=>ArrayCamera);
parcelHelpers.export(exports, "Camera", ()=>Camera);
parcelHelpers.export(exports, "AudioListener", ()=>AudioListener);
parcelHelpers.export(exports, "PositionalAudio", ()=>PositionalAudio);
parcelHelpers.export(exports, "AudioContext", ()=>AudioContext);
parcelHelpers.export(exports, "AudioAnalyser", ()=>AudioAnalyser);
parcelHelpers.export(exports, "Audio", ()=>Audio);
parcelHelpers.export(exports, "VectorKeyframeTrack", ()=>VectorKeyframeTrack);
parcelHelpers.export(exports, "StringKeyframeTrack", ()=>StringKeyframeTrack);
parcelHelpers.export(exports, "QuaternionKeyframeTrack", ()=>QuaternionKeyframeTrack);
parcelHelpers.export(exports, "NumberKeyframeTrack", ()=>NumberKeyframeTrack);
parcelHelpers.export(exports, "ColorKeyframeTrack", ()=>ColorKeyframeTrack);
parcelHelpers.export(exports, "BooleanKeyframeTrack", ()=>BooleanKeyframeTrack);
parcelHelpers.export(exports, "PropertyMixer", ()=>PropertyMixer);
parcelHelpers.export(exports, "PropertyBinding", ()=>PropertyBinding);
parcelHelpers.export(exports, "KeyframeTrack", ()=>KeyframeTrack);
parcelHelpers.export(exports, "AnimationUtils", ()=>AnimationUtils);
parcelHelpers.export(exports, "AnimationObjectGroup", ()=>AnimationObjectGroup);
parcelHelpers.export(exports, "AnimationMixer", ()=>AnimationMixer);
parcelHelpers.export(exports, "AnimationClip", ()=>AnimationClip);
parcelHelpers.export(exports, "Uniform", ()=>Uniform);
parcelHelpers.export(exports, "InstancedBufferGeometry", ()=>InstancedBufferGeometry);
parcelHelpers.export(exports, "BufferGeometry", ()=>BufferGeometry);
parcelHelpers.export(exports, "Geometry", ()=>Geometry);
parcelHelpers.export(exports, "InterleavedBufferAttribute", ()=>InterleavedBufferAttribute);
parcelHelpers.export(exports, "InstancedInterleavedBuffer", ()=>InstancedInterleavedBuffer);
parcelHelpers.export(exports, "InterleavedBuffer", ()=>InterleavedBuffer);
parcelHelpers.export(exports, "InstancedBufferAttribute", ()=>InstancedBufferAttribute);
parcelHelpers.export(exports, "Face3", ()=>Face3);
parcelHelpers.export(exports, "Object3D", ()=>Object3D);
parcelHelpers.export(exports, "Raycaster", ()=>Raycaster);
parcelHelpers.export(exports, "Layers", ()=>Layers);
parcelHelpers.export(exports, "EventDispatcher", ()=>EventDispatcher);
parcelHelpers.export(exports, "Clock", ()=>Clock);
parcelHelpers.export(exports, "QuaternionLinearInterpolant", ()=>QuaternionLinearInterpolant);
parcelHelpers.export(exports, "LinearInterpolant", ()=>LinearInterpolant);
parcelHelpers.export(exports, "DiscreteInterpolant", ()=>DiscreteInterpolant);
parcelHelpers.export(exports, "CubicInterpolant", ()=>CubicInterpolant);
parcelHelpers.export(exports, "Interpolant", ()=>Interpolant);
parcelHelpers.export(exports, "Triangle", ()=>Triangle);
parcelHelpers.export(exports, "Math", ()=>_Math);
parcelHelpers.export(exports, "Spherical", ()=>Spherical);
parcelHelpers.export(exports, "Cylindrical", ()=>Cylindrical);
parcelHelpers.export(exports, "Plane", ()=>Plane);
parcelHelpers.export(exports, "Frustum", ()=>Frustum);
parcelHelpers.export(exports, "Sphere", ()=>Sphere);
parcelHelpers.export(exports, "Ray", ()=>Ray);
parcelHelpers.export(exports, "Matrix4", ()=>Matrix4);
parcelHelpers.export(exports, "Matrix3", ()=>Matrix3);
parcelHelpers.export(exports, "Box3", ()=>Box3);
parcelHelpers.export(exports, "Box2", ()=>Box2);
parcelHelpers.export(exports, "Line3", ()=>Line3);
parcelHelpers.export(exports, "Euler", ()=>Euler);
parcelHelpers.export(exports, "Vector4", ()=>Vector4);
parcelHelpers.export(exports, "Vector3", ()=>Vector3);
parcelHelpers.export(exports, "Vector2", ()=>Vector2);
parcelHelpers.export(exports, "Quaternion", ()=>Quaternion);
parcelHelpers.export(exports, "Color", ()=>Color);
parcelHelpers.export(exports, "ImmediateRenderObject", ()=>ImmediateRenderObject);
parcelHelpers.export(exports, "VertexNormalsHelper", ()=>VertexNormalsHelper);
parcelHelpers.export(exports, "SpotLightHelper", ()=>SpotLightHelper);
parcelHelpers.export(exports, "SkeletonHelper", ()=>SkeletonHelper);
parcelHelpers.export(exports, "PointLightHelper", ()=>PointLightHelper);
parcelHelpers.export(exports, "RectAreaLightHelper", ()=>RectAreaLightHelper);
parcelHelpers.export(exports, "HemisphereLightHelper", ()=>HemisphereLightHelper);
parcelHelpers.export(exports, "GridHelper", ()=>GridHelper);
parcelHelpers.export(exports, "PolarGridHelper", ()=>PolarGridHelper);
parcelHelpers.export(exports, "FaceNormalsHelper", ()=>FaceNormalsHelper);
parcelHelpers.export(exports, "DirectionalLightHelper", ()=>DirectionalLightHelper);
parcelHelpers.export(exports, "CameraHelper", ()=>CameraHelper);
parcelHelpers.export(exports, "BoxHelper", ()=>BoxHelper);
parcelHelpers.export(exports, "Box3Helper", ()=>Box3Helper);
parcelHelpers.export(exports, "PlaneHelper", ()=>PlaneHelper);
parcelHelpers.export(exports, "ArrowHelper", ()=>ArrowHelper);
parcelHelpers.export(exports, "AxesHelper", ()=>AxesHelper);
parcelHelpers.export(exports, "Shape", ()=>Shape);
parcelHelpers.export(exports, "Path", ()=>Path);
parcelHelpers.export(exports, "ShapePath", ()=>ShapePath);
parcelHelpers.export(exports, "Font", ()=>Font);
parcelHelpers.export(exports, "CurvePath", ()=>CurvePath);
parcelHelpers.export(exports, "Curve", ()=>Curve);
parcelHelpers.export(exports, "ImageUtils", ()=>ImageUtils);
parcelHelpers.export(exports, "ShapeUtils", ()=>ShapeUtils);
parcelHelpers.export(exports, "WebGLUtils", ()=>WebGLUtils);
parcelHelpers.export(exports, "WireframeGeometry", ()=>WireframeGeometry);
parcelHelpers.export(exports, "ParametricGeometry", ()=>ParametricGeometry);
parcelHelpers.export(exports, "ParametricBufferGeometry", ()=>ParametricBufferGeometry);
parcelHelpers.export(exports, "TetrahedronGeometry", ()=>TetrahedronGeometry);
parcelHelpers.export(exports, "TetrahedronBufferGeometry", ()=>TetrahedronBufferGeometry);
parcelHelpers.export(exports, "OctahedronGeometry", ()=>OctahedronGeometry);
parcelHelpers.export(exports, "OctahedronBufferGeometry", ()=>OctahedronBufferGeometry);
parcelHelpers.export(exports, "IcosahedronGeometry", ()=>IcosahedronGeometry);
parcelHelpers.export(exports, "IcosahedronBufferGeometry", ()=>IcosahedronBufferGeometry);
parcelHelpers.export(exports, "DodecahedronGeometry", ()=>DodecahedronGeometry);
parcelHelpers.export(exports, "DodecahedronBufferGeometry", ()=>DodecahedronBufferGeometry);
parcelHelpers.export(exports, "PolyhedronGeometry", ()=>PolyhedronGeometry);
parcelHelpers.export(exports, "PolyhedronBufferGeometry", ()=>PolyhedronBufferGeometry);
parcelHelpers.export(exports, "TubeGeometry", ()=>TubeGeometry);
parcelHelpers.export(exports, "TubeBufferGeometry", ()=>TubeBufferGeometry);
parcelHelpers.export(exports, "TorusKnotGeometry", ()=>TorusKnotGeometry);
parcelHelpers.export(exports, "TorusKnotBufferGeometry", ()=>TorusKnotBufferGeometry);
parcelHelpers.export(exports, "TorusGeometry", ()=>TorusGeometry);
parcelHelpers.export(exports, "TorusBufferGeometry", ()=>TorusBufferGeometry);
parcelHelpers.export(exports, "TextGeometry", ()=>TextGeometry);
parcelHelpers.export(exports, "TextBufferGeometry", ()=>TextBufferGeometry);
parcelHelpers.export(exports, "SphereGeometry", ()=>SphereGeometry);
parcelHelpers.export(exports, "SphereBufferGeometry", ()=>SphereBufferGeometry);
parcelHelpers.export(exports, "RingGeometry", ()=>RingGeometry);
parcelHelpers.export(exports, "RingBufferGeometry", ()=>RingBufferGeometry);
parcelHelpers.export(exports, "PlaneGeometry", ()=>PlaneGeometry);
parcelHelpers.export(exports, "PlaneBufferGeometry", ()=>PlaneBufferGeometry);
parcelHelpers.export(exports, "LatheGeometry", ()=>LatheGeometry);
parcelHelpers.export(exports, "LatheBufferGeometry", ()=>LatheBufferGeometry);
parcelHelpers.export(exports, "ShapeGeometry", ()=>ShapeGeometry);
parcelHelpers.export(exports, "ShapeBufferGeometry", ()=>ShapeBufferGeometry);
parcelHelpers.export(exports, "ExtrudeGeometry", ()=>ExtrudeGeometry);
parcelHelpers.export(exports, "ExtrudeBufferGeometry", ()=>ExtrudeBufferGeometry);
parcelHelpers.export(exports, "EdgesGeometry", ()=>EdgesGeometry);
parcelHelpers.export(exports, "ConeGeometry", ()=>ConeGeometry);
parcelHelpers.export(exports, "ConeBufferGeometry", ()=>ConeBufferGeometry);
parcelHelpers.export(exports, "CylinderGeometry", ()=>CylinderGeometry);
parcelHelpers.export(exports, "CylinderBufferGeometry", ()=>CylinderBufferGeometry);
parcelHelpers.export(exports, "CircleGeometry", ()=>CircleGeometry);
parcelHelpers.export(exports, "CircleBufferGeometry", ()=>CircleBufferGeometry);
parcelHelpers.export(exports, "BoxGeometry", ()=>BoxGeometry);
parcelHelpers.export(exports, "BoxBufferGeometry", ()=>BoxBufferGeometry);
parcelHelpers.export(exports, "ShadowMaterial", ()=>ShadowMaterial);
parcelHelpers.export(exports, "SpriteMaterial", ()=>SpriteMaterial);
parcelHelpers.export(exports, "RawShaderMaterial", ()=>RawShaderMaterial);
parcelHelpers.export(exports, "ShaderMaterial", ()=>ShaderMaterial);
parcelHelpers.export(exports, "PointsMaterial", ()=>PointsMaterial);
parcelHelpers.export(exports, "MeshPhysicalMaterial", ()=>MeshPhysicalMaterial);
parcelHelpers.export(exports, "MeshStandardMaterial", ()=>MeshStandardMaterial);
parcelHelpers.export(exports, "MeshPhongMaterial", ()=>MeshPhongMaterial);
parcelHelpers.export(exports, "MeshToonMaterial", ()=>MeshToonMaterial);
parcelHelpers.export(exports, "MeshNormalMaterial", ()=>MeshNormalMaterial);
parcelHelpers.export(exports, "MeshLambertMaterial", ()=>MeshLambertMaterial);
parcelHelpers.export(exports, "MeshDepthMaterial", ()=>MeshDepthMaterial);
parcelHelpers.export(exports, "MeshDistanceMaterial", ()=>MeshDistanceMaterial);
parcelHelpers.export(exports, "MeshBasicMaterial", ()=>MeshBasicMaterial);
parcelHelpers.export(exports, "MeshMatcapMaterial", ()=>MeshMatcapMaterial);
parcelHelpers.export(exports, "LineDashedMaterial", ()=>LineDashedMaterial);
parcelHelpers.export(exports, "LineBasicMaterial", ()=>LineBasicMaterial);
parcelHelpers.export(exports, "Material", ()=>Material);
parcelHelpers.export(exports, "Float64BufferAttribute", ()=>Float64BufferAttribute);
parcelHelpers.export(exports, "Float32BufferAttribute", ()=>Float32BufferAttribute);
parcelHelpers.export(exports, "Uint32BufferAttribute", ()=>Uint32BufferAttribute);
parcelHelpers.export(exports, "Int32BufferAttribute", ()=>Int32BufferAttribute);
parcelHelpers.export(exports, "Uint16BufferAttribute", ()=>Uint16BufferAttribute);
parcelHelpers.export(exports, "Int16BufferAttribute", ()=>Int16BufferAttribute);
parcelHelpers.export(exports, "Uint8ClampedBufferAttribute", ()=>Uint8ClampedBufferAttribute);
parcelHelpers.export(exports, "Uint8BufferAttribute", ()=>Uint8BufferAttribute);
parcelHelpers.export(exports, "Int8BufferAttribute", ()=>Int8BufferAttribute);
parcelHelpers.export(exports, "BufferAttribute", ()=>BufferAttribute);
parcelHelpers.export(exports, "ArcCurve", ()=>ArcCurve);
parcelHelpers.export(exports, "CatmullRomCurve3", ()=>CatmullRomCurve3);
parcelHelpers.export(exports, "CubicBezierCurve", ()=>CubicBezierCurve);
parcelHelpers.export(exports, "CubicBezierCurve3", ()=>CubicBezierCurve3);
parcelHelpers.export(exports, "EllipseCurve", ()=>EllipseCurve);
parcelHelpers.export(exports, "LineCurve", ()=>LineCurve);
parcelHelpers.export(exports, "LineCurve3", ()=>LineCurve3);
parcelHelpers.export(exports, "QuadraticBezierCurve", ()=>QuadraticBezierCurve);
parcelHelpers.export(exports, "QuadraticBezierCurve3", ()=>QuadraticBezierCurve3);
parcelHelpers.export(exports, "SplineCurve", ()=>SplineCurve);
parcelHelpers.export(exports, "REVISION", ()=>REVISION);
parcelHelpers.export(exports, "MOUSE", ()=>MOUSE);
parcelHelpers.export(exports, "CullFaceNone", ()=>CullFaceNone);
parcelHelpers.export(exports, "CullFaceBack", ()=>CullFaceBack);
parcelHelpers.export(exports, "CullFaceFront", ()=>CullFaceFront);
parcelHelpers.export(exports, "CullFaceFrontBack", ()=>CullFaceFrontBack);
parcelHelpers.export(exports, "FrontFaceDirectionCW", ()=>FrontFaceDirectionCW);
parcelHelpers.export(exports, "FrontFaceDirectionCCW", ()=>FrontFaceDirectionCCW);
parcelHelpers.export(exports, "BasicShadowMap", ()=>BasicShadowMap);
parcelHelpers.export(exports, "PCFShadowMap", ()=>PCFShadowMap);
parcelHelpers.export(exports, "PCFSoftShadowMap", ()=>PCFSoftShadowMap);
parcelHelpers.export(exports, "FrontSide", ()=>FrontSide);
parcelHelpers.export(exports, "BackSide", ()=>BackSide);
parcelHelpers.export(exports, "DoubleSide", ()=>DoubleSide);
parcelHelpers.export(exports, "FlatShading", ()=>FlatShading);
parcelHelpers.export(exports, "SmoothShading", ()=>SmoothShading);
parcelHelpers.export(exports, "NoColors", ()=>NoColors);
parcelHelpers.export(exports, "FaceColors", ()=>FaceColors);
parcelHelpers.export(exports, "VertexColors", ()=>VertexColors);
parcelHelpers.export(exports, "NoBlending", ()=>NoBlending);
parcelHelpers.export(exports, "NormalBlending", ()=>NormalBlending);
parcelHelpers.export(exports, "AdditiveBlending", ()=>AdditiveBlending);
parcelHelpers.export(exports, "SubtractiveBlending", ()=>SubtractiveBlending);
parcelHelpers.export(exports, "MultiplyBlending", ()=>MultiplyBlending);
parcelHelpers.export(exports, "CustomBlending", ()=>CustomBlending);
parcelHelpers.export(exports, "AddEquation", ()=>AddEquation);
parcelHelpers.export(exports, "SubtractEquation", ()=>SubtractEquation);
parcelHelpers.export(exports, "ReverseSubtractEquation", ()=>ReverseSubtractEquation);
parcelHelpers.export(exports, "MinEquation", ()=>MinEquation);
parcelHelpers.export(exports, "MaxEquation", ()=>MaxEquation);
parcelHelpers.export(exports, "ZeroFactor", ()=>ZeroFactor);
parcelHelpers.export(exports, "OneFactor", ()=>OneFactor);
parcelHelpers.export(exports, "SrcColorFactor", ()=>SrcColorFactor);
parcelHelpers.export(exports, "OneMinusSrcColorFactor", ()=>OneMinusSrcColorFactor);
parcelHelpers.export(exports, "SrcAlphaFactor", ()=>SrcAlphaFactor);
parcelHelpers.export(exports, "OneMinusSrcAlphaFactor", ()=>OneMinusSrcAlphaFactor);
parcelHelpers.export(exports, "DstAlphaFactor", ()=>DstAlphaFactor);
parcelHelpers.export(exports, "OneMinusDstAlphaFactor", ()=>OneMinusDstAlphaFactor);
parcelHelpers.export(exports, "DstColorFactor", ()=>DstColorFactor);
parcelHelpers.export(exports, "OneMinusDstColorFactor", ()=>OneMinusDstColorFactor);
parcelHelpers.export(exports, "SrcAlphaSaturateFactor", ()=>SrcAlphaSaturateFactor);
parcelHelpers.export(exports, "NeverDepth", ()=>NeverDepth);
parcelHelpers.export(exports, "AlwaysDepth", ()=>AlwaysDepth);
parcelHelpers.export(exports, "LessDepth", ()=>LessDepth);
parcelHelpers.export(exports, "LessEqualDepth", ()=>LessEqualDepth);
parcelHelpers.export(exports, "EqualDepth", ()=>EqualDepth);
parcelHelpers.export(exports, "GreaterEqualDepth", ()=>GreaterEqualDepth);
parcelHelpers.export(exports, "GreaterDepth", ()=>GreaterDepth);
parcelHelpers.export(exports, "NotEqualDepth", ()=>NotEqualDepth);
parcelHelpers.export(exports, "MultiplyOperation", ()=>MultiplyOperation);
parcelHelpers.export(exports, "MixOperation", ()=>MixOperation);
parcelHelpers.export(exports, "AddOperation", ()=>AddOperation);
parcelHelpers.export(exports, "NoToneMapping", ()=>NoToneMapping);
parcelHelpers.export(exports, "LinearToneMapping", ()=>LinearToneMapping);
parcelHelpers.export(exports, "ReinhardToneMapping", ()=>ReinhardToneMapping);
parcelHelpers.export(exports, "Uncharted2ToneMapping", ()=>Uncharted2ToneMapping);
parcelHelpers.export(exports, "CineonToneMapping", ()=>CineonToneMapping);
parcelHelpers.export(exports, "ACESFilmicToneMapping", ()=>ACESFilmicToneMapping);
parcelHelpers.export(exports, "UVMapping", ()=>UVMapping);
parcelHelpers.export(exports, "CubeReflectionMapping", ()=>CubeReflectionMapping);
parcelHelpers.export(exports, "CubeRefractionMapping", ()=>CubeRefractionMapping);
parcelHelpers.export(exports, "EquirectangularReflectionMapping", ()=>EquirectangularReflectionMapping);
parcelHelpers.export(exports, "EquirectangularRefractionMapping", ()=>EquirectangularRefractionMapping);
parcelHelpers.export(exports, "SphericalReflectionMapping", ()=>SphericalReflectionMapping);
parcelHelpers.export(exports, "CubeUVReflectionMapping", ()=>CubeUVReflectionMapping);
parcelHelpers.export(exports, "CubeUVRefractionMapping", ()=>CubeUVRefractionMapping);
parcelHelpers.export(exports, "RepeatWrapping", ()=>RepeatWrapping);
parcelHelpers.export(exports, "ClampToEdgeWrapping", ()=>ClampToEdgeWrapping);
parcelHelpers.export(exports, "MirroredRepeatWrapping", ()=>MirroredRepeatWrapping);
parcelHelpers.export(exports, "NearestFilter", ()=>NearestFilter);
parcelHelpers.export(exports, "NearestMipMapNearestFilter", ()=>NearestMipMapNearestFilter);
parcelHelpers.export(exports, "NearestMipMapLinearFilter", ()=>NearestMipMapLinearFilter);
parcelHelpers.export(exports, "LinearFilter", ()=>LinearFilter);
parcelHelpers.export(exports, "LinearMipMapNearestFilter", ()=>LinearMipMapNearestFilter);
parcelHelpers.export(exports, "LinearMipMapLinearFilter", ()=>LinearMipMapLinearFilter);
parcelHelpers.export(exports, "UnsignedByteType", ()=>UnsignedByteType);
parcelHelpers.export(exports, "ByteType", ()=>ByteType);
parcelHelpers.export(exports, "ShortType", ()=>ShortType);
parcelHelpers.export(exports, "UnsignedShortType", ()=>UnsignedShortType);
parcelHelpers.export(exports, "IntType", ()=>IntType);
parcelHelpers.export(exports, "UnsignedIntType", ()=>UnsignedIntType);
parcelHelpers.export(exports, "FloatType", ()=>FloatType);
parcelHelpers.export(exports, "HalfFloatType", ()=>HalfFloatType);
parcelHelpers.export(exports, "UnsignedShort4444Type", ()=>UnsignedShort4444Type);
parcelHelpers.export(exports, "UnsignedShort5551Type", ()=>UnsignedShort5551Type);
parcelHelpers.export(exports, "UnsignedShort565Type", ()=>UnsignedShort565Type);
parcelHelpers.export(exports, "UnsignedInt248Type", ()=>UnsignedInt248Type);
parcelHelpers.export(exports, "AlphaFormat", ()=>AlphaFormat);
parcelHelpers.export(exports, "RGBFormat", ()=>RGBFormat);
parcelHelpers.export(exports, "RGBAFormat", ()=>RGBAFormat);
parcelHelpers.export(exports, "LuminanceFormat", ()=>LuminanceFormat);
parcelHelpers.export(exports, "LuminanceAlphaFormat", ()=>LuminanceAlphaFormat);
parcelHelpers.export(exports, "RGBEFormat", ()=>RGBEFormat);
parcelHelpers.export(exports, "DepthFormat", ()=>DepthFormat);
parcelHelpers.export(exports, "DepthStencilFormat", ()=>DepthStencilFormat);
parcelHelpers.export(exports, "RedFormat", ()=>RedFormat);
parcelHelpers.export(exports, "RGB_S3TC_DXT1_Format", ()=>RGB_S3TC_DXT1_Format);
parcelHelpers.export(exports, "RGBA_S3TC_DXT1_Format", ()=>RGBA_S3TC_DXT1_Format);
parcelHelpers.export(exports, "RGBA_S3TC_DXT3_Format", ()=>RGBA_S3TC_DXT3_Format);
parcelHelpers.export(exports, "RGBA_S3TC_DXT5_Format", ()=>RGBA_S3TC_DXT5_Format);
parcelHelpers.export(exports, "RGB_PVRTC_4BPPV1_Format", ()=>RGB_PVRTC_4BPPV1_Format);
parcelHelpers.export(exports, "RGB_PVRTC_2BPPV1_Format", ()=>RGB_PVRTC_2BPPV1_Format);
parcelHelpers.export(exports, "RGBA_PVRTC_4BPPV1_Format", ()=>RGBA_PVRTC_4BPPV1_Format);
parcelHelpers.export(exports, "RGBA_PVRTC_2BPPV1_Format", ()=>RGBA_PVRTC_2BPPV1_Format);
parcelHelpers.export(exports, "RGB_ETC1_Format", ()=>RGB_ETC1_Format);
parcelHelpers.export(exports, "RGBA_ASTC_4x4_Format", ()=>RGBA_ASTC_4x4_Format);
parcelHelpers.export(exports, "RGBA_ASTC_5x4_Format", ()=>RGBA_ASTC_5x4_Format);
parcelHelpers.export(exports, "RGBA_ASTC_5x5_Format", ()=>RGBA_ASTC_5x5_Format);
parcelHelpers.export(exports, "RGBA_ASTC_6x5_Format", ()=>RGBA_ASTC_6x5_Format);
parcelHelpers.export(exports, "RGBA_ASTC_6x6_Format", ()=>RGBA_ASTC_6x6_Format);
parcelHelpers.export(exports, "RGBA_ASTC_8x5_Format", ()=>RGBA_ASTC_8x5_Format);
parcelHelpers.export(exports, "RGBA_ASTC_8x6_Format", ()=>RGBA_ASTC_8x6_Format);
parcelHelpers.export(exports, "RGBA_ASTC_8x8_Format", ()=>RGBA_ASTC_8x8_Format);
parcelHelpers.export(exports, "RGBA_ASTC_10x5_Format", ()=>RGBA_ASTC_10x5_Format);
parcelHelpers.export(exports, "RGBA_ASTC_10x6_Format", ()=>RGBA_ASTC_10x6_Format);
parcelHelpers.export(exports, "RGBA_ASTC_10x8_Format", ()=>RGBA_ASTC_10x8_Format);
parcelHelpers.export(exports, "RGBA_ASTC_10x10_Format", ()=>RGBA_ASTC_10x10_Format);
parcelHelpers.export(exports, "RGBA_ASTC_12x10_Format", ()=>RGBA_ASTC_12x10_Format);
parcelHelpers.export(exports, "RGBA_ASTC_12x12_Format", ()=>RGBA_ASTC_12x12_Format);
parcelHelpers.export(exports, "LoopOnce", ()=>LoopOnce);
parcelHelpers.export(exports, "LoopRepeat", ()=>LoopRepeat);
parcelHelpers.export(exports, "LoopPingPong", ()=>LoopPingPong);
parcelHelpers.export(exports, "InterpolateDiscrete", ()=>InterpolateDiscrete);
parcelHelpers.export(exports, "InterpolateLinear", ()=>InterpolateLinear);
parcelHelpers.export(exports, "InterpolateSmooth", ()=>InterpolateSmooth);
parcelHelpers.export(exports, "ZeroCurvatureEnding", ()=>ZeroCurvatureEnding);
parcelHelpers.export(exports, "ZeroSlopeEnding", ()=>ZeroSlopeEnding);
parcelHelpers.export(exports, "WrapAroundEnding", ()=>WrapAroundEnding);
parcelHelpers.export(exports, "TrianglesDrawMode", ()=>TrianglesDrawMode);
parcelHelpers.export(exports, "TriangleStripDrawMode", ()=>TriangleStripDrawMode);
parcelHelpers.export(exports, "TriangleFanDrawMode", ()=>TriangleFanDrawMode);
parcelHelpers.export(exports, "LinearEncoding", ()=>LinearEncoding);
parcelHelpers.export(exports, "sRGBEncoding", ()=>sRGBEncoding);
parcelHelpers.export(exports, "GammaEncoding", ()=>GammaEncoding);
parcelHelpers.export(exports, "RGBEEncoding", ()=>RGBEEncoding);
parcelHelpers.export(exports, "LogLuvEncoding", ()=>LogLuvEncoding);
parcelHelpers.export(exports, "RGBM7Encoding", ()=>RGBM7Encoding);
parcelHelpers.export(exports, "RGBM16Encoding", ()=>RGBM16Encoding);
parcelHelpers.export(exports, "RGBDEncoding", ()=>RGBDEncoding);
parcelHelpers.export(exports, "BasicDepthPacking", ()=>BasicDepthPacking);
parcelHelpers.export(exports, "RGBADepthPacking", ()=>RGBADepthPacking);
parcelHelpers.export(exports, "TangentSpaceNormalMap", ()=>TangentSpaceNormalMap);
parcelHelpers.export(exports, "ObjectSpaceNormalMap", ()=>ObjectSpaceNormalMap);
parcelHelpers.export(exports, "CubeGeometry", ()=>BoxGeometry);
parcelHelpers.export(exports, "Face4", ()=>Face4);
parcelHelpers.export(exports, "LineStrip", ()=>LineStrip);
parcelHelpers.export(exports, "LinePieces", ()=>LinePieces);
parcelHelpers.export(exports, "MeshFaceMaterial", ()=>MeshFaceMaterial);
parcelHelpers.export(exports, "MultiMaterial", ()=>MultiMaterial);
parcelHelpers.export(exports, "PointCloud", ()=>PointCloud);
parcelHelpers.export(exports, "Particle", ()=>Particle);
parcelHelpers.export(exports, "ParticleSystem", ()=>ParticleSystem);
parcelHelpers.export(exports, "PointCloudMaterial", ()=>PointCloudMaterial);
parcelHelpers.export(exports, "ParticleBasicMaterial", ()=>ParticleBasicMaterial);
parcelHelpers.export(exports, "ParticleSystemMaterial", ()=>ParticleSystemMaterial);
parcelHelpers.export(exports, "Vertex", ()=>Vertex);
parcelHelpers.export(exports, "DynamicBufferAttribute", ()=>DynamicBufferAttribute);
parcelHelpers.export(exports, "Int8Attribute", ()=>Int8Attribute);
parcelHelpers.export(exports, "Uint8Attribute", ()=>Uint8Attribute);
parcelHelpers.export(exports, "Uint8ClampedAttribute", ()=>Uint8ClampedAttribute);
parcelHelpers.export(exports, "Int16Attribute", ()=>Int16Attribute);
parcelHelpers.export(exports, "Uint16Attribute", ()=>Uint16Attribute);
parcelHelpers.export(exports, "Int32Attribute", ()=>Int32Attribute);
parcelHelpers.export(exports, "Uint32Attribute", ()=>Uint32Attribute);
parcelHelpers.export(exports, "Float32Attribute", ()=>Float32Attribute);
parcelHelpers.export(exports, "Float64Attribute", ()=>Float64Attribute);
parcelHelpers.export(exports, "ClosedSplineCurve3", ()=>ClosedSplineCurve3);
parcelHelpers.export(exports, "SplineCurve3", ()=>SplineCurve3);
parcelHelpers.export(exports, "Spline", ()=>Spline);
parcelHelpers.export(exports, "AxisHelper", ()=>AxisHelper);
parcelHelpers.export(exports, "BoundingBoxHelper", ()=>BoundingBoxHelper);
parcelHelpers.export(exports, "EdgesHelper", ()=>EdgesHelper);
parcelHelpers.export(exports, "WireframeHelper", ()=>WireframeHelper);
parcelHelpers.export(exports, "XHRLoader", ()=>XHRLoader);
parcelHelpers.export(exports, "BinaryTextureLoader", ()=>BinaryTextureLoader);
parcelHelpers.export(exports, "GeometryUtils", ()=>GeometryUtils);
parcelHelpers.export(exports, "Projector", ()=>Projector);
parcelHelpers.export(exports, "CanvasRenderer", ()=>CanvasRenderer);
parcelHelpers.export(exports, "JSONLoader", ()=>JSONLoader);
parcelHelpers.export(exports, "SceneUtils", ()=>SceneUtils);
parcelHelpers.export(exports, "LensFlare", ()=>LensFlare);
if (Number.EPSILON === undefined) Number.EPSILON = Math.pow(2, -52);
if (Number.isInteger === undefined) // Missing in IE
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger
Number.isInteger = function(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
};
//
if (Math.sign === undefined) // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign
Math.sign = function(x) {
    return x < 0 ? -1 : x > 0 ? 1 : +x;
};
if ("name" in Function.prototype === false) // Missing in IE
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name
Object.defineProperty(Function.prototype, "name", {
    get: function() {
        return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];
    }
});
if (Object.assign === undefined) // Missing in IE
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
(function() {
    Object.assign = function(target) {
        if (target === undefined || target === null) throw new TypeError("Cannot convert undefined or null to object");
        var output = Object(target);
        for(var index = 1; index < arguments.length; index++){
            var source = arguments[index];
            if (source !== undefined && source !== null) {
                for(var nextKey in source)if (Object.prototype.hasOwnProperty.call(source, nextKey)) output[nextKey] = source[nextKey];
            }
        }
        return output;
    };
})();
/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */ function EventDispatcher() {}
Object.assign(EventDispatcher.prototype, {
    addEventListener: function(type, listener) {
        if (this._listeners === undefined) this._listeners = {};
        var listeners = this._listeners;
        if (listeners[type] === undefined) listeners[type] = [];
        if (listeners[type].indexOf(listener) === -1) listeners[type].push(listener);
    },
    hasEventListener: function(type, listener) {
        if (this._listeners === undefined) return false;
        var listeners = this._listeners;
        return listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;
    },
    removeEventListener: function(type, listener) {
        if (this._listeners === undefined) return;
        var listeners = this._listeners;
        var listenerArray = listeners[type];
        if (listenerArray !== undefined) {
            var index = listenerArray.indexOf(listener);
            if (index !== -1) listenerArray.splice(index, 1);
        }
    },
    dispatchEvent: function(event) {
        if (this._listeners === undefined) return;
        var listeners = this._listeners;
        var listenerArray = listeners[event.type];
        if (listenerArray !== undefined) {
            event.target = this;
            var array = listenerArray.slice(0);
            for(var i = 0, l = array.length; i < l; i++)array[i].call(this, event);
        }
    }
});
var REVISION = "100";
var MOUSE = {
    LEFT: 0,
    MIDDLE: 1,
    RIGHT: 2
};
var CullFaceNone = 0;
var CullFaceBack = 1;
var CullFaceFront = 2;
var CullFaceFrontBack = 3;
var FrontFaceDirectionCW = 0;
var FrontFaceDirectionCCW = 1;
var BasicShadowMap = 0;
var PCFShadowMap = 1;
var PCFSoftShadowMap = 2;
var FrontSide = 0;
var BackSide = 1;
var DoubleSide = 2;
var FlatShading = 1;
var SmoothShading = 2;
var NoColors = 0;
var FaceColors = 1;
var VertexColors = 2;
var NoBlending = 0;
var NormalBlending = 1;
var AdditiveBlending = 2;
var SubtractiveBlending = 3;
var MultiplyBlending = 4;
var CustomBlending = 5;
var AddEquation = 100;
var SubtractEquation = 101;
var ReverseSubtractEquation = 102;
var MinEquation = 103;
var MaxEquation = 104;
var ZeroFactor = 200;
var OneFactor = 201;
var SrcColorFactor = 202;
var OneMinusSrcColorFactor = 203;
var SrcAlphaFactor = 204;
var OneMinusSrcAlphaFactor = 205;
var DstAlphaFactor = 206;
var OneMinusDstAlphaFactor = 207;
var DstColorFactor = 208;
var OneMinusDstColorFactor = 209;
var SrcAlphaSaturateFactor = 210;
var NeverDepth = 0;
var AlwaysDepth = 1;
var LessDepth = 2;
var LessEqualDepth = 3;
var EqualDepth = 4;
var GreaterEqualDepth = 5;
var GreaterDepth = 6;
var NotEqualDepth = 7;
var MultiplyOperation = 0;
var MixOperation = 1;
var AddOperation = 2;
var NoToneMapping = 0;
var LinearToneMapping = 1;
var ReinhardToneMapping = 2;
var Uncharted2ToneMapping = 3;
var CineonToneMapping = 4;
var ACESFilmicToneMapping = 5;
var UVMapping = 300;
var CubeReflectionMapping = 301;
var CubeRefractionMapping = 302;
var EquirectangularReflectionMapping = 303;
var EquirectangularRefractionMapping = 304;
var SphericalReflectionMapping = 305;
var CubeUVReflectionMapping = 306;
var CubeUVRefractionMapping = 307;
var RepeatWrapping = 1000;
var ClampToEdgeWrapping = 1001;
var MirroredRepeatWrapping = 1002;
var NearestFilter = 1003;
var NearestMipMapNearestFilter = 1004;
var NearestMipMapLinearFilter = 1005;
var LinearFilter = 1006;
var LinearMipMapNearestFilter = 1007;
var LinearMipMapLinearFilter = 1008;
var UnsignedByteType = 1009;
var ByteType = 1010;
var ShortType = 1011;
var UnsignedShortType = 1012;
var IntType = 1013;
var UnsignedIntType = 1014;
var FloatType = 1015;
var HalfFloatType = 1016;
var UnsignedShort4444Type = 1017;
var UnsignedShort5551Type = 1018;
var UnsignedShort565Type = 1019;
var UnsignedInt248Type = 1020;
var AlphaFormat = 1021;
var RGBFormat = 1022;
var RGBAFormat = 1023;
var LuminanceFormat = 1024;
var LuminanceAlphaFormat = 1025;
var RGBEFormat = RGBAFormat;
var DepthFormat = 1026;
var DepthStencilFormat = 1027;
var RedFormat = 1028;
var RGB_S3TC_DXT1_Format = 33776;
var RGBA_S3TC_DXT1_Format = 33777;
var RGBA_S3TC_DXT3_Format = 33778;
var RGBA_S3TC_DXT5_Format = 33779;
var RGB_PVRTC_4BPPV1_Format = 35840;
var RGB_PVRTC_2BPPV1_Format = 35841;
var RGBA_PVRTC_4BPPV1_Format = 35842;
var RGBA_PVRTC_2BPPV1_Format = 35843;
var RGB_ETC1_Format = 36196;
var RGBA_ASTC_4x4_Format = 37808;
var RGBA_ASTC_5x4_Format = 37809;
var RGBA_ASTC_5x5_Format = 37810;
var RGBA_ASTC_6x5_Format = 37811;
var RGBA_ASTC_6x6_Format = 37812;
var RGBA_ASTC_8x5_Format = 37813;
var RGBA_ASTC_8x6_Format = 37814;
var RGBA_ASTC_8x8_Format = 37815;
var RGBA_ASTC_10x5_Format = 37816;
var RGBA_ASTC_10x6_Format = 37817;
var RGBA_ASTC_10x8_Format = 37818;
var RGBA_ASTC_10x10_Format = 37819;
var RGBA_ASTC_12x10_Format = 37820;
var RGBA_ASTC_12x12_Format = 37821;
var LoopOnce = 2200;
var LoopRepeat = 2201;
var LoopPingPong = 2202;
var InterpolateDiscrete = 2300;
var InterpolateLinear = 2301;
var InterpolateSmooth = 2302;
var ZeroCurvatureEnding = 2400;
var ZeroSlopeEnding = 2401;
var WrapAroundEnding = 2402;
var TrianglesDrawMode = 0;
var TriangleStripDrawMode = 1;
var TriangleFanDrawMode = 2;
var LinearEncoding = 3000;
var sRGBEncoding = 3001;
var GammaEncoding = 3007;
var RGBEEncoding = 3002;
var LogLuvEncoding = 3003;
var RGBM7Encoding = 3004;
var RGBM16Encoding = 3005;
var RGBDEncoding = 3006;
var BasicDepthPacking = 3200;
var RGBADepthPacking = 3201;
var TangentSpaceNormalMap = 0;
var ObjectSpaceNormalMap = 1;
/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */ var _Math = {
    DEG2RAD: Math.PI / 180,
    RAD2DEG: 180 / Math.PI,
    generateUUID: function() {
        // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
        var lut = [];
        for(var i = 0; i < 256; i++)lut[i] = (i < 16 ? "0" : "") + i.toString(16);
        return function generateUUID() {
            var d0 = Math.random() * 0xffffffff | 0;
            var d1 = Math.random() * 0xffffffff | 0;
            var d2 = Math.random() * 0xffffffff | 0;
            var d3 = Math.random() * 0xffffffff | 0;
            var uuid = lut[d0 & 0xff] + lut[d0 >> 8 & 0xff] + lut[d0 >> 16 & 0xff] + lut[d0 >> 24 & 0xff] + "-" + lut[d1 & 0xff] + lut[d1 >> 8 & 0xff] + "-" + lut[d1 >> 16 & 0x0f | 0x40] + lut[d1 >> 24 & 0xff] + "-" + lut[d2 & 0x3f | 0x80] + lut[d2 >> 8 & 0xff] + "-" + lut[d2 >> 16 & 0xff] + lut[d2 >> 24 & 0xff] + lut[d3 & 0xff] + lut[d3 >> 8 & 0xff] + lut[d3 >> 16 & 0xff] + lut[d3 >> 24 & 0xff];
            // .toUpperCase() here flattens concatenated strings to save heap memory space.
            return uuid.toUpperCase();
        };
    }(),
    clamp: function(value, min, max) {
        return Math.max(min, Math.min(max, value));
    },
    // compute euclidian modulo of m % n
    // https://en.wikipedia.org/wiki/Modulo_operation
    euclideanModulo: function(n, m) {
        return (n % m + m) % m;
    },
    // Linear mapping from range <a1, a2> to range <b1, b2>
    mapLinear: function(x, a1, a2, b1, b2) {
        return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
    },
    // https://en.wikipedia.org/wiki/Linear_interpolation
    lerp: function(x, y, t) {
        return (1 - t) * x + t * y;
    },
    // http://en.wikipedia.org/wiki/Smoothstep
    smoothstep: function(x, min, max) {
        if (x <= min) return 0;
        if (x >= max) return 1;
        x = (x - min) / (max - min);
        return x * x * (3 - 2 * x);
    },
    smootherstep: function(x, min, max) {
        if (x <= min) return 0;
        if (x >= max) return 1;
        x = (x - min) / (max - min);
        return x * x * x * (x * (x * 6 - 15) + 10);
    },
    // Random integer from <low, high> interval
    randInt: function(low, high) {
        return low + Math.floor(Math.random() * (high - low + 1));
    },
    // Random float from <low, high> interval
    randFloat: function(low, high) {
        return low + Math.random() * (high - low);
    },
    // Random float from <-range/2, range/2> interval
    randFloatSpread: function(range) {
        return range * (0.5 - Math.random());
    },
    degToRad: function(degrees) {
        return degrees * _Math.DEG2RAD;
    },
    radToDeg: function(radians) {
        return radians * _Math.RAD2DEG;
    },
    isPowerOfTwo: function(value) {
        return (value & value - 1) === 0 && value !== 0;
    },
    ceilPowerOfTwo: function(value) {
        return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
    },
    floorPowerOfTwo: function(value) {
        return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
    }
};
/**
 * @author mrdoob / http://mrdoob.com/
 * @author philogb / http://blog.thejit.org/
 * @author egraether / http://egraether.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */ function Vector2(x, y) {
    this.x = x || 0;
    this.y = y || 0;
}
Object.defineProperties(Vector2.prototype, {
    "width": {
        get: function() {
            return this.x;
        },
        set: function(value) {
            this.x = value;
        }
    },
    "height": {
        get: function() {
            return this.y;
        },
        set: function(value) {
            this.y = value;
        }
    }
});
Object.assign(Vector2.prototype, {
    isVector2: true,
    set: function(x, y) {
        this.x = x;
        this.y = y;
        return this;
    },
    setScalar: function(scalar) {
        this.x = scalar;
        this.y = scalar;
        return this;
    },
    setX: function(x) {
        this.x = x;
        return this;
    },
    setY: function(y) {
        this.y = y;
        return this;
    },
    setComponent: function(index, value) {
        switch(index){
            case 0:
                this.x = value;
                break;
            case 1:
                this.y = value;
                break;
            default:
                throw new Error("index is out of range: " + index);
        }
        return this;
    },
    getComponent: function(index) {
        switch(index){
            case 0:
                return this.x;
            case 1:
                return this.y;
            default:
                throw new Error("index is out of range: " + index);
        }
    },
    clone: function() {
        return new this.constructor(this.x, this.y);
    },
    copy: function(v) {
        this.x = v.x;
        this.y = v.y;
        return this;
    },
    add: function(v, w) {
        if (w !== undefined) {
            console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
            return this.addVectors(v, w);
        }
        this.x += v.x;
        this.y += v.y;
        return this;
    },
    addScalar: function(s) {
        this.x += s;
        this.y += s;
        return this;
    },
    addVectors: function(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        return this;
    },
    addScaledVector: function(v, s) {
        this.x += v.x * s;
        this.y += v.y * s;
        return this;
    },
    sub: function(v, w) {
        if (w !== undefined) {
            console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
            return this.subVectors(v, w);
        }
        this.x -= v.x;
        this.y -= v.y;
        return this;
    },
    subScalar: function(s) {
        this.x -= s;
        this.y -= s;
        return this;
    },
    subVectors: function(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        return this;
    },
    multiply: function(v) {
        this.x *= v.x;
        this.y *= v.y;
        return this;
    },
    multiplyScalar: function(scalar) {
        this.x *= scalar;
        this.y *= scalar;
        return this;
    },
    divide: function(v) {
        this.x /= v.x;
        this.y /= v.y;
        return this;
    },
    divideScalar: function(scalar) {
        return this.multiplyScalar(1 / scalar);
    },
    applyMatrix3: function(m) {
        var x = this.x, y = this.y;
        var e = m.elements;
        this.x = e[0] * x + e[3] * y + e[6];
        this.y = e[1] * x + e[4] * y + e[7];
        return this;
    },
    min: function(v) {
        this.x = Math.min(this.x, v.x);
        this.y = Math.min(this.y, v.y);
        return this;
    },
    max: function(v) {
        this.x = Math.max(this.x, v.x);
        this.y = Math.max(this.y, v.y);
        return this;
    },
    clamp: function(min, max) {
        // assumes min < max, componentwise
        this.x = Math.max(min.x, Math.min(max.x, this.x));
        this.y = Math.max(min.y, Math.min(max.y, this.y));
        return this;
    },
    clampScalar: function() {
        var min = new Vector2();
        var max = new Vector2();
        return function clampScalar(minVal, maxVal) {
            min.set(minVal, minVal);
            max.set(maxVal, maxVal);
            return this.clamp(min, max);
        };
    }(),
    clampLength: function(min, max) {
        var length = this.length();
        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
    },
    floor: function() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        return this;
    },
    ceil: function() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        return this;
    },
    round: function() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        return this;
    },
    roundToZero: function() {
        this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
        return this;
    },
    negate: function() {
        this.x = -this.x;
        this.y = -this.y;
        return this;
    },
    dot: function(v) {
        return this.x * v.x + this.y * v.y;
    },
    cross: function(v) {
        return this.x * v.y - this.y * v.x;
    },
    lengthSq: function() {
        return this.x * this.x + this.y * this.y;
    },
    length: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    },
    manhattanLength: function() {
        return Math.abs(this.x) + Math.abs(this.y);
    },
    normalize: function() {
        return this.divideScalar(this.length() || 1);
    },
    angle: function() {
        // computes the angle in radians with respect to the positive x-axis
        var angle = Math.atan2(this.y, this.x);
        if (angle < 0) angle += 2 * Math.PI;
        return angle;
    },
    distanceTo: function(v) {
        return Math.sqrt(this.distanceToSquared(v));
    },
    distanceToSquared: function(v) {
        var dx = this.x - v.x, dy = this.y - v.y;
        return dx * dx + dy * dy;
    },
    manhattanDistanceTo: function(v) {
        return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
    },
    setLength: function(length) {
        return this.normalize().multiplyScalar(length);
    },
    lerp: function(v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        return this;
    },
    lerpVectors: function(v1, v2, alpha) {
        return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
    },
    equals: function(v) {
        return v.x === this.x && v.y === this.y;
    },
    fromArray: function(array, offset) {
        if (offset === undefined) offset = 0;
        this.x = array[offset];
        this.y = array[offset + 1];
        return this;
    },
    toArray: function(array, offset) {
        if (array === undefined) array = [];
        if (offset === undefined) offset = 0;
        array[offset] = this.x;
        array[offset + 1] = this.y;
        return array;
    },
    fromBufferAttribute: function(attribute, index, offset) {
        if (offset !== undefined) console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute().");
        this.x = attribute.getX(index);
        this.y = attribute.getY(index);
        return this;
    },
    rotateAround: function(center, angle) {
        var c = Math.cos(angle), s = Math.sin(angle);
        var x = this.x - center.x;
        var y = this.y - center.y;
        this.x = x * c - y * s + center.x;
        this.y = x * s + y * c + center.y;
        return this;
    }
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author jordi_ros / http://plattsoft.com
 * @author D1plo1d / http://github.com/D1plo1d
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author timknip / http://www.floorplanner.com/
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 */ function Matrix4() {
    this.elements = [
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
    ];
    if (arguments.length > 0) console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
}
Object.assign(Matrix4.prototype, {
    isMatrix4: true,
    set: function(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
        var te = this.elements;
        te[0] = n11;
        te[4] = n12;
        te[8] = n13;
        te[12] = n14;
        te[1] = n21;
        te[5] = n22;
        te[9] = n23;
        te[13] = n24;
        te[2] = n31;
        te[6] = n32;
        te[10] = n33;
        te[14] = n34;
        te[3] = n41;
        te[7] = n42;
        te[11] = n43;
        te[15] = n44;
        return this;
    },
    identity: function() {
        this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        return this;
    },
    clone: function() {
        return new Matrix4().fromArray(this.elements);
    },
    copy: function(m) {
        var te = this.elements;
        var me = m.elements;
        te[0] = me[0];
        te[1] = me[1];
        te[2] = me[2];
        te[3] = me[3];
        te[4] = me[4];
        te[5] = me[5];
        te[6] = me[6];
        te[7] = me[7];
        te[8] = me[8];
        te[9] = me[9];
        te[10] = me[10];
        te[11] = me[11];
        te[12] = me[12];
        te[13] = me[13];
        te[14] = me[14];
        te[15] = me[15];
        return this;
    },
    copyPosition: function(m) {
        var te = this.elements, me = m.elements;
        te[12] = me[12];
        te[13] = me[13];
        te[14] = me[14];
        return this;
    },
    extractBasis: function(xAxis, yAxis, zAxis) {
        xAxis.setFromMatrixColumn(this, 0);
        yAxis.setFromMatrixColumn(this, 1);
        zAxis.setFromMatrixColumn(this, 2);
        return this;
    },
    makeBasis: function(xAxis, yAxis, zAxis) {
        this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
        return this;
    },
    extractRotation: function() {
        var v1 = new Vector3();
        return function extractRotation(m) {
            // this method does not support reflection matrices
            var te = this.elements;
            var me = m.elements;
            var scaleX = 1 / v1.setFromMatrixColumn(m, 0).length();
            var scaleY = 1 / v1.setFromMatrixColumn(m, 1).length();
            var scaleZ = 1 / v1.setFromMatrixColumn(m, 2).length();
            te[0] = me[0] * scaleX;
            te[1] = me[1] * scaleX;
            te[2] = me[2] * scaleX;
            te[3] = 0;
            te[4] = me[4] * scaleY;
            te[5] = me[5] * scaleY;
            te[6] = me[6] * scaleY;
            te[7] = 0;
            te[8] = me[8] * scaleZ;
            te[9] = me[9] * scaleZ;
            te[10] = me[10] * scaleZ;
            te[11] = 0;
            te[12] = 0;
            te[13] = 0;
            te[14] = 0;
            te[15] = 1;
            return this;
        };
    }(),
    makeRotationFromEuler: function(euler) {
        if (!(euler && euler.isEuler)) console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
        var te = this.elements;
        var x = euler.x, y = euler.y, z = euler.z;
        var a = Math.cos(x), b = Math.sin(x);
        var c = Math.cos(y), d = Math.sin(y);
        var e = Math.cos(z), f = Math.sin(z);
        if (euler.order === "XYZ") {
            var ae = a * e, af = a * f, be = b * e, bf = b * f;
            te[0] = c * e;
            te[4] = -c * f;
            te[8] = d;
            te[1] = af + be * d;
            te[5] = ae - bf * d;
            te[9] = -b * c;
            te[2] = bf - ae * d;
            te[6] = be + af * d;
            te[10] = a * c;
        } else if (euler.order === "YXZ") {
            var ce = c * e, cf = c * f, de = d * e, df = d * f;
            te[0] = ce + df * b;
            te[4] = de * b - cf;
            te[8] = a * d;
            te[1] = a * f;
            te[5] = a * e;
            te[9] = -b;
            te[2] = cf * b - de;
            te[6] = df + ce * b;
            te[10] = a * c;
        } else if (euler.order === "ZXY") {
            var ce = c * e, cf = c * f, de = d * e, df = d * f;
            te[0] = ce - df * b;
            te[4] = -a * f;
            te[8] = de + cf * b;
            te[1] = cf + de * b;
            te[5] = a * e;
            te[9] = df - ce * b;
            te[2] = -a * d;
            te[6] = b;
            te[10] = a * c;
        } else if (euler.order === "ZYX") {
            var ae = a * e, af = a * f, be = b * e, bf = b * f;
            te[0] = c * e;
            te[4] = be * d - af;
            te[8] = ae * d + bf;
            te[1] = c * f;
            te[5] = bf * d + ae;
            te[9] = af * d - be;
            te[2] = -d;
            te[6] = b * c;
            te[10] = a * c;
        } else if (euler.order === "YZX") {
            var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
            te[0] = c * e;
            te[4] = bd - ac * f;
            te[8] = bc * f + ad;
            te[1] = f;
            te[5] = a * e;
            te[9] = -b * e;
            te[2] = -d * e;
            te[6] = ad * f + bc;
            te[10] = ac - bd * f;
        } else if (euler.order === "XZY") {
            var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
            te[0] = c * e;
            te[4] = -f;
            te[8] = d * e;
            te[1] = ac * f + bd;
            te[5] = a * e;
            te[9] = ad * f - bc;
            te[2] = bc * f - ad;
            te[6] = b * e;
            te[10] = bd * f + ac;
        }
        // bottom row
        te[3] = 0;
        te[7] = 0;
        te[11] = 0;
        // last column
        te[12] = 0;
        te[13] = 0;
        te[14] = 0;
        te[15] = 1;
        return this;
    },
    makeRotationFromQuaternion: function() {
        var zero = new Vector3(0, 0, 0);
        var one = new Vector3(1, 1, 1);
        return function makeRotationFromQuaternion(q) {
            return this.compose(zero, q, one);
        };
    }(),
    lookAt: function() {
        var x = new Vector3();
        var y = new Vector3();
        var z = new Vector3();
        return function lookAt(eye, target, up) {
            var te = this.elements;
            z.subVectors(eye, target);
            if (z.lengthSq() === 0) // eye and target are in the same position
            z.z = 1;
            z.normalize();
            x.crossVectors(up, z);
            if (x.lengthSq() === 0) {
                // up and z are parallel
                if (Math.abs(up.z) === 1) z.x += 0.0001;
                else z.z += 0.0001;
                z.normalize();
                x.crossVectors(up, z);
            }
            x.normalize();
            y.crossVectors(z, x);
            te[0] = x.x;
            te[4] = y.x;
            te[8] = z.x;
            te[1] = x.y;
            te[5] = y.y;
            te[9] = z.y;
            te[2] = x.z;
            te[6] = y.z;
            te[10] = z.z;
            return this;
        };
    }(),
    multiply: function(m, n) {
        if (n !== undefined) {
            console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.");
            return this.multiplyMatrices(m, n);
        }
        return this.multiplyMatrices(this, m);
    },
    premultiply: function(m) {
        return this.multiplyMatrices(m, this);
    },
    multiplyMatrices: function(a, b) {
        var ae = a.elements;
        var be = b.elements;
        var te = this.elements;
        var a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
        var a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
        var a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
        var a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
        var b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
        var b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
        var b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
        var b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
        te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
        te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
        te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
        te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
        te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
        te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
        te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
        te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
        te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
        te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
        te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
        te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
        te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
        te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
        te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
        te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
        return this;
    },
    multiplyScalar: function(s) {
        var te = this.elements;
        te[0] *= s;
        te[4] *= s;
        te[8] *= s;
        te[12] *= s;
        te[1] *= s;
        te[5] *= s;
        te[9] *= s;
        te[13] *= s;
        te[2] *= s;
        te[6] *= s;
        te[10] *= s;
        te[14] *= s;
        te[3] *= s;
        te[7] *= s;
        te[11] *= s;
        te[15] *= s;
        return this;
    },
    applyToBufferAttribute: function() {
        var v1 = new Vector3();
        return function applyToBufferAttribute(attribute) {
            for(var i = 0, l = attribute.count; i < l; i++){
                v1.x = attribute.getX(i);
                v1.y = attribute.getY(i);
                v1.z = attribute.getZ(i);
                v1.applyMatrix4(this);
                attribute.setXYZ(i, v1.x, v1.y, v1.z);
            }
            return attribute;
        };
    }(),
    determinant: function() {
        var te = this.elements;
        var n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
        var n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
        var n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
        var n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
        //TODO: make this more efficient
        //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )
        return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
    },
    transpose: function() {
        var te = this.elements;
        var tmp;
        tmp = te[1];
        te[1] = te[4];
        te[4] = tmp;
        tmp = te[2];
        te[2] = te[8];
        te[8] = tmp;
        tmp = te[6];
        te[6] = te[9];
        te[9] = tmp;
        tmp = te[3];
        te[3] = te[12];
        te[12] = tmp;
        tmp = te[7];
        te[7] = te[13];
        te[13] = tmp;
        tmp = te[11];
        te[11] = te[14];
        te[14] = tmp;
        return this;
    },
    setPosition: function(v) {
        var te = this.elements;
        te[12] = v.x;
        te[13] = v.y;
        te[14] = v.z;
        return this;
    },
    getInverse: function(m, throwOnDegenerate) {
        // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
        var te = this.elements, me = m.elements, n11 = me[0], n21 = me[1], n31 = me[2], n41 = me[3], n12 = me[4], n22 = me[5], n32 = me[6], n42 = me[7], n13 = me[8], n23 = me[9], n33 = me[10], n43 = me[11], n14 = me[12], n24 = me[13], n34 = me[14], n44 = me[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
        var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
        if (det === 0) {
            var msg = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";
            if (throwOnDegenerate === true) throw new Error(msg);
            else console.warn(msg);
            return this.identity();
        }
        var detInv = 1 / det;
        te[0] = t11 * detInv;
        te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
        te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
        te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
        te[4] = t12 * detInv;
        te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
        te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
        te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
        te[8] = t13 * detInv;
        te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
        te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
        te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
        te[12] = t14 * detInv;
        te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
        te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
        te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
        return this;
    },
    scale: function(v) {
        var te = this.elements;
        var x = v.x, y = v.y, z = v.z;
        te[0] *= x;
        te[4] *= y;
        te[8] *= z;
        te[1] *= x;
        te[5] *= y;
        te[9] *= z;
        te[2] *= x;
        te[6] *= y;
        te[10] *= z;
        te[3] *= x;
        te[7] *= y;
        te[11] *= z;
        return this;
    },
    getMaxScaleOnAxis: function() {
        var te = this.elements;
        var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
        var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
        var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
        return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
    },
    makeTranslation: function(x, y, z) {
        this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
        return this;
    },
    makeRotationX: function(theta) {
        var c = Math.cos(theta), s = Math.sin(theta);
        this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
        return this;
    },
    makeRotationY: function(theta) {
        var c = Math.cos(theta), s = Math.sin(theta);
        this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
        return this;
    },
    makeRotationZ: function(theta) {
        var c = Math.cos(theta), s = Math.sin(theta);
        this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        return this;
    },
    makeRotationAxis: function(axis, angle) {
        // Based on http://www.gamedev.net/reference/articles/article1199.asp
        var c = Math.cos(angle);
        var s = Math.sin(angle);
        var t = 1 - c;
        var x = axis.x, y = axis.y, z = axis.z;
        var tx = t * x, ty = t * y;
        this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
        return this;
    },
    makeScale: function(x, y, z) {
        this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
        return this;
    },
    makeShear: function(x, y, z) {
        this.set(1, y, z, 0, x, 1, z, 0, x, y, 1, 0, 0, 0, 0, 1);
        return this;
    },
    compose: function(position, quaternion, scale) {
        var te = this.elements;
        var x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
        var x2 = x + x, y2 = y + y, z2 = z + z;
        var xx = x * x2, xy = x * y2, xz = x * z2;
        var yy = y * y2, yz = y * z2, zz = z * z2;
        var wx = w * x2, wy = w * y2, wz = w * z2;
        var sx = scale.x, sy = scale.y, sz = scale.z;
        te[0] = (1 - (yy + zz)) * sx;
        te[1] = (xy + wz) * sx;
        te[2] = (xz - wy) * sx;
        te[3] = 0;
        te[4] = (xy - wz) * sy;
        te[5] = (1 - (xx + zz)) * sy;
        te[6] = (yz + wx) * sy;
        te[7] = 0;
        te[8] = (xz + wy) * sz;
        te[9] = (yz - wx) * sz;
        te[10] = (1 - (xx + yy)) * sz;
        te[11] = 0;
        te[12] = position.x;
        te[13] = position.y;
        te[14] = position.z;
        te[15] = 1;
        return this;
    },
    decompose: function() {
        var vector = new Vector3();
        var matrix = new Matrix4();
        return function decompose(position, quaternion, scale) {
            var te = this.elements;
            var sx = vector.set(te[0], te[1], te[2]).length();
            var sy = vector.set(te[4], te[5], te[6]).length();
            var sz = vector.set(te[8], te[9], te[10]).length();
            // if determine is negative, we need to invert one scale
            var det = this.determinant();
            if (det < 0) sx = -sx;
            position.x = te[12];
            position.y = te[13];
            position.z = te[14];
            // scale the rotation part
            matrix.copy(this);
            var invSX = 1 / sx;
            var invSY = 1 / sy;
            var invSZ = 1 / sz;
            matrix.elements[0] *= invSX;
            matrix.elements[1] *= invSX;
            matrix.elements[2] *= invSX;
            matrix.elements[4] *= invSY;
            matrix.elements[5] *= invSY;
            matrix.elements[6] *= invSY;
            matrix.elements[8] *= invSZ;
            matrix.elements[9] *= invSZ;
            matrix.elements[10] *= invSZ;
            quaternion.setFromRotationMatrix(matrix);
            scale.x = sx;
            scale.y = sy;
            scale.z = sz;
            return this;
        };
    }(),
    makePerspective: function(left, right, top, bottom, near, far) {
        if (far === undefined) console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
        var te = this.elements;
        var x = 2 * near / (right - left);
        var y = 2 * near / (top - bottom);
        var a = (right + left) / (right - left);
        var b = (top + bottom) / (top - bottom);
        var c = -(far + near) / (far - near);
        var d = -2 * far * near / (far - near);
        te[0] = x;
        te[4] = 0;
        te[8] = a;
        te[12] = 0;
        te[1] = 0;
        te[5] = y;
        te[9] = b;
        te[13] = 0;
        te[2] = 0;
        te[6] = 0;
        te[10] = c;
        te[14] = d;
        te[3] = 0;
        te[7] = 0;
        te[11] = -1;
        te[15] = 0;
        return this;
    },
    makeOrthographic: function(left, right, top, bottom, near, far) {
        var te = this.elements;
        var w = 1.0 / (right - left);
        var h = 1.0 / (top - bottom);
        var p = 1.0 / (far - near);
        var x = (right + left) * w;
        var y = (top + bottom) * h;
        var z = (far + near) * p;
        te[0] = 2 * w;
        te[4] = 0;
        te[8] = 0;
        te[12] = -x;
        te[1] = 0;
        te[5] = 2 * h;
        te[9] = 0;
        te[13] = -y;
        te[2] = 0;
        te[6] = 0;
        te[10] = -2 * p;
        te[14] = -z;
        te[3] = 0;
        te[7] = 0;
        te[11] = 0;
        te[15] = 1;
        return this;
    },
    equals: function(matrix) {
        var te = this.elements;
        var me = matrix.elements;
        for(var i = 0; i < 16; i++){
            if (te[i] !== me[i]) return false;
        }
        return true;
    },
    fromArray: function(array, offset) {
        if (offset === undefined) offset = 0;
        for(var i = 0; i < 16; i++)this.elements[i] = array[i + offset];
        return this;
    },
    toArray: function(array, offset) {
        if (array === undefined) array = [];
        if (offset === undefined) offset = 0;
        var te = this.elements;
        array[offset] = te[0];
        array[offset + 1] = te[1];
        array[offset + 2] = te[2];
        array[offset + 3] = te[3];
        array[offset + 4] = te[4];
        array[offset + 5] = te[5];
        array[offset + 6] = te[6];
        array[offset + 7] = te[7];
        array[offset + 8] = te[8];
        array[offset + 9] = te[9];
        array[offset + 10] = te[10];
        array[offset + 11] = te[11];
        array[offset + 12] = te[12];
        array[offset + 13] = te[13];
        array[offset + 14] = te[14];
        array[offset + 15] = te[15];
        return array;
    }
});
/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 */ function Quaternion(x, y, z, w) {
    this._x = x || 0;
    this._y = y || 0;
    this._z = z || 0;
    this._w = w !== undefined ? w : 1;
}
Object.assign(Quaternion, {
    slerp: function(qa, qb, qm, t) {
        return qm.copy(qa).slerp(qb, t);
    },
    slerpFlat: function(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
        // fuzz-free, array-based Quaternion SLERP operation
        var x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3], x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
        if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
            var s = 1 - t, cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;
            // Skip the Slerp for tiny steps to avoid numeric problems:
            if (sqrSin > Number.EPSILON) {
                var sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
                s = Math.sin(s * len) / sin;
                t = Math.sin(t * len) / sin;
            }
            var tDir = t * dir;
            x0 = x0 * s + x1 * tDir;
            y0 = y0 * s + y1 * tDir;
            z0 = z0 * s + z1 * tDir;
            w0 = w0 * s + w1 * tDir;
            // Normalize in case we just did a lerp:
            if (s === 1 - t) {
                var f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
                x0 *= f;
                y0 *= f;
                z0 *= f;
                w0 *= f;
            }
        }
        dst[dstOffset] = x0;
        dst[dstOffset + 1] = y0;
        dst[dstOffset + 2] = z0;
        dst[dstOffset + 3] = w0;
    }
});
Object.defineProperties(Quaternion.prototype, {
    x: {
        get: function() {
            return this._x;
        },
        set: function(value) {
            this._x = value;
            this.onChangeCallback();
        }
    },
    y: {
        get: function() {
            return this._y;
        },
        set: function(value) {
            this._y = value;
            this.onChangeCallback();
        }
    },
    z: {
        get: function() {
            return this._z;
        },
        set: function(value) {
            this._z = value;
            this.onChangeCallback();
        }
    },
    w: {
        get: function() {
            return this._w;
        },
        set: function(value) {
            this._w = value;
            this.onChangeCallback();
        }
    }
});
Object.assign(Quaternion.prototype, {
    isQuaternion: true,
    set: function(x, y, z, w) {
        this._x = x;
        this._y = y;
        this._z = z;
        this._w = w;
        this.onChangeCallback();
        return this;
    },
    clone: function() {
        return new this.constructor(this._x, this._y, this._z, this._w);
    },
    copy: function(quaternion) {
        this._x = quaternion.x;
        this._y = quaternion.y;
        this._z = quaternion.z;
        this._w = quaternion.w;
        this.onChangeCallback();
        return this;
    },
    setFromEuler: function(euler, update) {
        if (!(euler && euler.isEuler)) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
        var x = euler._x, y = euler._y, z = euler._z, order = euler.order;
        // http://www.mathworks.com/matlabcentral/fileexchange/
        // 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
        //	content/SpinCalc.m
        var cos = Math.cos;
        var sin = Math.sin;
        var c1 = cos(x / 2);
        var c2 = cos(y / 2);
        var c3 = cos(z / 2);
        var s1 = sin(x / 2);
        var s2 = sin(y / 2);
        var s3 = sin(z / 2);
        if (order === "XYZ") {
            this._x = s1 * c2 * c3 + c1 * s2 * s3;
            this._y = c1 * s2 * c3 - s1 * c2 * s3;
            this._z = c1 * c2 * s3 + s1 * s2 * c3;
            this._w = c1 * c2 * c3 - s1 * s2 * s3;
        } else if (order === "YXZ") {
            this._x = s1 * c2 * c3 + c1 * s2 * s3;
            this._y = c1 * s2 * c3 - s1 * c2 * s3;
            this._z = c1 * c2 * s3 - s1 * s2 * c3;
            this._w = c1 * c2 * c3 + s1 * s2 * s3;
        } else if (order === "ZXY") {
            this._x = s1 * c2 * c3 - c1 * s2 * s3;
            this._y = c1 * s2 * c3 + s1 * c2 * s3;
            this._z = c1 * c2 * s3 + s1 * s2 * c3;
            this._w = c1 * c2 * c3 - s1 * s2 * s3;
        } else if (order === "ZYX") {
            this._x = s1 * c2 * c3 - c1 * s2 * s3;
            this._y = c1 * s2 * c3 + s1 * c2 * s3;
            this._z = c1 * c2 * s3 - s1 * s2 * c3;
            this._w = c1 * c2 * c3 + s1 * s2 * s3;
        } else if (order === "YZX") {
            this._x = s1 * c2 * c3 + c1 * s2 * s3;
            this._y = c1 * s2 * c3 + s1 * c2 * s3;
            this._z = c1 * c2 * s3 - s1 * s2 * c3;
            this._w = c1 * c2 * c3 - s1 * s2 * s3;
        } else if (order === "XZY") {
            this._x = s1 * c2 * c3 - c1 * s2 * s3;
            this._y = c1 * s2 * c3 - s1 * c2 * s3;
            this._z = c1 * c2 * s3 + s1 * s2 * c3;
            this._w = c1 * c2 * c3 + s1 * s2 * s3;
        }
        if (update !== false) this.onChangeCallback();
        return this;
    },
    setFromAxisAngle: function(axis, angle) {
        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
        // assumes axis is normalized
        var halfAngle = angle / 2, s = Math.sin(halfAngle);
        this._x = axis.x * s;
        this._y = axis.y * s;
        this._z = axis.z * s;
        this._w = Math.cos(halfAngle);
        this.onChangeCallback();
        return this;
    },
    setFromRotationMatrix: function(m) {
        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
        var te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33, s;
        if (trace > 0) {
            s = 0.5 / Math.sqrt(trace + 1.0);
            this._w = 0.25 / s;
            this._x = (m32 - m23) * s;
            this._y = (m13 - m31) * s;
            this._z = (m21 - m12) * s;
        } else if (m11 > m22 && m11 > m33) {
            s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
            this._w = (m32 - m23) / s;
            this._x = 0.25 * s;
            this._y = (m12 + m21) / s;
            this._z = (m13 + m31) / s;
        } else if (m22 > m33) {
            s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
            this._w = (m13 - m31) / s;
            this._x = (m12 + m21) / s;
            this._y = 0.25 * s;
            this._z = (m23 + m32) / s;
        } else {
            s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
            this._w = (m21 - m12) / s;
            this._x = (m13 + m31) / s;
            this._y = (m23 + m32) / s;
            this._z = 0.25 * s;
        }
        this.onChangeCallback();
        return this;
    },
    setFromUnitVectors: function() {
        // assumes direction vectors vFrom and vTo are normalized
        var v1 = new Vector3();
        var r;
        var EPS = 0.000001;
        return function setFromUnitVectors(vFrom, vTo) {
            if (v1 === undefined) v1 = new Vector3();
            r = vFrom.dot(vTo) + 1;
            if (r < EPS) {
                r = 0;
                if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) v1.set(-vFrom.y, vFrom.x, 0);
                else v1.set(0, -vFrom.z, vFrom.y);
            } else v1.crossVectors(vFrom, vTo);
            this._x = v1.x;
            this._y = v1.y;
            this._z = v1.z;
            this._w = r;
            return this.normalize();
        };
    }(),
    angleTo: function(q) {
        return 2 * Math.acos(Math.abs(_Math.clamp(this.dot(q), -1, 1)));
    },
    rotateTowards: function(q, step) {
        var angle = this.angleTo(q);
        if (angle === 0) return this;
        var t = Math.min(1, step / angle);
        this.slerp(q, t);
        return this;
    },
    inverse: function() {
        // quaternion is assumed to have unit length
        return this.conjugate();
    },
    conjugate: function() {
        this._x *= -1;
        this._y *= -1;
        this._z *= -1;
        this.onChangeCallback();
        return this;
    },
    dot: function(v) {
        return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
    },
    lengthSq: function() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
    },
    length: function() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
    },
    normalize: function() {
        var l = this.length();
        if (l === 0) {
            this._x = 0;
            this._y = 0;
            this._z = 0;
            this._w = 1;
        } else {
            l = 1 / l;
            this._x = this._x * l;
            this._y = this._y * l;
            this._z = this._z * l;
            this._w = this._w * l;
        }
        this.onChangeCallback();
        return this;
    },
    multiply: function(q, p) {
        if (p !== undefined) {
            console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.");
            return this.multiplyQuaternions(q, p);
        }
        return this.multiplyQuaternions(this, q);
    },
    premultiply: function(q) {
        return this.multiplyQuaternions(q, this);
    },
    multiplyQuaternions: function(a, b) {
        // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
        var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
        var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
        this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
        this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
        this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
        this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
        this.onChangeCallback();
        return this;
    },
    slerp: function(qb, t) {
        if (t === 0) return this;
        if (t === 1) return this.copy(qb);
        var x = this._x, y = this._y, z = this._z, w = this._w;
        // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
        var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
        if (cosHalfTheta < 0) {
            this._w = -qb._w;
            this._x = -qb._x;
            this._y = -qb._y;
            this._z = -qb._z;
            cosHalfTheta = -cosHalfTheta;
        } else this.copy(qb);
        if (cosHalfTheta >= 1.0) {
            this._w = w;
            this._x = x;
            this._y = y;
            this._z = z;
            return this;
        }
        var sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;
        if (sqrSinHalfTheta <= Number.EPSILON) {
            var s = 1 - t;
            this._w = s * w + t * this._w;
            this._x = s * x + t * this._x;
            this._y = s * y + t * this._y;
            this._z = s * z + t * this._z;
            return this.normalize();
        }
        var sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
        var halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
        var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
        this._w = w * ratioA + this._w * ratioB;
        this._x = x * ratioA + this._x * ratioB;
        this._y = y * ratioA + this._y * ratioB;
        this._z = z * ratioA + this._z * ratioB;
        this.onChangeCallback();
        return this;
    },
    equals: function(quaternion) {
        return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
    },
    fromArray: function(array, offset) {
        if (offset === undefined) offset = 0;
        this._x = array[offset];
        this._y = array[offset + 1];
        this._z = array[offset + 2];
        this._w = array[offset + 3];
        this.onChangeCallback();
        return this;
    },
    toArray: function(array, offset) {
        if (array === undefined) array = [];
        if (offset === undefined) offset = 0;
        array[offset] = this._x;
        array[offset + 1] = this._y;
        array[offset + 2] = this._z;
        array[offset + 3] = this._w;
        return array;
    },
    onChange: function(callback) {
        this.onChangeCallback = callback;
        return this;
    },
    onChangeCallback: function() {}
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author kile / http://kile.stravaganza.org/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */ function Vector3(x, y, z) {
    this.x = x || 0;
    this.y = y || 0;
    this.z = z || 0;
}
Object.assign(Vector3.prototype, {
    isVector3: true,
    set: function(x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
        return this;
    },
    setScalar: function(scalar) {
        this.x = scalar;
        this.y = scalar;
        this.z = scalar;
        return this;
    },
    setX: function(x) {
        this.x = x;
        return this;
    },
    setY: function(y) {
        this.y = y;
        return this;
    },
    setZ: function(z) {
        this.z = z;
        return this;
    },
    setComponent: function(index, value) {
        switch(index){
            case 0:
                this.x = value;
                break;
            case 1:
                this.y = value;
                break;
            case 2:
                this.z = value;
                break;
            default:
                throw new Error("index is out of range: " + index);
        }
        return this;
    },
    getComponent: function(index) {
        switch(index){
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            default:
                throw new Error("index is out of range: " + index);
        }
    },
    clone: function() {
        return new this.constructor(this.x, this.y, this.z);
    },
    copy: function(v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        return this;
    },
    add: function(v, w) {
        if (w !== undefined) {
            console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
            return this.addVectors(v, w);
        }
        this.x += v.x;
        this.y += v.y;
        this.z += v.z;
        return this;
    },
    addScalar: function(s) {
        this.x += s;
        this.y += s;
        this.z += s;
        return this;
    },
    addVectors: function(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        this.z = a.z + b.z;
        return this;
    },
    addScaledVector: function(v, s) {
        this.x += v.x * s;
        this.y += v.y * s;
        this.z += v.z * s;
        return this;
    },
    sub: function(v, w) {
        if (w !== undefined) {
            console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
            return this.subVectors(v, w);
        }
        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;
        return this;
    },
    subScalar: function(s) {
        this.x -= s;
        this.y -= s;
        this.z -= s;
        return this;
    },
    subVectors: function(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        this.z = a.z - b.z;
        return this;
    },
    multiply: function(v, w) {
        if (w !== undefined) {
            console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.");
            return this.multiplyVectors(v, w);
        }
        this.x *= v.x;
        this.y *= v.y;
        this.z *= v.z;
        return this;
    },
    multiplyScalar: function(scalar) {
        this.x *= scalar;
        this.y *= scalar;
        this.z *= scalar;
        return this;
    },
    multiplyVectors: function(a, b) {
        this.x = a.x * b.x;
        this.y = a.y * b.y;
        this.z = a.z * b.z;
        return this;
    },
    applyEuler: function() {
        var quaternion = new Quaternion();
        return function applyEuler(euler) {
            if (!(euler && euler.isEuler)) console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.");
            return this.applyQuaternion(quaternion.setFromEuler(euler));
        };
    }(),
    applyAxisAngle: function() {
        var quaternion = new Quaternion();
        return function applyAxisAngle(axis, angle) {
            return this.applyQuaternion(quaternion.setFromAxisAngle(axis, angle));
        };
    }(),
    applyMatrix3: function(m) {
        var x = this.x, y = this.y, z = this.z;
        var e = m.elements;
        this.x = e[0] * x + e[3] * y + e[6] * z;
        this.y = e[1] * x + e[4] * y + e[7] * z;
        this.z = e[2] * x + e[5] * y + e[8] * z;
        return this;
    },
    applyMatrix4: function(m) {
        var x = this.x, y = this.y, z = this.z;
        var e = m.elements;
        var w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
        this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
        this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
        this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
        return this;
    },
    applyQuaternion: function(q) {
        var x = this.x, y = this.y, z = this.z;
        var qx = q.x, qy = q.y, qz = q.z, qw = q.w;
        // calculate quat * vector
        var ix = qw * x + qy * z - qz * y;
        var iy = qw * y + qz * x - qx * z;
        var iz = qw * z + qx * y - qy * x;
        var iw = -qx * x - qy * y - qz * z;
        // calculate result * inverse quat
        this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
        this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
        this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
        return this;
    },
    project: function(camera) {
        return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
    },
    unproject: function() {
        var matrix = new Matrix4();
        return function unproject(camera) {
            return this.applyMatrix4(matrix.getInverse(camera.projectionMatrix)).applyMatrix4(camera.matrixWorld);
        };
    }(),
    transformDirection: function(m) {
        // input: THREE.Matrix4 affine matrix
        // vector interpreted as a direction
        var x = this.x, y = this.y, z = this.z;
        var e = m.elements;
        this.x = e[0] * x + e[4] * y + e[8] * z;
        this.y = e[1] * x + e[5] * y + e[9] * z;
        this.z = e[2] * x + e[6] * y + e[10] * z;
        return this.normalize();
    },
    divide: function(v) {
        this.x /= v.x;
        this.y /= v.y;
        this.z /= v.z;
        return this;
    },
    divideScalar: function(scalar) {
        return this.multiplyScalar(1 / scalar);
    },
    min: function(v) {
        this.x = Math.min(this.x, v.x);
        this.y = Math.min(this.y, v.y);
        this.z = Math.min(this.z, v.z);
        return this;
    },
    max: function(v) {
        this.x = Math.max(this.x, v.x);
        this.y = Math.max(this.y, v.y);
        this.z = Math.max(this.z, v.z);
        return this;
    },
    clamp: function(min, max) {
        // assumes min < max, componentwise
        this.x = Math.max(min.x, Math.min(max.x, this.x));
        this.y = Math.max(min.y, Math.min(max.y, this.y));
        this.z = Math.max(min.z, Math.min(max.z, this.z));
        return this;
    },
    clampScalar: function() {
        var min = new Vector3();
        var max = new Vector3();
        return function clampScalar(minVal, maxVal) {
            min.set(minVal, minVal, minVal);
            max.set(maxVal, maxVal, maxVal);
            return this.clamp(min, max);
        };
    }(),
    clampLength: function(min, max) {
        var length = this.length();
        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
    },
    floor: function() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        this.z = Math.floor(this.z);
        return this;
    },
    ceil: function() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        this.z = Math.ceil(this.z);
        return this;
    },
    round: function() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        this.z = Math.round(this.z);
        return this;
    },
    roundToZero: function() {
        this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
        return this;
    },
    negate: function() {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        return this;
    },
    dot: function(v) {
        return this.x * v.x + this.y * v.y + this.z * v.z;
    },
    // TODO lengthSquared?
    lengthSq: function() {
        return this.x * this.x + this.y * this.y + this.z * this.z;
    },
    length: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    },
    manhattanLength: function() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    },
    normalize: function() {
        return this.divideScalar(this.length() || 1);
    },
    setLength: function(length) {
        return this.normalize().multiplyScalar(length);
    },
    lerp: function(v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        this.z += (v.z - this.z) * alpha;
        return this;
    },
    lerpVectors: function(v1, v2, alpha) {
        return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
    },
    cross: function(v, w) {
        if (w !== undefined) {
            console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.");
            return this.crossVectors(v, w);
        }
        return this.crossVectors(this, v);
    },
    crossVectors: function(a, b) {
        var ax = a.x, ay = a.y, az = a.z;
        var bx = b.x, by = b.y, bz = b.z;
        this.x = ay * bz - az * by;
        this.y = az * bx - ax * bz;
        this.z = ax * by - ay * bx;
        return this;
    },
    projectOnVector: function(vector) {
        var scalar = vector.dot(this) / vector.lengthSq();
        return this.copy(vector).multiplyScalar(scalar);
    },
    projectOnPlane: function() {
        var v1 = new Vector3();
        return function projectOnPlane(planeNormal) {
            v1.copy(this).projectOnVector(planeNormal);
            return this.sub(v1);
        };
    }(),
    reflect: function() {
        // reflect incident vector off plane orthogonal to normal
        // normal is assumed to have unit length
        var v1 = new Vector3();
        return function reflect(normal) {
            return this.sub(v1.copy(normal).multiplyScalar(2 * this.dot(normal)));
        };
    }(),
    angleTo: function(v) {
        var theta = this.dot(v) / Math.sqrt(this.lengthSq() * v.lengthSq());
        // clamp, to handle numerical problems
        return Math.acos(_Math.clamp(theta, -1, 1));
    },
    distanceTo: function(v) {
        return Math.sqrt(this.distanceToSquared(v));
    },
    distanceToSquared: function(v) {
        var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
        return dx * dx + dy * dy + dz * dz;
    },
    manhattanDistanceTo: function(v) {
        return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
    },
    setFromSpherical: function(s) {
        return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
    },
    setFromSphericalCoords: function(radius, phi, theta) {
        var sinPhiRadius = Math.sin(phi) * radius;
        this.x = sinPhiRadius * Math.sin(theta);
        this.y = Math.cos(phi) * radius;
        this.z = sinPhiRadius * Math.cos(theta);
        return this;
    },
    setFromCylindrical: function(c) {
        return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
    },
    setFromCylindricalCoords: function(radius, theta, y) {
        this.x = radius * Math.sin(theta);
        this.y = y;
        this.z = radius * Math.cos(theta);
        return this;
    },
    setFromMatrixPosition: function(m) {
        var e = m.elements;
        this.x = e[12];
        this.y = e[13];
        this.z = e[14];
        return this;
    },
    setFromMatrixScale: function(m) {
        var sx = this.setFromMatrixColumn(m, 0).length();
        var sy = this.setFromMatrixColumn(m, 1).length();
        var sz = this.setFromMatrixColumn(m, 2).length();
        this.x = sx;
        this.y = sy;
        this.z = sz;
        return this;
    },
    setFromMatrixColumn: function(m, index) {
        return this.fromArray(m.elements, index * 4);
    },
    equals: function(v) {
        return v.x === this.x && v.y === this.y && v.z === this.z;
    },
    fromArray: function(array, offset) {
        if (offset === undefined) offset = 0;
        this.x = array[offset];
        this.y = array[offset + 1];
        this.z = array[offset + 2];
        return this;
    },
    toArray: function(array, offset) {
        if (array === undefined) array = [];
        if (offset === undefined) offset = 0;
        array[offset] = this.x;
        array[offset + 1] = this.y;
        array[offset + 2] = this.z;
        return array;
    },
    fromBufferAttribute: function(attribute, index, offset) {
        if (offset !== undefined) console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute().");
        this.x = attribute.getX(index);
        this.y = attribute.getY(index);
        this.z = attribute.getZ(index);
        return this;
    }
});
/**
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 * @author tschw
 */ function Matrix3() {
    this.elements = [
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
    ];
    if (arguments.length > 0) console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
}
Object.assign(Matrix3.prototype, {
    isMatrix3: true,
    set: function(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
        var te = this.elements;
        te[0] = n11;
        te[1] = n21;
        te[2] = n31;
        te[3] = n12;
        te[4] = n22;
        te[5] = n32;
        te[6] = n13;
        te[7] = n23;
        te[8] = n33;
        return this;
    },
    identity: function() {
        this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
        return this;
    },
    clone: function() {
        return new this.constructor().fromArray(this.elements);
    },
    copy: function(m) {
        var te = this.elements;
        var me = m.elements;
        te[0] = me[0];
        te[1] = me[1];
        te[2] = me[2];
        te[3] = me[3];
        te[4] = me[4];
        te[5] = me[5];
        te[6] = me[6];
        te[7] = me[7];
        te[8] = me[8];
        return this;
    },
    setFromMatrix4: function(m) {
        var me = m.elements;
        this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
        return this;
    },
    applyToBufferAttribute: function() {
        var v1 = new Vector3();
        return function applyToBufferAttribute(attribute) {
            for(var i = 0, l = attribute.count; i < l; i++){
                v1.x = attribute.getX(i);
                v1.y = attribute.getY(i);
                v1.z = attribute.getZ(i);
                v1.applyMatrix3(this);
                attribute.setXYZ(i, v1.x, v1.y, v1.z);
            }
            return attribute;
        };
    }(),
    multiply: function(m) {
        return this.multiplyMatrices(this, m);
    },
    premultiply: function(m) {
        return this.multiplyMatrices(m, this);
    },
    multiplyMatrices: function(a, b) {
        var ae = a.elements;
        var be = b.elements;
        var te = this.elements;
        var a11 = ae[0], a12 = ae[3], a13 = ae[6];
        var a21 = ae[1], a22 = ae[4], a23 = ae[7];
        var a31 = ae[2], a32 = ae[5], a33 = ae[8];
        var b11 = be[0], b12 = be[3], b13 = be[6];
        var b21 = be[1], b22 = be[4], b23 = be[7];
        var b31 = be[2], b32 = be[5], b33 = be[8];
        te[0] = a11 * b11 + a12 * b21 + a13 * b31;
        te[3] = a11 * b12 + a12 * b22 + a13 * b32;
        te[6] = a11 * b13 + a12 * b23 + a13 * b33;
        te[1] = a21 * b11 + a22 * b21 + a23 * b31;
        te[4] = a21 * b12 + a22 * b22 + a23 * b32;
        te[7] = a21 * b13 + a22 * b23 + a23 * b33;
        te[2] = a31 * b11 + a32 * b21 + a33 * b31;
        te[5] = a31 * b12 + a32 * b22 + a33 * b32;
        te[8] = a31 * b13 + a32 * b23 + a33 * b33;
        return this;
    },
    multiplyScalar: function(s) {
        var te = this.elements;
        te[0] *= s;
        te[3] *= s;
        te[6] *= s;
        te[1] *= s;
        te[4] *= s;
        te[7] *= s;
        te[2] *= s;
        te[5] *= s;
        te[8] *= s;
        return this;
    },
    determinant: function() {
        var te = this.elements;
        var a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i = te[8];
        return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
    },
    getInverse: function(matrix, throwOnDegenerate) {
        if (matrix && matrix.isMatrix4) console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
        var me = matrix.elements, te = this.elements, n11 = me[0], n21 = me[1], n31 = me[2], n12 = me[3], n22 = me[4], n32 = me[5], n13 = me[6], n23 = me[7], n33 = me[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
        if (det === 0) {
            var msg = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";
            if (throwOnDegenerate === true) throw new Error(msg);
            else console.warn(msg);
            return this.identity();
        }
        var detInv = 1 / det;
        te[0] = t11 * detInv;
        te[1] = (n31 * n23 - n33 * n21) * detInv;
        te[2] = (n32 * n21 - n31 * n22) * detInv;
        te[3] = t12 * detInv;
        te[4] = (n33 * n11 - n31 * n13) * detInv;
        te[5] = (n31 * n12 - n32 * n11) * detInv;
        te[6] = t13 * detInv;
        te[7] = (n21 * n13 - n23 * n11) * detInv;
        te[8] = (n22 * n11 - n21 * n12) * detInv;
        return this;
    },
    transpose: function() {
        var tmp, m = this.elements;
        tmp = m[1];
        m[1] = m[3];
        m[3] = tmp;
        tmp = m[2];
        m[2] = m[6];
        m[6] = tmp;
        tmp = m[5];
        m[5] = m[7];
        m[7] = tmp;
        return this;
    },
    getNormalMatrix: function(matrix4) {
        return this.setFromMatrix4(matrix4).getInverse(this).transpose();
    },
    transposeIntoArray: function(r) {
        var m = this.elements;
        r[0] = m[0];
        r[1] = m[3];
        r[2] = m[6];
        r[3] = m[1];
        r[4] = m[4];
        r[5] = m[7];
        r[6] = m[2];
        r[7] = m[5];
        r[8] = m[8];
        return this;
    },
    setUvTransform: function(tx, ty, sx, sy, rotation, cx, cy) {
        var c = Math.cos(rotation);
        var s = Math.sin(rotation);
        this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);
    },
    scale: function(sx, sy) {
        var te = this.elements;
        te[0] *= sx;
        te[3] *= sx;
        te[6] *= sx;
        te[1] *= sy;
        te[4] *= sy;
        te[7] *= sy;
        return this;
    },
    rotate: function(theta) {
        var c = Math.cos(theta);
        var s = Math.sin(theta);
        var te = this.elements;
        var a11 = te[0], a12 = te[3], a13 = te[6];
        var a21 = te[1], a22 = te[4], a23 = te[7];
        te[0] = c * a11 + s * a21;
        te[3] = c * a12 + s * a22;
        te[6] = c * a13 + s * a23;
        te[1] = -s * a11 + c * a21;
        te[4] = -s * a12 + c * a22;
        te[7] = -s * a13 + c * a23;
        return this;
    },
    translate: function(tx, ty) {
        var te = this.elements;
        te[0] += tx * te[2];
        te[3] += tx * te[5];
        te[6] += tx * te[8];
        te[1] += ty * te[2];
        te[4] += ty * te[5];
        te[7] += ty * te[8];
        return this;
    },
    equals: function(matrix) {
        var te = this.elements;
        var me = matrix.elements;
        for(var i = 0; i < 9; i++){
            if (te[i] !== me[i]) return false;
        }
        return true;
    },
    fromArray: function(array, offset) {
        if (offset === undefined) offset = 0;
        for(var i = 0; i < 9; i++)this.elements[i] = array[i + offset];
        return this;
    },
    toArray: function(array, offset) {
        if (array === undefined) array = [];
        if (offset === undefined) offset = 0;
        var te = this.elements;
        array[offset] = te[0];
        array[offset + 1] = te[1];
        array[offset + 2] = te[2];
        array[offset + 3] = te[3];
        array[offset + 4] = te[4];
        array[offset + 5] = te[5];
        array[offset + 6] = te[6];
        array[offset + 7] = te[7];
        array[offset + 8] = te[8];
        return array;
    }
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */ var _canvas;
var ImageUtils = {
    getDataURL: function(image) {
        var canvas;
        if (typeof HTMLCanvasElement == "undefined") return image.src;
        else if (image instanceof HTMLCanvasElement) canvas = image;
        else {
            if (_canvas === undefined) _canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
            _canvas.width = image.width;
            _canvas.height = image.height;
            var context = _canvas.getContext("2d");
            if (image instanceof ImageData) context.putImageData(image, 0, 0);
            else context.drawImage(image, 0, 0, image.width, image.height);
            canvas = _canvas;
        }
        if (canvas.width > 2048 || canvas.height > 2048) return canvas.toDataURL("image/jpeg", 0.6);
        else return canvas.toDataURL("image/png");
    }
};
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */ var textureId = 0;
function Texture(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
    Object.defineProperty(this, "id", {
        value: textureId++
    });
    this.uuid = _Math.generateUUID();
    this.name = "";
    this.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;
    this.mipmaps = [];
    this.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;
    this.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;
    this.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;
    this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
    this.minFilter = minFilter !== undefined ? minFilter : LinearMipMapLinearFilter;
    this.anisotropy = anisotropy !== undefined ? anisotropy : 1;
    this.format = format !== undefined ? format : RGBAFormat;
    this.type = type !== undefined ? type : UnsignedByteType;
    this.offset = new Vector2(0, 0);
    this.repeat = new Vector2(1, 1);
    this.center = new Vector2(0, 0);
    this.rotation = 0;
    this.matrixAutoUpdate = true;
    this.matrix = new Matrix3();
    this.generateMipmaps = true;
    this.premultiplyAlpha = false;
    this.flipY = true;
    this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)
    // Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
    //
    // Also changing the encoding after already used by a Material will not automatically make the Material
    // update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.
    this.encoding = encoding !== undefined ? encoding : LinearEncoding;
    this.version = 0;
    this.onUpdate = null;
}
Texture.DEFAULT_IMAGE = undefined;
Texture.DEFAULT_MAPPING = UVMapping;
Texture.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
    constructor: Texture,
    isTexture: true,
    updateMatrix: function() {
        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(source) {
        this.name = source.name;
        this.image = source.image;
        this.mipmaps = source.mipmaps.slice(0);
        this.mapping = source.mapping;
        this.wrapS = source.wrapS;
        this.wrapT = source.wrapT;
        this.magFilter = source.magFilter;
        this.minFilter = source.minFilter;
        this.anisotropy = source.anisotropy;
        this.format = source.format;
        this.type = source.type;
        this.offset.copy(source.offset);
        this.repeat.copy(source.repeat);
        this.center.copy(source.center);
        this.rotation = source.rotation;
        this.matrixAutoUpdate = source.matrixAutoUpdate;
        this.matrix.copy(source.matrix);
        this.generateMipmaps = source.generateMipmaps;
        this.premultiplyAlpha = source.premultiplyAlpha;
        this.flipY = source.flipY;
        this.unpackAlignment = source.unpackAlignment;
        this.encoding = source.encoding;
        return this;
    },
    toJSON: function(meta) {
        var isRootObject = meta === undefined || typeof meta === "string";
        if (!isRootObject && meta.textures[this.uuid] !== undefined) return meta.textures[this.uuid];
        var output = {
            metadata: {
                version: 4.5,
                type: "Texture",
                generator: "Texture.toJSON"
            },
            uuid: this.uuid,
            name: this.name,
            mapping: this.mapping,
            repeat: [
                this.repeat.x,
                this.repeat.y
            ],
            offset: [
                this.offset.x,
                this.offset.y
            ],
            center: [
                this.center.x,
                this.center.y
            ],
            rotation: this.rotation,
            wrap: [
                this.wrapS,
                this.wrapT
            ],
            format: this.format,
            type: this.type,
            encoding: this.encoding,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment
        };
        if (this.image !== undefined) {
            // TODO: Move to THREE.Image
            var image = this.image;
            if (image.uuid === undefined) image.uuid = _Math.generateUUID(); // UGH
            if (!isRootObject && meta.images[image.uuid] === undefined) {
                var url;
                if (Array.isArray(image)) {
                    // process array of images e.g. CubeTexture
                    url = [];
                    for(var i = 0, l = image.length; i < l; i++)url.push(ImageUtils.getDataURL(image[i]));
                } else // process single image
                url = ImageUtils.getDataURL(image);
                meta.images[image.uuid] = {
                    uuid: image.uuid,
                    url: url
                };
            }
            output.image = image.uuid;
        }
        if (!isRootObject) meta.textures[this.uuid] = output;
        return output;
    },
    dispose: function() {
        this.dispatchEvent({
            type: "dispose"
        });
    },
    transformUv: function(uv) {
        if (this.mapping !== UVMapping) return uv;
        uv.applyMatrix3(this.matrix);
        if (uv.x < 0 || uv.x > 1) switch(this.wrapS){
            case RepeatWrapping:
                uv.x = uv.x - Math.floor(uv.x);
                break;
            case ClampToEdgeWrapping:
                uv.x = uv.x < 0 ? 0 : 1;
                break;
            case MirroredRepeatWrapping:
                if (Math.abs(Math.floor(uv.x) % 2) === 1) uv.x = Math.ceil(uv.x) - uv.x;
                else uv.x = uv.x - Math.floor(uv.x);
                break;
        }
        if (uv.y < 0 || uv.y > 1) switch(this.wrapT){
            case RepeatWrapping:
                uv.y = uv.y - Math.floor(uv.y);
                break;
            case ClampToEdgeWrapping:
                uv.y = uv.y < 0 ? 0 : 1;
                break;
            case MirroredRepeatWrapping:
                if (Math.abs(Math.floor(uv.y) % 2) === 1) uv.y = Math.ceil(uv.y) - uv.y;
                else uv.y = uv.y - Math.floor(uv.y);
                break;
        }
        if (this.flipY) uv.y = 1 - uv.y;
        return uv;
    }
});
Object.defineProperty(Texture.prototype, "needsUpdate", {
    set: function(value) {
        if (value === true) this.version++;
    }
});
/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */ function Vector4(x, y, z, w) {
    this.x = x || 0;
    this.y = y || 0;
    this.z = z || 0;
    this.w = w !== undefined ? w : 1;
}
Object.assign(Vector4.prototype, {
    isVector4: true,
    set: function(x, y, z, w) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
        return this;
    },
    setScalar: function(scalar) {
        this.x = scalar;
        this.y = scalar;
        this.z = scalar;
        this.w = scalar;
        return this;
    },
    setX: function(x) {
        this.x = x;
        return this;
    },
    setY: function(y) {
        this.y = y;
        return this;
    },
    setZ: function(z) {
        this.z = z;
        return this;
    },
    setW: function(w) {
        this.w = w;
        return this;
    },
    setComponent: function(index, value) {
        switch(index){
            case 0:
                this.x = value;
                break;
            case 1:
                this.y = value;
                break;
            case 2:
                this.z = value;
                break;
            case 3:
                this.w = value;
                break;
            default:
                throw new Error("index is out of range: " + index);
        }
        return this;
    },
    getComponent: function(index) {
        switch(index){
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            case 3:
                return this.w;
            default:
                throw new Error("index is out of range: " + index);
        }
    },
    clone: function() {
        return new this.constructor(this.x, this.y, this.z, this.w);
    },
    copy: function(v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        this.w = v.w !== undefined ? v.w : 1;
        return this;
    },
    add: function(v, w) {
        if (w !== undefined) {
            console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
            return this.addVectors(v, w);
        }
        this.x += v.x;
        this.y += v.y;
        this.z += v.z;
        this.w += v.w;
        return this;
    },
    addScalar: function(s) {
        this.x += s;
        this.y += s;
        this.z += s;
        this.w += s;
        return this;
    },
    addVectors: function(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        this.z = a.z + b.z;
        this.w = a.w + b.w;
        return this;
    },
    addScaledVector: function(v, s) {
        this.x += v.x * s;
        this.y += v.y * s;
        this.z += v.z * s;
        this.w += v.w * s;
        return this;
    },
    sub: function(v, w) {
        if (w !== undefined) {
            console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
            return this.subVectors(v, w);
        }
        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;
        this.w -= v.w;
        return this;
    },
    subScalar: function(s) {
        this.x -= s;
        this.y -= s;
        this.z -= s;
        this.w -= s;
        return this;
    },
    subVectors: function(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        this.z = a.z - b.z;
        this.w = a.w - b.w;
        return this;
    },
    multiplyScalar: function(scalar) {
        this.x *= scalar;
        this.y *= scalar;
        this.z *= scalar;
        this.w *= scalar;
        return this;
    },
    applyMatrix4: function(m) {
        var x = this.x, y = this.y, z = this.z, w = this.w;
        var e = m.elements;
        this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
        this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
        this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
        this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
        return this;
    },
    divideScalar: function(scalar) {
        return this.multiplyScalar(1 / scalar);
    },
    setAxisAngleFromQuaternion: function(q) {
        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
        // q is assumed to be normalized
        this.w = 2 * Math.acos(q.w);
        var s = Math.sqrt(1 - q.w * q.w);
        if (s < 0.0001) {
            this.x = 1;
            this.y = 0;
            this.z = 0;
        } else {
            this.x = q.x / s;
            this.y = q.y / s;
            this.z = q.z / s;
        }
        return this;
    },
    setAxisAngleFromRotationMatrix: function(m) {
        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm
        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
        var angle, x, y, z, epsilon = 0.01, epsilon2 = 0.1, te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
        if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
            // singularity found
            // first check for identity matrix which must have +1 for all terms
            // in leading diagonal and zero in other terms
            if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
                // this singularity is identity matrix so angle = 0
                this.set(1, 0, 0, 0);
                return this; // zero angle, arbitrary axis
            }
            // otherwise this singularity is angle = 180
            angle = Math.PI;
            var xx = (m11 + 1) / 2;
            var yy = (m22 + 1) / 2;
            var zz = (m33 + 1) / 2;
            var xy = (m12 + m21) / 4;
            var xz = (m13 + m31) / 4;
            var yz = (m23 + m32) / 4;
            if (xx > yy && xx > zz) {
                // m11 is the largest diagonal term
                if (xx < epsilon) {
                    x = 0;
                    y = 0.707106781;
                    z = 0.707106781;
                } else {
                    x = Math.sqrt(xx);
                    y = xy / x;
                    z = xz / x;
                }
            } else if (yy > zz) {
                // m22 is the largest diagonal term
                if (yy < epsilon) {
                    x = 0.707106781;
                    y = 0;
                    z = 0.707106781;
                } else {
                    y = Math.sqrt(yy);
                    x = xy / y;
                    z = yz / y;
                }
            } else // m33 is the largest diagonal term so base result on this
            if (zz < epsilon) {
                x = 0.707106781;
                y = 0.707106781;
                z = 0;
            } else {
                z = Math.sqrt(zz);
                x = xz / z;
                y = yz / z;
            }
            this.set(x, y, z, angle);
            return this; // return 180 deg rotation
        }
        // as we have reached here there are no singularities so we can handle normally
        var s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12)); // used to normalize
        if (Math.abs(s) < 0.001) s = 1;
        // prevent divide by zero, should not happen if matrix is orthogonal and should be
        // caught by singularity test above, but I've left it in just in case
        this.x = (m32 - m23) / s;
        this.y = (m13 - m31) / s;
        this.z = (m21 - m12) / s;
        this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
        return this;
    },
    min: function(v) {
        this.x = Math.min(this.x, v.x);
        this.y = Math.min(this.y, v.y);
        this.z = Math.min(this.z, v.z);
        this.w = Math.min(this.w, v.w);
        return this;
    },
    max: function(v) {
        this.x = Math.max(this.x, v.x);
        this.y = Math.max(this.y, v.y);
        this.z = Math.max(this.z, v.z);
        this.w = Math.max(this.w, v.w);
        return this;
    },
    clamp: function(min, max) {
        // assumes min < max, componentwise
        this.x = Math.max(min.x, Math.min(max.x, this.x));
        this.y = Math.max(min.y, Math.min(max.y, this.y));
        this.z = Math.max(min.z, Math.min(max.z, this.z));
        this.w = Math.max(min.w, Math.min(max.w, this.w));
        return this;
    },
    clampScalar: function() {
        var min, max;
        return function clampScalar(minVal, maxVal) {
            if (min === undefined) {
                min = new Vector4();
                max = new Vector4();
            }
            min.set(minVal, minVal, minVal, minVal);
            max.set(maxVal, maxVal, maxVal, maxVal);
            return this.clamp(min, max);
        };
    }(),
    clampLength: function(min, max) {
        var length = this.length();
        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
    },
    floor: function() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        this.z = Math.floor(this.z);
        this.w = Math.floor(this.w);
        return this;
    },
    ceil: function() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        this.z = Math.ceil(this.z);
        this.w = Math.ceil(this.w);
        return this;
    },
    round: function() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        this.z = Math.round(this.z);
        this.w = Math.round(this.w);
        return this;
    },
    roundToZero: function() {
        this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
        this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
        return this;
    },
    negate: function() {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        this.w = -this.w;
        return this;
    },
    dot: function(v) {
        return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
    },
    lengthSq: function() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    },
    length: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    },
    manhattanLength: function() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
    },
    normalize: function() {
        return this.divideScalar(this.length() || 1);
    },
    setLength: function(length) {
        return this.normalize().multiplyScalar(length);
    },
    lerp: function(v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        this.z += (v.z - this.z) * alpha;
        this.w += (v.w - this.w) * alpha;
        return this;
    },
    lerpVectors: function(v1, v2, alpha) {
        return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
    },
    equals: function(v) {
        return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
    },
    fromArray: function(array, offset) {
        if (offset === undefined) offset = 0;
        this.x = array[offset];
        this.y = array[offset + 1];
        this.z = array[offset + 2];
        this.w = array[offset + 3];
        return this;
    },
    toArray: function(array, offset) {
        if (array === undefined) array = [];
        if (offset === undefined) offset = 0;
        array[offset] = this.x;
        array[offset + 1] = this.y;
        array[offset + 2] = this.z;
        array[offset + 3] = this.w;
        return array;
    },
    fromBufferAttribute: function(attribute, index, offset) {
        if (offset !== undefined) console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute().");
        this.x = attribute.getX(index);
        this.y = attribute.getY(index);
        this.z = attribute.getZ(index);
        this.w = attribute.getW(index);
        return this;
    }
});
/**
 * @author szimek / https://github.com/szimek/
 * @author alteredq / http://alteredqualia.com/
 * @author Marius Kintel / https://github.com/kintel
 */ /*
 In options, we can specify:
 * Texture parameters for an auto-generated target texture
 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
*/ function WebGLRenderTarget(width, height, options) {
    this.width = width;
    this.height = height;
    this.scissor = new Vector4(0, 0, width, height);
    this.scissorTest = false;
    this.viewport = new Vector4(0, 0, width, height);
    options = options || {};
    this.texture = new Texture(undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
    this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
    this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;
    this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
    this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
    this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;
}
WebGLRenderTarget.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
    constructor: WebGLRenderTarget,
    isWebGLRenderTarget: true,
    setSize: function(width, height) {
        if (this.width !== width || this.height !== height) {
            this.width = width;
            this.height = height;
            this.dispose();
        }
        this.viewport.set(0, 0, width, height);
        this.scissor.set(0, 0, width, height);
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(source) {
        this.width = source.width;
        this.height = source.height;
        this.viewport.copy(source.viewport);
        this.texture = source.texture.clone();
        this.depthBuffer = source.depthBuffer;
        this.stencilBuffer = source.stencilBuffer;
        this.depthTexture = source.depthTexture;
        return this;
    },
    dispose: function() {
        this.dispatchEvent({
            type: "dispose"
        });
    }
});
/**
 * @author alteredq / http://alteredqualia.com
 */ function WebGLRenderTargetCube(width, height, options) {
    WebGLRenderTarget.call(this, width, height, options);
    this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5
    this.activeMipMapLevel = 0;
}
WebGLRenderTargetCube.prototype = Object.create(WebGLRenderTarget.prototype);
WebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube;
WebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = true;
/**
 * @author alteredq / http://alteredqualia.com/
 */ function DataTexture(data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
    Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
    this.image = {
        data: data,
        width: width,
        height: height
    };
    this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
    this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
}
DataTexture.prototype = Object.create(Texture.prototype);
DataTexture.prototype.constructor = DataTexture;
DataTexture.prototype.isDataTexture = true;
/**
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 */ function Box3(min, max) {
    this.min = min !== undefined ? min : new Vector3(Infinity, Infinity, Infinity);
    this.max = max !== undefined ? max : new Vector3(-Infinity, -Infinity, -Infinity);
}
Object.assign(Box3.prototype, {
    isBox3: true,
    set: function(min, max) {
        this.min.copy(min);
        this.max.copy(max);
        return this;
    },
    setFromArray: function(array) {
        var minX = Infinity;
        var minY = Infinity;
        var minZ = Infinity;
        var maxX = -Infinity;
        var maxY = -Infinity;
        var maxZ = -Infinity;
        for(var i = 0, l = array.length; i < l; i += 3){
            var x = array[i];
            var y = array[i + 1];
            var z = array[i + 2];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (z < minZ) minZ = z;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
            if (z > maxZ) maxZ = z;
        }
        this.min.set(minX, minY, minZ);
        this.max.set(maxX, maxY, maxZ);
        return this;
    },
    setFromBufferAttribute: function(attribute) {
        var minX = Infinity;
        var minY = Infinity;
        var minZ = Infinity;
        var maxX = -Infinity;
        var maxY = -Infinity;
        var maxZ = -Infinity;
        for(var i = 0, l = attribute.count; i < l; i++){
            var x = attribute.getX(i);
            var y = attribute.getY(i);
            var z = attribute.getZ(i);
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (z < minZ) minZ = z;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
            if (z > maxZ) maxZ = z;
        }
        this.min.set(minX, minY, minZ);
        this.max.set(maxX, maxY, maxZ);
        return this;
    },
    setFromPoints: function(points) {
        this.makeEmpty();
        for(var i = 0, il = points.length; i < il; i++)this.expandByPoint(points[i]);
        return this;
    },
    setFromCenterAndSize: function() {
        var v1 = new Vector3();
        return function setFromCenterAndSize(center, size) {
            var halfSize = v1.copy(size).multiplyScalar(0.5);
            this.min.copy(center).sub(halfSize);
            this.max.copy(center).add(halfSize);
            return this;
        };
    }(),
    setFromObject: function(object) {
        this.makeEmpty();
        return this.expandByObject(object);
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(box) {
        this.min.copy(box.min);
        this.max.copy(box.max);
        return this;
    },
    makeEmpty: function() {
        this.min.x = this.min.y = this.min.z = Infinity;
        this.max.x = this.max.y = this.max.z = -Infinity;
        return this;
    },
    isEmpty: function() {
        // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
    },
    getCenter: function(target) {
        if (target === undefined) {
            console.warn("THREE.Box3: .getCenter() target is now required");
            target = new Vector3();
        }
        return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
    },
    getSize: function(target) {
        if (target === undefined) {
            console.warn("THREE.Box3: .getSize() target is now required");
            target = new Vector3();
        }
        return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
    },
    expandByPoint: function(point) {
        this.min.min(point);
        this.max.max(point);
        return this;
    },
    expandByVector: function(vector) {
        this.min.sub(vector);
        this.max.add(vector);
        return this;
    },
    expandByScalar: function(scalar) {
        this.min.addScalar(-scalar);
        this.max.addScalar(scalar);
        return this;
    },
    expandByObject: function() {
        // Computes the world-axis-aligned bounding box of an object (including its children),
        // accounting for both the object's, and children's, world transforms
        var scope, i, l;
        var v1 = new Vector3();
        function traverse(node) {
            var geometry = node.geometry;
            if (geometry !== undefined) {
                if (geometry.isGeometry) {
                    var vertices = geometry.vertices;
                    for(i = 0, l = vertices.length; i < l; i++){
                        v1.copy(vertices[i]);
                        v1.applyMatrix4(node.matrixWorld);
                        scope.expandByPoint(v1);
                    }
                } else if (geometry.isBufferGeometry) {
                    var attribute = geometry.attributes.position;
                    if (attribute !== undefined) for(i = 0, l = attribute.count; i < l; i++){
                        v1.fromBufferAttribute(attribute, i).applyMatrix4(node.matrixWorld);
                        scope.expandByPoint(v1);
                    }
                }
            }
        }
        return function expandByObject(object) {
            scope = this;
            object.updateMatrixWorld(true);
            object.traverse(traverse);
            return this;
        };
    }(),
    containsPoint: function(point) {
        return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
    },
    containsBox: function(box) {
        return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
    },
    getParameter: function(point, target) {
        // This can potentially have a divide by zero if the box
        // has a size dimension of 0.
        if (target === undefined) {
            console.warn("THREE.Box3: .getParameter() target is now required");
            target = new Vector3();
        }
        return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
    },
    intersectsBox: function(box) {
        // using 6 splitting planes to rule out intersections.
        return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
    },
    intersectsSphere: function() {
        var closestPoint = new Vector3();
        return function intersectsSphere(sphere) {
            // Find the point on the AABB closest to the sphere center.
            this.clampPoint(sphere.center, closestPoint);
            // If that point is inside the sphere, the AABB and sphere intersect.
            return closestPoint.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
        };
    }(),
    intersectsPlane: function(plane) {
        // We compute the minimum and maximum dot product values. If those values
        // are on the same side (back or front) of the plane, then there is no intersection.
        var min, max;
        if (plane.normal.x > 0) {
            min = plane.normal.x * this.min.x;
            max = plane.normal.x * this.max.x;
        } else {
            min = plane.normal.x * this.max.x;
            max = plane.normal.x * this.min.x;
        }
        if (plane.normal.y > 0) {
            min += plane.normal.y * this.min.y;
            max += plane.normal.y * this.max.y;
        } else {
            min += plane.normal.y * this.max.y;
            max += plane.normal.y * this.min.y;
        }
        if (plane.normal.z > 0) {
            min += plane.normal.z * this.min.z;
            max += plane.normal.z * this.max.z;
        } else {
            min += plane.normal.z * this.max.z;
            max += plane.normal.z * this.min.z;
        }
        return min <= -plane.constant && max >= -plane.constant;
    },
    intersectsTriangle: function() {
        // triangle centered vertices
        var v0 = new Vector3();
        var v1 = new Vector3();
        var v2 = new Vector3();
        // triangle edge vectors
        var f0 = new Vector3();
        var f1 = new Vector3();
        var f2 = new Vector3();
        var testAxis = new Vector3();
        var center = new Vector3();
        var extents = new Vector3();
        var triangleNormal = new Vector3();
        function satForAxes(axes) {
            var i, j;
            for(i = 0, j = axes.length - 3; i <= j; i += 3){
                testAxis.fromArray(axes, i);
                // project the aabb onto the seperating axis
                var r = extents.x * Math.abs(testAxis.x) + extents.y * Math.abs(testAxis.y) + extents.z * Math.abs(testAxis.z);
                // project all 3 vertices of the triangle onto the seperating axis
                var p0 = v0.dot(testAxis);
                var p1 = v1.dot(testAxis);
                var p2 = v2.dot(testAxis);
                // actual test, basically see if either of the most extreme of the triangle points intersects r
                if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) // points of the projected triangle are outside the projected half-length of the aabb
                // the axis is seperating and we can exit
                return false;
            }
            return true;
        }
        return function intersectsTriangle(triangle) {
            if (this.isEmpty()) return false;
            // compute box center and extents
            this.getCenter(center);
            extents.subVectors(this.max, center);
            // translate triangle to aabb origin
            v0.subVectors(triangle.a, center);
            v1.subVectors(triangle.b, center);
            v2.subVectors(triangle.c, center);
            // compute edge vectors for triangle
            f0.subVectors(v1, v0);
            f1.subVectors(v2, v1);
            f2.subVectors(v0, v2);
            // test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
            // make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
            // axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
            var axes = [
                0,
                -f0.z,
                f0.y,
                0,
                -f1.z,
                f1.y,
                0,
                -f2.z,
                f2.y,
                f0.z,
                0,
                -f0.x,
                f1.z,
                0,
                -f1.x,
                f2.z,
                0,
                -f2.x,
                -f0.y,
                f0.x,
                0,
                -f1.y,
                f1.x,
                0,
                -f2.y,
                f2.x,
                0
            ];
            if (!satForAxes(axes)) return false;
            // test 3 face normals from the aabb
            axes = [
                1,
                0,
                0,
                0,
                1,
                0,
                0,
                0,
                1
            ];
            if (!satForAxes(axes)) return false;
            // finally testing the face normal of the triangle
            // use already existing triangle edge vectors here
            triangleNormal.crossVectors(f0, f1);
            axes = [
                triangleNormal.x,
                triangleNormal.y,
                triangleNormal.z
            ];
            return satForAxes(axes);
        };
    }(),
    clampPoint: function(point, target) {
        if (target === undefined) {
            console.warn("THREE.Box3: .clampPoint() target is now required");
            target = new Vector3();
        }
        return target.copy(point).clamp(this.min, this.max);
    },
    distanceToPoint: function() {
        var v1 = new Vector3();
        return function distanceToPoint(point) {
            var clampedPoint = v1.copy(point).clamp(this.min, this.max);
            return clampedPoint.sub(point).length();
        };
    }(),
    getBoundingSphere: function() {
        var v1 = new Vector3();
        return function getBoundingSphere(target) {
            if (target === undefined) {
                console.warn("THREE.Box3: .getBoundingSphere() target is now required");
                target = new Sphere();
            }
            this.getCenter(target.center);
            target.radius = this.getSize(v1).length() * 0.5;
            return target;
        };
    }(),
    intersect: function(box) {
        this.min.max(box.min);
        this.max.min(box.max);
        // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
        if (this.isEmpty()) this.makeEmpty();
        return this;
    },
    union: function(box) {
        this.min.min(box.min);
        this.max.max(box.max);
        return this;
    },
    applyMatrix4: function() {
        var points = [
            new Vector3(),
            new Vector3(),
            new Vector3(),
            new Vector3(),
            new Vector3(),
            new Vector3(),
            new Vector3(),
            new Vector3()
        ];
        return function applyMatrix4(matrix) {
            // transform of empty box is an empty box.
            if (this.isEmpty()) return this;
            // NOTE: I am using a binary pattern to specify all 2^3 combinations below
            points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000
            points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001
            points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010
            points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011
            points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100
            points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101
            points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110
            points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix); // 111
            this.setFromPoints(points);
            return this;
        };
    }(),
    translate: function(offset) {
        this.min.add(offset);
        this.max.add(offset);
        return this;
    },
    equals: function(box) {
        return box.min.equals(this.min) && box.max.equals(this.max);
    }
});
/**
 * @author bhouston / http://clara.io
 * @author mrdoob / http://mrdoob.com/
 */ function Sphere(center, radius) {
    this.center = center !== undefined ? center : new Vector3();
    this.radius = radius !== undefined ? radius : 0;
}
Object.assign(Sphere.prototype, {
    set: function(center, radius) {
        this.center.copy(center);
        this.radius = radius;
        return this;
    },
    setFromPoints: function() {
        var box = new Box3();
        return function setFromPoints(points, optionalCenter) {
            var center = this.center;
            if (optionalCenter !== undefined) center.copy(optionalCenter);
            else box.setFromPoints(points).getCenter(center);
            var maxRadiusSq = 0;
            for(var i = 0, il = points.length; i < il; i++)maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
            this.radius = Math.sqrt(maxRadiusSq);
            return this;
        };
    }(),
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(sphere) {
        this.center.copy(sphere.center);
        this.radius = sphere.radius;
        return this;
    },
    empty: function() {
        return this.radius <= 0;
    },
    containsPoint: function(point) {
        return point.distanceToSquared(this.center) <= this.radius * this.radius;
    },
    distanceToPoint: function(point) {
        return point.distanceTo(this.center) - this.radius;
    },
    intersectsSphere: function(sphere) {
        var radiusSum = this.radius + sphere.radius;
        return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
    },
    intersectsBox: function(box) {
        return box.intersectsSphere(this);
    },
    intersectsPlane: function(plane) {
        return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
    },
    clampPoint: function(point, target) {
        var deltaLengthSq = this.center.distanceToSquared(point);
        if (target === undefined) {
            console.warn("THREE.Sphere: .clampPoint() target is now required");
            target = new Vector3();
        }
        target.copy(point);
        if (deltaLengthSq > this.radius * this.radius) {
            target.sub(this.center).normalize();
            target.multiplyScalar(this.radius).add(this.center);
        }
        return target;
    },
    getBoundingBox: function(target) {
        if (target === undefined) {
            console.warn("THREE.Sphere: .getBoundingBox() target is now required");
            target = new Box3();
        }
        target.set(this.center, this.center);
        target.expandByScalar(this.radius);
        return target;
    },
    applyMatrix4: function(matrix) {
        this.center.applyMatrix4(matrix);
        this.radius = this.radius * matrix.getMaxScaleOnAxis();
        return this;
    },
    translate: function(offset) {
        this.center.add(offset);
        return this;
    },
    equals: function(sphere) {
        return sphere.center.equals(this.center) && sphere.radius === this.radius;
    }
});
/**
 * @author bhouston / http://clara.io
 */ function Plane(normal, constant) {
    // normal is assumed to be normalized
    this.normal = normal !== undefined ? normal : new Vector3(1, 0, 0);
    this.constant = constant !== undefined ? constant : 0;
}
Object.assign(Plane.prototype, {
    set: function(normal, constant) {
        this.normal.copy(normal);
        this.constant = constant;
        return this;
    },
    setComponents: function(x, y, z, w) {
        this.normal.set(x, y, z);
        this.constant = w;
        return this;
    },
    setFromNormalAndCoplanarPoint: function(normal, point) {
        this.normal.copy(normal);
        this.constant = -point.dot(this.normal);
        return this;
    },
    setFromCoplanarPoints: function() {
        var v1 = new Vector3();
        var v2 = new Vector3();
        return function setFromCoplanarPoints(a, b, c) {
            var normal = v1.subVectors(c, b).cross(v2.subVectors(a, b)).normalize();
            // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?
            this.setFromNormalAndCoplanarPoint(normal, a);
            return this;
        };
    }(),
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(plane) {
        this.normal.copy(plane.normal);
        this.constant = plane.constant;
        return this;
    },
    normalize: function() {
        // Note: will lead to a divide by zero if the plane is invalid.
        var inverseNormalLength = 1.0 / this.normal.length();
        this.normal.multiplyScalar(inverseNormalLength);
        this.constant *= inverseNormalLength;
        return this;
    },
    negate: function() {
        this.constant *= -1;
        this.normal.negate();
        return this;
    },
    distanceToPoint: function(point) {
        return this.normal.dot(point) + this.constant;
    },
    distanceToSphere: function(sphere) {
        return this.distanceToPoint(sphere.center) - sphere.radius;
    },
    projectPoint: function(point, target) {
        if (target === undefined) {
            console.warn("THREE.Plane: .projectPoint() target is now required");
            target = new Vector3();
        }
        return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
    },
    intersectLine: function() {
        var v1 = new Vector3();
        return function intersectLine(line, target) {
            if (target === undefined) {
                console.warn("THREE.Plane: .intersectLine() target is now required");
                target = new Vector3();
            }
            var direction = line.delta(v1);
            var denominator = this.normal.dot(direction);
            if (denominator === 0) {
                // line is coplanar, return origin
                if (this.distanceToPoint(line.start) === 0) return target.copy(line.start);
                // Unsure if this is the correct method to handle this case.
                return undefined;
            }
            var t = -(line.start.dot(this.normal) + this.constant) / denominator;
            if (t < 0 || t > 1) return undefined;
            return target.copy(direction).multiplyScalar(t).add(line.start);
        };
    }(),
    intersectsLine: function(line) {
        // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.
        var startSign = this.distanceToPoint(line.start);
        var endSign = this.distanceToPoint(line.end);
        return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
    },
    intersectsBox: function(box) {
        return box.intersectsPlane(this);
    },
    intersectsSphere: function(sphere) {
        return sphere.intersectsPlane(this);
    },
    coplanarPoint: function(target) {
        if (target === undefined) {
            console.warn("THREE.Plane: .coplanarPoint() target is now required");
            target = new Vector3();
        }
        return target.copy(this.normal).multiplyScalar(-this.constant);
    },
    applyMatrix4: function() {
        var v1 = new Vector3();
        var m1 = new Matrix3();
        return function applyMatrix4(matrix, optionalNormalMatrix) {
            var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix(matrix);
            var referencePoint = this.coplanarPoint(v1).applyMatrix4(matrix);
            var normal = this.normal.applyMatrix3(normalMatrix).normalize();
            this.constant = -referencePoint.dot(normal);
            return this;
        };
    }(),
    translate: function(offset) {
        this.constant -= offset.dot(this.normal);
        return this;
    },
    equals: function(plane) {
        return plane.normal.equals(this.normal) && plane.constant === this.constant;
    }
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author bhouston / http://clara.io
 */ function Frustum(p0, p1, p2, p3, p4, p5) {
    this.planes = [
        p0 !== undefined ? p0 : new Plane(),
        p1 !== undefined ? p1 : new Plane(),
        p2 !== undefined ? p2 : new Plane(),
        p3 !== undefined ? p3 : new Plane(),
        p4 !== undefined ? p4 : new Plane(),
        p5 !== undefined ? p5 : new Plane()
    ];
}
Object.assign(Frustum.prototype, {
    set: function(p0, p1, p2, p3, p4, p5) {
        var planes = this.planes;
        planes[0].copy(p0);
        planes[1].copy(p1);
        planes[2].copy(p2);
        planes[3].copy(p3);
        planes[4].copy(p4);
        planes[5].copy(p5);
        return this;
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(frustum) {
        var planes = this.planes;
        for(var i = 0; i < 6; i++)planes[i].copy(frustum.planes[i]);
        return this;
    },
    setFromMatrix: function(m) {
        var planes = this.planes;
        var me = m.elements;
        var me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
        var me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
        var me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
        var me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
        planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
        planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
        planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
        planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
        planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
        planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
        return this;
    },
    intersectsObject: function() {
        var sphere = new Sphere();
        return function intersectsObject(object) {
            var geometry = object.geometry;
            if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
            sphere.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
            return this.intersectsSphere(sphere);
        };
    }(),
    intersectsSprite: function() {
        var sphere = new Sphere();
        return function intersectsSprite(sprite) {
            sphere.center.set(0, 0, 0);
            sphere.radius = 0.7071067811865476;
            sphere.applyMatrix4(sprite.matrixWorld);
            return this.intersectsSphere(sphere);
        };
    }(),
    intersectsSphere: function(sphere) {
        var planes = this.planes;
        var center = sphere.center;
        var negRadius = -sphere.radius;
        for(var i = 0; i < 6; i++){
            var distance = planes[i].distanceToPoint(center);
            if (distance < negRadius) return false;
        }
        return true;
    },
    intersectsBox: function() {
        var p = new Vector3();
        return function intersectsBox(box) {
            var planes = this.planes;
            for(var i = 0; i < 6; i++){
                var plane = planes[i];
                // corner at max distance
                p.x = plane.normal.x > 0 ? box.max.x : box.min.x;
                p.y = plane.normal.y > 0 ? box.max.y : box.min.y;
                p.z = plane.normal.z > 0 ? box.max.z : box.min.z;
                if (plane.distanceToPoint(p) < 0) return false;
            }
            return true;
        };
    }(),
    containsPoint: function(point) {
        var planes = this.planes;
        for(var i = 0; i < 6; i++){
            if (planes[i].distanceToPoint(point) < 0) return false;
        }
        return true;
    }
});
var alphamap_fragment = "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";
var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
var alphatest_fragment = "#ifdef ALPHATEST\n	if ( diffuseColor.a < ALPHATEST ) discard;\n#endif";
var aomap_fragment = "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n	#endif\n#endif";
var aomap_pars_fragment = "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif";
var begin_vertex = "vec3 transformed = vec3( position );";
var beginnormal_vertex = "vec3 objectNormal = vec3( normal );";
var bsdfs = "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n	if( cutoffDistance > 0.0 ) {\n		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n	}\n	return distanceFalloff;\n#else\n	if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n	}\n	return 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n	return ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	return 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n	float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n	float dotNH = saturate( dot( geometry.normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE  = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS  = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n	return specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n	float dotNH = saturate( dot( geometry.normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}";
var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 );\n		fDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif";
var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		if ( clipped ) discard;\n	#endif\n#endif";
var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n	#if ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n		varying vec3 vViewPosition;\n	#endif\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n	varying vec3 vViewPosition;\n#endif";
var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n	vViewPosition = - mvPosition.xyz;\n#endif";
var color_fragment = "#ifdef USE_COLOR\n	diffuseColor.rgb *= vColor;\n#endif";
var color_pars_fragment = "#ifdef USE_COLOR\n	varying vec3 vColor;\n#endif";
var color_pars_vertex = "#ifdef USE_COLOR\n	varying vec3 vColor;\n#endif";
var color_vertex = "#ifdef USE_COLOR\n	vColor.xyz = color.xyz;\n#endif";
var common = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract(sin(sn) * c);\n}\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	float distance = dot( planeNormal, point - pointOnPlane );\n	return - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n	return dot( weights, color.rgb );\n}";
var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n	vec3 absDirection = abs(direction);\n	int face = -1;\n	if( absDirection.x > absDirection.z ) {\n		if(absDirection.x > absDirection.y )\n			face = direction.x > 0.0 ? 0 : 3;\n		else\n			face = direction.y > 0.0 ? 1 : 4;\n	}\n	else {\n		if(absDirection.z > absDirection.y )\n			face = direction.z > 0.0 ? 2 : 5;\n		else\n			face = direction.y > 0.0 ? 1 : 4;\n	}\n	return face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n	float scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n	float dxRoughness = dFdx(roughness);\n	float dyRoughness = dFdy(roughness);\n	vec3 dx = dFdx( vec * scale * dxRoughness );\n	vec3 dy = dFdy( vec * scale * dyRoughness );\n	float d = max( dot( dx, dx ), dot( dy, dy ) );\n	d = clamp(d, 1.0, cubeUV_rangeClamp);\n	float mipLevel = 0.5 * log2(d);\n	return vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n	mipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n	float a = 16.0 * cubeUV_rcpTextureSize;\n	vec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n	vec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n	float powScale = exp2_packed.x * exp2_packed.y;\n	float scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n	float mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n	bool bRes = mipLevel == 0.0;\n	scale =  bRes && (scale < a) ? a : scale;\n	vec3 r;\n	vec2 offset;\n	int face = getFaceFromDirection(direction);\n	float rcpPowScale = 1.0 / powScale;\n	if( face == 0) {\n		r = vec3(direction.x, -direction.z, direction.y);\n		offset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n	}\n	else if( face == 1) {\n		r = vec3(direction.y, direction.x, direction.z);\n		offset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n	}\n	else if( face == 2) {\n		r = vec3(direction.z, direction.x, direction.y);\n		offset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n	}\n	else if( face == 3) {\n		r = vec3(direction.x, direction.z, direction.y);\n		offset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n	}\n	else if( face == 4) {\n		r = vec3(direction.y, direction.x, -direction.z);\n		offset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n	}\n	else {\n		r = vec3(direction.z, -direction.x, direction.y);\n		offset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n	}\n	r = normalize(r);\n	float texelOffset = 0.5 * cubeUV_rcpTextureSize;\n	vec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n	vec2 base = offset + vec2( texelOffset );\n	return base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n	float roughnessVal = roughness* cubeUV_maxLods3;\n	float r1 = floor(roughnessVal);\n	float r2 = r1 + 1.0;\n	float t = fract(roughnessVal);\n	vec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n	float s = mipInfo.y;\n	float level0 = mipInfo.x;\n	float level1 = level0 + 1.0;\n	level1 = level1 > 5.0 ? 5.0 : level1;\n	level0 += min( floor( s + 0.5 ), 5.0 );\n	vec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n	vec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n	vec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n	vec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n	vec4 result = mix(color10, color20, t);\n	return vec4(result.rgb, 1.0);\n}\n#endif";
var defaultnormal_vertex = "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif";
var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif";
var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif";
var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif";
var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n	float maxComponent = max( max( value.r, value.g ), value.b );\n	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n	M = ceil( M * 255.0 ) / 255.0;\n	return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float D = max( maxRange / maxRGB, 1.0 );\n	D = min( floor( D ) / 255.0, 1.0 );\n	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n	vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n	vec4 vResult;\n	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n	vResult.w = fract( Le );\n	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n	return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n	float Le = value.z * 255.0 + value.w;\n	vec3 Xp_Y_XYZp;\n	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n	vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n	return vec4( max( vRGB, 0.0 ), 1.0 );\n}";
var envmap_fragment = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToVertex, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#elif defined( ENVMAP_TYPE_EQUIREC )\n		vec2 sampleUV;\n		reflectVec = normalize( reflectVec );\n		sampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n		sampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n		vec4 envColor = texture2D( envMap, sampleUV );\n	#elif defined( ENVMAP_TYPE_SPHERE )\n		reflectVec = normalize( reflectVec );\n		vec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n		vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	envColor = envMapTexelToLinear( envColor );\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif";
var envmap_pars_fragment = "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n	uniform float reflectivity;\n	uniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n	#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n		varying vec3 vWorldPosition;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	uniform float flipEnvMap;\n	uniform int maxMipLevel;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif";
var envmap_pars_vertex = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif";
var envmap_vertex = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif";
var fog_vertex = "#ifdef USE_FOG\n	fogDepth = -mvPosition.z;\n#endif";
var fog_pars_vertex = "#ifdef USE_FOG\n	varying float fogDepth;\n#endif";
var fog_fragment = "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
var fog_pars_fragment = "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float fogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif";
var gradientmap_pars_fragment = "#ifdef TOON\n	uniform sampler2D gradientMap;\n	vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n		float dotNL = dot( normal, lightDirection );\n		vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n		#ifdef USE_GRADIENTMAP\n			return texture2D( gradientMap, coord ).rgb;\n		#else\n			return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n		#endif\n	}\n#endif";
var lightmap_fragment = "#ifdef USE_LIGHTMAP\n	reflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif";
var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif";
var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_DIR_LIGHTS > 0\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		#ifdef DOUBLE_SIDED\n			vLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n		#endif\n	}\n#endif";
var lights_pars_begin = "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	return irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		directLight.color = directionalLight.color;\n		directLight.direction = directionalLight.direction;\n		directLight.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n		float shadowCameraNear;\n		float shadowCameraFar;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		directLight.color = pointLight.color;\n		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n		directLight.visible = ( directLight.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		float angleCos = dot( directLight.direction, spotLight.direction );\n		if ( angleCos > spotLight.coneCos ) {\n			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n			directLight.color = spotLight.color;\n			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n			directLight.visible = true;\n		} else {\n			directLight.color = vec3( 0.0 );\n			directLight.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n		float dotNL = dot( geometry.normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			irradiance *= PI;\n		#endif\n		return irradiance;\n	}\n#endif";
var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n			vec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n		#else\n			vec4 envMapColor = vec4( 0.0 );\n		#endif\n		return PI * envMapColor.rgb * envMapIntensity;\n	}\n	float getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n		float maxMIPLevelScalar = float( maxMIPLevel );\n		float desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n	}\n	vec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n		#else\n			vec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n		#endif\n		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n		float specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n			vec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\n		#elif defined( ENVMAP_TYPE_EQUIREC )\n			vec2 sampleUV;\n			sampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n			sampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n			#else\n				vec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_SPHERE )\n			vec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n			#else\n				vec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#endif\n		return envMapColor.rgb * envMapIntensity;\n	}\n#endif";
var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n	vec3	diffuseColor;\n	vec3	specularColor;\n	float	specularShininess;\n	float	specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	#ifdef TOON\n		vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n	#else\n		float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n		vec3 irradiance = dotNL * directLight.color;\n	#endif\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)";
var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n	material.clearCoat = saturate( clearCoat );	material.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif";
var lights_physical_pars_fragment = "struct PhysicalMaterial {\n	vec3	diffuseColor;\n	float	specularRoughness;\n	vec3	specularColor;\n	#ifndef STANDARD\n		float clearCoat;\n		float clearCoatRoughness;\n	#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.specularRoughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	#ifndef STANDARD\n		float clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n	#else\n		float clearCoatDHR = 0.0;\n	#endif\n	reflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n	reflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n	#ifndef STANDARD\n		reflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n	#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	#ifndef STANDARD\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		float dotNL = dotNV;\n		float clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n	#else\n		float clearCoatDHR = 0.0;\n	#endif\n	reflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n	#ifndef STANDARD\n		reflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n	#endif\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointDirectLightIrradiance( pointLight, geometry, directLight );\n		#ifdef USE_SHADOWMAP\n		directLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotDirectLightIrradiance( spotLight, geometry, directLight );\n		#ifdef USE_SHADOWMAP\n		directLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n		#ifdef USE_SHADOWMAP\n		directLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n	}\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		}\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearCoatRadiance = vec3( 0.0 );\n#endif";
var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			lightMapIrradiance *= PI;\n		#endif\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n		irradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	radiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n	#ifndef STANDARD\n		clearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n	#endif\n#endif";
var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif";
var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n#endif";
var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif";
var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n	#else\n		gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n		gl_Position.z *= gl_Position.w;\n	#endif\n#endif";
var map_fragment = "#ifdef USE_MAP\n	vec4 texelColor = texture2D( map, vUv );\n	texelColor = mapTexelToLinear( texelColor );\n	diffuseColor *= texelColor;\n#endif";
var map_pars_fragment = "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif";
var map_particle_fragment = "#ifdef USE_MAP\n	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n	vec4 mapTexel = texture2D( map, uv );\n	diffuseColor *= mapTexelToLinear( mapTexel );\n#endif";
var map_particle_pars_fragment = "#ifdef USE_MAP\n	uniform mat3 uvTransform;\n	uniform sampler2D map;\n#endif";
var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.b;\n#endif";
var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif";
var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n	objectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n	objectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n	objectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n	objectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif";
var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n	#ifndef USE_MORPHNORMALS\n	uniform float morphTargetInfluences[ 8 ];\n	#else\n	uniform float morphTargetInfluences[ 4 ];\n	#endif\n#endif";
var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n	transformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n	transformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n	transformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n	transformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n	#ifndef USE_MORPHNORMALS\n	transformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n	transformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n	transformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n	transformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n	#endif\n#endif";
var normal_fragment_begin = "#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n	#endif\n#endif";
var normal_fragment_maps = "#ifdef USE_NORMALMAP\n	#ifdef OBJECTSPACE_NORMALMAP\n		normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n		#ifdef FLIP_SIDED\n			normal = - normal;\n		#endif\n		#ifdef DOUBLE_SIDED\n			normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n		#endif\n		normal = normalize( normalMatrix * normal );\n	#else\n		normal = perturbNormal2Arb( -vViewPosition, normal );\n	#endif\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif";
var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n	#ifdef OBJECTSPACE_NORMALMAP\n		uniform mat3 normalMatrix;\n	#else\n		vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n			vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n			vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n			vec2 st0 = dFdx( vUv.st );\n			vec2 st1 = dFdy( vUv.st );\n			float scale = sign( st1.t * st0.s - st0.t * st1.s );\n			vec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n			vec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n			vec3 N = normalize( surf_norm );\n			mat3 tsn = mat3( S, T, N );\n			vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n			mapN.xy *= normalScale;\n			mapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n			return normalize( tsn * mapN );\n		}\n	#endif\n#endif";
var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n	return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";
var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif";
var project_vertex = "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;";
var dithering_fragment = "#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
var dithering_pars_fragment = "#if defined( DITHERING )\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif";
var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.g;\n#endif";
var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif";
var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	float texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n		const vec2 offset = vec2( 0.0, 1.0 );\n		vec2 texelSize = vec2( 1.0 ) / size;\n		vec2 centroidUV = floor( uv * size + 0.5 ) / size;\n		float lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n		float lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n		float rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n		float rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n		vec2 f = fract( uv * size + 0.5 );\n		float a = mix( lb, lt, f.y );\n		float b = mix( rb, rt, f.y );\n		float c = mix( a, b, f.x );\n		return c;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			shadow = (\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 9.0 );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif";
var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n	#endif\n#endif";
var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n	}\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n	}\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n	}\n	#endif\n#endif";
var shadowmask_pars_fragment = "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n	DirectionalLight directionalLight;\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		shadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n	SpotLight spotLight;\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		shadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n	PointLight pointLight;\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		shadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#endif\n	#endif\n	return shadow;\n}";
var skinbase_vertex = "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
var skinning_pars_vertex = "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	#ifdef BONE_TEXTURE\n		uniform sampler2D boneTexture;\n		uniform int boneTextureSize;\n		mat4 getBoneMatrix( const in float i ) {\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureSize ) );\n			float y = floor( j / float( boneTextureSize ) );\n			float dx = 1.0 / float( boneTextureSize );\n			float dy = 1.0 / float( boneTextureSize );\n			y = dy * ( y + 0.5 );\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n			mat4 bone = mat4( v1, v2, v3, v4 );\n			return bone;\n		}\n	#else\n		uniform mat4 boneMatrices[ MAX_BONES ];\n		mat4 getBoneMatrix( const in float i ) {\n			mat4 bone = boneMatrices[ int(i) ];\n			return bone;\n		}\n	#endif\n#endif";
var skinning_vertex = "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
var skinnormal_vertex = "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif";
var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif";
var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif";
var tonemapping_fragment = "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
var tonemapping_pars_fragment = "#ifndef saturate\n	#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n	return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}";
var uv_pars_fragment = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n	varying vec2 vUv;\n#endif";
var uv_pars_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n	varying vec2 vUv;\n	uniform mat3 uvTransform;\n#endif";
var uv_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";
var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif";
var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n#endif";
var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = uv2;\n#endif";
var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n	vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif";
var background_frag = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n	vec4 texColor = texture2D( t2D, vUv );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
var background_vert = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
var cube_frag = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n	gl_FragColor = mapTexelToLinear( texColor );\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
var cube_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}";
var depth_frag = "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n	#endif\n}";
var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n}";
var distanceRGBA_frag = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}";
var distanceRGBA_vert = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}";
var equirect_frag = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV;\n	sampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n	vec4 texColor = texture2D( tEquirect, sampleUV );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
var equirect_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}";
var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	vLineDistance = scale * lineDistance;\n	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n		reflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_ENVMAP\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}";
var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n	reflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n	#include <lightmap_fragment>\n	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n	#else\n		reflectedLight.directDiffuse = vLightFront;\n	#endif\n	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var meshmatcap_frag = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n		matcapColor = matcapTexelToLinear( matcapColor );\n	#else\n		vec4 matcapColor = vec4( 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
var meshmatcap_vert = "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#ifndef FLAT_SHADED\n		vNormal = normalize( transformedNormal );\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}";
var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var meshphysical_frag = "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n	uniform float clearCoat;\n	uniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var meshphysical_vert = "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n	varying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}";
var normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n	varying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}";
var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}";
var shadow_frag = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <fog_fragment>\n}";
var shadow_vert = "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <begin_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var sprite_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
var sprite_vert = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
var ShaderChunk = {
    alphamap_fragment: alphamap_fragment,
    alphamap_pars_fragment: alphamap_pars_fragment,
    alphatest_fragment: alphatest_fragment,
    aomap_fragment: aomap_fragment,
    aomap_pars_fragment: aomap_pars_fragment,
    begin_vertex: begin_vertex,
    beginnormal_vertex: beginnormal_vertex,
    bsdfs: bsdfs,
    bumpmap_pars_fragment: bumpmap_pars_fragment,
    clipping_planes_fragment: clipping_planes_fragment,
    clipping_planes_pars_fragment: clipping_planes_pars_fragment,
    clipping_planes_pars_vertex: clipping_planes_pars_vertex,
    clipping_planes_vertex: clipping_planes_vertex,
    color_fragment: color_fragment,
    color_pars_fragment: color_pars_fragment,
    color_pars_vertex: color_pars_vertex,
    color_vertex: color_vertex,
    common: common,
    cube_uv_reflection_fragment: cube_uv_reflection_fragment,
    defaultnormal_vertex: defaultnormal_vertex,
    displacementmap_pars_vertex: displacementmap_pars_vertex,
    displacementmap_vertex: displacementmap_vertex,
    emissivemap_fragment: emissivemap_fragment,
    emissivemap_pars_fragment: emissivemap_pars_fragment,
    encodings_fragment: encodings_fragment,
    encodings_pars_fragment: encodings_pars_fragment,
    envmap_fragment: envmap_fragment,
    envmap_pars_fragment: envmap_pars_fragment,
    envmap_pars_vertex: envmap_pars_vertex,
    envmap_physical_pars_fragment: envmap_physical_pars_fragment,
    envmap_vertex: envmap_vertex,
    fog_vertex: fog_vertex,
    fog_pars_vertex: fog_pars_vertex,
    fog_fragment: fog_fragment,
    fog_pars_fragment: fog_pars_fragment,
    gradientmap_pars_fragment: gradientmap_pars_fragment,
    lightmap_fragment: lightmap_fragment,
    lightmap_pars_fragment: lightmap_pars_fragment,
    lights_lambert_vertex: lights_lambert_vertex,
    lights_pars_begin: lights_pars_begin,
    lights_phong_fragment: lights_phong_fragment,
    lights_phong_pars_fragment: lights_phong_pars_fragment,
    lights_physical_fragment: lights_physical_fragment,
    lights_physical_pars_fragment: lights_physical_pars_fragment,
    lights_fragment_begin: lights_fragment_begin,
    lights_fragment_maps: lights_fragment_maps,
    lights_fragment_end: lights_fragment_end,
    logdepthbuf_fragment: logdepthbuf_fragment,
    logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
    logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
    logdepthbuf_vertex: logdepthbuf_vertex,
    map_fragment: map_fragment,
    map_pars_fragment: map_pars_fragment,
    map_particle_fragment: map_particle_fragment,
    map_particle_pars_fragment: map_particle_pars_fragment,
    metalnessmap_fragment: metalnessmap_fragment,
    metalnessmap_pars_fragment: metalnessmap_pars_fragment,
    morphnormal_vertex: morphnormal_vertex,
    morphtarget_pars_vertex: morphtarget_pars_vertex,
    morphtarget_vertex: morphtarget_vertex,
    normal_fragment_begin: normal_fragment_begin,
    normal_fragment_maps: normal_fragment_maps,
    normalmap_pars_fragment: normalmap_pars_fragment,
    packing: packing,
    premultiplied_alpha_fragment: premultiplied_alpha_fragment,
    project_vertex: project_vertex,
    dithering_fragment: dithering_fragment,
    dithering_pars_fragment: dithering_pars_fragment,
    roughnessmap_fragment: roughnessmap_fragment,
    roughnessmap_pars_fragment: roughnessmap_pars_fragment,
    shadowmap_pars_fragment: shadowmap_pars_fragment,
    shadowmap_pars_vertex: shadowmap_pars_vertex,
    shadowmap_vertex: shadowmap_vertex,
    shadowmask_pars_fragment: shadowmask_pars_fragment,
    skinbase_vertex: skinbase_vertex,
    skinning_pars_vertex: skinning_pars_vertex,
    skinning_vertex: skinning_vertex,
    skinnormal_vertex: skinnormal_vertex,
    specularmap_fragment: specularmap_fragment,
    specularmap_pars_fragment: specularmap_pars_fragment,
    tonemapping_fragment: tonemapping_fragment,
    tonemapping_pars_fragment: tonemapping_pars_fragment,
    uv_pars_fragment: uv_pars_fragment,
    uv_pars_vertex: uv_pars_vertex,
    uv_vertex: uv_vertex,
    uv2_pars_fragment: uv2_pars_fragment,
    uv2_pars_vertex: uv2_pars_vertex,
    uv2_vertex: uv2_vertex,
    worldpos_vertex: worldpos_vertex,
    background_frag: background_frag,
    background_vert: background_vert,
    cube_frag: cube_frag,
    cube_vert: cube_vert,
    depth_frag: depth_frag,
    depth_vert: depth_vert,
    distanceRGBA_frag: distanceRGBA_frag,
    distanceRGBA_vert: distanceRGBA_vert,
    equirect_frag: equirect_frag,
    equirect_vert: equirect_vert,
    linedashed_frag: linedashed_frag,
    linedashed_vert: linedashed_vert,
    meshbasic_frag: meshbasic_frag,
    meshbasic_vert: meshbasic_vert,
    meshlambert_frag: meshlambert_frag,
    meshlambert_vert: meshlambert_vert,
    meshmatcap_frag: meshmatcap_frag,
    meshmatcap_vert: meshmatcap_vert,
    meshphong_frag: meshphong_frag,
    meshphong_vert: meshphong_vert,
    meshphysical_frag: meshphysical_frag,
    meshphysical_vert: meshphysical_vert,
    normal_frag: normal_frag,
    normal_vert: normal_vert,
    points_frag: points_frag,
    points_vert: points_vert,
    shadow_frag: shadow_frag,
    shadow_vert: shadow_vert,
    sprite_frag: sprite_frag,
    sprite_vert: sprite_vert
};
/**
 * Uniform Utilities
 */ function cloneUniforms(src) {
    var dst = {};
    for(var u in src){
        dst[u] = {};
        for(var p in src[u]){
            var property = src[u][p];
            if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture)) dst[u][p] = property.clone();
            else if (Array.isArray(property)) dst[u][p] = property.slice();
            else dst[u][p] = property;
        }
    }
    return dst;
}
function mergeUniforms(uniforms) {
    var merged = {};
    for(var u = 0; u < uniforms.length; u++){
        var tmp = cloneUniforms(uniforms[u]);
        for(var p in tmp)merged[p] = tmp[p];
    }
    return merged;
}
// Legacy
var UniformsUtils = {
    clone: cloneUniforms,
    merge: mergeUniforms
};
/**
 * @author mrdoob / http://mrdoob.com/
 */ var ColorKeywords = {
    "aliceblue": 0xF0F8FF,
    "antiquewhite": 0xFAEBD7,
    "aqua": 0x00FFFF,
    "aquamarine": 0x7FFFD4,
    "azure": 0xF0FFFF,
    "beige": 0xF5F5DC,
    "bisque": 0xFFE4C4,
    "black": 0x000000,
    "blanchedalmond": 0xFFEBCD,
    "blue": 0x0000FF,
    "blueviolet": 0x8A2BE2,
    "brown": 0xA52A2A,
    "burlywood": 0xDEB887,
    "cadetblue": 0x5F9EA0,
    "chartreuse": 0x7FFF00,
    "chocolate": 0xD2691E,
    "coral": 0xFF7F50,
    "cornflowerblue": 0x6495ED,
    "cornsilk": 0xFFF8DC,
    "crimson": 0xDC143C,
    "cyan": 0x00FFFF,
    "darkblue": 0x00008B,
    "darkcyan": 0x008B8B,
    "darkgoldenrod": 0xB8860B,
    "darkgray": 0xA9A9A9,
    "darkgreen": 0x006400,
    "darkgrey": 0xA9A9A9,
    "darkkhaki": 0xBDB76B,
    "darkmagenta": 0x8B008B,
    "darkolivegreen": 0x556B2F,
    "darkorange": 0xFF8C00,
    "darkorchid": 0x9932CC,
    "darkred": 0x8B0000,
    "darksalmon": 0xE9967A,
    "darkseagreen": 0x8FBC8F,
    "darkslateblue": 0x483D8B,
    "darkslategray": 0x2F4F4F,
    "darkslategrey": 0x2F4F4F,
    "darkturquoise": 0x00CED1,
    "darkviolet": 0x9400D3,
    "deeppink": 0xFF1493,
    "deepskyblue": 0x00BFFF,
    "dimgray": 0x696969,
    "dimgrey": 0x696969,
    "dodgerblue": 0x1E90FF,
    "firebrick": 0xB22222,
    "floralwhite": 0xFFFAF0,
    "forestgreen": 0x228B22,
    "fuchsia": 0xFF00FF,
    "gainsboro": 0xDCDCDC,
    "ghostwhite": 0xF8F8FF,
    "gold": 0xFFD700,
    "goldenrod": 0xDAA520,
    "gray": 0x808080,
    "green": 0x008000,
    "greenyellow": 0xADFF2F,
    "grey": 0x808080,
    "honeydew": 0xF0FFF0,
    "hotpink": 0xFF69B4,
    "indianred": 0xCD5C5C,
    "indigo": 0x4B0082,
    "ivory": 0xFFFFF0,
    "khaki": 0xF0E68C,
    "lavender": 0xE6E6FA,
    "lavenderblush": 0xFFF0F5,
    "lawngreen": 0x7CFC00,
    "lemonchiffon": 0xFFFACD,
    "lightblue": 0xADD8E6,
    "lightcoral": 0xF08080,
    "lightcyan": 0xE0FFFF,
    "lightgoldenrodyellow": 0xFAFAD2,
    "lightgray": 0xD3D3D3,
    "lightgreen": 0x90EE90,
    "lightgrey": 0xD3D3D3,
    "lightpink": 0xFFB6C1,
    "lightsalmon": 0xFFA07A,
    "lightseagreen": 0x20B2AA,
    "lightskyblue": 0x87CEFA,
    "lightslategray": 0x778899,
    "lightslategrey": 0x778899,
    "lightsteelblue": 0xB0C4DE,
    "lightyellow": 0xFFFFE0,
    "lime": 0x00FF00,
    "limegreen": 0x32CD32,
    "linen": 0xFAF0E6,
    "magenta": 0xFF00FF,
    "maroon": 0x800000,
    "mediumaquamarine": 0x66CDAA,
    "mediumblue": 0x0000CD,
    "mediumorchid": 0xBA55D3,
    "mediumpurple": 0x9370DB,
    "mediumseagreen": 0x3CB371,
    "mediumslateblue": 0x7B68EE,
    "mediumspringgreen": 0x00FA9A,
    "mediumturquoise": 0x48D1CC,
    "mediumvioletred": 0xC71585,
    "midnightblue": 0x191970,
    "mintcream": 0xF5FFFA,
    "mistyrose": 0xFFE4E1,
    "moccasin": 0xFFE4B5,
    "navajowhite": 0xFFDEAD,
    "navy": 0x000080,
    "oldlace": 0xFDF5E6,
    "olive": 0x808000,
    "olivedrab": 0x6B8E23,
    "orange": 0xFFA500,
    "orangered": 0xFF4500,
    "orchid": 0xDA70D6,
    "palegoldenrod": 0xEEE8AA,
    "palegreen": 0x98FB98,
    "paleturquoise": 0xAFEEEE,
    "palevioletred": 0xDB7093,
    "papayawhip": 0xFFEFD5,
    "peachpuff": 0xFFDAB9,
    "peru": 0xCD853F,
    "pink": 0xFFC0CB,
    "plum": 0xDDA0DD,
    "powderblue": 0xB0E0E6,
    "purple": 0x800080,
    "rebeccapurple": 0x663399,
    "red": 0xFF0000,
    "rosybrown": 0xBC8F8F,
    "royalblue": 0x4169E1,
    "saddlebrown": 0x8B4513,
    "salmon": 0xFA8072,
    "sandybrown": 0xF4A460,
    "seagreen": 0x2E8B57,
    "seashell": 0xFFF5EE,
    "sienna": 0xA0522D,
    "silver": 0xC0C0C0,
    "skyblue": 0x87CEEB,
    "slateblue": 0x6A5ACD,
    "slategray": 0x708090,
    "slategrey": 0x708090,
    "snow": 0xFFFAFA,
    "springgreen": 0x00FF7F,
    "steelblue": 0x4682B4,
    "tan": 0xD2B48C,
    "teal": 0x008080,
    "thistle": 0xD8BFD8,
    "tomato": 0xFF6347,
    "turquoise": 0x40E0D0,
    "violet": 0xEE82EE,
    "wheat": 0xF5DEB3,
    "white": 0xFFFFFF,
    "whitesmoke": 0xF5F5F5,
    "yellow": 0xFFFF00,
    "yellowgreen": 0x9ACD32
};
function Color(r, g, b) {
    if (g === undefined && b === undefined) // r is THREE.Color, hex or string
    return this.set(r);
    return this.setRGB(r, g, b);
}
Object.assign(Color.prototype, {
    isColor: true,
    r: 1,
    g: 1,
    b: 1,
    set: function(value) {
        if (value && value.isColor) this.copy(value);
        else if (typeof value === "number") this.setHex(value);
        else if (typeof value === "string") this.setStyle(value);
        return this;
    },
    setScalar: function(scalar) {
        this.r = scalar;
        this.g = scalar;
        this.b = scalar;
        return this;
    },
    setHex: function(hex) {
        hex = Math.floor(hex);
        this.r = (hex >> 16 & 255) / 255;
        this.g = (hex >> 8 & 255) / 255;
        this.b = (hex & 255) / 255;
        return this;
    },
    setRGB: function(r, g, b) {
        this.r = r;
        this.g = g;
        this.b = b;
        return this;
    },
    setHSL: function() {
        function hue2rgb(p, q, t) {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1 / 6) return p + (q - p) * 6 * t;
            if (t < 0.5) return q;
            if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);
            return p;
        }
        return function setHSL(h, s, l) {
            // h,s,l ranges are in 0.0 - 1.0
            h = _Math.euclideanModulo(h, 1);
            s = _Math.clamp(s, 0, 1);
            l = _Math.clamp(l, 0, 1);
            if (s === 0) this.r = this.g = this.b = l;
            else {
                var p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
                var q = 2 * l - p;
                this.r = hue2rgb(q, p, h + 1 / 3);
                this.g = hue2rgb(q, p, h);
                this.b = hue2rgb(q, p, h - 1 / 3);
            }
            return this;
        };
    }(),
    setStyle: function(style) {
        function handleAlpha(string) {
            if (string === undefined) return;
            if (parseFloat(string) < 1) console.warn("THREE.Color: Alpha component of " + style + " will be ignored.");
        }
        var m;
        if (m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(style)) {
            // rgb / hsl
            var color;
            var name = m[1];
            var components = m[2];
            switch(name){
                case "rgb":
                case "rgba":
                    if (color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
                        // rgb(255,0,0) rgba(255,0,0,0.5)
                        this.r = Math.min(255, parseInt(color[1], 10)) / 255;
                        this.g = Math.min(255, parseInt(color[2], 10)) / 255;
                        this.b = Math.min(255, parseInt(color[3], 10)) / 255;
                        handleAlpha(color[5]);
                        return this;
                    }
                    if (color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
                        // rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
                        this.r = Math.min(100, parseInt(color[1], 10)) / 100;
                        this.g = Math.min(100, parseInt(color[2], 10)) / 100;
                        this.b = Math.min(100, parseInt(color[3], 10)) / 100;
                        handleAlpha(color[5]);
                        return this;
                    }
                    break;
                case "hsl":
                case "hsla":
                    if (color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
                        // hsl(120,50%,50%) hsla(120,50%,50%,0.5)
                        var h = parseFloat(color[1]) / 360;
                        var s = parseInt(color[2], 10) / 100;
                        var l = parseInt(color[3], 10) / 100;
                        handleAlpha(color[5]);
                        return this.setHSL(h, s, l);
                    }
                    break;
            }
        } else if (m = /^\#([A-Fa-f0-9]+)$/.exec(style)) {
            // hex color
            var hex = m[1];
            var size = hex.length;
            if (size === 3) {
                // #ff0
                this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
                this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
                this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
                return this;
            } else if (size === 6) {
                // #ff0000
                this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
                this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
                this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
                return this;
            }
        }
        if (style && style.length > 0) {
            // color keywords
            var hex = ColorKeywords[style];
            if (hex !== undefined) // red
            this.setHex(hex);
            else // unknown color
            console.warn("THREE.Color: Unknown color " + style);
        }
        return this;
    },
    clone: function() {
        return new this.constructor(this.r, this.g, this.b);
    },
    copy: function(color) {
        this.r = color.r;
        this.g = color.g;
        this.b = color.b;
        return this;
    },
    copyGammaToLinear: function(color, gammaFactor) {
        if (gammaFactor === undefined) gammaFactor = 2.0;
        this.r = Math.pow(color.r, gammaFactor);
        this.g = Math.pow(color.g, gammaFactor);
        this.b = Math.pow(color.b, gammaFactor);
        return this;
    },
    copyLinearToGamma: function(color, gammaFactor) {
        if (gammaFactor === undefined) gammaFactor = 2.0;
        var safeInverse = gammaFactor > 0 ? 1.0 / gammaFactor : 1.0;
        this.r = Math.pow(color.r, safeInverse);
        this.g = Math.pow(color.g, safeInverse);
        this.b = Math.pow(color.b, safeInverse);
        return this;
    },
    convertGammaToLinear: function(gammaFactor) {
        this.copyGammaToLinear(this, gammaFactor);
        return this;
    },
    convertLinearToGamma: function(gammaFactor) {
        this.copyLinearToGamma(this, gammaFactor);
        return this;
    },
    copySRGBToLinear: function() {
        function SRGBToLinear(c) {
            return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
        }
        return function copySRGBToLinear(color) {
            this.r = SRGBToLinear(color.r);
            this.g = SRGBToLinear(color.g);
            this.b = SRGBToLinear(color.b);
            return this;
        };
    }(),
    copyLinearToSRGB: function() {
        function LinearToSRGB(c) {
            return c < 0.0031308 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
        }
        return function copyLinearToSRGB(color) {
            this.r = LinearToSRGB(color.r);
            this.g = LinearToSRGB(color.g);
            this.b = LinearToSRGB(color.b);
            return this;
        };
    }(),
    convertSRGBToLinear: function() {
        this.copySRGBToLinear(this);
        return this;
    },
    convertLinearToSRGB: function() {
        this.copyLinearToSRGB(this);
        return this;
    },
    getHex: function() {
        return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
    },
    getHexString: function() {
        return ("000000" + this.getHex().toString(16)).slice(-6);
    },
    getHSL: function(target) {
        // h,s,l ranges are in 0.0 - 1.0
        if (target === undefined) {
            console.warn("THREE.Color: .getHSL() target is now required");
            target = {
                h: 0,
                s: 0,
                l: 0
            };
        }
        var r = this.r, g = this.g, b = this.b;
        var max = Math.max(r, g, b);
        var min = Math.min(r, g, b);
        var hue, saturation;
        var lightness = (min + max) / 2.0;
        if (min === max) {
            hue = 0;
            saturation = 0;
        } else {
            var delta = max - min;
            saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
            switch(max){
                case r:
                    hue = (g - b) / delta + (g < b ? 6 : 0);
                    break;
                case g:
                    hue = (b - r) / delta + 2;
                    break;
                case b:
                    hue = (r - g) / delta + 4;
                    break;
            }
            hue /= 6;
        }
        target.h = hue;
        target.s = saturation;
        target.l = lightness;
        return target;
    },
    getStyle: function() {
        return "rgb(" + (this.r * 255 | 0) + "," + (this.g * 255 | 0) + "," + (this.b * 255 | 0) + ")";
    },
    offsetHSL: function() {
        var hsl = {};
        return function(h, s, l) {
            this.getHSL(hsl);
            hsl.h += h;
            hsl.s += s;
            hsl.l += l;
            this.setHSL(hsl.h, hsl.s, hsl.l);
            return this;
        };
    }(),
    add: function(color) {
        this.r += color.r;
        this.g += color.g;
        this.b += color.b;
        return this;
    },
    addColors: function(color1, color2) {
        this.r = color1.r + color2.r;
        this.g = color1.g + color2.g;
        this.b = color1.b + color2.b;
        return this;
    },
    addScalar: function(s) {
        this.r += s;
        this.g += s;
        this.b += s;
        return this;
    },
    sub: function(color) {
        this.r = Math.max(0, this.r - color.r);
        this.g = Math.max(0, this.g - color.g);
        this.b = Math.max(0, this.b - color.b);
        return this;
    },
    multiply: function(color) {
        this.r *= color.r;
        this.g *= color.g;
        this.b *= color.b;
        return this;
    },
    multiplyScalar: function(s) {
        this.r *= s;
        this.g *= s;
        this.b *= s;
        return this;
    },
    lerp: function(color, alpha) {
        this.r += (color.r - this.r) * alpha;
        this.g += (color.g - this.g) * alpha;
        this.b += (color.b - this.b) * alpha;
        return this;
    },
    lerpHSL: function() {
        var hslA = {
            h: 0,
            s: 0,
            l: 0
        };
        var hslB = {
            h: 0,
            s: 0,
            l: 0
        };
        return function lerpHSL(color, alpha) {
            this.getHSL(hslA);
            color.getHSL(hslB);
            var h = _Math.lerp(hslA.h, hslB.h, alpha);
            var s = _Math.lerp(hslA.s, hslB.s, alpha);
            var l = _Math.lerp(hslA.l, hslB.l, alpha);
            this.setHSL(h, s, l);
            return this;
        };
    }(),
    equals: function(c) {
        return c.r === this.r && c.g === this.g && c.b === this.b;
    },
    fromArray: function(array, offset) {
        if (offset === undefined) offset = 0;
        this.r = array[offset];
        this.g = array[offset + 1];
        this.b = array[offset + 2];
        return this;
    },
    toArray: function(array, offset) {
        if (array === undefined) array = [];
        if (offset === undefined) offset = 0;
        array[offset] = this.r;
        array[offset + 1] = this.g;
        array[offset + 2] = this.b;
        return array;
    },
    toJSON: function() {
        return this.getHex();
    }
});
/**
 * Uniforms library for shared webgl shaders
 */ var UniformsLib = {
    common: {
        diffuse: {
            value: new Color(0xeeeeee)
        },
        opacity: {
            value: 1.0
        },
        map: {
            value: null
        },
        uvTransform: {
            value: new Matrix3()
        },
        alphaMap: {
            value: null
        }
    },
    specularmap: {
        specularMap: {
            value: null
        }
    },
    envmap: {
        envMap: {
            value: null
        },
        flipEnvMap: {
            value: -1
        },
        reflectivity: {
            value: 1.0
        },
        refractionRatio: {
            value: 0.98
        },
        maxMipLevel: {
            value: 0
        }
    },
    aomap: {
        aoMap: {
            value: null
        },
        aoMapIntensity: {
            value: 1
        }
    },
    lightmap: {
        lightMap: {
            value: null
        },
        lightMapIntensity: {
            value: 1
        }
    },
    emissivemap: {
        emissiveMap: {
            value: null
        }
    },
    bumpmap: {
        bumpMap: {
            value: null
        },
        bumpScale: {
            value: 1
        }
    },
    normalmap: {
        normalMap: {
            value: null
        },
        normalScale: {
            value: new Vector2(1, 1)
        }
    },
    displacementmap: {
        displacementMap: {
            value: null
        },
        displacementScale: {
            value: 1
        },
        displacementBias: {
            value: 0
        }
    },
    roughnessmap: {
        roughnessMap: {
            value: null
        }
    },
    metalnessmap: {
        metalnessMap: {
            value: null
        }
    },
    gradientmap: {
        gradientMap: {
            value: null
        }
    },
    fog: {
        fogDensity: {
            value: 0.00025
        },
        fogNear: {
            value: 1
        },
        fogFar: {
            value: 2000
        },
        fogColor: {
            value: new Color(0xffffff)
        }
    },
    lights: {
        ambientLightColor: {
            value: []
        },
        directionalLights: {
            value: [],
            properties: {
                direction: {},
                color: {},
                shadow: {},
                shadowBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        directionalShadowMap: {
            value: []
        },
        directionalShadowMatrix: {
            value: []
        },
        spotLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                direction: {},
                distance: {},
                coneCos: {},
                penumbraCos: {},
                decay: {},
                shadow: {},
                shadowBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        spotShadowMap: {
            value: []
        },
        spotShadowMatrix: {
            value: []
        },
        pointLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                decay: {},
                distance: {},
                shadow: {},
                shadowBias: {},
                shadowRadius: {},
                shadowMapSize: {},
                shadowCameraNear: {},
                shadowCameraFar: {}
            }
        },
        pointShadowMap: {
            value: []
        },
        pointShadowMatrix: {
            value: []
        },
        hemisphereLights: {
            value: [],
            properties: {
                direction: {},
                skyColor: {},
                groundColor: {}
            }
        },
        // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
        rectAreaLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                width: {},
                height: {}
            }
        }
    },
    points: {
        diffuse: {
            value: new Color(0xeeeeee)
        },
        opacity: {
            value: 1.0
        },
        size: {
            value: 1.0
        },
        scale: {
            value: 1.0
        },
        map: {
            value: null
        },
        uvTransform: {
            value: new Matrix3()
        }
    },
    sprite: {
        diffuse: {
            value: new Color(0xeeeeee)
        },
        opacity: {
            value: 1.0
        },
        center: {
            value: new Vector2(0.5, 0.5)
        },
        rotation: {
            value: 0.0
        },
        map: {
            value: null
        },
        uvTransform: {
            value: new Matrix3()
        }
    }
};
/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 */ var ShaderLib = {
    basic: {
        uniforms: mergeUniforms([
            UniformsLib.common,
            UniformsLib.specularmap,
            UniformsLib.envmap,
            UniformsLib.aomap,
            UniformsLib.lightmap,
            UniformsLib.fog
        ]),
        vertexShader: ShaderChunk.meshbasic_vert,
        fragmentShader: ShaderChunk.meshbasic_frag
    },
    lambert: {
        uniforms: mergeUniforms([
            UniformsLib.common,
            UniformsLib.specularmap,
            UniformsLib.envmap,
            UniformsLib.aomap,
            UniformsLib.lightmap,
            UniformsLib.emissivemap,
            UniformsLib.fog,
            UniformsLib.lights,
            {
                emissive: {
                    value: new Color(0x000000)
                }
            }
        ]),
        vertexShader: ShaderChunk.meshlambert_vert,
        fragmentShader: ShaderChunk.meshlambert_frag
    },
    phong: {
        uniforms: mergeUniforms([
            UniformsLib.common,
            UniformsLib.specularmap,
            UniformsLib.envmap,
            UniformsLib.aomap,
            UniformsLib.lightmap,
            UniformsLib.emissivemap,
            UniformsLib.bumpmap,
            UniformsLib.normalmap,
            UniformsLib.displacementmap,
            UniformsLib.gradientmap,
            UniformsLib.fog,
            UniformsLib.lights,
            {
                emissive: {
                    value: new Color(0x000000)
                },
                specular: {
                    value: new Color(0x111111)
                },
                shininess: {
                    value: 30
                }
            }
        ]),
        vertexShader: ShaderChunk.meshphong_vert,
        fragmentShader: ShaderChunk.meshphong_frag
    },
    standard: {
        uniforms: mergeUniforms([
            UniformsLib.common,
            UniformsLib.envmap,
            UniformsLib.aomap,
            UniformsLib.lightmap,
            UniformsLib.emissivemap,
            UniformsLib.bumpmap,
            UniformsLib.normalmap,
            UniformsLib.displacementmap,
            UniformsLib.roughnessmap,
            UniformsLib.metalnessmap,
            UniformsLib.fog,
            UniformsLib.lights,
            {
                emissive: {
                    value: new Color(0x000000)
                },
                roughness: {
                    value: 0.5
                },
                metalness: {
                    value: 0.5
                },
                envMapIntensity: {
                    value: 1
                } // temporary
            }
        ]),
        vertexShader: ShaderChunk.meshphysical_vert,
        fragmentShader: ShaderChunk.meshphysical_frag
    },
    matcap: {
        uniforms: mergeUniforms([
            UniformsLib.common,
            UniformsLib.bumpmap,
            UniformsLib.normalmap,
            UniformsLib.displacementmap,
            UniformsLib.fog,
            {
                matcap: {
                    value: null
                }
            }
        ]),
        vertexShader: ShaderChunk.meshmatcap_vert,
        fragmentShader: ShaderChunk.meshmatcap_frag
    },
    points: {
        uniforms: mergeUniforms([
            UniformsLib.points,
            UniformsLib.fog
        ]),
        vertexShader: ShaderChunk.points_vert,
        fragmentShader: ShaderChunk.points_frag
    },
    dashed: {
        uniforms: mergeUniforms([
            UniformsLib.common,
            UniformsLib.fog,
            {
                scale: {
                    value: 1
                },
                dashSize: {
                    value: 1
                },
                totalSize: {
                    value: 2
                }
            }
        ]),
        vertexShader: ShaderChunk.linedashed_vert,
        fragmentShader: ShaderChunk.linedashed_frag
    },
    depth: {
        uniforms: mergeUniforms([
            UniformsLib.common,
            UniformsLib.displacementmap
        ]),
        vertexShader: ShaderChunk.depth_vert,
        fragmentShader: ShaderChunk.depth_frag
    },
    normal: {
        uniforms: mergeUniforms([
            UniformsLib.common,
            UniformsLib.bumpmap,
            UniformsLib.normalmap,
            UniformsLib.displacementmap,
            {
                opacity: {
                    value: 1.0
                }
            }
        ]),
        vertexShader: ShaderChunk.normal_vert,
        fragmentShader: ShaderChunk.normal_frag
    },
    sprite: {
        uniforms: mergeUniforms([
            UniformsLib.sprite,
            UniformsLib.fog
        ]),
        vertexShader: ShaderChunk.sprite_vert,
        fragmentShader: ShaderChunk.sprite_frag
    },
    background: {
        uniforms: {
            uvTransform: {
                value: new Matrix3()
            },
            t2D: {
                value: null
            }
        },
        vertexShader: ShaderChunk.background_vert,
        fragmentShader: ShaderChunk.background_frag
    },
    /* -------------------------------------------------------------------------
	//	Cube map shader
	 ------------------------------------------------------------------------- */ cube: {
        uniforms: {
            tCube: {
                value: null
            },
            tFlip: {
                value: -1
            },
            opacity: {
                value: 1.0
            }
        },
        vertexShader: ShaderChunk.cube_vert,
        fragmentShader: ShaderChunk.cube_frag
    },
    equirect: {
        uniforms: {
            tEquirect: {
                value: null
            }
        },
        vertexShader: ShaderChunk.equirect_vert,
        fragmentShader: ShaderChunk.equirect_frag
    },
    distanceRGBA: {
        uniforms: mergeUniforms([
            UniformsLib.common,
            UniformsLib.displacementmap,
            {
                referencePosition: {
                    value: new Vector3()
                },
                nearDistance: {
                    value: 1
                },
                farDistance: {
                    value: 1000
                }
            }
        ]),
        vertexShader: ShaderChunk.distanceRGBA_vert,
        fragmentShader: ShaderChunk.distanceRGBA_frag
    },
    shadow: {
        uniforms: mergeUniforms([
            UniformsLib.lights,
            UniformsLib.fog,
            {
                color: {
                    value: new Color(0x00000)
                },
                opacity: {
                    value: 1.0
                }
            }
        ]),
        vertexShader: ShaderChunk.shadow_vert,
        fragmentShader: ShaderChunk.shadow_frag
    }
};
ShaderLib.physical = {
    uniforms: mergeUniforms([
        ShaderLib.standard.uniforms,
        {
            clearCoat: {
                value: 0
            },
            clearCoatRoughness: {
                value: 0
            }
        }
    ]),
    vertexShader: ShaderChunk.meshphysical_vert,
    fragmentShader: ShaderChunk.meshphysical_frag
};
/**
 * @author mrdoob / http://mrdoob.com/
 */ function WebGLAnimation() {
    var context = null;
    var isAnimating = false;
    var animationLoop = null;
    function onAnimationFrame(time, frame) {
        if (isAnimating === false) return;
        animationLoop(time, frame);
        context.requestAnimationFrame(onAnimationFrame);
    }
    return {
        start: function() {
            if (isAnimating === true) return;
            if (animationLoop === null) return;
            context.requestAnimationFrame(onAnimationFrame);
            isAnimating = true;
        },
        stop: function() {
            isAnimating = false;
        },
        setAnimationLoop: function(callback) {
            animationLoop = callback;
        },
        setContext: function(value) {
            context = value;
        }
    };
}
/**
 * @author mrdoob / http://mrdoob.com/
 */ function WebGLAttributes(gl) {
    var buffers = new WeakMap();
    function createBuffer(attribute, bufferType) {
        var array = attribute.array;
        var usage = attribute.dynamic ? 35048 : 35044;
        var buffer = gl.createBuffer();
        gl.bindBuffer(bufferType, buffer);
        gl.bufferData(bufferType, array, usage);
        attribute.onUploadCallback();
        var type = 5126;
        if (array instanceof Float32Array) type = 5126;
        else if (array instanceof Float64Array) console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.");
        else if (array instanceof Uint16Array) type = 5123;
        else if (array instanceof Int16Array) type = 5122;
        else if (array instanceof Uint32Array) type = 5125;
        else if (array instanceof Int32Array) type = 5124;
        else if (array instanceof Int8Array) type = 5120;
        else if (array instanceof Uint8Array) type = 5121;
        return {
            buffer: buffer,
            type: type,
            bytesPerElement: array.BYTES_PER_ELEMENT,
            version: attribute.version
        };
    }
    function updateBuffer(buffer, attribute, bufferType) {
        var array = attribute.array;
        var updateRange = attribute.updateRange;
        gl.bindBuffer(bufferType, buffer);
        if (attribute.dynamic === false) gl.bufferData(bufferType, array, 35044);
        else if (updateRange.count === -1) // Not using update ranges
        gl.bufferSubData(bufferType, 0, array);
        else if (updateRange.count === 0) console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.");
        else {
            gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));
            updateRange.count = -1; // reset range
        }
    }
    //
    function get(attribute) {
        if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
        return buffers.get(attribute);
    }
    function remove(attribute) {
        if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
        var data = buffers.get(attribute);
        if (data) {
            gl.deleteBuffer(data.buffer);
            buffers.delete(attribute);
        }
    }
    function update(attribute, bufferType) {
        if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
        var data = buffers.get(attribute);
        if (data === undefined) buffers.set(attribute, createBuffer(attribute, bufferType));
        else if (data.version < attribute.version) {
            updateBuffer(data.buffer, attribute, bufferType);
            data.version = attribute.version;
        }
    }
    return {
        get: get,
        remove: remove,
        update: update
    };
}
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */ function Face3(a, b, c, normal, color, materialIndex) {
    this.a = a;
    this.b = b;
    this.c = c;
    this.normal = normal && normal.isVector3 ? normal : new Vector3();
    this.vertexNormals = Array.isArray(normal) ? normal : [];
    this.color = color && color.isColor ? color : new Color();
    this.vertexColors = Array.isArray(color) ? color : [];
    this.materialIndex = materialIndex !== undefined ? materialIndex : 0;
}
Object.assign(Face3.prototype, {
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(source) {
        this.a = source.a;
        this.b = source.b;
        this.c = source.c;
        this.normal.copy(source.normal);
        this.color.copy(source.color);
        this.materialIndex = source.materialIndex;
        for(var i = 0, il = source.vertexNormals.length; i < il; i++)this.vertexNormals[i] = source.vertexNormals[i].clone();
        for(var i = 0, il = source.vertexColors.length; i < il; i++)this.vertexColors[i] = source.vertexColors[i].clone();
        return this;
    }
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 */ function Euler(x, y, z, order) {
    this._x = x || 0;
    this._y = y || 0;
    this._z = z || 0;
    this._order = order || Euler.DefaultOrder;
}
Euler.RotationOrders = [
    "XYZ",
    "YZX",
    "ZXY",
    "XZY",
    "YXZ",
    "ZYX"
];
Euler.DefaultOrder = "XYZ";
Object.defineProperties(Euler.prototype, {
    x: {
        get: function() {
            return this._x;
        },
        set: function(value) {
            this._x = value;
            this.onChangeCallback();
        }
    },
    y: {
        get: function() {
            return this._y;
        },
        set: function(value) {
            this._y = value;
            this.onChangeCallback();
        }
    },
    z: {
        get: function() {
            return this._z;
        },
        set: function(value) {
            this._z = value;
            this.onChangeCallback();
        }
    },
    order: {
        get: function() {
            return this._order;
        },
        set: function(value) {
            this._order = value;
            this.onChangeCallback();
        }
    }
});
Object.assign(Euler.prototype, {
    isEuler: true,
    set: function(x, y, z, order) {
        this._x = x;
        this._y = y;
        this._z = z;
        this._order = order || this._order;
        this.onChangeCallback();
        return this;
    },
    clone: function() {
        return new this.constructor(this._x, this._y, this._z, this._order);
    },
    copy: function(euler) {
        this._x = euler._x;
        this._y = euler._y;
        this._z = euler._z;
        this._order = euler._order;
        this.onChangeCallback();
        return this;
    },
    setFromRotationMatrix: function(m, order, update) {
        var clamp = _Math.clamp;
        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
        var te = m.elements;
        var m11 = te[0], m12 = te[4], m13 = te[8];
        var m21 = te[1], m22 = te[5], m23 = te[9];
        var m31 = te[2], m32 = te[6], m33 = te[10];
        order = order || this._order;
        if (order === "XYZ") {
            this._y = Math.asin(clamp(m13, -1, 1));
            if (Math.abs(m13) < 0.99999) {
                this._x = Math.atan2(-m23, m33);
                this._z = Math.atan2(-m12, m11);
            } else {
                this._x = Math.atan2(m32, m22);
                this._z = 0;
            }
        } else if (order === "YXZ") {
            this._x = Math.asin(-clamp(m23, -1, 1));
            if (Math.abs(m23) < 0.99999) {
                this._y = Math.atan2(m13, m33);
                this._z = Math.atan2(m21, m22);
            } else {
                this._y = Math.atan2(-m31, m11);
                this._z = 0;
            }
        } else if (order === "ZXY") {
            this._x = Math.asin(clamp(m32, -1, 1));
            if (Math.abs(m32) < 0.99999) {
                this._y = Math.atan2(-m31, m33);
                this._z = Math.atan2(-m12, m22);
            } else {
                this._y = 0;
                this._z = Math.atan2(m21, m11);
            }
        } else if (order === "ZYX") {
            this._y = Math.asin(-clamp(m31, -1, 1));
            if (Math.abs(m31) < 0.99999) {
                this._x = Math.atan2(m32, m33);
                this._z = Math.atan2(m21, m11);
            } else {
                this._x = 0;
                this._z = Math.atan2(-m12, m22);
            }
        } else if (order === "YZX") {
            this._z = Math.asin(clamp(m21, -1, 1));
            if (Math.abs(m21) < 0.99999) {
                this._x = Math.atan2(-m23, m22);
                this._y = Math.atan2(-m31, m11);
            } else {
                this._x = 0;
                this._y = Math.atan2(m13, m33);
            }
        } else if (order === "XZY") {
            this._z = Math.asin(-clamp(m12, -1, 1));
            if (Math.abs(m12) < 0.99999) {
                this._x = Math.atan2(m32, m22);
                this._y = Math.atan2(m13, m11);
            } else {
                this._x = Math.atan2(-m23, m33);
                this._y = 0;
            }
        } else console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + order);
        this._order = order;
        if (update !== false) this.onChangeCallback();
        return this;
    },
    setFromQuaternion: function() {
        var matrix = new Matrix4();
        return function setFromQuaternion(q, order, update) {
            matrix.makeRotationFromQuaternion(q);
            return this.setFromRotationMatrix(matrix, order, update);
        };
    }(),
    setFromVector3: function(v, order) {
        return this.set(v.x, v.y, v.z, order || this._order);
    },
    reorder: function() {
        // WARNING: this discards revolution information -bhouston
        var q = new Quaternion();
        return function reorder(newOrder) {
            q.setFromEuler(this);
            return this.setFromQuaternion(q, newOrder);
        };
    }(),
    equals: function(euler) {
        return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
    },
    fromArray: function(array) {
        this._x = array[0];
        this._y = array[1];
        this._z = array[2];
        if (array[3] !== undefined) this._order = array[3];
        this.onChangeCallback();
        return this;
    },
    toArray: function(array, offset) {
        if (array === undefined) array = [];
        if (offset === undefined) offset = 0;
        array[offset] = this._x;
        array[offset + 1] = this._y;
        array[offset + 2] = this._z;
        array[offset + 3] = this._order;
        return array;
    },
    toVector3: function(optionalResult) {
        if (optionalResult) return optionalResult.set(this._x, this._y, this._z);
        else return new Vector3(this._x, this._y, this._z);
    },
    onChange: function(callback) {
        this.onChangeCallback = callback;
        return this;
    },
    onChangeCallback: function() {}
});
/**
 * @author mrdoob / http://mrdoob.com/
 */ function Layers() {
    this.mask = 1;
}
Object.assign(Layers.prototype, {
    set: function(channel) {
        this.mask = 1 << channel | 0;
    },
    enable: function(channel) {
        this.mask |= 1 << channel | 0;
    },
    toggle: function(channel) {
        this.mask ^= 1 << channel | 0;
    },
    disable: function(channel) {
        this.mask &= ~(1 << channel | 0);
    },
    test: function(layers) {
        return (this.mask & layers.mask) !== 0;
    }
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author elephantatwork / www.elephantatwork.ch
 */ var object3DId = 0;
function Object3D() {
    Object.defineProperty(this, "id", {
        value: object3DId++
    });
    this.uuid = _Math.generateUUID();
    this.name = "";
    this.type = "Object3D";
    this.parent = null;
    this.children = [];
    this.up = Object3D.DefaultUp.clone();
    var position = new Vector3();
    var rotation = new Euler();
    var quaternion = new Quaternion();
    var scale = new Vector3(1, 1, 1);
    function onRotationChange() {
        quaternion.setFromEuler(rotation, false);
    }
    function onQuaternionChange() {
        rotation.setFromQuaternion(quaternion, undefined, false);
    }
    rotation.onChange(onRotationChange);
    quaternion.onChange(onQuaternionChange);
    Object.defineProperties(this, {
        position: {
            configurable: true,
            enumerable: true,
            value: position
        },
        rotation: {
            configurable: true,
            enumerable: true,
            value: rotation
        },
        quaternion: {
            configurable: true,
            enumerable: true,
            value: quaternion
        },
        scale: {
            configurable: true,
            enumerable: true,
            value: scale
        },
        modelViewMatrix: {
            value: new Matrix4()
        },
        normalMatrix: {
            value: new Matrix3()
        }
    });
    this.matrix = new Matrix4();
    this.matrixWorld = new Matrix4();
    this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
    this.matrixWorldNeedsUpdate = false;
    this.layers = new Layers();
    this.visible = true;
    this.castShadow = false;
    this.receiveShadow = false;
    this.frustumCulled = true;
    this.renderOrder = 0;
    this.userData = {};
}
Object3D.DefaultUp = new Vector3(0, 1, 0);
Object3D.DefaultMatrixAutoUpdate = true;
Object3D.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
    constructor: Object3D,
    isObject3D: true,
    onBeforeRender: function() {},
    onAfterRender: function() {},
    applyMatrix: function(matrix) {
        this.matrix.multiplyMatrices(matrix, this.matrix);
        this.matrix.decompose(this.position, this.quaternion, this.scale);
    },
    applyQuaternion: function(q) {
        this.quaternion.premultiply(q);
        return this;
    },
    setRotationFromAxisAngle: function(axis, angle) {
        // assumes axis is normalized
        this.quaternion.setFromAxisAngle(axis, angle);
    },
    setRotationFromEuler: function(euler) {
        this.quaternion.setFromEuler(euler, true);
    },
    setRotationFromMatrix: function(m) {
        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
        this.quaternion.setFromRotationMatrix(m);
    },
    setRotationFromQuaternion: function(q) {
        // assumes q is normalized
        this.quaternion.copy(q);
    },
    rotateOnAxis: function() {
        // rotate object on axis in object space
        // axis is assumed to be normalized
        var q1 = new Quaternion();
        return function rotateOnAxis(axis, angle) {
            q1.setFromAxisAngle(axis, angle);
            this.quaternion.multiply(q1);
            return this;
        };
    }(),
    rotateOnWorldAxis: function() {
        // rotate object on axis in world space
        // axis is assumed to be normalized
        // method assumes no rotated parent
        var q1 = new Quaternion();
        return function rotateOnWorldAxis(axis, angle) {
            q1.setFromAxisAngle(axis, angle);
            this.quaternion.premultiply(q1);
            return this;
        };
    }(),
    rotateX: function() {
        var v1 = new Vector3(1, 0, 0);
        return function rotateX(angle) {
            return this.rotateOnAxis(v1, angle);
        };
    }(),
    rotateY: function() {
        var v1 = new Vector3(0, 1, 0);
        return function rotateY(angle) {
            return this.rotateOnAxis(v1, angle);
        };
    }(),
    rotateZ: function() {
        var v1 = new Vector3(0, 0, 1);
        return function rotateZ(angle) {
            return this.rotateOnAxis(v1, angle);
        };
    }(),
    translateOnAxis: function() {
        // translate object by distance along axis in object space
        // axis is assumed to be normalized
        var v1 = new Vector3();
        return function translateOnAxis(axis, distance) {
            v1.copy(axis).applyQuaternion(this.quaternion);
            this.position.add(v1.multiplyScalar(distance));
            return this;
        };
    }(),
    translateX: function() {
        var v1 = new Vector3(1, 0, 0);
        return function translateX(distance) {
            return this.translateOnAxis(v1, distance);
        };
    }(),
    translateY: function() {
        var v1 = new Vector3(0, 1, 0);
        return function translateY(distance) {
            return this.translateOnAxis(v1, distance);
        };
    }(),
    translateZ: function() {
        var v1 = new Vector3(0, 0, 1);
        return function translateZ(distance) {
            return this.translateOnAxis(v1, distance);
        };
    }(),
    localToWorld: function(vector) {
        return vector.applyMatrix4(this.matrixWorld);
    },
    worldToLocal: function() {
        var m1 = new Matrix4();
        return function worldToLocal(vector) {
            return vector.applyMatrix4(m1.getInverse(this.matrixWorld));
        };
    }(),
    lookAt: function() {
        // This method does not support objects having non-uniformly-scaled parent(s)
        var q1 = new Quaternion();
        var m1 = new Matrix4();
        var target = new Vector3();
        var position = new Vector3();
        return function lookAt(x, y, z) {
            if (x.isVector3) target.copy(x);
            else target.set(x, y, z);
            var parent = this.parent;
            this.updateWorldMatrix(true, false);
            position.setFromMatrixPosition(this.matrixWorld);
            if (this.isCamera || this.isLight) m1.lookAt(position, target, this.up);
            else m1.lookAt(target, position, this.up);
            this.quaternion.setFromRotationMatrix(m1);
            if (parent) {
                m1.extractRotation(parent.matrixWorld);
                q1.setFromRotationMatrix(m1);
                this.quaternion.premultiply(q1.inverse());
            }
        };
    }(),
    add: function(object) {
        if (arguments.length > 1) {
            for(var i = 0; i < arguments.length; i++)this.add(arguments[i]);
            return this;
        }
        if (object === this) {
            console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
            return this;
        }
        if (object && object.isObject3D) {
            if (object.parent !== null) object.parent.remove(object);
            object.parent = this;
            object.dispatchEvent({
                type: "added"
            });
            this.children.push(object);
        } else console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
        return this;
    },
    remove: function(object) {
        if (arguments.length > 1) {
            for(var i = 0; i < arguments.length; i++)this.remove(arguments[i]);
            return this;
        }
        var index = this.children.indexOf(object);
        if (index !== -1) {
            object.parent = null;
            object.dispatchEvent({
                type: "removed"
            });
            this.children.splice(index, 1);
        }
        return this;
    },
    getObjectById: function(id) {
        return this.getObjectByProperty("id", id);
    },
    getObjectByName: function(name) {
        return this.getObjectByProperty("name", name);
    },
    getObjectByProperty: function(name, value) {
        if (this[name] === value) return this;
        for(var i = 0, l = this.children.length; i < l; i++){
            var child = this.children[i];
            var object = child.getObjectByProperty(name, value);
            if (object !== undefined) return object;
        }
        return undefined;
    },
    getWorldPosition: function(target) {
        if (target === undefined) {
            console.warn("THREE.Object3D: .getWorldPosition() target is now required");
            target = new Vector3();
        }
        this.updateMatrixWorld(true);
        return target.setFromMatrixPosition(this.matrixWorld);
    },
    getWorldQuaternion: function() {
        var position = new Vector3();
        var scale = new Vector3();
        return function getWorldQuaternion(target) {
            if (target === undefined) {
                console.warn("THREE.Object3D: .getWorldQuaternion() target is now required");
                target = new Quaternion();
            }
            this.updateMatrixWorld(true);
            this.matrixWorld.decompose(position, target, scale);
            return target;
        };
    }(),
    getWorldScale: function() {
        var position = new Vector3();
        var quaternion = new Quaternion();
        return function getWorldScale(target) {
            if (target === undefined) {
                console.warn("THREE.Object3D: .getWorldScale() target is now required");
                target = new Vector3();
            }
            this.updateMatrixWorld(true);
            this.matrixWorld.decompose(position, quaternion, target);
            return target;
        };
    }(),
    getWorldDirection: function(target) {
        if (target === undefined) {
            console.warn("THREE.Object3D: .getWorldDirection() target is now required");
            target = new Vector3();
        }
        this.updateMatrixWorld(true);
        var e = this.matrixWorld.elements;
        return target.set(e[8], e[9], e[10]).normalize();
    },
    raycast: function() {},
    traverse: function(callback) {
        callback(this);
        var children = this.children;
        for(var i = 0, l = children.length; i < l; i++)children[i].traverse(callback);
    },
    traverseVisible: function(callback) {
        if (this.visible === false) return;
        callback(this);
        var children = this.children;
        for(var i = 0, l = children.length; i < l; i++)children[i].traverseVisible(callback);
    },
    traverseAncestors: function(callback) {
        var parent = this.parent;
        if (parent !== null) {
            callback(parent);
            parent.traverseAncestors(callback);
        }
    },
    updateMatrix: function() {
        this.matrix.compose(this.position, this.quaternion, this.scale);
        this.matrixWorldNeedsUpdate = true;
    },
    updateMatrixWorld: function(force) {
        if (this.matrixAutoUpdate) this.updateMatrix();
        if (this.matrixWorldNeedsUpdate || force) {
            if (this.parent === null) this.matrixWorld.copy(this.matrix);
            else this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
            this.matrixWorldNeedsUpdate = false;
            force = true;
        }
        // update children
        var children = this.children;
        for(var i = 0, l = children.length; i < l; i++)children[i].updateMatrixWorld(force);
    },
    updateWorldMatrix: function(updateParents, updateChildren) {
        var parent = this.parent;
        if (updateParents === true && parent !== null) parent.updateWorldMatrix(true, false);
        if (this.matrixAutoUpdate) this.updateMatrix();
        if (this.parent === null) this.matrixWorld.copy(this.matrix);
        else this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
        // update children
        if (updateChildren === true) {
            var children = this.children;
            for(var i = 0, l = children.length; i < l; i++)children[i].updateWorldMatrix(false, true);
        }
    },
    toJSON: function(meta) {
        // meta is a string when called from JSON.stringify
        var isRootObject = meta === undefined || typeof meta === "string";
        var output = {};
        // meta is a hash used to collect geometries, materials.
        // not providing it implies that this is the root object
        // being serialized.
        if (isRootObject) {
            // initialize meta obj
            meta = {
                geometries: {},
                materials: {},
                textures: {},
                images: {},
                shapes: {}
            };
            output.metadata = {
                version: 4.5,
                type: "Object",
                generator: "Object3D.toJSON"
            };
        }
        // standard Object3D serialization
        var object = {};
        object.uuid = this.uuid;
        object.type = this.type;
        if (this.name !== "") object.name = this.name;
        if (this.castShadow === true) object.castShadow = true;
        if (this.receiveShadow === true) object.receiveShadow = true;
        if (this.visible === false) object.visible = false;
        if (this.frustumCulled === false) object.frustumCulled = false;
        if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;
        if (JSON.stringify(this.userData) !== "{}") object.userData = this.userData;
        object.layers = this.layers.mask;
        object.matrix = this.matrix.toArray();
        if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false;
        //
        function serialize(library, element) {
            if (library[element.uuid] === undefined) library[element.uuid] = element.toJSON(meta);
            return element.uuid;
        }
        if (this.isMesh || this.isLine || this.isPoints) {
            object.geometry = serialize(meta.geometries, this.geometry);
            var parameters = this.geometry.parameters;
            if (parameters !== undefined && parameters.shapes !== undefined) {
                var shapes = parameters.shapes;
                if (Array.isArray(shapes)) for(var i = 0, l = shapes.length; i < l; i++){
                    var shape = shapes[i];
                    serialize(meta.shapes, shape);
                }
                else serialize(meta.shapes, shapes);
            }
        }
        if (this.material !== undefined) {
            if (Array.isArray(this.material)) {
                var uuids = [];
                for(var i = 0, l = this.material.length; i < l; i++)uuids.push(serialize(meta.materials, this.material[i]));
                object.material = uuids;
            } else object.material = serialize(meta.materials, this.material);
        }
        //
        if (this.children.length > 0) {
            object.children = [];
            for(var i = 0; i < this.children.length; i++)object.children.push(this.children[i].toJSON(meta).object);
        }
        if (isRootObject) {
            var geometries = extractFromCache(meta.geometries);
            var materials = extractFromCache(meta.materials);
            var textures = extractFromCache(meta.textures);
            var images = extractFromCache(meta.images);
            var shapes = extractFromCache(meta.shapes);
            if (geometries.length > 0) output.geometries = geometries;
            if (materials.length > 0) output.materials = materials;
            if (textures.length > 0) output.textures = textures;
            if (images.length > 0) output.images = images;
            if (shapes.length > 0) output.shapes = shapes;
        }
        output.object = object;
        return output;
        // extract data from the cache hash
        // remove metadata on each item
        // and return as array
        function extractFromCache(cache) {
            var values = [];
            for(var key in cache){
                var data = cache[key];
                delete data.metadata;
                values.push(data);
            }
            return values;
        }
    },
    clone: function(recursive) {
        return new this.constructor().copy(this, recursive);
    },
    copy: function(source, recursive) {
        if (recursive === undefined) recursive = true;
        this.name = source.name;
        this.up.copy(source.up);
        this.position.copy(source.position);
        this.quaternion.copy(source.quaternion);
        this.scale.copy(source.scale);
        this.matrix.copy(source.matrix);
        this.matrixWorld.copy(source.matrixWorld);
        this.matrixAutoUpdate = source.matrixAutoUpdate;
        this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
        this.layers.mask = source.layers.mask;
        this.visible = source.visible;
        this.castShadow = source.castShadow;
        this.receiveShadow = source.receiveShadow;
        this.frustumCulled = source.frustumCulled;
        this.renderOrder = source.renderOrder;
        this.userData = JSON.parse(JSON.stringify(source.userData));
        if (recursive === true) for(var i = 0; i < source.children.length; i++){
            var child = source.children[i];
            this.add(child.clone());
        }
        return this;
    }
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author kile / http://kile.stravaganza.org/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author bhouston / http://clara.io
 */ var geometryId = 0; // Geometry uses even numbers as Id
function Geometry() {
    Object.defineProperty(this, "id", {
        value: geometryId += 2
    });
    this.uuid = _Math.generateUUID();
    this.name = "";
    this.type = "Geometry";
    this.vertices = [];
    this.colors = [];
    this.faces = [];
    this.faceVertexUvs = [
        []
    ];
    this.morphTargets = [];
    this.morphNormals = [];
    this.skinWeights = [];
    this.skinIndices = [];
    this.lineDistances = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    // update flags
    this.elementsNeedUpdate = false;
    this.verticesNeedUpdate = false;
    this.uvsNeedUpdate = false;
    this.normalsNeedUpdate = false;
    this.colorsNeedUpdate = false;
    this.lineDistancesNeedUpdate = false;
    this.groupsNeedUpdate = false;
}
Geometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
    constructor: Geometry,
    isGeometry: true,
    applyMatrix: function(matrix) {
        var normalMatrix = new Matrix3().getNormalMatrix(matrix);
        for(var i = 0, il = this.vertices.length; i < il; i++){
            var vertex = this.vertices[i];
            vertex.applyMatrix4(matrix);
        }
        for(var i = 0, il = this.faces.length; i < il; i++){
            var face = this.faces[i];
            face.normal.applyMatrix3(normalMatrix).normalize();
            for(var j = 0, jl = face.vertexNormals.length; j < jl; j++)face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();
        }
        if (this.boundingBox !== null) this.computeBoundingBox();
        if (this.boundingSphere !== null) this.computeBoundingSphere();
        this.verticesNeedUpdate = true;
        this.normalsNeedUpdate = true;
        return this;
    },
    rotateX: function() {
        // rotate geometry around world x-axis
        var m1 = new Matrix4();
        return function rotateX(angle) {
            m1.makeRotationX(angle);
            this.applyMatrix(m1);
            return this;
        };
    }(),
    rotateY: function() {
        // rotate geometry around world y-axis
        var m1 = new Matrix4();
        return function rotateY(angle) {
            m1.makeRotationY(angle);
            this.applyMatrix(m1);
            return this;
        };
    }(),
    rotateZ: function() {
        // rotate geometry around world z-axis
        var m1 = new Matrix4();
        return function rotateZ(angle) {
            m1.makeRotationZ(angle);
            this.applyMatrix(m1);
            return this;
        };
    }(),
    translate: function() {
        // translate geometry
        var m1 = new Matrix4();
        return function translate(x, y, z) {
            m1.makeTranslation(x, y, z);
            this.applyMatrix(m1);
            return this;
        };
    }(),
    scale: function() {
        // scale geometry
        var m1 = new Matrix4();
        return function scale(x, y, z) {
            m1.makeScale(x, y, z);
            this.applyMatrix(m1);
            return this;
        };
    }(),
    lookAt: function() {
        var obj = new Object3D();
        return function lookAt(vector) {
            obj.lookAt(vector);
            obj.updateMatrix();
            this.applyMatrix(obj.matrix);
        };
    }(),
    fromBufferGeometry: function(geometry) {
        var scope = this;
        var indices = geometry.index !== null ? geometry.index.array : undefined;
        var attributes = geometry.attributes;
        var positions = attributes.position.array;
        var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
        var colors = attributes.color !== undefined ? attributes.color.array : undefined;
        var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
        var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;
        if (uvs2 !== undefined) this.faceVertexUvs[1] = [];
        for(var i = 0, j = 0; i < positions.length; i += 3, j += 2){
            scope.vertices.push(new Vector3().fromArray(positions, i));
            if (colors !== undefined) scope.colors.push(new Color().fromArray(colors, i));
        }
        function addFace(a, b, c, materialIndex) {
            var vertexColors = colors === undefined ? [] : [
                scope.colors[a].clone(),
                scope.colors[b].clone(),
                scope.colors[c].clone()
            ];
            var vertexNormals = normals === undefined ? [] : [
                new Vector3().fromArray(normals, a * 3),
                new Vector3().fromArray(normals, b * 3),
                new Vector3().fromArray(normals, c * 3)
            ];
            var face = new Face3(a, b, c, vertexNormals, vertexColors, materialIndex);
            scope.faces.push(face);
            if (uvs !== undefined) scope.faceVertexUvs[0].push([
                new Vector2().fromArray(uvs, a * 2),
                new Vector2().fromArray(uvs, b * 2),
                new Vector2().fromArray(uvs, c * 2)
            ]);
            if (uvs2 !== undefined) scope.faceVertexUvs[1].push([
                new Vector2().fromArray(uvs2, a * 2),
                new Vector2().fromArray(uvs2, b * 2),
                new Vector2().fromArray(uvs2, c * 2)
            ]);
        }
        var groups = geometry.groups;
        if (groups.length > 0) for(var i = 0; i < groups.length; i++){
            var group = groups[i];
            var start = group.start;
            var count = group.count;
            for(var j = start, jl = start + count; j < jl; j += 3)if (indices !== undefined) addFace(indices[j], indices[j + 1], indices[j + 2], group.materialIndex);
            else addFace(j, j + 1, j + 2, group.materialIndex);
        }
        else {
            if (indices !== undefined) for(var i = 0; i < indices.length; i += 3)addFace(indices[i], indices[i + 1], indices[i + 2]);
            else for(var i = 0; i < positions.length / 3; i += 3)addFace(i, i + 1, i + 2);
        }
        this.computeFaceNormals();
        if (geometry.boundingBox !== null) this.boundingBox = geometry.boundingBox.clone();
        if (geometry.boundingSphere !== null) this.boundingSphere = geometry.boundingSphere.clone();
        return this;
    },
    center: function() {
        var offset = new Vector3();
        return function center() {
            this.computeBoundingBox();
            this.boundingBox.getCenter(offset).negate();
            this.translate(offset.x, offset.y, offset.z);
            return this;
        };
    }(),
    normalize: function() {
        this.computeBoundingSphere();
        var center = this.boundingSphere.center;
        var radius = this.boundingSphere.radius;
        var s = radius === 0 ? 1 : 1.0 / radius;
        var matrix = new Matrix4();
        matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1);
        this.applyMatrix(matrix);
        return this;
    },
    computeFaceNormals: function() {
        var cb = new Vector3(), ab = new Vector3();
        for(var f = 0, fl = this.faces.length; f < fl; f++){
            var face = this.faces[f];
            var vA = this.vertices[face.a];
            var vB = this.vertices[face.b];
            var vC = this.vertices[face.c];
            cb.subVectors(vC, vB);
            ab.subVectors(vA, vB);
            cb.cross(ab);
            cb.normalize();
            face.normal.copy(cb);
        }
    },
    computeVertexNormals: function(areaWeighted) {
        if (areaWeighted === undefined) areaWeighted = true;
        var v, vl, f, fl, face, vertices;
        vertices = new Array(this.vertices.length);
        for(v = 0, vl = this.vertices.length; v < vl; v++)vertices[v] = new Vector3();
        if (areaWeighted) {
            // vertex normals weighted by triangle areas
            // http://www.iquilezles.org/www/articles/normals/normals.htm
            var vA, vB, vC;
            var cb = new Vector3(), ab = new Vector3();
            for(f = 0, fl = this.faces.length; f < fl; f++){
                face = this.faces[f];
                vA = this.vertices[face.a];
                vB = this.vertices[face.b];
                vC = this.vertices[face.c];
                cb.subVectors(vC, vB);
                ab.subVectors(vA, vB);
                cb.cross(ab);
                vertices[face.a].add(cb);
                vertices[face.b].add(cb);
                vertices[face.c].add(cb);
            }
        } else {
            this.computeFaceNormals();
            for(f = 0, fl = this.faces.length; f < fl; f++){
                face = this.faces[f];
                vertices[face.a].add(face.normal);
                vertices[face.b].add(face.normal);
                vertices[face.c].add(face.normal);
            }
        }
        for(v = 0, vl = this.vertices.length; v < vl; v++)vertices[v].normalize();
        for(f = 0, fl = this.faces.length; f < fl; f++){
            face = this.faces[f];
            var vertexNormals = face.vertexNormals;
            if (vertexNormals.length === 3) {
                vertexNormals[0].copy(vertices[face.a]);
                vertexNormals[1].copy(vertices[face.b]);
                vertexNormals[2].copy(vertices[face.c]);
            } else {
                vertexNormals[0] = vertices[face.a].clone();
                vertexNormals[1] = vertices[face.b].clone();
                vertexNormals[2] = vertices[face.c].clone();
            }
        }
        if (this.faces.length > 0) this.normalsNeedUpdate = true;
    },
    computeFlatVertexNormals: function() {
        var f, fl, face;
        this.computeFaceNormals();
        for(f = 0, fl = this.faces.length; f < fl; f++){
            face = this.faces[f];
            var vertexNormals = face.vertexNormals;
            if (vertexNormals.length === 3) {
                vertexNormals[0].copy(face.normal);
                vertexNormals[1].copy(face.normal);
                vertexNormals[2].copy(face.normal);
            } else {
                vertexNormals[0] = face.normal.clone();
                vertexNormals[1] = face.normal.clone();
                vertexNormals[2] = face.normal.clone();
            }
        }
        if (this.faces.length > 0) this.normalsNeedUpdate = true;
    },
    computeMorphNormals: function() {
        var i, il, f, fl, face;
        // save original normals
        // - create temp variables on first access
        //   otherwise just copy (for faster repeated calls)
        for(f = 0, fl = this.faces.length; f < fl; f++){
            face = this.faces[f];
            if (!face.__originalFaceNormal) face.__originalFaceNormal = face.normal.clone();
            else face.__originalFaceNormal.copy(face.normal);
            if (!face.__originalVertexNormals) face.__originalVertexNormals = [];
            for(i = 0, il = face.vertexNormals.length; i < il; i++)if (!face.__originalVertexNormals[i]) face.__originalVertexNormals[i] = face.vertexNormals[i].clone();
            else face.__originalVertexNormals[i].copy(face.vertexNormals[i]);
        }
        // use temp geometry to compute face and vertex normals for each morph
        var tmpGeo = new Geometry();
        tmpGeo.faces = this.faces;
        for(i = 0, il = this.morphTargets.length; i < il; i++){
            // create on first access
            if (!this.morphNormals[i]) {
                this.morphNormals[i] = {};
                this.morphNormals[i].faceNormals = [];
                this.morphNormals[i].vertexNormals = [];
                var dstNormalsFace = this.morphNormals[i].faceNormals;
                var dstNormalsVertex = this.morphNormals[i].vertexNormals;
                var faceNormal, vertexNormals;
                for(f = 0, fl = this.faces.length; f < fl; f++){
                    faceNormal = new Vector3();
                    vertexNormals = {
                        a: new Vector3(),
                        b: new Vector3(),
                        c: new Vector3()
                    };
                    dstNormalsFace.push(faceNormal);
                    dstNormalsVertex.push(vertexNormals);
                }
            }
            var morphNormals = this.morphNormals[i];
            // set vertices to morph target
            tmpGeo.vertices = this.morphTargets[i].vertices;
            // compute morph normals
            tmpGeo.computeFaceNormals();
            tmpGeo.computeVertexNormals();
            // store morph normals
            var faceNormal, vertexNormals;
            for(f = 0, fl = this.faces.length; f < fl; f++){
                face = this.faces[f];
                faceNormal = morphNormals.faceNormals[f];
                vertexNormals = morphNormals.vertexNormals[f];
                faceNormal.copy(face.normal);
                vertexNormals.a.copy(face.vertexNormals[0]);
                vertexNormals.b.copy(face.vertexNormals[1]);
                vertexNormals.c.copy(face.vertexNormals[2]);
            }
        }
        // restore original normals
        for(f = 0, fl = this.faces.length; f < fl; f++){
            face = this.faces[f];
            face.normal = face.__originalFaceNormal;
            face.vertexNormals = face.__originalVertexNormals;
        }
    },
    computeBoundingBox: function() {
        if (this.boundingBox === null) this.boundingBox = new Box3();
        this.boundingBox.setFromPoints(this.vertices);
    },
    computeBoundingSphere: function() {
        if (this.boundingSphere === null) this.boundingSphere = new Sphere();
        this.boundingSphere.setFromPoints(this.vertices);
    },
    merge: function(geometry, matrix, materialIndexOffset) {
        if (!(geometry && geometry.isGeometry)) {
            console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", geometry);
            return;
        }
        var normalMatrix, vertexOffset = this.vertices.length, vertices1 = this.vertices, vertices2 = geometry.vertices, faces1 = this.faces, faces2 = geometry.faces, uvs1 = this.faceVertexUvs[0], uvs2 = geometry.faceVertexUvs[0], colors1 = this.colors, colors2 = geometry.colors;
        if (materialIndexOffset === undefined) materialIndexOffset = 0;
        if (matrix !== undefined) normalMatrix = new Matrix3().getNormalMatrix(matrix);
        // vertices
        for(var i = 0, il = vertices2.length; i < il; i++){
            var vertex = vertices2[i];
            var vertexCopy = vertex.clone();
            if (matrix !== undefined) vertexCopy.applyMatrix4(matrix);
            vertices1.push(vertexCopy);
        }
        // colors
        for(var i = 0, il = colors2.length; i < il; i++)colors1.push(colors2[i].clone());
        // faces
        for(i = 0, il = faces2.length; i < il; i++){
            var face = faces2[i], faceCopy, normal, color, faceVertexNormals = face.vertexNormals, faceVertexColors = face.vertexColors;
            faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);
            faceCopy.normal.copy(face.normal);
            if (normalMatrix !== undefined) faceCopy.normal.applyMatrix3(normalMatrix).normalize();
            for(var j = 0, jl = faceVertexNormals.length; j < jl; j++){
                normal = faceVertexNormals[j].clone();
                if (normalMatrix !== undefined) normal.applyMatrix3(normalMatrix).normalize();
                faceCopy.vertexNormals.push(normal);
            }
            faceCopy.color.copy(face.color);
            for(var j = 0, jl = faceVertexColors.length; j < jl; j++){
                color = faceVertexColors[j];
                faceCopy.vertexColors.push(color.clone());
            }
            faceCopy.materialIndex = face.materialIndex + materialIndexOffset;
            faces1.push(faceCopy);
        }
        // uvs
        for(i = 0, il = uvs2.length; i < il; i++){
            var uv = uvs2[i], uvCopy = [];
            if (uv === undefined) continue;
            for(var j = 0, jl = uv.length; j < jl; j++)uvCopy.push(uv[j].clone());
            uvs1.push(uvCopy);
        }
    },
    mergeMesh: function(mesh) {
        if (!(mesh && mesh.isMesh)) {
            console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", mesh);
            return;
        }
        if (mesh.matrixAutoUpdate) mesh.updateMatrix();
        this.merge(mesh.geometry, mesh.matrix);
    },
    /*
	 * Checks for duplicate vertices with hashmap.
	 * Duplicated vertices are removed
	 * and faces' vertices are updated.
	 */ mergeVertices: function() {
        var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
        var unique = [], changes = [];
        var v, key;
        var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
        var precision = Math.pow(10, precisionPoints);
        var i, il, face;
        var indices, j, jl;
        for(i = 0, il = this.vertices.length; i < il; i++){
            v = this.vertices[i];
            key = Math.round(v.x * precision) + "_" + Math.round(v.y * precision) + "_" + Math.round(v.z * precision);
            if (verticesMap[key] === undefined) {
                verticesMap[key] = i;
                unique.push(this.vertices[i]);
                changes[i] = unique.length - 1;
            } else //console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
            changes[i] = changes[verticesMap[key]];
        }
        // if faces are completely degenerate after merging vertices, we
        // have to remove them from the geometry.
        var faceIndicesToRemove = [];
        for(i = 0, il = this.faces.length; i < il; i++){
            face = this.faces[i];
            face.a = changes[face.a];
            face.b = changes[face.b];
            face.c = changes[face.c];
            indices = [
                face.a,
                face.b,
                face.c
            ];
            // if any duplicate vertices are found in a Face3
            // we have to remove the face as nothing can be saved
            for(var n = 0; n < 3; n++)if (indices[n] === indices[(n + 1) % 3]) {
                faceIndicesToRemove.push(i);
                break;
            }
        }
        for(i = faceIndicesToRemove.length - 1; i >= 0; i--){
            var idx = faceIndicesToRemove[i];
            this.faces.splice(idx, 1);
            for(j = 0, jl = this.faceVertexUvs.length; j < jl; j++)this.faceVertexUvs[j].splice(idx, 1);
        }
        // Use unique set of vertices
        var diff = this.vertices.length - unique.length;
        this.vertices = unique;
        return diff;
    },
    setFromPoints: function(points) {
        this.vertices = [];
        for(var i = 0, l = points.length; i < l; i++){
            var point = points[i];
            this.vertices.push(new Vector3(point.x, point.y, point.z || 0));
        }
        return this;
    },
    sortFacesByMaterialIndex: function() {
        var faces = this.faces;
        var length = faces.length;
        // tag faces
        for(var i = 0; i < length; i++)faces[i]._id = i;
        // sort faces
        function materialIndexSort(a, b) {
            return a.materialIndex - b.materialIndex;
        }
        faces.sort(materialIndexSort);
        // sort uvs
        var uvs1 = this.faceVertexUvs[0];
        var uvs2 = this.faceVertexUvs[1];
        var newUvs1, newUvs2;
        if (uvs1 && uvs1.length === length) newUvs1 = [];
        if (uvs2 && uvs2.length === length) newUvs2 = [];
        for(var i = 0; i < length; i++){
            var id = faces[i]._id;
            if (newUvs1) newUvs1.push(uvs1[id]);
            if (newUvs2) newUvs2.push(uvs2[id]);
        }
        if (newUvs1) this.faceVertexUvs[0] = newUvs1;
        if (newUvs2) this.faceVertexUvs[1] = newUvs2;
    },
    toJSON: function() {
        var data = {
            metadata: {
                version: 4.5,
                type: "Geometry",
                generator: "Geometry.toJSON"
            }
        };
        // standard Geometry serialization
        data.uuid = this.uuid;
        data.type = this.type;
        if (this.name !== "") data.name = this.name;
        if (this.parameters !== undefined) {
            var parameters = this.parameters;
            for(var key in parameters)if (parameters[key] !== undefined) data[key] = parameters[key];
            return data;
        }
        var vertices = [];
        for(var i = 0; i < this.vertices.length; i++){
            var vertex = this.vertices[i];
            vertices.push(vertex.x, vertex.y, vertex.z);
        }
        var faces = [];
        var normals = [];
        var normalsHash = {};
        var colors = [];
        var colorsHash = {};
        var uvs = [];
        var uvsHash = {};
        for(var i = 0; i < this.faces.length; i++){
            var face = this.faces[i];
            var hasMaterial = true;
            var hasFaceUv = false; // deprecated
            var hasFaceVertexUv = this.faceVertexUvs[0][i] !== undefined;
            var hasFaceNormal = face.normal.length() > 0;
            var hasFaceVertexNormal = face.vertexNormals.length > 0;
            var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
            var hasFaceVertexColor = face.vertexColors.length > 0;
            var faceType = 0;
            faceType = setBit(faceType, 0, 0); // isQuad
            faceType = setBit(faceType, 1, hasMaterial);
            faceType = setBit(faceType, 2, hasFaceUv);
            faceType = setBit(faceType, 3, hasFaceVertexUv);
            faceType = setBit(faceType, 4, hasFaceNormal);
            faceType = setBit(faceType, 5, hasFaceVertexNormal);
            faceType = setBit(faceType, 6, hasFaceColor);
            faceType = setBit(faceType, 7, hasFaceVertexColor);
            faces.push(faceType);
            faces.push(face.a, face.b, face.c);
            faces.push(face.materialIndex);
            if (hasFaceVertexUv) {
                var faceVertexUvs = this.faceVertexUvs[0][i];
                faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));
            }
            if (hasFaceNormal) faces.push(getNormalIndex(face.normal));
            if (hasFaceVertexNormal) {
                var vertexNormals = face.vertexNormals;
                faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));
            }
            if (hasFaceColor) faces.push(getColorIndex(face.color));
            if (hasFaceVertexColor) {
                var vertexColors = face.vertexColors;
                faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));
            }
        }
        function setBit(value, position, enabled) {
            return enabled ? value | 1 << position : value & ~(1 << position);
        }
        function getNormalIndex(normal) {
            var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();
            if (normalsHash[hash] !== undefined) return normalsHash[hash];
            normalsHash[hash] = normals.length / 3;
            normals.push(normal.x, normal.y, normal.z);
            return normalsHash[hash];
        }
        function getColorIndex(color) {
            var hash = color.r.toString() + color.g.toString() + color.b.toString();
            if (colorsHash[hash] !== undefined) return colorsHash[hash];
            colorsHash[hash] = colors.length;
            colors.push(color.getHex());
            return colorsHash[hash];
        }
        function getUvIndex(uv) {
            var hash = uv.x.toString() + uv.y.toString();
            if (uvsHash[hash] !== undefined) return uvsHash[hash];
            uvsHash[hash] = uvs.length / 2;
            uvs.push(uv.x, uv.y);
            return uvsHash[hash];
        }
        data.data = {};
        data.data.vertices = vertices;
        data.data.normals = normals;
        if (colors.length > 0) data.data.colors = colors;
        if (uvs.length > 0) data.data.uvs = [
            uvs
        ]; // temporal backward compatibility
        data.data.faces = faces;
        return data;
    },
    clone: function() {
        /*
		 // Handle primitives

		 var parameters = this.parameters;

		 if ( parameters !== undefined ) {

		 var values = [];

		 for ( var key in parameters ) {

		 values.push( parameters[ key ] );

		 }

		 var geometry = Object.create( this.constructor.prototype );
		 this.constructor.apply( geometry, values );
		 return geometry;

		 }

		 return new this.constructor().copy( this );
		 */ return new Geometry().copy(this);
    },
    copy: function(source) {
        var i, il, j, jl, k, kl;
        // reset
        this.vertices = [];
        this.colors = [];
        this.faces = [];
        this.faceVertexUvs = [
            []
        ];
        this.morphTargets = [];
        this.morphNormals = [];
        this.skinWeights = [];
        this.skinIndices = [];
        this.lineDistances = [];
        this.boundingBox = null;
        this.boundingSphere = null;
        // name
        this.name = source.name;
        // vertices
        var vertices = source.vertices;
        for(i = 0, il = vertices.length; i < il; i++)this.vertices.push(vertices[i].clone());
        // colors
        var colors = source.colors;
        for(i = 0, il = colors.length; i < il; i++)this.colors.push(colors[i].clone());
        // faces
        var faces = source.faces;
        for(i = 0, il = faces.length; i < il; i++)this.faces.push(faces[i].clone());
        // face vertex uvs
        for(i = 0, il = source.faceVertexUvs.length; i < il; i++){
            var faceVertexUvs = source.faceVertexUvs[i];
            if (this.faceVertexUvs[i] === undefined) this.faceVertexUvs[i] = [];
            for(j = 0, jl = faceVertexUvs.length; j < jl; j++){
                var uvs = faceVertexUvs[j], uvsCopy = [];
                for(k = 0, kl = uvs.length; k < kl; k++){
                    var uv = uvs[k];
                    uvsCopy.push(uv.clone());
                }
                this.faceVertexUvs[i].push(uvsCopy);
            }
        }
        // morph targets
        var morphTargets = source.morphTargets;
        for(i = 0, il = morphTargets.length; i < il; i++){
            var morphTarget = {};
            morphTarget.name = morphTargets[i].name;
            // vertices
            if (morphTargets[i].vertices !== undefined) {
                morphTarget.vertices = [];
                for(j = 0, jl = morphTargets[i].vertices.length; j < jl; j++)morphTarget.vertices.push(morphTargets[i].vertices[j].clone());
            }
            // normals
            if (morphTargets[i].normals !== undefined) {
                morphTarget.normals = [];
                for(j = 0, jl = morphTargets[i].normals.length; j < jl; j++)morphTarget.normals.push(morphTargets[i].normals[j].clone());
            }
            this.morphTargets.push(morphTarget);
        }
        // morph normals
        var morphNormals = source.morphNormals;
        for(i = 0, il = morphNormals.length; i < il; i++){
            var morphNormal = {};
            // vertex normals
            if (morphNormals[i].vertexNormals !== undefined) {
                morphNormal.vertexNormals = [];
                for(j = 0, jl = morphNormals[i].vertexNormals.length; j < jl; j++){
                    var srcVertexNormal = morphNormals[i].vertexNormals[j];
                    var destVertexNormal = {};
                    destVertexNormal.a = srcVertexNormal.a.clone();
                    destVertexNormal.b = srcVertexNormal.b.clone();
                    destVertexNormal.c = srcVertexNormal.c.clone();
                    morphNormal.vertexNormals.push(destVertexNormal);
                }
            }
            // face normals
            if (morphNormals[i].faceNormals !== undefined) {
                morphNormal.faceNormals = [];
                for(j = 0, jl = morphNormals[i].faceNormals.length; j < jl; j++)morphNormal.faceNormals.push(morphNormals[i].faceNormals[j].clone());
            }
            this.morphNormals.push(morphNormal);
        }
        // skin weights
        var skinWeights = source.skinWeights;
        for(i = 0, il = skinWeights.length; i < il; i++)this.skinWeights.push(skinWeights[i].clone());
        // skin indices
        var skinIndices = source.skinIndices;
        for(i = 0, il = skinIndices.length; i < il; i++)this.skinIndices.push(skinIndices[i].clone());
        // line distances
        var lineDistances = source.lineDistances;
        for(i = 0, il = lineDistances.length; i < il; i++)this.lineDistances.push(lineDistances[i]);
        // bounding box
        var boundingBox = source.boundingBox;
        if (boundingBox !== null) this.boundingBox = boundingBox.clone();
        // bounding sphere
        var boundingSphere = source.boundingSphere;
        if (boundingSphere !== null) this.boundingSphere = boundingSphere.clone();
        // update flags
        this.elementsNeedUpdate = source.elementsNeedUpdate;
        this.verticesNeedUpdate = source.verticesNeedUpdate;
        this.uvsNeedUpdate = source.uvsNeedUpdate;
        this.normalsNeedUpdate = source.normalsNeedUpdate;
        this.colorsNeedUpdate = source.colorsNeedUpdate;
        this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;
        this.groupsNeedUpdate = source.groupsNeedUpdate;
        return this;
    },
    dispose: function() {
        this.dispatchEvent({
            type: "dispose"
        });
    }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */ function BufferAttribute(array, itemSize, normalized) {
    if (Array.isArray(array)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.name = "";
    this.array = array;
    this.itemSize = itemSize;
    this.count = array !== undefined ? array.length / itemSize : 0;
    this.normalized = normalized === true;
    this.dynamic = false;
    this.updateRange = {
        offset: 0,
        count: -1
    };
    this.version = 0;
}
Object.defineProperty(BufferAttribute.prototype, "needsUpdate", {
    set: function(value) {
        if (value === true) this.version++;
    }
});
Object.assign(BufferAttribute.prototype, {
    isBufferAttribute: true,
    onUploadCallback: function() {},
    setArray: function(array) {
        if (Array.isArray(array)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.count = array !== undefined ? array.length / this.itemSize : 0;
        this.array = array;
        return this;
    },
    setDynamic: function(value) {
        this.dynamic = value;
        return this;
    },
    copy: function(source) {
        this.name = source.name;
        this.array = new source.array.constructor(source.array);
        this.itemSize = source.itemSize;
        this.count = source.count;
        this.normalized = source.normalized;
        this.dynamic = source.dynamic;
        return this;
    },
    copyAt: function(index1, attribute, index2) {
        index1 *= this.itemSize;
        index2 *= attribute.itemSize;
        for(var i = 0, l = this.itemSize; i < l; i++)this.array[index1 + i] = attribute.array[index2 + i];
        return this;
    },
    copyArray: function(array) {
        this.array.set(array);
        return this;
    },
    copyColorsArray: function(colors) {
        var array = this.array, offset = 0;
        for(var i = 0, l = colors.length; i < l; i++){
            var color = colors[i];
            if (color === undefined) {
                console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i);
                color = new Color();
            }
            array[offset++] = color.r;
            array[offset++] = color.g;
            array[offset++] = color.b;
        }
        return this;
    },
    copyVector2sArray: function(vectors) {
        var array = this.array, offset = 0;
        for(var i = 0, l = vectors.length; i < l; i++){
            var vector = vectors[i];
            if (vector === undefined) {
                console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i);
                vector = new Vector2();
            }
            array[offset++] = vector.x;
            array[offset++] = vector.y;
        }
        return this;
    },
    copyVector3sArray: function(vectors) {
        var array = this.array, offset = 0;
        for(var i = 0, l = vectors.length; i < l; i++){
            var vector = vectors[i];
            if (vector === undefined) {
                console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i);
                vector = new Vector3();
            }
            array[offset++] = vector.x;
            array[offset++] = vector.y;
            array[offset++] = vector.z;
        }
        return this;
    },
    copyVector4sArray: function(vectors) {
        var array = this.array, offset = 0;
        for(var i = 0, l = vectors.length; i < l; i++){
            var vector = vectors[i];
            if (vector === undefined) {
                console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i);
                vector = new Vector4();
            }
            array[offset++] = vector.x;
            array[offset++] = vector.y;
            array[offset++] = vector.z;
            array[offset++] = vector.w;
        }
        return this;
    },
    set: function(value, offset) {
        if (offset === undefined) offset = 0;
        this.array.set(value, offset);
        return this;
    },
    getX: function(index) {
        return this.array[index * this.itemSize];
    },
    setX: function(index, x) {
        this.array[index * this.itemSize] = x;
        return this;
    },
    getY: function(index) {
        return this.array[index * this.itemSize + 1];
    },
    setY: function(index, y) {
        this.array[index * this.itemSize + 1] = y;
        return this;
    },
    getZ: function(index) {
        return this.array[index * this.itemSize + 2];
    },
    setZ: function(index, z) {
        this.array[index * this.itemSize + 2] = z;
        return this;
    },
    getW: function(index) {
        return this.array[index * this.itemSize + 3];
    },
    setW: function(index, w) {
        this.array[index * this.itemSize + 3] = w;
        return this;
    },
    setXY: function(index, x, y) {
        index *= this.itemSize;
        this.array[index + 0] = x;
        this.array[index + 1] = y;
        return this;
    },
    setXYZ: function(index, x, y, z) {
        index *= this.itemSize;
        this.array[index + 0] = x;
        this.array[index + 1] = y;
        this.array[index + 2] = z;
        return this;
    },
    setXYZW: function(index, x, y, z, w) {
        index *= this.itemSize;
        this.array[index + 0] = x;
        this.array[index + 1] = y;
        this.array[index + 2] = z;
        this.array[index + 3] = w;
        return this;
    },
    onUpload: function(callback) {
        this.onUploadCallback = callback;
        return this;
    },
    clone: function() {
        return new this.constructor(this.array, this.itemSize).copy(this);
    }
});
//
function Int8BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Int8Array(array), itemSize, normalized);
}
Int8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;
function Uint8BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Uint8Array(array), itemSize, normalized);
}
Uint8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;
function Uint8ClampedBufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Uint8ClampedArray(array), itemSize, normalized);
}
Uint8ClampedBufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;
function Int16BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Int16Array(array), itemSize, normalized);
}
Int16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;
function Uint16BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Uint16Array(array), itemSize, normalized);
}
Uint16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;
function Int32BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Int32Array(array), itemSize, normalized);
}
Int32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;
function Uint32BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Uint32Array(array), itemSize, normalized);
}
Uint32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;
function Float32BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Float32Array(array), itemSize, normalized);
}
Float32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;
function Float64BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Float64Array(array), itemSize, normalized);
}
Float64BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;
/**
 * @author mrdoob / http://mrdoob.com/
 */ function DirectGeometry() {
    this.vertices = [];
    this.normals = [];
    this.colors = [];
    this.uvs = [];
    this.uvs2 = [];
    this.groups = [];
    this.morphTargets = {};
    this.skinWeights = [];
    this.skinIndices = [];
    // this.lineDistances = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    // update flags
    this.verticesNeedUpdate = false;
    this.normalsNeedUpdate = false;
    this.colorsNeedUpdate = false;
    this.uvsNeedUpdate = false;
    this.groupsNeedUpdate = false;
}
Object.assign(DirectGeometry.prototype, {
    computeGroups: function(geometry) {
        var group;
        var groups = [];
        var materialIndex = undefined;
        var faces = geometry.faces;
        for(var i = 0; i < faces.length; i++){
            var face = faces[i];
            // materials
            if (face.materialIndex !== materialIndex) {
                materialIndex = face.materialIndex;
                if (group !== undefined) {
                    group.count = i * 3 - group.start;
                    groups.push(group);
                }
                group = {
                    start: i * 3,
                    materialIndex: materialIndex
                };
            }
        }
        if (group !== undefined) {
            group.count = i * 3 - group.start;
            groups.push(group);
        }
        this.groups = groups;
    },
    fromGeometry: function(geometry) {
        var faces = geometry.faces;
        var vertices = geometry.vertices;
        var faceVertexUvs = geometry.faceVertexUvs;
        var hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;
        var hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0;
        // morphs
        var morphTargets = geometry.morphTargets;
        var morphTargetsLength = morphTargets.length;
        var morphTargetsPosition;
        if (morphTargetsLength > 0) {
            morphTargetsPosition = [];
            for(var i = 0; i < morphTargetsLength; i++)morphTargetsPosition[i] = {
                name: morphTargets[i].name,
                data: []
            };
            this.morphTargets.position = morphTargetsPosition;
        }
        var morphNormals = geometry.morphNormals;
        var morphNormalsLength = morphNormals.length;
        var morphTargetsNormal;
        if (morphNormalsLength > 0) {
            morphTargetsNormal = [];
            for(var i = 0; i < morphNormalsLength; i++)morphTargetsNormal[i] = {
                name: morphNormals[i].name,
                data: []
            };
            this.morphTargets.normal = morphTargetsNormal;
        }
        // skins
        var skinIndices = geometry.skinIndices;
        var skinWeights = geometry.skinWeights;
        var hasSkinIndices = skinIndices.length === vertices.length;
        var hasSkinWeights = skinWeights.length === vertices.length;
        //
        if (vertices.length > 0 && faces.length === 0) console.error("THREE.DirectGeometry: Faceless geometries are not supported.");
        for(var i = 0; i < faces.length; i++){
            var face = faces[i];
            this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);
            var vertexNormals = face.vertexNormals;
            if (vertexNormals.length === 3) this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);
            else {
                var normal = face.normal;
                this.normals.push(normal, normal, normal);
            }
            var vertexColors = face.vertexColors;
            if (vertexColors.length === 3) this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);
            else {
                var color = face.color;
                this.colors.push(color, color, color);
            }
            if (hasFaceVertexUv === true) {
                var vertexUvs = faceVertexUvs[0][i];
                if (vertexUvs !== undefined) this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
                else {
                    console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", i);
                    this.uvs.push(new Vector2(), new Vector2(), new Vector2());
                }
            }
            if (hasFaceVertexUv2 === true) {
                var vertexUvs = faceVertexUvs[1][i];
                if (vertexUvs !== undefined) this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
                else {
                    console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", i);
                    this.uvs2.push(new Vector2(), new Vector2(), new Vector2());
                }
            }
            // morphs
            for(var j = 0; j < morphTargetsLength; j++){
                var morphTarget = morphTargets[j].vertices;
                morphTargetsPosition[j].data.push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);
            }
            for(var j = 0; j < morphNormalsLength; j++){
                var morphNormal = morphNormals[j].vertexNormals[i];
                morphTargetsNormal[j].data.push(morphNormal.a, morphNormal.b, morphNormal.c);
            }
            // skins
            if (hasSkinIndices) this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);
            if (hasSkinWeights) this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);
        }
        this.computeGroups(geometry);
        this.verticesNeedUpdate = geometry.verticesNeedUpdate;
        this.normalsNeedUpdate = geometry.normalsNeedUpdate;
        this.colorsNeedUpdate = geometry.colorsNeedUpdate;
        this.uvsNeedUpdate = geometry.uvsNeedUpdate;
        this.groupsNeedUpdate = geometry.groupsNeedUpdate;
        return this;
    }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */ function arrayMax(array) {
    if (array.length === 0) return -Infinity;
    var max = array[0];
    for(var i = 1, l = array.length; i < l; ++i)if (array[i] > max) max = array[i];
    return max;
}
/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */ var bufferGeometryId = 1; // BufferGeometry uses odd numbers as Id
function BufferGeometry() {
    Object.defineProperty(this, "id", {
        value: bufferGeometryId += 2
    });
    this.uuid = _Math.generateUUID();
    this.name = "";
    this.type = "BufferGeometry";
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.drawRange = {
        start: 0,
        count: Infinity
    };
    this.userData = {};
}
BufferGeometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
    constructor: BufferGeometry,
    isBufferGeometry: true,
    getIndex: function() {
        return this.index;
    },
    setIndex: function(index) {
        if (Array.isArray(index)) this.index = new (arrayMax(index) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
        else this.index = index;
    },
    addAttribute: function(name, attribute) {
        if (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {
            console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).");
            return this.addAttribute(name, new BufferAttribute(arguments[1], arguments[2]));
        }
        if (name === "index") {
            console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.");
            this.setIndex(attribute);
            return this;
        }
        this.attributes[name] = attribute;
        return this;
    },
    getAttribute: function(name) {
        return this.attributes[name];
    },
    removeAttribute: function(name) {
        delete this.attributes[name];
        return this;
    },
    addGroup: function(start, count, materialIndex) {
        this.groups.push({
            start: start,
            count: count,
            materialIndex: materialIndex !== undefined ? materialIndex : 0
        });
    },
    clearGroups: function() {
        this.groups = [];
    },
    setDrawRange: function(start, count) {
        this.drawRange.start = start;
        this.drawRange.count = count;
    },
    applyMatrix: function(matrix) {
        var position = this.attributes.position;
        if (position !== undefined) {
            matrix.applyToBufferAttribute(position);
            position.needsUpdate = true;
        }
        var normal = this.attributes.normal;
        if (normal !== undefined) {
            var normalMatrix = new Matrix3().getNormalMatrix(matrix);
            normalMatrix.applyToBufferAttribute(normal);
            normal.needsUpdate = true;
        }
        if (this.boundingBox !== null) this.computeBoundingBox();
        if (this.boundingSphere !== null) this.computeBoundingSphere();
        return this;
    },
    rotateX: function() {
        // rotate geometry around world x-axis
        var m1 = new Matrix4();
        return function rotateX(angle) {
            m1.makeRotationX(angle);
            this.applyMatrix(m1);
            return this;
        };
    }(),
    rotateY: function() {
        // rotate geometry around world y-axis
        var m1 = new Matrix4();
        return function rotateY(angle) {
            m1.makeRotationY(angle);
            this.applyMatrix(m1);
            return this;
        };
    }(),
    rotateZ: function() {
        // rotate geometry around world z-axis
        var m1 = new Matrix4();
        return function rotateZ(angle) {
            m1.makeRotationZ(angle);
            this.applyMatrix(m1);
            return this;
        };
    }(),
    translate: function() {
        // translate geometry
        var m1 = new Matrix4();
        return function translate(x, y, z) {
            m1.makeTranslation(x, y, z);
            this.applyMatrix(m1);
            return this;
        };
    }(),
    scale: function() {
        // scale geometry
        var m1 = new Matrix4();
        return function scale(x, y, z) {
            m1.makeScale(x, y, z);
            this.applyMatrix(m1);
            return this;
        };
    }(),
    lookAt: function() {
        var obj = new Object3D();
        return function lookAt(vector) {
            obj.lookAt(vector);
            obj.updateMatrix();
            this.applyMatrix(obj.matrix);
        };
    }(),
    center: function() {
        var offset = new Vector3();
        return function center() {
            this.computeBoundingBox();
            this.boundingBox.getCenter(offset).negate();
            this.translate(offset.x, offset.y, offset.z);
            return this;
        };
    }(),
    setFromObject: function(object) {
        // console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );
        var geometry = object.geometry;
        if (object.isPoints || object.isLine) {
            var positions = new Float32BufferAttribute(geometry.vertices.length * 3, 3);
            var colors = new Float32BufferAttribute(geometry.colors.length * 3, 3);
            this.addAttribute("position", positions.copyVector3sArray(geometry.vertices));
            this.addAttribute("color", colors.copyColorsArray(geometry.colors));
            if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {
                var lineDistances = new Float32BufferAttribute(geometry.lineDistances.length, 1);
                this.addAttribute("lineDistance", lineDistances.copyArray(geometry.lineDistances));
            }
            if (geometry.boundingSphere !== null) this.boundingSphere = geometry.boundingSphere.clone();
            if (geometry.boundingBox !== null) this.boundingBox = geometry.boundingBox.clone();
        } else if (object.isMesh) {
            if (geometry && geometry.isGeometry) this.fromGeometry(geometry);
        }
        return this;
    },
    setFromPoints: function(points) {
        var position = [];
        for(var i = 0, l = points.length; i < l; i++){
            var point = points[i];
            position.push(point.x, point.y, point.z || 0);
        }
        this.addAttribute("position", new Float32BufferAttribute(position, 3));
        return this;
    },
    updateFromObject: function(object) {
        var geometry = object.geometry;
        if (object.isMesh) {
            var direct = geometry.__directGeometry;
            if (geometry.elementsNeedUpdate === true) {
                direct = undefined;
                geometry.elementsNeedUpdate = false;
            }
            if (direct === undefined) return this.fromGeometry(geometry);
            direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
            direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
            direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
            direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
            direct.groupsNeedUpdate = geometry.groupsNeedUpdate;
            geometry.verticesNeedUpdate = false;
            geometry.normalsNeedUpdate = false;
            geometry.colorsNeedUpdate = false;
            geometry.uvsNeedUpdate = false;
            geometry.groupsNeedUpdate = false;
            geometry = direct;
        }
        var attribute;
        if (geometry.verticesNeedUpdate === true) {
            attribute = this.attributes.position;
            if (attribute !== undefined) {
                attribute.copyVector3sArray(geometry.vertices);
                attribute.needsUpdate = true;
            }
            geometry.verticesNeedUpdate = false;
        }
        if (geometry.normalsNeedUpdate === true) {
            attribute = this.attributes.normal;
            if (attribute !== undefined) {
                attribute.copyVector3sArray(geometry.normals);
                attribute.needsUpdate = true;
            }
            geometry.normalsNeedUpdate = false;
        }
        if (geometry.colorsNeedUpdate === true) {
            attribute = this.attributes.color;
            if (attribute !== undefined) {
                attribute.copyColorsArray(geometry.colors);
                attribute.needsUpdate = true;
            }
            geometry.colorsNeedUpdate = false;
        }
        if (geometry.uvsNeedUpdate) {
            attribute = this.attributes.uv;
            if (attribute !== undefined) {
                attribute.copyVector2sArray(geometry.uvs);
                attribute.needsUpdate = true;
            }
            geometry.uvsNeedUpdate = false;
        }
        if (geometry.lineDistancesNeedUpdate) {
            attribute = this.attributes.lineDistance;
            if (attribute !== undefined) {
                attribute.copyArray(geometry.lineDistances);
                attribute.needsUpdate = true;
            }
            geometry.lineDistancesNeedUpdate = false;
        }
        if (geometry.groupsNeedUpdate) {
            geometry.computeGroups(object.geometry);
            this.groups = geometry.groups;
            geometry.groupsNeedUpdate = false;
        }
        return this;
    },
    fromGeometry: function(geometry) {
        geometry.__directGeometry = new DirectGeometry().fromGeometry(geometry);
        return this.fromDirectGeometry(geometry.__directGeometry);
    },
    fromDirectGeometry: function(geometry) {
        var positions = new Float32Array(geometry.vertices.length * 3);
        this.addAttribute("position", new BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));
        if (geometry.normals.length > 0) {
            var normals = new Float32Array(geometry.normals.length * 3);
            this.addAttribute("normal", new BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));
        }
        if (geometry.colors.length > 0) {
            var colors = new Float32Array(geometry.colors.length * 3);
            this.addAttribute("color", new BufferAttribute(colors, 3).copyColorsArray(geometry.colors));
        }
        if (geometry.uvs.length > 0) {
            var uvs = new Float32Array(geometry.uvs.length * 2);
            this.addAttribute("uv", new BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));
        }
        if (geometry.uvs2.length > 0) {
            var uvs2 = new Float32Array(geometry.uvs2.length * 2);
            this.addAttribute("uv2", new BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));
        }
        // groups
        this.groups = geometry.groups;
        // morphs
        for(var name in geometry.morphTargets){
            var array = [];
            var morphTargets = geometry.morphTargets[name];
            for(var i = 0, l = morphTargets.length; i < l; i++){
                var morphTarget = morphTargets[i];
                var attribute = new Float32BufferAttribute(morphTarget.data.length * 3, 3);
                attribute.name = morphTarget.name;
                array.push(attribute.copyVector3sArray(morphTarget.data));
            }
            this.morphAttributes[name] = array;
        }
        // skinning
        if (geometry.skinIndices.length > 0) {
            var skinIndices = new Float32BufferAttribute(geometry.skinIndices.length * 4, 4);
            this.addAttribute("skinIndex", skinIndices.copyVector4sArray(geometry.skinIndices));
        }
        if (geometry.skinWeights.length > 0) {
            var skinWeights = new Float32BufferAttribute(geometry.skinWeights.length * 4, 4);
            this.addAttribute("skinWeight", skinWeights.copyVector4sArray(geometry.skinWeights));
        }
        //
        if (geometry.boundingSphere !== null) this.boundingSphere = geometry.boundingSphere.clone();
        if (geometry.boundingBox !== null) this.boundingBox = geometry.boundingBox.clone();
        return this;
    },
    computeBoundingBox: function() {
        if (this.boundingBox === null) this.boundingBox = new Box3();
        var position = this.attributes.position;
        if (position !== undefined) this.boundingBox.setFromBufferAttribute(position);
        else this.boundingBox.makeEmpty();
        if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
    },
    computeBoundingSphere: function() {
        var box = new Box3();
        var vector = new Vector3();
        return function computeBoundingSphere() {
            if (this.boundingSphere === null) this.boundingSphere = new Sphere();
            var position = this.attributes.position;
            if (position) {
                var center = this.boundingSphere.center;
                box.setFromBufferAttribute(position);
                box.getCenter(center);
                // hoping to find a boundingSphere with a radius smaller than the
                // boundingSphere of the boundingBox: sqrt(3) smaller in the best case
                var maxRadiusSq = 0;
                for(var i = 0, il = position.count; i < il; i++){
                    vector.x = position.getX(i);
                    vector.y = position.getY(i);
                    vector.z = position.getZ(i);
                    maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));
                }
                this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
                if (isNaN(this.boundingSphere.radius)) console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
            }
        };
    }(),
    computeFaceNormals: function() {
    // backwards compatibility
    },
    computeVertexNormals: function() {
        var index = this.index;
        var attributes = this.attributes;
        if (attributes.position) {
            var positions = attributes.position.array;
            if (attributes.normal === undefined) this.addAttribute("normal", new BufferAttribute(new Float32Array(positions.length), 3));
            else {
                // reset existing normals to zero
                var array = attributes.normal.array;
                for(var i = 0, il = array.length; i < il; i++)array[i] = 0;
            }
            var normals = attributes.normal.array;
            var vA, vB, vC;
            var pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
            var cb = new Vector3(), ab = new Vector3();
            // indexed elements
            if (index) {
                var indices = index.array;
                for(var i = 0, il = index.count; i < il; i += 3){
                    vA = indices[i + 0] * 3;
                    vB = indices[i + 1] * 3;
                    vC = indices[i + 2] * 3;
                    pA.fromArray(positions, vA);
                    pB.fromArray(positions, vB);
                    pC.fromArray(positions, vC);
                    cb.subVectors(pC, pB);
                    ab.subVectors(pA, pB);
                    cb.cross(ab);
                    normals[vA] += cb.x;
                    normals[vA + 1] += cb.y;
                    normals[vA + 2] += cb.z;
                    normals[vB] += cb.x;
                    normals[vB + 1] += cb.y;
                    normals[vB + 2] += cb.z;
                    normals[vC] += cb.x;
                    normals[vC + 1] += cb.y;
                    normals[vC + 2] += cb.z;
                }
            } else // non-indexed elements (unconnected triangle soup)
            for(var i = 0, il = positions.length; i < il; i += 9){
                pA.fromArray(positions, i);
                pB.fromArray(positions, i + 3);
                pC.fromArray(positions, i + 6);
                cb.subVectors(pC, pB);
                ab.subVectors(pA, pB);
                cb.cross(ab);
                normals[i] = cb.x;
                normals[i + 1] = cb.y;
                normals[i + 2] = cb.z;
                normals[i + 3] = cb.x;
                normals[i + 4] = cb.y;
                normals[i + 5] = cb.z;
                normals[i + 6] = cb.x;
                normals[i + 7] = cb.y;
                normals[i + 8] = cb.z;
            }
            this.normalizeNormals();
            attributes.normal.needsUpdate = true;
        }
    },
    merge: function(geometry, offset) {
        if (!(geometry && geometry.isBufferGeometry)) {
            console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", geometry);
            return;
        }
        if (offset === undefined) {
            offset = 0;
            console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.");
        }
        var attributes = this.attributes;
        for(var key in attributes){
            if (geometry.attributes[key] === undefined) continue;
            var attribute1 = attributes[key];
            var attributeArray1 = attribute1.array;
            var attribute2 = geometry.attributes[key];
            var attributeArray2 = attribute2.array;
            var attributeSize = attribute2.itemSize;
            for(var i = 0, j = attributeSize * offset; i < attributeArray2.length; i++, j++)attributeArray1[j] = attributeArray2[i];
        }
        return this;
    },
    normalizeNormals: function() {
        var vector = new Vector3();
        return function normalizeNormals() {
            var normals = this.attributes.normal;
            for(var i = 0, il = normals.count; i < il; i++){
                vector.x = normals.getX(i);
                vector.y = normals.getY(i);
                vector.z = normals.getZ(i);
                vector.normalize();
                normals.setXYZ(i, vector.x, vector.y, vector.z);
            }
        };
    }(),
    toNonIndexed: function() {
        if (this.index === null) {
            console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.");
            return this;
        }
        var geometry2 = new BufferGeometry();
        var indices = this.index.array;
        var attributes = this.attributes;
        for(var name in attributes){
            var attribute = attributes[name];
            var array = attribute.array;
            var itemSize = attribute.itemSize;
            var array2 = new array.constructor(indices.length * itemSize);
            var index = 0, index2 = 0;
            for(var i = 0, l = indices.length; i < l; i++){
                index = indices[i] * itemSize;
                for(var j = 0; j < itemSize; j++)array2[index2++] = array[index++];
            }
            geometry2.addAttribute(name, new BufferAttribute(array2, itemSize));
        }
        var groups = this.groups;
        for(var i = 0, l = groups.length; i < l; i++){
            var group = groups[i];
            geometry2.addGroup(group.start, group.count, group.materialIndex);
        }
        return geometry2;
    },
    toJSON: function() {
        var data = {
            metadata: {
                version: 4.5,
                type: "BufferGeometry",
                generator: "BufferGeometry.toJSON"
            }
        };
        // standard BufferGeometry serialization
        data.uuid = this.uuid;
        data.type = this.type;
        if (this.name !== "") data.name = this.name;
        if (Object.keys(this.userData).length > 0) data.userData = this.userData;
        if (this.parameters !== undefined) {
            var parameters = this.parameters;
            for(var key in parameters)if (parameters[key] !== undefined) data[key] = parameters[key];
            return data;
        }
        data.data = {
            attributes: {}
        };
        var index = this.index;
        if (index !== null) {
            var array = Array.prototype.slice.call(index.array);
            data.data.index = {
                type: index.array.constructor.name,
                array: array
            };
        }
        var attributes = this.attributes;
        for(var key in attributes){
            var attribute = attributes[key];
            var array = Array.prototype.slice.call(attribute.array);
            data.data.attributes[key] = {
                itemSize: attribute.itemSize,
                type: attribute.array.constructor.name,
                array: array,
                normalized: attribute.normalized
            };
        }
        var groups = this.groups;
        if (groups.length > 0) data.data.groups = JSON.parse(JSON.stringify(groups));
        var boundingSphere = this.boundingSphere;
        if (boundingSphere !== null) data.data.boundingSphere = {
            center: boundingSphere.center.toArray(),
            radius: boundingSphere.radius
        };
        return data;
    },
    clone: function() {
        /*
		 // Handle primitives

		 var parameters = this.parameters;

		 if ( parameters !== undefined ) {

		 var values = [];

		 for ( var key in parameters ) {

		 values.push( parameters[ key ] );

		 }

		 var geometry = Object.create( this.constructor.prototype );
		 this.constructor.apply( geometry, values );
		 return geometry;

		 }

		 return new this.constructor().copy( this );
		 */ return new BufferGeometry().copy(this);
    },
    copy: function(source) {
        var name, i, l;
        // reset
        this.index = null;
        this.attributes = {};
        this.morphAttributes = {};
        this.groups = [];
        this.boundingBox = null;
        this.boundingSphere = null;
        // name
        this.name = source.name;
        // index
        var index = source.index;
        if (index !== null) this.setIndex(index.clone());
        // attributes
        var attributes = source.attributes;
        for(name in attributes){
            var attribute = attributes[name];
            this.addAttribute(name, attribute.clone());
        }
        // morph attributes
        var morphAttributes = source.morphAttributes;
        for(name in morphAttributes){
            var array = [];
            var morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes
            for(i = 0, l = morphAttribute.length; i < l; i++)array.push(morphAttribute[i].clone());
            this.morphAttributes[name] = array;
        }
        // groups
        var groups = source.groups;
        for(i = 0, l = groups.length; i < l; i++){
            var group = groups[i];
            this.addGroup(group.start, group.count, group.materialIndex);
        }
        // bounding box
        var boundingBox = source.boundingBox;
        if (boundingBox !== null) this.boundingBox = boundingBox.clone();
        // bounding sphere
        var boundingSphere = source.boundingSphere;
        if (boundingSphere !== null) this.boundingSphere = boundingSphere.clone();
        // draw range
        this.drawRange.start = source.drawRange.start;
        this.drawRange.count = source.drawRange.count;
        // user data
        this.userData = source.userData;
        return this;
    },
    dispose: function() {
        this.dispatchEvent({
            type: "dispose"
        });
    }
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */ // BoxGeometry
function BoxGeometry(width, height, depth, widthSegments, heightSegments, depthSegments) {
    Geometry.call(this);
    this.type = "BoxGeometry";
    this.parameters = {
        width: width,
        height: height,
        depth: depth,
        widthSegments: widthSegments,
        heightSegments: heightSegments,
        depthSegments: depthSegments
    };
    this.fromBufferGeometry(new BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments));
    this.mergeVertices();
}
BoxGeometry.prototype = Object.create(Geometry.prototype);
BoxGeometry.prototype.constructor = BoxGeometry;
// BoxBufferGeometry
function BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments) {
    BufferGeometry.call(this);
    this.type = "BoxBufferGeometry";
    this.parameters = {
        width: width,
        height: height,
        depth: depth,
        widthSegments: widthSegments,
        heightSegments: heightSegments,
        depthSegments: depthSegments
    };
    var scope = this;
    width = width || 1;
    height = height || 1;
    depth = depth || 1;
    // segments
    widthSegments = Math.floor(widthSegments) || 1;
    heightSegments = Math.floor(heightSegments) || 1;
    depthSegments = Math.floor(depthSegments) || 1;
    // buffers
    var indices = [];
    var vertices = [];
    var normals = [];
    var uvs = [];
    // helper variables
    var numberOfVertices = 0;
    var groupStart = 0;
    // build each side of the box geometry
    buildPlane("z", "y", "x", -1, -1, depth, height, width, depthSegments, heightSegments, 0); // px
    buildPlane("z", "y", "x", 1, -1, depth, height, -width, depthSegments, heightSegments, 1); // nx
    buildPlane("x", "z", "y", 1, 1, width, depth, height, widthSegments, depthSegments, 2); // py
    buildPlane("x", "z", "y", 1, -1, width, depth, -height, widthSegments, depthSegments, 3); // ny
    buildPlane("x", "y", "z", 1, -1, width, height, depth, widthSegments, heightSegments, 4); // pz
    buildPlane("x", "y", "z", -1, -1, width, height, -depth, widthSegments, heightSegments, 5); // nz
    // build geometry
    this.setIndex(indices);
    this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {
        var segmentWidth = width / gridX;
        var segmentHeight = height / gridY;
        var widthHalf = width / 2;
        var heightHalf = height / 2;
        var depthHalf = depth / 2;
        var gridX1 = gridX + 1;
        var gridY1 = gridY + 1;
        var vertexCounter = 0;
        var groupCount = 0;
        var ix, iy;
        var vector = new Vector3();
        // generate vertices, normals and uvs
        for(iy = 0; iy < gridY1; iy++){
            var y = iy * segmentHeight - heightHalf;
            for(ix = 0; ix < gridX1; ix++){
                var x = ix * segmentWidth - widthHalf;
                // set values to correct vector component
                vector[u] = x * udir;
                vector[v] = y * vdir;
                vector[w] = depthHalf;
                // now apply vector to vertex buffer
                vertices.push(vector.x, vector.y, vector.z);
                // set values to correct vector component
                vector[u] = 0;
                vector[v] = 0;
                vector[w] = depth > 0 ? 1 : -1;
                // now apply vector to normal buffer
                normals.push(vector.x, vector.y, vector.z);
                // uvs
                uvs.push(ix / gridX);
                uvs.push(1 - iy / gridY);
                // counters
                vertexCounter += 1;
            }
        }
        // indices
        // 1. you need three indices to draw a single face
        // 2. a single segment consists of two faces
        // 3. so we need to generate six (2*3) indices per segment
        for(iy = 0; iy < gridY; iy++)for(ix = 0; ix < gridX; ix++){
            var a = numberOfVertices + ix + gridX1 * iy;
            var b = numberOfVertices + ix + gridX1 * (iy + 1);
            var c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
            var d = numberOfVertices + (ix + 1) + gridX1 * iy;
            // faces
            indices.push(a, b, d);
            indices.push(b, c, d);
            // increase counter
            groupCount += 6;
        }
        // add a group to the geometry. this will ensure multi material support
        scope.addGroup(groupStart, groupCount, materialIndex);
        // calculate new start value for groups
        groupStart += groupCount;
        // update total number of vertices
        numberOfVertices += vertexCounter;
    }
}
BoxBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
BoxBufferGeometry.prototype.constructor = BoxBufferGeometry;
/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */ // PlaneGeometry
function PlaneGeometry(width, height, widthSegments, heightSegments) {
    Geometry.call(this);
    this.type = "PlaneGeometry";
    this.parameters = {
        width: width,
        height: height,
        widthSegments: widthSegments,
        heightSegments: heightSegments
    };
    this.fromBufferGeometry(new PlaneBufferGeometry(width, height, widthSegments, heightSegments));
    this.mergeVertices();
}
PlaneGeometry.prototype = Object.create(Geometry.prototype);
PlaneGeometry.prototype.constructor = PlaneGeometry;
// PlaneBufferGeometry
function PlaneBufferGeometry(width, height, widthSegments, heightSegments) {
    BufferGeometry.call(this);
    this.type = "PlaneBufferGeometry";
    this.parameters = {
        width: width,
        height: height,
        widthSegments: widthSegments,
        heightSegments: heightSegments
    };
    width = width || 1;
    height = height || 1;
    var width_half = width / 2;
    var height_half = height / 2;
    var gridX = Math.floor(widthSegments) || 1;
    var gridY = Math.floor(heightSegments) || 1;
    var gridX1 = gridX + 1;
    var gridY1 = gridY + 1;
    var segment_width = width / gridX;
    var segment_height = height / gridY;
    var ix, iy;
    // buffers
    var indices = [];
    var vertices = [];
    var normals = [];
    var uvs = [];
    // generate vertices, normals and uvs
    for(iy = 0; iy < gridY1; iy++){
        var y = iy * segment_height - height_half;
        for(ix = 0; ix < gridX1; ix++){
            var x = ix * segment_width - width_half;
            vertices.push(x, -y, 0);
            normals.push(0, 0, 1);
            uvs.push(ix / gridX);
            uvs.push(1 - iy / gridY);
        }
    }
    // indices
    for(iy = 0; iy < gridY; iy++)for(ix = 0; ix < gridX; ix++){
        var a = ix + gridX1 * iy;
        var b = ix + gridX1 * (iy + 1);
        var c = ix + 1 + gridX1 * (iy + 1);
        var d = ix + 1 + gridX1 * iy;
        // faces
        indices.push(a, b, d);
        indices.push(b, c, d);
    }
    // build geometry
    this.setIndex(indices);
    this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
}
PlaneBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
PlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */ var materialId = 0;
function Material() {
    Object.defineProperty(this, "id", {
        value: materialId++
    });
    this.uuid = _Math.generateUUID();
    this.name = "";
    this.type = "Material";
    this.fog = true;
    this.lights = true;
    this.blending = NormalBlending;
    this.side = FrontSide;
    this.flatShading = false;
    this.vertexColors = NoColors; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors
    this.opacity = 1;
    this.transparent = false;
    this.blendSrc = SrcAlphaFactor;
    this.blendDst = OneMinusSrcAlphaFactor;
    this.blendEquation = AddEquation;
    this.blendSrcAlpha = null;
    this.blendDstAlpha = null;
    this.blendEquationAlpha = null;
    this.depthFunc = LessEqualDepth;
    this.depthTest = true;
    this.depthWrite = true;
    this.clippingPlanes = null;
    this.clipIntersection = false;
    this.clipShadows = false;
    this.shadowSide = null;
    this.colorWrite = true;
    this.precision = null; // override the renderer's default precision for this material
    this.polygonOffset = false;
    this.polygonOffsetFactor = 0;
    this.polygonOffsetUnits = 0;
    this.dithering = false;
    this.alphaTest = 0;
    this.premultipliedAlpha = false;
    this.visible = true;
    this.userData = {};
    this.needsUpdate = true;
}
Material.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
    constructor: Material,
    isMaterial: true,
    onBeforeCompile: function() {},
    setValues: function(values) {
        if (values === undefined) return;
        for(var key in values){
            var newValue = values[key];
            if (newValue === undefined) {
                console.warn("THREE.Material: '" + key + "' parameter is undefined.");
                continue;
            }
            // for backward compatability if shading is set in the constructor
            if (key === "shading") {
                console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
                this.flatShading = newValue === FlatShading ? true : false;
                continue;
            }
            var currentValue = this[key];
            if (currentValue === undefined) {
                console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.");
                continue;
            }
            if (currentValue && currentValue.isColor) currentValue.set(newValue);
            else if (currentValue && currentValue.isVector3 && newValue && newValue.isVector3) currentValue.copy(newValue);
            else this[key] = newValue;
        }
    },
    toJSON: function(meta) {
        var isRoot = meta === undefined || typeof meta === "string";
        if (isRoot) meta = {
            textures: {},
            images: {}
        };
        var data = {
            metadata: {
                version: 4.5,
                type: "Material",
                generator: "Material.toJSON"
            }
        };
        // standard Material serialization
        data.uuid = this.uuid;
        data.type = this.type;
        if (this.name !== "") data.name = this.name;
        if (this.color && this.color.isColor) data.color = this.color.getHex();
        if (this.roughness !== undefined) data.roughness = this.roughness;
        if (this.metalness !== undefined) data.metalness = this.metalness;
        if (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();
        if (this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity;
        if (this.specular && this.specular.isColor) data.specular = this.specular.getHex();
        if (this.shininess !== undefined) data.shininess = this.shininess;
        if (this.clearCoat !== undefined) data.clearCoat = this.clearCoat;
        if (this.clearCoatRoughness !== undefined) data.clearCoatRoughness = this.clearCoatRoughness;
        if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;
        if (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;
        if (this.lightMap && this.lightMap.isTexture) data.lightMap = this.lightMap.toJSON(meta).uuid;
        if (this.aoMap && this.aoMap.isTexture) {
            data.aoMap = this.aoMap.toJSON(meta).uuid;
            data.aoMapIntensity = this.aoMapIntensity;
        }
        if (this.bumpMap && this.bumpMap.isTexture) {
            data.bumpMap = this.bumpMap.toJSON(meta).uuid;
            data.bumpScale = this.bumpScale;
        }
        if (this.normalMap && this.normalMap.isTexture) {
            data.normalMap = this.normalMap.toJSON(meta).uuid;
            data.normalMapType = this.normalMapType;
            data.normalScale = this.normalScale.toArray();
        }
        if (this.displacementMap && this.displacementMap.isTexture) {
            data.displacementMap = this.displacementMap.toJSON(meta).uuid;
            data.displacementScale = this.displacementScale;
            data.displacementBias = this.displacementBias;
        }
        if (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
        if (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
        if (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
        if (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;
        if (this.envMap && this.envMap.isTexture) {
            data.envMap = this.envMap.toJSON(meta).uuid;
            data.reflectivity = this.reflectivity; // Scale behind envMap
            if (this.combine !== undefined) data.combine = this.combine;
            if (this.envMapIntensity !== undefined) data.envMapIntensity = this.envMapIntensity;
        }
        if (this.gradientMap && this.gradientMap.isTexture) data.gradientMap = this.gradientMap.toJSON(meta).uuid;
        if (this.size !== undefined) data.size = this.size;
        if (this.sizeAttenuation !== undefined) data.sizeAttenuation = this.sizeAttenuation;
        if (this.blending !== NormalBlending) data.blending = this.blending;
        if (this.flatShading === true) data.flatShading = this.flatShading;
        if (this.side !== FrontSide) data.side = this.side;
        if (this.vertexColors !== NoColors) data.vertexColors = this.vertexColors;
        if (this.opacity < 1) data.opacity = this.opacity;
        if (this.transparent === true) data.transparent = this.transparent;
        data.depthFunc = this.depthFunc;
        data.depthTest = this.depthTest;
        data.depthWrite = this.depthWrite;
        // rotation (SpriteMaterial)
        if (this.rotation !== 0) data.rotation = this.rotation;
        if (this.polygonOffset === true) data.polygonOffset = true;
        if (this.polygonOffsetFactor !== 0) data.polygonOffsetFactor = this.polygonOffsetFactor;
        if (this.polygonOffsetUnits !== 0) data.polygonOffsetUnits = this.polygonOffsetUnits;
        if (this.linewidth !== 1) data.linewidth = this.linewidth;
        if (this.dashSize !== undefined) data.dashSize = this.dashSize;
        if (this.gapSize !== undefined) data.gapSize = this.gapSize;
        if (this.scale !== undefined) data.scale = this.scale;
        if (this.dithering === true) data.dithering = true;
        if (this.alphaTest > 0) data.alphaTest = this.alphaTest;
        if (this.premultipliedAlpha === true) data.premultipliedAlpha = this.premultipliedAlpha;
        if (this.wireframe === true) data.wireframe = this.wireframe;
        if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;
        if (this.wireframeLinecap !== "round") data.wireframeLinecap = this.wireframeLinecap;
        if (this.wireframeLinejoin !== "round") data.wireframeLinejoin = this.wireframeLinejoin;
        if (this.morphTargets === true) data.morphTargets = true;
        if (this.skinning === true) data.skinning = true;
        if (this.visible === false) data.visible = false;
        if (JSON.stringify(this.userData) !== "{}") data.userData = this.userData;
        // TODO: Copied from Object3D.toJSON
        function extractFromCache(cache) {
            var values = [];
            for(var key in cache){
                var data = cache[key];
                delete data.metadata;
                values.push(data);
            }
            return values;
        }
        if (isRoot) {
            var textures = extractFromCache(meta.textures);
            var images = extractFromCache(meta.images);
            if (textures.length > 0) data.textures = textures;
            if (images.length > 0) data.images = images;
        }
        return data;
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(source) {
        this.name = source.name;
        this.fog = source.fog;
        this.lights = source.lights;
        this.blending = source.blending;
        this.side = source.side;
        this.flatShading = source.flatShading;
        this.vertexColors = source.vertexColors;
        this.opacity = source.opacity;
        this.transparent = source.transparent;
        this.blendSrc = source.blendSrc;
        this.blendDst = source.blendDst;
        this.blendEquation = source.blendEquation;
        this.blendSrcAlpha = source.blendSrcAlpha;
        this.blendDstAlpha = source.blendDstAlpha;
        this.blendEquationAlpha = source.blendEquationAlpha;
        this.depthFunc = source.depthFunc;
        this.depthTest = source.depthTest;
        this.depthWrite = source.depthWrite;
        this.colorWrite = source.colorWrite;
        this.precision = source.precision;
        this.polygonOffset = source.polygonOffset;
        this.polygonOffsetFactor = source.polygonOffsetFactor;
        this.polygonOffsetUnits = source.polygonOffsetUnits;
        this.dithering = source.dithering;
        this.alphaTest = source.alphaTest;
        this.premultipliedAlpha = source.premultipliedAlpha;
        this.visible = source.visible;
        this.userData = JSON.parse(JSON.stringify(source.userData));
        this.clipShadows = source.clipShadows;
        this.clipIntersection = source.clipIntersection;
        var srcPlanes = source.clippingPlanes, dstPlanes = null;
        if (srcPlanes !== null) {
            var n = srcPlanes.length;
            dstPlanes = new Array(n);
            for(var i = 0; i !== n; ++i)dstPlanes[i] = srcPlanes[i].clone();
        }
        this.clippingPlanes = dstPlanes;
        this.shadowSide = source.shadowSide;
        return this;
    },
    dispose: function() {
        this.dispatchEvent({
            type: "dispose"
        });
    }
});
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  defines: { "label" : "value" },
 *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
 *
 *  fragmentShader: <string>,
 *  vertexShader: <string>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  lights: <bool>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */ function ShaderMaterial(parameters) {
    Material.call(this);
    this.type = "ShaderMaterial";
    this.defines = {};
    this.uniforms = {};
    this.vertexShader = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
    this.fragmentShader = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
    this.linewidth = 1;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false; // set to use scene fog
    this.lights = false; // set to use scene lights
    this.clipping = false; // set to use user-defined clipping planes
    this.skinning = false; // set to use skinning attribute streams
    this.morphTargets = false; // set to use morph targets
    this.morphNormals = false; // set to use morph normals
    this.extensions = {
        derivatives: false,
        fragDepth: false,
        drawBuffers: false,
        shaderTextureLOD: false // set to use shader texture LOD
    };
    // When rendered geometry doesn't include these attributes but the material does,
    // use these default values in WebGL. This avoids errors when buffer data is missing.
    this.defaultAttributeValues = {
        "color": [
            1,
            1,
            1
        ],
        "uv": [
            0,
            0
        ],
        "uv2": [
            0,
            0
        ]
    };
    this.index0AttributeName = undefined;
    this.uniformsNeedUpdate = false;
    if (parameters !== undefined) {
        if (parameters.attributes !== undefined) console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.");
        this.setValues(parameters);
    }
}
ShaderMaterial.prototype = Object.create(Material.prototype);
ShaderMaterial.prototype.constructor = ShaderMaterial;
ShaderMaterial.prototype.isShaderMaterial = true;
ShaderMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.fragmentShader = source.fragmentShader;
    this.vertexShader = source.vertexShader;
    this.uniforms = cloneUniforms(source.uniforms);
    this.defines = Object.assign({}, source.defines);
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.lights = source.lights;
    this.clipping = source.clipping;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    this.extensions = source.extensions;
    return this;
};
ShaderMaterial.prototype.toJSON = function(meta) {
    var data = Material.prototype.toJSON.call(this, meta);
    data.uniforms = {};
    for(var name in this.uniforms){
        var uniform = this.uniforms[name];
        var value = uniform.value;
        if (value && value.isTexture) data.uniforms[name] = {
            type: "t",
            value: value.toJSON(meta).uuid
        };
        else if (value && value.isColor) data.uniforms[name] = {
            type: "c",
            value: value.getHex()
        };
        else if (value && value.isVector2) data.uniforms[name] = {
            type: "v2",
            value: value.toArray()
        };
        else if (value && value.isVector3) data.uniforms[name] = {
            type: "v3",
            value: value.toArray()
        };
        else if (value && value.isVector4) data.uniforms[name] = {
            type: "v4",
            value: value.toArray()
        };
        else if (value && value.isMatrix4) data.uniforms[name] = {
            type: "m4",
            value: value.toArray()
        };
        else data.uniforms[name] = {
            value: value
        };
    }
    if (Object.keys(this.defines).length > 0) data.defines = this.defines;
    data.vertexShader = this.vertexShader;
    data.fragmentShader = this.fragmentShader;
    var extensions = {};
    for(var key in this.extensions)if (this.extensions[key] === true) extensions[key] = true;
    if (Object.keys(extensions).length > 0) data.extensions = extensions;
    return data;
};
/**
 * @author bhouston / http://clara.io
 */ function Ray(origin, direction) {
    this.origin = origin !== undefined ? origin : new Vector3();
    this.direction = direction !== undefined ? direction : new Vector3();
}
Object.assign(Ray.prototype, {
    set: function(origin, direction) {
        this.origin.copy(origin);
        this.direction.copy(direction);
        return this;
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(ray) {
        this.origin.copy(ray.origin);
        this.direction.copy(ray.direction);
        return this;
    },
    at: function(t, target) {
        if (target === undefined) {
            console.warn("THREE.Ray: .at() target is now required");
            target = new Vector3();
        }
        return target.copy(this.direction).multiplyScalar(t).add(this.origin);
    },
    lookAt: function(v) {
        this.direction.copy(v).sub(this.origin).normalize();
        return this;
    },
    recast: function() {
        var v1 = new Vector3();
        return function recast(t) {
            this.origin.copy(this.at(t, v1));
            return this;
        };
    }(),
    closestPointToPoint: function(point, target) {
        if (target === undefined) {
            console.warn("THREE.Ray: .closestPointToPoint() target is now required");
            target = new Vector3();
        }
        target.subVectors(point, this.origin);
        var directionDistance = target.dot(this.direction);
        if (directionDistance < 0) return target.copy(this.origin);
        return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
    },
    distanceToPoint: function(point) {
        return Math.sqrt(this.distanceSqToPoint(point));
    },
    distanceSqToPoint: function() {
        var v1 = new Vector3();
        return function distanceSqToPoint(point) {
            var directionDistance = v1.subVectors(point, this.origin).dot(this.direction);
            // point behind the ray
            if (directionDistance < 0) return this.origin.distanceToSquared(point);
            v1.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
            return v1.distanceToSquared(point);
        };
    }(),
    distanceSqToSegment: function() {
        var segCenter = new Vector3();
        var segDir = new Vector3();
        var diff = new Vector3();
        return function distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
            // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
            // It returns the min distance between the ray and the segment
            // defined by v0 and v1
            // It can also set two optional targets :
            // - The closest point on the ray
            // - The closest point on the segment
            segCenter.copy(v0).add(v1).multiplyScalar(0.5);
            segDir.copy(v1).sub(v0).normalize();
            diff.copy(this.origin).sub(segCenter);
            var segExtent = v0.distanceTo(v1) * 0.5;
            var a01 = -this.direction.dot(segDir);
            var b0 = diff.dot(this.direction);
            var b1 = -diff.dot(segDir);
            var c = diff.lengthSq();
            var det = Math.abs(1 - a01 * a01);
            var s0, s1, sqrDist, extDet;
            if (det > 0) {
                // The ray and segment are not parallel.
                s0 = a01 * b1 - b0;
                s1 = a01 * b0 - b1;
                extDet = segExtent * det;
                if (s0 >= 0) {
                    if (s1 >= -extDet) {
                        if (s1 <= extDet) {
                            // region 0
                            // Minimum at interior points of ray and segment.
                            var invDet = 1 / det;
                            s0 *= invDet;
                            s1 *= invDet;
                            sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
                        } else {
                            // region 1
                            s1 = segExtent;
                            s0 = Math.max(0, -(a01 * s1 + b0));
                            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                        }
                    } else {
                        // region 5
                        s1 = -segExtent;
                        s0 = Math.max(0, -(a01 * s1 + b0));
                        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                    }
                } else {
                    if (s1 <= -extDet) {
                        // region 4
                        s0 = Math.max(0, -(-a01 * segExtent + b0));
                        s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                    } else if (s1 <= extDet) {
                        // region 3
                        s0 = 0;
                        s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
                        sqrDist = s1 * (s1 + 2 * b1) + c;
                    } else {
                        // region 2
                        s0 = Math.max(0, -(a01 * segExtent + b0));
                        s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                    }
                }
            } else {
                // Ray and segment are parallel.
                s1 = a01 > 0 ? -segExtent : segExtent;
                s0 = Math.max(0, -(a01 * s1 + b0));
                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
            }
            if (optionalPointOnRay) optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
            if (optionalPointOnSegment) optionalPointOnSegment.copy(segDir).multiplyScalar(s1).add(segCenter);
            return sqrDist;
        };
    }(),
    intersectSphere: function() {
        var v1 = new Vector3();
        return function intersectSphere(sphere, target) {
            v1.subVectors(sphere.center, this.origin);
            var tca = v1.dot(this.direction);
            var d2 = v1.dot(v1) - tca * tca;
            var radius2 = sphere.radius * sphere.radius;
            if (d2 > radius2) return null;
            var thc = Math.sqrt(radius2 - d2);
            // t0 = first intersect point - entrance on front of sphere
            var t0 = tca - thc;
            // t1 = second intersect point - exit point on back of sphere
            var t1 = tca + thc;
            // test to see if both t0 and t1 are behind the ray - if so, return null
            if (t0 < 0 && t1 < 0) return null;
            // test to see if t0 is behind the ray:
            // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
            // in order to always return an intersect point that is in front of the ray.
            if (t0 < 0) return this.at(t1, target);
            // else t0 is in front of the ray, so return the first collision point scaled by t0
            return this.at(t0, target);
        };
    }(),
    intersectsSphere: function(sphere) {
        return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
    },
    distanceToPlane: function(plane) {
        var denominator = plane.normal.dot(this.direction);
        if (denominator === 0) {
            // line is coplanar, return origin
            if (plane.distanceToPoint(this.origin) === 0) return 0;
            // Null is preferable to undefined since undefined means.... it is undefined
            return null;
        }
        var t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
        // Return if the ray never intersects the plane
        return t >= 0 ? t : null;
    },
    intersectPlane: function(plane, target) {
        var t = this.distanceToPlane(plane);
        if (t === null) return null;
        return this.at(t, target);
    },
    intersectsPlane: function(plane) {
        // check if the ray lies on the plane first
        var distToPoint = plane.distanceToPoint(this.origin);
        if (distToPoint === 0) return true;
        var denominator = plane.normal.dot(this.direction);
        if (denominator * distToPoint < 0) return true;
        // ray origin is behind the plane (and is pointing behind it)
        return false;
    },
    intersectBox: function(box, target) {
        var tmin, tmax, tymin, tymax, tzmin, tzmax;
        var invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
        var origin = this.origin;
        if (invdirx >= 0) {
            tmin = (box.min.x - origin.x) * invdirx;
            tmax = (box.max.x - origin.x) * invdirx;
        } else {
            tmin = (box.max.x - origin.x) * invdirx;
            tmax = (box.min.x - origin.x) * invdirx;
        }
        if (invdiry >= 0) {
            tymin = (box.min.y - origin.y) * invdiry;
            tymax = (box.max.y - origin.y) * invdiry;
        } else {
            tymin = (box.max.y - origin.y) * invdiry;
            tymax = (box.min.y - origin.y) * invdiry;
        }
        if (tmin > tymax || tymin > tmax) return null;
        // These lines also handle the case where tmin or tmax is NaN
        // (result of 0 * Infinity). x !== x returns true if x is NaN
        if (tymin > tmin || tmin !== tmin) tmin = tymin;
        if (tymax < tmax || tmax !== tmax) tmax = tymax;
        if (invdirz >= 0) {
            tzmin = (box.min.z - origin.z) * invdirz;
            tzmax = (box.max.z - origin.z) * invdirz;
        } else {
            tzmin = (box.max.z - origin.z) * invdirz;
            tzmax = (box.min.z - origin.z) * invdirz;
        }
        if (tmin > tzmax || tzmin > tmax) return null;
        if (tzmin > tmin || tmin !== tmin) tmin = tzmin;
        if (tzmax < tmax || tmax !== tmax) tmax = tzmax;
        //return point closest to the ray (positive side)
        if (tmax < 0) return null;
        return this.at(tmin >= 0 ? tmin : tmax, target);
    },
    intersectsBox: function() {
        var v = new Vector3();
        return function intersectsBox(box) {
            return this.intersectBox(box, v) !== null;
        };
    }(),
    intersectTriangle: function() {
        // Compute the offset origin, edges, and normal.
        var diff = new Vector3();
        var edge1 = new Vector3();
        var edge2 = new Vector3();
        var normal = new Vector3();
        return function intersectTriangle(a, b, c, backfaceCulling, target) {
            // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h
            edge1.subVectors(b, a);
            edge2.subVectors(c, a);
            normal.crossVectors(edge1, edge2);
            // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
            // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
            //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
            //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
            //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
            var DdN = this.direction.dot(normal);
            var sign;
            if (DdN > 0) {
                if (backfaceCulling) return null;
                sign = 1;
            } else if (DdN < 0) {
                sign = -1;
                DdN = -DdN;
            } else return null;
            diff.subVectors(this.origin, a);
            var DdQxE2 = sign * this.direction.dot(edge2.crossVectors(diff, edge2));
            // b1 < 0, no intersection
            if (DdQxE2 < 0) return null;
            var DdE1xQ = sign * this.direction.dot(edge1.cross(diff));
            // b2 < 0, no intersection
            if (DdE1xQ < 0) return null;
            // b1+b2 > 1, no intersection
            if (DdQxE2 + DdE1xQ > DdN) return null;
            // Line intersects triangle, check if ray does.
            var QdN = -sign * diff.dot(normal);
            // t < 0, no intersection
            if (QdN < 0) return null;
            // Ray intersects triangle.
            return this.at(QdN / DdN, target);
        };
    }(),
    applyMatrix4: function(matrix4) {
        this.origin.applyMatrix4(matrix4);
        this.direction.transformDirection(matrix4);
        return this;
    },
    equals: function(ray) {
        return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
    }
});
/**
 * @author bhouston / http://clara.io
 * @author mrdoob / http://mrdoob.com/
 */ function Triangle(a, b, c) {
    this.a = a !== undefined ? a : new Vector3();
    this.b = b !== undefined ? b : new Vector3();
    this.c = c !== undefined ? c : new Vector3();
}
Object.assign(Triangle, {
    getNormal: function() {
        var v0 = new Vector3();
        return function getNormal(a, b, c, target) {
            if (target === undefined) {
                console.warn("THREE.Triangle: .getNormal() target is now required");
                target = new Vector3();
            }
            target.subVectors(c, b);
            v0.subVectors(a, b);
            target.cross(v0);
            var targetLengthSq = target.lengthSq();
            if (targetLengthSq > 0) return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
            return target.set(0, 0, 0);
        };
    }(),
    // static/instance method to calculate barycentric coordinates
    // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
    getBarycoord: function() {
        var v0 = new Vector3();
        var v1 = new Vector3();
        var v2 = new Vector3();
        return function getBarycoord(point, a, b, c, target) {
            v0.subVectors(c, a);
            v1.subVectors(b, a);
            v2.subVectors(point, a);
            var dot00 = v0.dot(v0);
            var dot01 = v0.dot(v1);
            var dot02 = v0.dot(v2);
            var dot11 = v1.dot(v1);
            var dot12 = v1.dot(v2);
            var denom = dot00 * dot11 - dot01 * dot01;
            if (target === undefined) {
                console.warn("THREE.Triangle: .getBarycoord() target is now required");
                target = new Vector3();
            }
            // collinear or singular triangle
            if (denom === 0) // arbitrary location outside of triangle?
            // not sure if this is the best idea, maybe should be returning undefined
            return target.set(-2, -1, -1);
            var invDenom = 1 / denom;
            var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
            var v = (dot00 * dot12 - dot01 * dot02) * invDenom;
            // barycentric coordinates must always sum to 1
            return target.set(1 - u - v, v, u);
        };
    }(),
    containsPoint: function() {
        var v1 = new Vector3();
        return function containsPoint(point, a, b, c) {
            Triangle.getBarycoord(point, a, b, c, v1);
            return v1.x >= 0 && v1.y >= 0 && v1.x + v1.y <= 1;
        };
    }(),
    getUV: function() {
        var barycoord = new Vector3();
        return function getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {
            this.getBarycoord(point, p1, p2, p3, barycoord);
            target.set(0, 0);
            target.addScaledVector(uv1, barycoord.x);
            target.addScaledVector(uv2, barycoord.y);
            target.addScaledVector(uv3, barycoord.z);
            return target;
        };
    }()
});
Object.assign(Triangle.prototype, {
    set: function(a, b, c) {
        this.a.copy(a);
        this.b.copy(b);
        this.c.copy(c);
        return this;
    },
    setFromPointsAndIndices: function(points, i0, i1, i2) {
        this.a.copy(points[i0]);
        this.b.copy(points[i1]);
        this.c.copy(points[i2]);
        return this;
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(triangle) {
        this.a.copy(triangle.a);
        this.b.copy(triangle.b);
        this.c.copy(triangle.c);
        return this;
    },
    getArea: function() {
        var v0 = new Vector3();
        var v1 = new Vector3();
        return function getArea() {
            v0.subVectors(this.c, this.b);
            v1.subVectors(this.a, this.b);
            return v0.cross(v1).length() * 0.5;
        };
    }(),
    getMidpoint: function(target) {
        if (target === undefined) {
            console.warn("THREE.Triangle: .getMidpoint() target is now required");
            target = new Vector3();
        }
        return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
    },
    getNormal: function(target) {
        return Triangle.getNormal(this.a, this.b, this.c, target);
    },
    getPlane: function(target) {
        if (target === undefined) {
            console.warn("THREE.Triangle: .getPlane() target is now required");
            target = new Vector3();
        }
        return target.setFromCoplanarPoints(this.a, this.b, this.c);
    },
    getBarycoord: function(point, target) {
        return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
    },
    containsPoint: function(point) {
        return Triangle.containsPoint(point, this.a, this.b, this.c);
    },
    getUV: function(point, uv1, uv2, uv3, result) {
        return Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, result);
    },
    intersectsBox: function(box) {
        return box.intersectsTriangle(this);
    },
    closestPointToPoint: function() {
        var vab = new Vector3();
        var vac = new Vector3();
        var vbc = new Vector3();
        var vap = new Vector3();
        var vbp = new Vector3();
        var vcp = new Vector3();
        return function closestPointToPoint(p, target) {
            if (target === undefined) {
                console.warn("THREE.Triangle: .closestPointToPoint() target is now required");
                target = new Vector3();
            }
            var a = this.a, b = this.b, c = this.c;
            var v, w;
            // algorithm thanks to Real-Time Collision Detection by Christer Ericson,
            // published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
            // under the accompanying license; see chapter 5.1.5 for detailed explanation.
            // basically, we're distinguishing which of the voronoi regions of the triangle
            // the point lies in with the minimum amount of redundant computation.
            vab.subVectors(b, a);
            vac.subVectors(c, a);
            vap.subVectors(p, a);
            var d1 = vab.dot(vap);
            var d2 = vac.dot(vap);
            if (d1 <= 0 && d2 <= 0) // vertex region of A; barycentric coords (1, 0, 0)
            return target.copy(a);
            vbp.subVectors(p, b);
            var d3 = vab.dot(vbp);
            var d4 = vac.dot(vbp);
            if (d3 >= 0 && d4 <= d3) // vertex region of B; barycentric coords (0, 1, 0)
            return target.copy(b);
            var vc = d1 * d4 - d3 * d2;
            if (vc <= 0 && d1 >= 0 && d3 <= 0) {
                v = d1 / (d1 - d3);
                // edge region of AB; barycentric coords (1-v, v, 0)
                return target.copy(a).addScaledVector(vab, v);
            }
            vcp.subVectors(p, c);
            var d5 = vab.dot(vcp);
            var d6 = vac.dot(vcp);
            if (d6 >= 0 && d5 <= d6) // vertex region of C; barycentric coords (0, 0, 1)
            return target.copy(c);
            var vb = d5 * d2 - d1 * d6;
            if (vb <= 0 && d2 >= 0 && d6 <= 0) {
                w = d2 / (d2 - d6);
                // edge region of AC; barycentric coords (1-w, 0, w)
                return target.copy(a).addScaledVector(vac, w);
            }
            var va = d3 * d6 - d5 * d4;
            if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
                vbc.subVectors(c, b);
                w = (d4 - d3) / (d4 - d3 + (d5 - d6));
                // edge region of BC; barycentric coords (0, 1-w, w)
                return target.copy(b).addScaledVector(vbc, w); // edge region of BC
            }
            // face region
            var denom = 1 / (va + vb + vc);
            // u = va * denom
            v = vb * denom;
            w = vc * denom;
            return target.copy(a).addScaledVector(vab, v).addScaledVector(vac, w);
        };
    }(),
    equals: function(triangle) {
        return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
    }
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>
 * }
 */ function MeshBasicMaterial(parameters) {
    Material.call(this);
    this.type = "MeshBasicMaterial";
    this.color = new Color(0xffffff); // emissive
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1.0;
    this.aoMap = null;
    this.aoMapIntensity = 1.0;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.skinning = false;
    this.morphTargets = false;
    this.lights = false;
    this.setValues(parameters);
}
MeshBasicMaterial.prototype = Object.create(Material.prototype);
MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;
MeshBasicMaterial.prototype.isMeshBasicMaterial = true;
MeshBasicMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    return this;
};
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author jonobr1 / http://jonobr1.com/
 */ function Mesh(geometry, material) {
    Object3D.call(this);
    this.type = "Mesh";
    this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
    this.material = material !== undefined ? material : new MeshBasicMaterial({
        color: Math.random() * 0xffffff
    });
    this.drawMode = TrianglesDrawMode;
    this.updateMorphTargets();
}
Mesh.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Mesh,
    isMesh: true,
    setDrawMode: function(value) {
        this.drawMode = value;
    },
    copy: function(source) {
        Object3D.prototype.copy.call(this, source);
        this.drawMode = source.drawMode;
        if (source.morphTargetInfluences !== undefined) this.morphTargetInfluences = source.morphTargetInfluences.slice();
        if (source.morphTargetDictionary !== undefined) this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
        return this;
    },
    updateMorphTargets: function() {
        var geometry = this.geometry;
        var m, ml, name;
        if (geometry.isBufferGeometry) {
            var morphAttributes = geometry.morphAttributes;
            var keys = Object.keys(morphAttributes);
            if (keys.length > 0) {
                var morphAttribute = morphAttributes[keys[0]];
                if (morphAttribute !== undefined) {
                    this.morphTargetInfluences = [];
                    this.morphTargetDictionary = {};
                    for(m = 0, ml = morphAttribute.length; m < ml; m++){
                        name = morphAttribute[m].name || String(m);
                        this.morphTargetInfluences.push(0);
                        this.morphTargetDictionary[name] = m;
                    }
                }
            }
        } else {
            var morphTargets = geometry.morphTargets;
            if (morphTargets !== undefined && morphTargets.length > 0) console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
        }
    },
    raycast: function() {
        var inverseMatrix = new Matrix4();
        var ray = new Ray();
        var sphere = new Sphere();
        var vA = new Vector3();
        var vB = new Vector3();
        var vC = new Vector3();
        var tempA = new Vector3();
        var tempB = new Vector3();
        var tempC = new Vector3();
        var uvA = new Vector2();
        var uvB = new Vector2();
        var uvC = new Vector2();
        var intersectionPoint = new Vector3();
        var intersectionPointWorld = new Vector3();
        function checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {
            var intersect;
            if (material.side === BackSide) intersect = ray.intersectTriangle(pC, pB, pA, true, point);
            else intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);
            if (intersect === null) return null;
            intersectionPointWorld.copy(point);
            intersectionPointWorld.applyMatrix4(object.matrixWorld);
            var distance = raycaster.ray.origin.distanceTo(intersectionPointWorld);
            if (distance < raycaster.near || distance > raycaster.far) return null;
            return {
                distance: distance,
                point: intersectionPointWorld.clone(),
                object: object
            };
        }
        function checkBufferGeometryIntersection(object, material, raycaster, ray, position, uv, a, b, c) {
            vA.fromBufferAttribute(position, a);
            vB.fromBufferAttribute(position, b);
            vC.fromBufferAttribute(position, c);
            var intersection = checkIntersection(object, material, raycaster, ray, vA, vB, vC, intersectionPoint);
            if (intersection) {
                if (uv) {
                    uvA.fromBufferAttribute(uv, a);
                    uvB.fromBufferAttribute(uv, b);
                    uvC.fromBufferAttribute(uv, c);
                    intersection.uv = Triangle.getUV(intersectionPoint, vA, vB, vC, uvA, uvB, uvC, new Vector2());
                }
                var face = new Face3(a, b, c);
                Triangle.getNormal(vA, vB, vC, face.normal);
                intersection.face = face;
            }
            return intersection;
        }
        return function raycast(raycaster, intersects) {
            var geometry = this.geometry;
            var material = this.material;
            var matrixWorld = this.matrixWorld;
            if (material === undefined) return;
            // Checking boundingSphere distance to ray
            if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
            sphere.copy(geometry.boundingSphere);
            sphere.applyMatrix4(matrixWorld);
            if (raycaster.ray.intersectsSphere(sphere) === false) return;
            //
            inverseMatrix.getInverse(matrixWorld);
            ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
            // Check boundingBox before continuing
            if (geometry.boundingBox !== null) {
                if (ray.intersectsBox(geometry.boundingBox) === false) return;
            }
            var intersection;
            if (geometry.isBufferGeometry) {
                var a, b, c;
                var index = geometry.index;
                var position = geometry.attributes.position;
                var uv = geometry.attributes.uv;
                var groups = geometry.groups;
                var drawRange = geometry.drawRange;
                var i, j, il, jl;
                var group, groupMaterial;
                var start, end;
                if (index !== null) {
                    // indexed buffer geometry
                    if (Array.isArray(material)) for(i = 0, il = groups.length; i < il; i++){
                        group = groups[i];
                        groupMaterial = material[group.materialIndex];
                        start = Math.max(group.start, drawRange.start);
                        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);
                        for(j = start, jl = end; j < jl; j += 3){
                            a = index.getX(j);
                            b = index.getX(j + 1);
                            c = index.getX(j + 2);
                            intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, ray, position, uv, a, b, c);
                            if (intersection) {
                                intersection.faceIndex = Math.floor(j / 3); // triangle number in indexed buffer semantics
                                intersects.push(intersection);
                            }
                        }
                    }
                    else {
                        start = Math.max(0, drawRange.start);
                        end = Math.min(index.count, drawRange.start + drawRange.count);
                        for(i = start, il = end; i < il; i += 3){
                            a = index.getX(i);
                            b = index.getX(i + 1);
                            c = index.getX(i + 2);
                            intersection = checkBufferGeometryIntersection(this, material, raycaster, ray, position, uv, a, b, c);
                            if (intersection) {
                                intersection.faceIndex = Math.floor(i / 3); // triangle number in indexed buffer semantics
                                intersects.push(intersection);
                            }
                        }
                    }
                } else if (position !== undefined) {
                    // non-indexed buffer geometry
                    if (Array.isArray(material)) for(i = 0, il = groups.length; i < il; i++){
                        group = groups[i];
                        groupMaterial = material[group.materialIndex];
                        start = Math.max(group.start, drawRange.start);
                        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);
                        for(j = start, jl = end; j < jl; j += 3){
                            a = j;
                            b = j + 1;
                            c = j + 2;
                            intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, ray, position, uv, a, b, c);
                            if (intersection) {
                                intersection.faceIndex = Math.floor(j / 3); // triangle number in non-indexed buffer semantics
                                intersects.push(intersection);
                            }
                        }
                    }
                    else {
                        start = Math.max(0, drawRange.start);
                        end = Math.min(position.count, drawRange.start + drawRange.count);
                        for(i = start, il = end; i < il; i += 3){
                            a = i;
                            b = i + 1;
                            c = i + 2;
                            intersection = checkBufferGeometryIntersection(this, material, raycaster, ray, position, uv, a, b, c);
                            if (intersection) {
                                intersection.faceIndex = Math.floor(i / 3); // triangle number in non-indexed buffer semantics
                                intersects.push(intersection);
                            }
                        }
                    }
                }
            } else if (geometry.isGeometry) {
                var fvA, fvB, fvC;
                var isMultiMaterial = Array.isArray(material);
                var vertices = geometry.vertices;
                var faces = geometry.faces;
                var uvs;
                var faceVertexUvs = geometry.faceVertexUvs[0];
                if (faceVertexUvs.length > 0) uvs = faceVertexUvs;
                for(var f = 0, fl = faces.length; f < fl; f++){
                    var face = faces[f];
                    var faceMaterial = isMultiMaterial ? material[face.materialIndex] : material;
                    if (faceMaterial === undefined) continue;
                    fvA = vertices[face.a];
                    fvB = vertices[face.b];
                    fvC = vertices[face.c];
                    if (faceMaterial.morphTargets === true) {
                        var morphTargets = geometry.morphTargets;
                        var morphInfluences = this.morphTargetInfluences;
                        vA.set(0, 0, 0);
                        vB.set(0, 0, 0);
                        vC.set(0, 0, 0);
                        for(var t = 0, tl = morphTargets.length; t < tl; t++){
                            var influence = morphInfluences[t];
                            if (influence === 0) continue;
                            var targets = morphTargets[t].vertices;
                            vA.addScaledVector(tempA.subVectors(targets[face.a], fvA), influence);
                            vB.addScaledVector(tempB.subVectors(targets[face.b], fvB), influence);
                            vC.addScaledVector(tempC.subVectors(targets[face.c], fvC), influence);
                        }
                        vA.add(fvA);
                        vB.add(fvB);
                        vC.add(fvC);
                        fvA = vA;
                        fvB = vB;
                        fvC = vC;
                    }
                    intersection = checkIntersection(this, faceMaterial, raycaster, ray, fvA, fvB, fvC, intersectionPoint);
                    if (intersection) {
                        if (uvs && uvs[f]) {
                            var uvs_f = uvs[f];
                            uvA.copy(uvs_f[0]);
                            uvB.copy(uvs_f[1]);
                            uvC.copy(uvs_f[2]);
                            intersection.uv = Triangle.getUV(intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC, new Vector2());
                        }
                        intersection.face = face;
                        intersection.faceIndex = f;
                        intersects.push(intersection);
                    }
                }
            }
        };
    }(),
    clone: function() {
        return new this.constructor(this.geometry, this.material).copy(this);
    }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */ function WebGLBackground(renderer, state, objects, premultipliedAlpha) {
    var clearColor = new Color(0x000000);
    var clearAlpha = 0;
    var planeMesh;
    var boxMesh;
    // Store the current background texture and its `version`
    // so we can recompile the material accordingly.
    var currentBackground = null;
    var currentBackgroundVersion = 0;
    function render(renderList, scene, camera, forceClear) {
        var background = scene.background;
        if (background === null) {
            setClear(clearColor, clearAlpha);
            currentBackground = null;
            currentBackgroundVersion = 0;
        } else if (background && background.isColor) {
            setClear(background, 1);
            forceClear = true;
            currentBackground = null;
            currentBackgroundVersion = 0;
        }
        if (renderer.autoClear || forceClear) renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
        if (background && (background.isCubeTexture || background.isWebGLRenderTargetCube)) {
            if (boxMesh === undefined) {
                boxMesh = new Mesh(new BoxBufferGeometry(1, 1, 1), new ShaderMaterial({
                    type: "BackgroundCubeMaterial",
                    uniforms: cloneUniforms(ShaderLib.cube.uniforms),
                    vertexShader: ShaderLib.cube.vertexShader,
                    fragmentShader: ShaderLib.cube.fragmentShader,
                    side: BackSide,
                    depthTest: true,
                    depthWrite: false,
                    fog: false
                }));
                boxMesh.geometry.removeAttribute("normal");
                boxMesh.geometry.removeAttribute("uv");
                boxMesh.onBeforeRender = function(renderer, scene, camera) {
                    this.matrixWorld.copyPosition(camera.matrixWorld);
                };
                // enable code injection for non-built-in material
                Object.defineProperty(boxMesh.material, "map", {
                    get: function() {
                        return this.uniforms.tCube.value;
                    }
                });
                objects.update(boxMesh);
            }
            var texture = background.isWebGLRenderTargetCube ? background.texture : background;
            boxMesh.material.uniforms.tCube.value = texture;
            boxMesh.material.uniforms.tFlip.value = background.isWebGLRenderTargetCube ? 1 : -1;
            if (currentBackground !== background || currentBackgroundVersion !== texture.version) {
                boxMesh.material.needsUpdate = true;
                currentBackground = background;
                currentBackgroundVersion = texture.version;
            }
            // push to the pre-sorted opaque render list
            renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, null);
        } else if (background && background.isTexture) {
            if (planeMesh === undefined) {
                planeMesh = new Mesh(new PlaneBufferGeometry(2, 2), new ShaderMaterial({
                    type: "BackgroundMaterial",
                    uniforms: cloneUniforms(ShaderLib.background.uniforms),
                    vertexShader: ShaderLib.background.vertexShader,
                    fragmentShader: ShaderLib.background.fragmentShader,
                    side: FrontSide,
                    depthTest: false,
                    depthWrite: false,
                    fog: false
                }));
                planeMesh.geometry.removeAttribute("normal");
                // enable code injection for non-built-in material
                Object.defineProperty(planeMesh.material, "map", {
                    get: function() {
                        return this.uniforms.t2D.value;
                    }
                });
                objects.update(planeMesh);
            }
            planeMesh.material.uniforms.t2D.value = background;
            if (background.matrixAutoUpdate === true) background.updateMatrix();
            planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);
            if (currentBackground !== background || currentBackgroundVersion !== background.version) {
                planeMesh.material.needsUpdate = true;
                currentBackground = background;
                currentBackgroundVersion = background.version;
            }
            // push to the pre-sorted opaque render list
            renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, null);
        }
    }
    function setClear(color, alpha) {
        state.buffers.color.setClear(color.r, color.g, color.b, alpha, premultipliedAlpha);
    }
    return {
        getClearColor: function() {
            return clearColor;
        },
        setClearColor: function(color, alpha) {
            clearColor.set(color);
            clearAlpha = alpha !== undefined ? alpha : 1;
            setClear(clearColor, clearAlpha);
        },
        getClearAlpha: function() {
            return clearAlpha;
        },
        setClearAlpha: function(alpha) {
            clearAlpha = alpha;
            setClear(clearColor, clearAlpha);
        },
        render: render
    };
}
/**
 * @author mrdoob / http://mrdoob.com/
 */ function WebGLBufferRenderer(gl, extensions, info, capabilities) {
    var mode;
    function setMode(value) {
        mode = value;
    }
    function render(start, count) {
        gl.drawArrays(mode, start, count);
        info.update(count, mode);
    }
    function renderInstances(geometry, start, count) {
        var extension;
        if (capabilities.isWebGL2) extension = gl;
        else {
            extension = extensions.get("ANGLE_instanced_arrays");
            if (extension === null) {
                console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                return;
            }
        }
        extension[capabilities.isWebGL2 ? "drawArraysInstanced" : "drawArraysInstancedANGLE"](mode, start, count, geometry.maxInstancedCount);
        info.update(count, mode, geometry.maxInstancedCount);
    }
    //
    this.setMode = setMode;
    this.render = render;
    this.renderInstances = renderInstances;
}
/**
 * @author mrdoob / http://mrdoob.com/
 */ function WebGLCapabilities(gl, extensions, parameters) {
    var maxAnisotropy;
    function getMaxAnisotropy() {
        if (maxAnisotropy !== undefined) return maxAnisotropy;
        var extension = extensions.get("EXT_texture_filter_anisotropic");
        if (extension !== null) maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
        else maxAnisotropy = 0;
        return maxAnisotropy;
    }
    function getMaxPrecision(precision) {
        if (precision === "highp") {
            if (gl.getShaderPrecisionFormat(35633, 36338).precision > 0 && gl.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
            precision = "mediump";
        }
        if (precision === "mediump") {
            if (gl.getShaderPrecisionFormat(35633, 36337).precision > 0 && gl.getShaderPrecisionFormat(35632, 36337).precision > 0) return "mediump";
        }
        return "lowp";
    }
    var isWebGL2 = typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext;
    var precision = parameters.precision !== undefined ? parameters.precision : "highp";
    var maxPrecision = getMaxPrecision(precision);
    if (maxPrecision !== precision) {
        console.warn("THREE.WebGLRenderer:", precision, "not supported, using", maxPrecision, "instead.");
        precision = maxPrecision;
    }
    var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
    var maxTextures = gl.getParameter(34930);
    var maxVertexTextures = gl.getParameter(35660);
    var maxTextureSize = gl.getParameter(3379);
    var maxCubemapSize = gl.getParameter(34076);
    var maxAttributes = gl.getParameter(34921);
    var maxVertexUniforms = gl.getParameter(36347);
    var maxVaryings = gl.getParameter(36348);
    var maxFragmentUniforms = gl.getParameter(36349);
    var vertexTextures = maxVertexTextures > 0;
    var floatFragmentTextures = isWebGL2 || !!extensions.get("OES_texture_float");
    var floatVertexTextures = vertexTextures && floatFragmentTextures;
    return {
        isWebGL2: isWebGL2,
        getMaxAnisotropy: getMaxAnisotropy,
        getMaxPrecision: getMaxPrecision,
        precision: precision,
        logarithmicDepthBuffer: logarithmicDepthBuffer,
        maxTextures: maxTextures,
        maxVertexTextures: maxVertexTextures,
        maxTextureSize: maxTextureSize,
        maxCubemapSize: maxCubemapSize,
        maxAttributes: maxAttributes,
        maxVertexUniforms: maxVertexUniforms,
        maxVaryings: maxVaryings,
        maxFragmentUniforms: maxFragmentUniforms,
        vertexTextures: vertexTextures,
        floatFragmentTextures: floatFragmentTextures,
        floatVertexTextures: floatVertexTextures
    };
}
/**
 * @author tschw
 */ function WebGLClipping() {
    var scope = this, globalState = null, numGlobalPlanes = 0, localClippingEnabled = false, renderingShadows = false, plane = new Plane(), viewNormalMatrix = new Matrix3(), uniform = {
        value: null,
        needsUpdate: false
    };
    this.uniform = uniform;
    this.numPlanes = 0;
    this.numIntersection = 0;
    this.init = function(planes, enableLocalClipping, camera) {
        var enabled = planes.length !== 0 || enableLocalClipping || // enable state of previous frame - the clipping code has to
        // run another frame in order to reset the state:
        numGlobalPlanes !== 0 || localClippingEnabled;
        localClippingEnabled = enableLocalClipping;
        globalState = projectPlanes(planes, camera, 0);
        numGlobalPlanes = planes.length;
        return enabled;
    };
    this.beginShadows = function() {
        renderingShadows = true;
        projectPlanes(null);
    };
    this.endShadows = function() {
        renderingShadows = false;
        resetGlobalState();
    };
    this.setState = function(planes, clipIntersection, clipShadows, camera, cache, fromCache) {
        if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
            // there's no local clipping
            if (renderingShadows) // there's no global clipping
            projectPlanes(null);
            else resetGlobalState();
        } else {
            var nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4, dstArray = cache.clippingState || null;
            uniform.value = dstArray; // ensure unique state
            dstArray = projectPlanes(planes, camera, lGlobal, fromCache);
            for(var i = 0; i !== lGlobal; ++i)dstArray[i] = globalState[i];
            cache.clippingState = dstArray;
            this.numIntersection = clipIntersection ? this.numPlanes : 0;
            this.numPlanes += nGlobal;
        }
    };
    function resetGlobalState() {
        if (uniform.value !== globalState) {
            uniform.value = globalState;
            uniform.needsUpdate = numGlobalPlanes > 0;
        }
        scope.numPlanes = numGlobalPlanes;
        scope.numIntersection = 0;
    }
    function projectPlanes(planes, camera, dstOffset, skipTransform) {
        var nPlanes = planes !== null ? planes.length : 0, dstArray = null;
        if (nPlanes !== 0) {
            dstArray = uniform.value;
            if (skipTransform !== true || dstArray === null) {
                var flatSize = dstOffset + nPlanes * 4, viewMatrix = camera.matrixWorldInverse;
                viewNormalMatrix.getNormalMatrix(viewMatrix);
                if (dstArray === null || dstArray.length < flatSize) dstArray = new Float32Array(flatSize);
                for(var i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4){
                    plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);
                    plane.normal.toArray(dstArray, i4);
                    dstArray[i4 + 3] = plane.constant;
                }
            }
            uniform.value = dstArray;
            uniform.needsUpdate = true;
        }
        scope.numPlanes = nPlanes;
        return dstArray;
    }
}
/**
 * @author mrdoob / http://mrdoob.com/
 */ function WebGLExtensions(gl) {
    var extensions = {};
    return {
        get: function(name) {
            if (extensions[name] !== undefined) return extensions[name];
            var extension;
            switch(name){
                case "WEBGL_depth_texture":
                    extension = gl.getExtension("WEBGL_depth_texture") || gl.getExtension("MOZ_WEBGL_depth_texture") || gl.getExtension("WEBKIT_WEBGL_depth_texture");
                    break;
                case "EXT_texture_filter_anisotropic":
                    extension = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("MOZ_EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                    break;
                case "WEBGL_compressed_texture_s3tc":
                    extension = gl.getExtension("WEBGL_compressed_texture_s3tc") || gl.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                    break;
                case "WEBGL_compressed_texture_pvrtc":
                    extension = gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                    break;
                default:
                    extension = gl.getExtension(name);
            }
            if (extension === null) console.warn("THREE.WebGLRenderer: " + name + " extension not supported.");
            extensions[name] = extension;
            return extension;
        }
    };
}
/**
 * @author mrdoob / http://mrdoob.com/
 */ function WebGLGeometries(gl, attributes, info) {
    var geometries = {};
    var wireframeAttributes = {};
    function onGeometryDispose(event) {
        var geometry = event.target;
        var buffergeometry = geometries[geometry.id];
        if (buffergeometry.index !== null) attributes.remove(buffergeometry.index);
        for(var name in buffergeometry.attributes)attributes.remove(buffergeometry.attributes[name]);
        geometry.removeEventListener("dispose", onGeometryDispose);
        delete geometries[geometry.id];
        var attribute = wireframeAttributes[buffergeometry.id];
        if (attribute) {
            attributes.remove(attribute);
            delete wireframeAttributes[buffergeometry.id];
        }
        //
        info.memory.geometries--;
    }
    function get(object, geometry) {
        var buffergeometry = geometries[geometry.id];
        if (buffergeometry) return buffergeometry;
        geometry.addEventListener("dispose", onGeometryDispose);
        if (geometry.isBufferGeometry) buffergeometry = geometry;
        else if (geometry.isGeometry) {
            if (geometry._bufferGeometry === undefined) geometry._bufferGeometry = new BufferGeometry().setFromObject(object);
            buffergeometry = geometry._bufferGeometry;
        }
        geometries[geometry.id] = buffergeometry;
        info.memory.geometries++;
        return buffergeometry;
    }
    function update(geometry) {
        var index = geometry.index;
        var geometryAttributes = geometry.attributes;
        if (index !== null) attributes.update(index, 34963);
        for(var name in geometryAttributes)attributes.update(geometryAttributes[name], 34962);
        // morph targets
        var morphAttributes = geometry.morphAttributes;
        for(var name in morphAttributes){
            var array = morphAttributes[name];
            for(var i = 0, l = array.length; i < l; i++)attributes.update(array[i], 34962);
        }
    }
    function getWireframeAttribute(geometry) {
        var attribute = wireframeAttributes[geometry.id];
        if (attribute) return attribute;
        var indices = [];
        var geometryIndex = geometry.index;
        var geometryAttributes = geometry.attributes;
        // console.time( 'wireframe' );
        if (geometryIndex !== null) {
            var array = geometryIndex.array;
            for(var i = 0, l = array.length; i < l; i += 3){
                var a = array[i + 0];
                var b = array[i + 1];
                var c = array[i + 2];
                indices.push(a, b, b, c, c, a);
            }
        } else {
            var array = geometryAttributes.position.array;
            for(var i = 0, l = array.length / 3 - 1; i < l; i += 3){
                var a = i + 0;
                var b = i + 1;
                var c = i + 2;
                indices.push(a, b, b, c, c, a);
            }
        }
        // console.timeEnd( 'wireframe' );
        attribute = new (arrayMax(indices) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
        attributes.update(attribute, 34963);
        wireframeAttributes[geometry.id] = attribute;
        return attribute;
    }
    return {
        get: get,
        update: update,
        getWireframeAttribute: getWireframeAttribute
    };
}
/**
 * @author mrdoob / http://mrdoob.com/
 */ function WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {
    var mode;
    function setMode(value) {
        mode = value;
    }
    var type, bytesPerElement;
    function setIndex(value) {
        type = value.type;
        bytesPerElement = value.bytesPerElement;
    }
    function render(start, count) {
        gl.drawElements(mode, count, type, start * bytesPerElement);
        info.update(count, mode);
    }
    function renderInstances(geometry, start, count) {
        var extension;
        if (capabilities.isWebGL2) extension = gl;
        else {
            var extension = extensions.get("ANGLE_instanced_arrays");
            if (extension === null) {
                console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                return;
            }
        }
        extension[capabilities.isWebGL2 ? "drawElementsInstanced" : "drawElementsInstancedANGLE"](mode, count, type, start * bytesPerElement, geometry.maxInstancedCount);
        info.update(count, mode, geometry.maxInstancedCount);
    }
    //
    this.setMode = setMode;
    this.setIndex = setIndex;
    this.render = render;
    this.renderInstances = renderInstances;
}
/**
 * @author Mugen87 / https://github.com/Mugen87
 */ function WebGLInfo(gl) {
    var memory = {
        geometries: 0,
        textures: 0
    };
    var render = {
        frame: 0,
        calls: 0,
        triangles: 0,
        points: 0,
        lines: 0
    };
    function update(count, mode, instanceCount) {
        instanceCount = instanceCount || 1;
        render.calls++;
        switch(mode){
            case 4:
                render.triangles += instanceCount * (count / 3);
                break;
            case 5:
            case 6:
                render.triangles += instanceCount * (count - 2);
                break;
            case 1:
                render.lines += instanceCount * (count / 2);
                break;
            case 3:
                render.lines += instanceCount * (count - 1);
                break;
            case 2:
                render.lines += instanceCount * count;
                break;
            case 0:
                render.points += instanceCount * count;
                break;
            default:
                console.error("THREE.WebGLInfo: Unknown draw mode:", mode);
                break;
        }
    }
    function reset() {
        render.frame++;
        render.calls = 0;
        render.triangles = 0;
        render.points = 0;
        render.lines = 0;
    }
    return {
        memory: memory,
        render: render,
        programs: null,
        autoReset: true,
        reset: reset,
        update: update
    };
}
/**
 * @author mrdoob / http://mrdoob.com/
 */ function absNumericalSort(a, b) {
    return Math.abs(b[1]) - Math.abs(a[1]);
}
function WebGLMorphtargets(gl) {
    var influencesList = {};
    var morphInfluences = new Float32Array(8);
    function update(object, geometry, material, program) {
        var objectInfluences = object.morphTargetInfluences;
        var length = objectInfluences.length;
        var influences = influencesList[geometry.id];
        if (influences === undefined) {
            // initialise list
            influences = [];
            for(var i = 0; i < length; i++)influences[i] = [
                i,
                0
            ];
            influencesList[geometry.id] = influences;
        }
        var morphTargets = material.morphTargets && geometry.morphAttributes.position;
        var morphNormals = material.morphNormals && geometry.morphAttributes.normal;
        // Remove current morphAttributes
        for(var i = 0; i < length; i++){
            var influence = influences[i];
            if (influence[1] !== 0) {
                if (morphTargets) geometry.removeAttribute("morphTarget" + i);
                if (morphNormals) geometry.removeAttribute("morphNormal" + i);
            }
        }
        // Collect influences
        for(var i = 0; i < length; i++){
            var influence = influences[i];
            influence[0] = i;
            influence[1] = objectInfluences[i];
        }
        influences.sort(absNumericalSort);
        // Add morphAttributes
        for(var i = 0; i < 8; i++){
            var influence = influences[i];
            if (influence) {
                var index = influence[0];
                var value = influence[1];
                if (value) {
                    if (morphTargets) geometry.addAttribute("morphTarget" + i, morphTargets[index]);
                    if (morphNormals) geometry.addAttribute("morphNormal" + i, morphNormals[index]);
                    morphInfluences[i] = value;
                    continue;
                }
            }
            morphInfluences[i] = 0;
        }
        program.getUniforms().setValue(gl, "morphTargetInfluences", morphInfluences);
    }
    return {
        update: update
    };
}
/**
 * @author mrdoob / http://mrdoob.com/
 */ function WebGLObjects(geometries, info) {
    var updateList = {};
    function update(object) {
        var frame = info.render.frame;
        var geometry = object.geometry;
        var buffergeometry = geometries.get(object, geometry);
        // Update once per frame
        if (updateList[buffergeometry.id] !== frame) {
            if (geometry.isGeometry) buffergeometry.updateFromObject(object);
            geometries.update(buffergeometry);
            updateList[buffergeometry.id] = frame;
        }
        return buffergeometry;
    }
    function dispose() {
        updateList = {};
    }
    return {
        update: update,
        dispose: dispose
    };
}
/**
 * @author mrdoob / http://mrdoob.com/
 */ function CubeTexture(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
    images = images !== undefined ? images : [];
    mapping = mapping !== undefined ? mapping : CubeReflectionMapping;
    Texture.call(this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
    this.flipY = false;
}
CubeTexture.prototype = Object.create(Texture.prototype);
CubeTexture.prototype.constructor = CubeTexture;
CubeTexture.prototype.isCubeTexture = true;
Object.defineProperty(CubeTexture.prototype, "images", {
    get: function() {
        return this.image;
    },
    set: function(value) {
        this.image = value;
    }
});
/**
 * @author Artur Trzesiok
 */ function DataTexture3D(data, width, height, depth) {
    // We're going to add .setXXX() methods for setting properties later.
    // Users can still set in DataTexture3D directly.
    //
    //	var texture = new THREE.DataTexture3D( data, width, height, depth );
    // 	texture.anisotropy = 16;
    //
    // See #14839
    Texture.call(this, null);
    this.image = {
        data: data,
        width: width,
        height: height,
        depth: depth
    };
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.generateMipmaps = false;
    this.flipY = false;
}
DataTexture3D.prototype = Object.create(Texture.prototype);
DataTexture3D.prototype.constructor = DataTexture3D;
DataTexture3D.prototype.isDataTexture3D = true;
/**
 * @author tschw
 * @author Mugen87 / https://github.com/Mugen87
 * @author mrdoob / http://mrdoob.com/
 *
 * Uniforms of a program.
 * Those form a tree structure with a special top-level container for the root,
 * which you get by calling 'new WebGLUniforms( gl, program, renderer )'.
 *
 *
 * Properties of inner nodes including the top-level container:
 *
 * .seq - array of nested uniforms
 * .map - nested uniforms by name
 *
 *
 * Methods of all nodes except the top-level container:
 *
 * .setValue( gl, value, [renderer] )
 *
 * 		uploads a uniform value(s)
 *  	the 'renderer' parameter is needed for sampler uniforms
 *
 *
 * Static methods of the top-level container (renderer factorizations):
 *
 * .upload( gl, seq, values, renderer )
 *
 * 		sets uniforms in 'seq' to 'values[id].value'
 *
 * .seqWithValue( seq, values ) : filteredSeq
 *
 * 		filters 'seq' entries with corresponding entry in values
 *
 *
 * Methods of the top-level container (renderer factorizations):
 *
 * .setValue( gl, name, value )
 *
 * 		sets uniform with  name 'name' to 'value'
 *
 * .set( gl, obj, prop )
 *
 * 		sets uniform from object and property with same name than uniform
 *
 * .setOptional( gl, obj, prop )
 *
 * 		like .set for an optional property of the object
 *
 */ var emptyTexture = new Texture();
var emptyTexture3d = new DataTexture3D();
var emptyCubeTexture = new CubeTexture();
// --- Base for inner nodes (including the root) ---
function UniformContainer() {
    this.seq = [];
    this.map = {};
}
// --- Utilities ---
// Array Caches (provide typed arrays for temporary by size)
var arrayCacheF32 = [];
var arrayCacheI32 = [];
// Float32Array caches used for uploading Matrix uniforms
var mat4array = new Float32Array(16);
var mat3array = new Float32Array(9);
var mat2array = new Float32Array(4);
// Flattening for arrays of vectors and matrices
function flatten(array, nBlocks, blockSize) {
    var firstElem = array[0];
    if (firstElem <= 0 || firstElem > 0) return array;
    // unoptimized: ! isNaN( firstElem )
    // see http://jacksondunstan.com/articles/983
    var n = nBlocks * blockSize, r = arrayCacheF32[n];
    if (r === undefined) {
        r = new Float32Array(n);
        arrayCacheF32[n] = r;
    }
    if (nBlocks !== 0) {
        firstElem.toArray(r, 0);
        for(var i = 1, offset = 0; i !== nBlocks; ++i){
            offset += blockSize;
            array[i].toArray(r, offset);
        }
    }
    return r;
}
function arraysEqual(a, b) {
    if (a.length !== b.length) return false;
    for(var i = 0, l = a.length; i < l; i++){
        if (a[i] !== b[i]) return false;
    }
    return true;
}
function copyArray(a, b) {
    for(var i = 0, l = b.length; i < l; i++)a[i] = b[i];
}
// Texture unit allocation
function allocTexUnits(renderer, n) {
    var r = arrayCacheI32[n];
    if (r === undefined) {
        r = new Int32Array(n);
        arrayCacheI32[n] = r;
    }
    for(var i = 0; i !== n; ++i)r[i] = renderer.allocTextureUnit();
    return r;
}
// --- Setters ---
// Note: Defining these methods externally, because they come in a bunch
// and this way their names minify.
// Single scalar
function setValue1f(gl, v) {
    var cache = this.cache;
    if (cache[0] === v) return;
    gl.uniform1f(this.addr, v);
    cache[0] = v;
}
function setValue1i(gl, v) {
    var cache = this.cache;
    if (cache[0] === v) return;
    gl.uniform1i(this.addr, v);
    cache[0] = v;
}
// Single float vector (from flat array or THREE.VectorN)
function setValue2fv(gl, v) {
    var cache = this.cache;
    if (v.x !== undefined) {
        if (cache[0] !== v.x || cache[1] !== v.y) {
            gl.uniform2f(this.addr, v.x, v.y);
            cache[0] = v.x;
            cache[1] = v.y;
        }
    } else {
        if (arraysEqual(cache, v)) return;
        gl.uniform2fv(this.addr, v);
        copyArray(cache, v);
    }
}
function setValue3fv(gl, v) {
    var cache = this.cache;
    if (v.x !== undefined) {
        if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
            gl.uniform3f(this.addr, v.x, v.y, v.z);
            cache[0] = v.x;
            cache[1] = v.y;
            cache[2] = v.z;
        }
    } else if (v.r !== undefined) {
        if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {
            gl.uniform3f(this.addr, v.r, v.g, v.b);
            cache[0] = v.r;
            cache[1] = v.g;
            cache[2] = v.b;
        }
    } else {
        if (arraysEqual(cache, v)) return;
        gl.uniform3fv(this.addr, v);
        copyArray(cache, v);
    }
}
function setValue4fv(gl, v) {
    var cache = this.cache;
    if (v.x !== undefined) {
        if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
            gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
            cache[0] = v.x;
            cache[1] = v.y;
            cache[2] = v.z;
            cache[3] = v.w;
        }
    } else {
        if (arraysEqual(cache, v)) return;
        gl.uniform4fv(this.addr, v);
        copyArray(cache, v);
    }
}
// Single matrix (from flat array or MatrixN)
function setValue2fm(gl, v) {
    var cache = this.cache;
    var elements = v.elements;
    if (elements === undefined) {
        if (arraysEqual(cache, v)) return;
        gl.uniformMatrix2fv(this.addr, false, v);
        copyArray(cache, v);
    } else {
        if (arraysEqual(cache, elements)) return;
        mat2array.set(elements);
        gl.uniformMatrix2fv(this.addr, false, mat2array);
        copyArray(cache, elements);
    }
}
function setValue3fm(gl, v) {
    var cache = this.cache;
    var elements = v.elements;
    if (elements === undefined) {
        if (arraysEqual(cache, v)) return;
        gl.uniformMatrix3fv(this.addr, false, v);
        copyArray(cache, v);
    } else {
        if (arraysEqual(cache, elements)) return;
        mat3array.set(elements);
        gl.uniformMatrix3fv(this.addr, false, mat3array);
        copyArray(cache, elements);
    }
}
function setValue4fm(gl, v) {
    var cache = this.cache;
    var elements = v.elements;
    if (elements === undefined) {
        if (arraysEqual(cache, v)) return;
        gl.uniformMatrix4fv(this.addr, false, v);
        copyArray(cache, v);
    } else {
        if (arraysEqual(cache, elements)) return;
        mat4array.set(elements);
        gl.uniformMatrix4fv(this.addr, false, mat4array);
        copyArray(cache, elements);
    }
}
// Single texture (2D / Cube)
function setValueT1(gl, v, renderer) {
    var cache = this.cache;
    var unit = renderer.allocTextureUnit();
    if (cache[0] !== unit) {
        gl.uniform1i(this.addr, unit);
        cache[0] = unit;
    }
    renderer.setTexture2D(v || emptyTexture, unit);
}
function setValueT3D1(gl, v, renderer) {
    var cache = this.cache;
    var unit = renderer.allocTextureUnit();
    if (cache[0] !== unit) {
        gl.uniform1i(this.addr, unit);
        cache[0] = unit;
    }
    renderer.setTexture3D(v || emptyTexture3d, unit);
}
function setValueT6(gl, v, renderer) {
    var cache = this.cache;
    var unit = renderer.allocTextureUnit();
    if (cache[0] !== unit) {
        gl.uniform1i(this.addr, unit);
        cache[0] = unit;
    }
    renderer.setTextureCube(v || emptyCubeTexture, unit);
}
// Integer / Boolean vectors or arrays thereof (always flat arrays)
function setValue2iv(gl, v) {
    var cache = this.cache;
    if (arraysEqual(cache, v)) return;
    gl.uniform2iv(this.addr, v);
    copyArray(cache, v);
}
function setValue3iv(gl, v) {
    var cache = this.cache;
    if (arraysEqual(cache, v)) return;
    gl.uniform3iv(this.addr, v);
    copyArray(cache, v);
}
function setValue4iv(gl, v) {
    var cache = this.cache;
    if (arraysEqual(cache, v)) return;
    gl.uniform4iv(this.addr, v);
    copyArray(cache, v);
}
// Helper to pick the right setter for the singular case
function getSingularSetter(type) {
    switch(type){
        case 0x1406:
            return setValue1f; // FLOAT
        case 0x8b50:
            return setValue2fv; // _VEC2
        case 0x8b51:
            return setValue3fv; // _VEC3
        case 0x8b52:
            return setValue4fv; // _VEC4
        case 0x8b5a:
            return setValue2fm; // _MAT2
        case 0x8b5b:
            return setValue3fm; // _MAT3
        case 0x8b5c:
            return setValue4fm; // _MAT4
        case 0x8b5e:
        case 0x8d66:
            return setValueT1; // SAMPLER_2D, SAMPLER_EXTERNAL_OES
        case 0x8B5F:
            return setValueT3D1; // SAMPLER_3D
        case 0x8b60:
            return setValueT6; // SAMPLER_CUBE
        case 0x1404:
        case 0x8b56:
            return setValue1i; // INT, BOOL
        case 0x8b53:
        case 0x8b57:
            return setValue2iv; // _VEC2
        case 0x8b54:
        case 0x8b58:
            return setValue3iv; // _VEC3
        case 0x8b55:
        case 0x8b59:
            return setValue4iv; // _VEC4
    }
}
// Array of scalars
function setValue1fv(gl, v) {
    var cache = this.cache;
    if (arraysEqual(cache, v)) return;
    gl.uniform1fv(this.addr, v);
    copyArray(cache, v);
}
function setValue1iv(gl, v) {
    var cache = this.cache;
    if (arraysEqual(cache, v)) return;
    gl.uniform1iv(this.addr, v);
    copyArray(cache, v);
}
// Array of vectors (flat or from THREE classes)
function setValueV2a(gl, v) {
    var cache = this.cache;
    var data = flatten(v, this.size, 2);
    if (arraysEqual(cache, data)) return;
    gl.uniform2fv(this.addr, data);
    this.updateCache(data);
}
function setValueV3a(gl, v) {
    var cache = this.cache;
    var data = flatten(v, this.size, 3);
    if (arraysEqual(cache, data)) return;
    gl.uniform3fv(this.addr, data);
    this.updateCache(data);
}
function setValueV4a(gl, v) {
    var cache = this.cache;
    var data = flatten(v, this.size, 4);
    if (arraysEqual(cache, data)) return;
    gl.uniform4fv(this.addr, data);
    this.updateCache(data);
}
// Array of matrices (flat or from THREE clases)
function setValueM2a(gl, v) {
    var cache = this.cache;
    var data = flatten(v, this.size, 4);
    if (arraysEqual(cache, data)) return;
    gl.uniformMatrix2fv(this.addr, false, data);
    this.updateCache(data);
}
function setValueM3a(gl, v) {
    var cache = this.cache;
    var data = flatten(v, this.size, 9);
    if (arraysEqual(cache, data)) return;
    gl.uniformMatrix3fv(this.addr, false, data);
    this.updateCache(data);
}
function setValueM4a(gl, v) {
    var cache = this.cache;
    var data = flatten(v, this.size, 16);
    if (arraysEqual(cache, data)) return;
    gl.uniformMatrix4fv(this.addr, false, data);
    this.updateCache(data);
}
// Array of textures (2D / Cube)
function setValueT1a(gl, v, renderer) {
    var cache = this.cache;
    var n = v.length;
    var units = allocTexUnits(renderer, n);
    if (arraysEqual(cache, units) === false) {
        gl.uniform1iv(this.addr, units);
        copyArray(cache, units);
    }
    for(var i = 0; i !== n; ++i)renderer.setTexture2D(v[i] || emptyTexture, units[i]);
}
function setValueT6a(gl, v, renderer) {
    var cache = this.cache;
    var n = v.length;
    var units = allocTexUnits(renderer, n);
    if (arraysEqual(cache, units) === false) {
        gl.uniform1iv(this.addr, units);
        copyArray(cache, units);
    }
    for(var i = 0; i !== n; ++i)renderer.setTextureCube(v[i] || emptyCubeTexture, units[i]);
}
// Helper to pick the right setter for a pure (bottom-level) array
function getPureArraySetter(type) {
    switch(type){
        case 0x1406:
            return setValue1fv; // FLOAT
        case 0x8b50:
            return setValueV2a; // _VEC2
        case 0x8b51:
            return setValueV3a; // _VEC3
        case 0x8b52:
            return setValueV4a; // _VEC4
        case 0x8b5a:
            return setValueM2a; // _MAT2
        case 0x8b5b:
            return setValueM3a; // _MAT3
        case 0x8b5c:
            return setValueM4a; // _MAT4
        case 0x8b5e:
            return setValueT1a; // SAMPLER_2D
        case 0x8b60:
            return setValueT6a; // SAMPLER_CUBE
        case 0x1404:
        case 0x8b56:
            return setValue1iv; // INT, BOOL
        case 0x8b53:
        case 0x8b57:
            return setValue2iv; // _VEC2
        case 0x8b54:
        case 0x8b58:
            return setValue3iv; // _VEC3
        case 0x8b55:
        case 0x8b59:
            return setValue4iv; // _VEC4
    }
}
// --- Uniform Classes ---
function SingleUniform(id, activeInfo, addr) {
    this.id = id;
    this.addr = addr;
    this.cache = [];
    this.setValue = getSingularSetter(activeInfo.type);
// this.path = activeInfo.name; // DEBUG
}
function PureArrayUniform(id, activeInfo, addr) {
    this.id = id;
    this.addr = addr;
    this.cache = [];
    this.size = activeInfo.size;
    this.setValue = getPureArraySetter(activeInfo.type);
// this.path = activeInfo.name; // DEBUG
}
PureArrayUniform.prototype.updateCache = function(data) {
    var cache = this.cache;
    if (data instanceof Float32Array && cache.length !== data.length) this.cache = new Float32Array(data.length);
    copyArray(cache, data);
};
function StructuredUniform(id) {
    this.id = id;
    UniformContainer.call(this); // mix-in
}
StructuredUniform.prototype.setValue = function(gl, value, renderer) {
    var seq = this.seq;
    for(var i = 0, n = seq.length; i !== n; ++i){
        var u = seq[i];
        u.setValue(gl, value[u.id], renderer);
    }
};
// --- Top-level ---
// Parser - builds up the property tree from the path strings
var RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;
// extracts
// 	- the identifier (member name or array index)
//  - followed by an optional right bracket (found when array index)
//  - followed by an optional left bracket or dot (type of subscript)
//
// Note: These portions can be read in a non-overlapping fashion and
// allow straightforward parsing of the hierarchy that WebGL encodes
// in the uniform names.
function addUniform(container, uniformObject) {
    container.seq.push(uniformObject);
    container.map[uniformObject.id] = uniformObject;
}
function parseUniform(activeInfo, addr, container) {
    var path = activeInfo.name, pathLength = path.length;
    // reset RegExp object, because of the early exit of a previous run
    RePathPart.lastIndex = 0;
    while(true){
        var match = RePathPart.exec(path), matchEnd = RePathPart.lastIndex, id = match[1], idIsIndex = match[2] === "]", subscript = match[3];
        if (idIsIndex) id = id | 0; // convert to integer
        if (subscript === undefined || subscript === "[" && matchEnd + 2 === pathLength) {
            // bare name or "pure" bottom-level array "[0]" suffix
            addUniform(container, subscript === undefined ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
            break;
        } else {
            // step into inner node / create it in case it doesn't exist
            var map = container.map, next = map[id];
            if (next === undefined) {
                next = new StructuredUniform(id);
                addUniform(container, next);
            }
            container = next;
        }
    }
}
// Root Container
function WebGLUniforms(gl, program, renderer) {
    UniformContainer.call(this);
    this.renderer = renderer;
    var n = gl.getProgramParameter(program, 35718);
    for(var i = 0; i < n; ++i){
        var info = gl.getActiveUniform(program, i), addr = gl.getUniformLocation(program, info.name);
        parseUniform(info, addr, this);
    }
}
WebGLUniforms.prototype.setValue = function(gl, name, value) {
    var u = this.map[name];
    if (u !== undefined) u.setValue(gl, value, this.renderer);
};
WebGLUniforms.prototype.setOptional = function(gl, object, name) {
    var v = object[name];
    if (v !== undefined) this.setValue(gl, name, v);
};
// Static interface
WebGLUniforms.upload = function(gl, seq, values, renderer) {
    for(var i = 0, n = seq.length; i !== n; ++i){
        var u = seq[i], v = values[u.id];
        if (v.needsUpdate !== false) // note: always updating when .needsUpdate is undefined
        u.setValue(gl, v.value, renderer);
    }
};
WebGLUniforms.seqWithValue = function(seq, values) {
    var r = [];
    for(var i = 0, n = seq.length; i !== n; ++i){
        var u = seq[i];
        if (u.id in values) r.push(u);
    }
    return r;
};
/**
 * @author mrdoob / http://mrdoob.com/
 */ function addLineNumbers(string) {
    var lines = string.split("\n");
    for(var i = 0; i < lines.length; i++)lines[i] = i + 1 + ": " + lines[i];
    return lines.join("\n");
}
function WebGLShader(gl, type, string) {
    var shader = gl.createShader(type);
    gl.shaderSource(shader, string);
    gl.compileShader(shader);
    if (gl.getShaderParameter(shader, 35713) === false) console.error("THREE.WebGLShader: Shader couldn't compile.");
    if (gl.getShaderInfoLog(shader) !== "") console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", type === 35633 ? "vertex" : "fragment", gl.getShaderInfoLog(shader), addLineNumbers(string));
    // --enable-privileged-webgl-extension
    // console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );
    return shader;
}
/**
 * @author mrdoob / http://mrdoob.com/
 */ var programIdCount = 0;
function getEncodingComponents(encoding) {
    switch(encoding){
        case LinearEncoding:
            return [
                "Linear",
                "( value )"
            ];
        case sRGBEncoding:
            return [
                "sRGB",
                "( value )"
            ];
        case RGBEEncoding:
            return [
                "RGBE",
                "( value )"
            ];
        case RGBM7Encoding:
            return [
                "RGBM",
                "( value, 7.0 )"
            ];
        case RGBM16Encoding:
            return [
                "RGBM",
                "( value, 16.0 )"
            ];
        case RGBDEncoding:
            return [
                "RGBD",
                "( value, 256.0 )"
            ];
        case GammaEncoding:
            return [
                "Gamma",
                "( value, float( GAMMA_FACTOR ) )"
            ];
        default:
            throw new Error("unsupported encoding: " + encoding);
    }
}
function getTexelDecodingFunction(functionName, encoding) {
    var components = getEncodingComponents(encoding);
    return "vec4 " + functionName + "( vec4 value ) { return " + components[0] + "ToLinear" + components[1] + "; }";
}
function getTexelEncodingFunction(functionName, encoding) {
    var components = getEncodingComponents(encoding);
    return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[0] + components[1] + "; }";
}
function getToneMappingFunction(functionName, toneMapping) {
    var toneMappingName;
    switch(toneMapping){
        case LinearToneMapping:
            toneMappingName = "Linear";
            break;
        case ReinhardToneMapping:
            toneMappingName = "Reinhard";
            break;
        case Uncharted2ToneMapping:
            toneMappingName = "Uncharted2";
            break;
        case CineonToneMapping:
            toneMappingName = "OptimizedCineon";
            break;
        case ACESFilmicToneMapping:
            toneMappingName = "ACESFilmic";
            break;
        default:
            throw new Error("unsupported toneMapping: " + toneMapping);
    }
    return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";
}
function generateExtensions(extensions, parameters, rendererExtensions) {
    extensions = extensions || {};
    var chunks = [
        extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap && !parameters.objectSpaceNormalMap || parameters.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "",
        (extensions.fragDepth || parameters.logarithmicDepthBuffer) && rendererExtensions.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "",
        extensions.drawBuffers && rendererExtensions.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "",
        (extensions.shaderTextureLOD || parameters.envMap) && rendererExtensions.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""
    ];
    return chunks.filter(filterEmptyLine).join("\n");
}
function generateDefines(defines) {
    var chunks = [];
    for(var name in defines){
        var value = defines[name];
        if (value === false) continue;
        chunks.push("#define " + name + " " + value);
    }
    return chunks.join("\n");
}
function fetchAttributeLocations(gl, program) {
    var attributes = {};
    var n = gl.getProgramParameter(program, 35721);
    for(var i = 0; i < n; i++){
        var info = gl.getActiveAttrib(program, i);
        var name = info.name;
        // console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );
        attributes[name] = gl.getAttribLocation(program, name);
    }
    return attributes;
}
function filterEmptyLine(string) {
    return string !== "";
}
function replaceLightNums(string, parameters) {
    return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights);
}
function replaceClippingPlaneNums(string, parameters) {
    return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
}
function parseIncludes(string) {
    var pattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
    function replace(match, include) {
        var replace = ShaderChunk[include];
        if (replace === undefined) throw new Error("Can not resolve #include <" + include + ">");
        return parseIncludes(replace);
    }
    return string.replace(pattern, replace);
}
function unrollLoops(string) {
    var pattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
    function replace(match, start, end, snippet) {
        var unroll = "";
        for(var i = parseInt(start); i < parseInt(end); i++)unroll += snippet.replace(/\[ i \]/g, "[ " + i + " ]");
        return unroll;
    }
    return string.replace(pattern, replace);
}
function WebGLProgram(renderer, extensions, code, material, shader, parameters, capabilities) {
    var gl = renderer.context;
    var defines = material.defines;
    var vertexShader = shader.vertexShader;
    var fragmentShader = shader.fragmentShader;
    var shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";
    if (parameters.shadowMapType === PCFShadowMap) shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";
    else if (parameters.shadowMapType === PCFSoftShadowMap) shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";
    var envMapTypeDefine = "ENVMAP_TYPE_CUBE";
    var envMapModeDefine = "ENVMAP_MODE_REFLECTION";
    var envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
    if (parameters.envMap) {
        switch(material.envMap.mapping){
            case CubeReflectionMapping:
            case CubeRefractionMapping:
                envMapTypeDefine = "ENVMAP_TYPE_CUBE";
                break;
            case CubeUVReflectionMapping:
            case CubeUVRefractionMapping:
                envMapTypeDefine = "ENVMAP_TYPE_CUBE_UV";
                break;
            case EquirectangularReflectionMapping:
            case EquirectangularRefractionMapping:
                envMapTypeDefine = "ENVMAP_TYPE_EQUIREC";
                break;
            case SphericalReflectionMapping:
                envMapTypeDefine = "ENVMAP_TYPE_SPHERE";
                break;
        }
        switch(material.envMap.mapping){
            case CubeRefractionMapping:
            case EquirectangularRefractionMapping:
                envMapModeDefine = "ENVMAP_MODE_REFRACTION";
                break;
        }
        switch(material.combine){
            case MultiplyOperation:
                envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
                break;
            case MixOperation:
                envMapBlendingDefine = "ENVMAP_BLENDING_MIX";
                break;
            case AddOperation:
                envMapBlendingDefine = "ENVMAP_BLENDING_ADD";
                break;
        }
    }
    var gammaFactorDefine = renderer.gammaFactor > 0 ? renderer.gammaFactor : 1.0;
    // console.log( 'building new program ' );
    //
    var customExtensions = capabilities.isWebGL2 ? "" : generateExtensions(material.extensions, parameters, extensions);
    var customDefines = generateDefines(defines);
    //
    var program = gl.createProgram();
    var prefixVertex, prefixFragment;
    if (material.isRawShaderMaterial) {
        prefixVertex = [
            customDefines
        ].filter(filterEmptyLine).join("\n");
        if (prefixVertex.length > 0) prefixVertex += "\n";
        prefixFragment = [
            customExtensions,
            customDefines
        ].filter(filterEmptyLine).join("\n");
        if (prefixFragment.length > 0) prefixFragment += "\n";
    } else {
        prefixVertex = [
            "precision " + parameters.precision + " float;",
            "precision " + parameters.precision + " int;",
            "#define SHADER_NAME " + shader.name,
            customDefines,
            parameters.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
            "#define GAMMA_FACTOR " + gammaFactorDefine,
            "#define MAX_BONES " + parameters.maxBones,
            parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
            parameters.useFog && parameters.fogExp ? "#define FOG_EXP2" : "",
            parameters.map ? "#define USE_MAP" : "",
            parameters.envMap ? "#define USE_ENVMAP" : "",
            parameters.envMap ? "#define " + envMapModeDefine : "",
            parameters.lightMap ? "#define USE_LIGHTMAP" : "",
            parameters.aoMap ? "#define USE_AOMAP" : "",
            parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
            parameters.bumpMap ? "#define USE_BUMPMAP" : "",
            parameters.normalMap ? "#define USE_NORMALMAP" : "",
            parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
            parameters.displacementMap && parameters.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "",
            parameters.specularMap ? "#define USE_SPECULARMAP" : "",
            parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
            parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
            parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
            parameters.vertexColors ? "#define USE_COLOR" : "",
            parameters.flatShading ? "#define FLAT_SHADED" : "",
            parameters.skinning ? "#define USE_SKINNING" : "",
            parameters.useVertexTexture ? "#define BONE_TEXTURE" : "",
            parameters.morphTargets ? "#define USE_MORPHTARGETS" : "",
            parameters.morphNormals && parameters.flatShading === false ? "#define USE_MORPHNORMALS" : "",
            parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
            parameters.flipSided ? "#define FLIP_SIDED" : "",
            parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
            parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
            parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
            parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
            parameters.logarithmicDepthBuffer && (capabilities.isWebGL2 || extensions.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "",
            "uniform mat4 modelMatrix;",
            "uniform mat4 modelViewMatrix;",
            "uniform mat4 projectionMatrix;",
            "uniform mat4 viewMatrix;",
            "uniform mat3 normalMatrix;",
            "uniform vec3 cameraPosition;",
            "attribute vec3 position;",
            "attribute vec3 normal;",
            "attribute vec2 uv;",
            "#ifdef USE_COLOR",
            "	attribute vec3 color;",
            "#endif",
            "#ifdef USE_MORPHTARGETS",
            "	attribute vec3 morphTarget0;",
            "	attribute vec3 morphTarget1;",
            "	attribute vec3 morphTarget2;",
            "	attribute vec3 morphTarget3;",
            "	#ifdef USE_MORPHNORMALS",
            "		attribute vec3 morphNormal0;",
            "		attribute vec3 morphNormal1;",
            "		attribute vec3 morphNormal2;",
            "		attribute vec3 morphNormal3;",
            "	#else",
            "		attribute vec3 morphTarget4;",
            "		attribute vec3 morphTarget5;",
            "		attribute vec3 morphTarget6;",
            "		attribute vec3 morphTarget7;",
            "	#endif",
            "#endif",
            "#ifdef USE_SKINNING",
            "	attribute vec4 skinIndex;",
            "	attribute vec4 skinWeight;",
            "#endif",
            "\n"
        ].filter(filterEmptyLine).join("\n");
        prefixFragment = [
            customExtensions,
            "precision " + parameters.precision + " float;",
            "precision " + parameters.precision + " int;",
            "#define SHADER_NAME " + shader.name,
            customDefines,
            parameters.alphaTest ? "#define ALPHATEST " + parameters.alphaTest + (parameters.alphaTest % 1 ? "" : ".0") : "",
            "#define GAMMA_FACTOR " + gammaFactorDefine,
            parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
            parameters.useFog && parameters.fogExp ? "#define FOG_EXP2" : "",
            parameters.map ? "#define USE_MAP" : "",
            parameters.matcap ? "#define USE_MATCAP" : "",
            parameters.envMap ? "#define USE_ENVMAP" : "",
            parameters.envMap ? "#define " + envMapTypeDefine : "",
            parameters.envMap ? "#define " + envMapModeDefine : "",
            parameters.envMap ? "#define " + envMapBlendingDefine : "",
            parameters.lightMap ? "#define USE_LIGHTMAP" : "",
            parameters.aoMap ? "#define USE_AOMAP" : "",
            parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
            parameters.bumpMap ? "#define USE_BUMPMAP" : "",
            parameters.normalMap ? "#define USE_NORMALMAP" : "",
            parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
            parameters.specularMap ? "#define USE_SPECULARMAP" : "",
            parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
            parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
            parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
            parameters.vertexColors ? "#define USE_COLOR" : "",
            parameters.gradientMap ? "#define USE_GRADIENTMAP" : "",
            parameters.flatShading ? "#define FLAT_SHADED" : "",
            parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
            parameters.flipSided ? "#define FLIP_SIDED" : "",
            parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
            parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
            parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
            parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
            parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
            parameters.logarithmicDepthBuffer && (capabilities.isWebGL2 || extensions.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "",
            parameters.envMap && (capabilities.isWebGL2 || extensions.get("EXT_shader_texture_lod")) ? "#define TEXTURE_LOD_EXT" : "",
            "uniform mat4 viewMatrix;",
            "uniform vec3 cameraPosition;",
            parameters.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "",
            parameters.toneMapping !== NoToneMapping ? ShaderChunk["tonemapping_pars_fragment"] : "",
            parameters.toneMapping !== NoToneMapping ? getToneMappingFunction("toneMapping", parameters.toneMapping) : "",
            parameters.dithering ? "#define DITHERING" : "",
            parameters.outputEncoding || parameters.mapEncoding || parameters.matcapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ? ShaderChunk["encodings_pars_fragment"] : "",
            parameters.mapEncoding ? getTexelDecodingFunction("mapTexelToLinear", parameters.mapEncoding) : "",
            parameters.matcapEncoding ? getTexelDecodingFunction("matcapTexelToLinear", parameters.matcapEncoding) : "",
            parameters.envMapEncoding ? getTexelDecodingFunction("envMapTexelToLinear", parameters.envMapEncoding) : "",
            parameters.emissiveMapEncoding ? getTexelDecodingFunction("emissiveMapTexelToLinear", parameters.emissiveMapEncoding) : "",
            parameters.outputEncoding ? getTexelEncodingFunction("linearToOutputTexel", parameters.outputEncoding) : "",
            parameters.depthPacking ? "#define DEPTH_PACKING " + material.depthPacking : "",
            "\n"
        ].filter(filterEmptyLine).join("\n");
    }
    vertexShader = parseIncludes(vertexShader);
    vertexShader = replaceLightNums(vertexShader, parameters);
    vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
    fragmentShader = parseIncludes(fragmentShader);
    fragmentShader = replaceLightNums(fragmentShader, parameters);
    fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
    vertexShader = unrollLoops(vertexShader);
    fragmentShader = unrollLoops(fragmentShader);
    if (capabilities.isWebGL2 && !material.isRawShaderMaterial) {
        var isGLSL3ShaderMaterial = false;
        var versionRegex = /^\s*#version\s+300\s+es\s*\n/;
        if (material.isShaderMaterial && vertexShader.match(versionRegex) !== null && fragmentShader.match(versionRegex) !== null) {
            isGLSL3ShaderMaterial = true;
            vertexShader = vertexShader.replace(versionRegex, "");
            fragmentShader = fragmentShader.replace(versionRegex, "");
        }
        // GLSL 3.0 conversion
        prefixVertex = [
            "#version 300 es\n",
            "#define attribute in",
            "#define varying out",
            "#define texture2D texture"
        ].join("\n") + "\n" + prefixVertex;
        prefixFragment = [
            "#version 300 es\n",
            "#define varying in",
            isGLSL3ShaderMaterial ? "" : "out highp vec4 pc_fragColor;",
            isGLSL3ShaderMaterial ? "" : "#define gl_FragColor pc_fragColor",
            "#define gl_FragDepthEXT gl_FragDepth",
            "#define texture2D texture",
            "#define textureCube texture",
            "#define texture2DProj textureProj",
            "#define texture2DLodEXT textureLod",
            "#define texture2DProjLodEXT textureProjLod",
            "#define textureCubeLodEXT textureLod",
            "#define texture2DGradEXT textureGrad",
            "#define texture2DProjGradEXT textureProjGrad",
            "#define textureCubeGradEXT textureGrad"
        ].join("\n") + "\n" + prefixFragment;
    }
    var vertexGlsl = prefixVertex + vertexShader;
    var fragmentGlsl = prefixFragment + fragmentShader;
    // console.log( '*VERTEX*', vertexGlsl );
    // console.log( '*FRAGMENT*', fragmentGlsl );
    var glVertexShader = WebGLShader(gl, 35633, vertexGlsl);
    var glFragmentShader = WebGLShader(gl, 35632, fragmentGlsl);
    gl.attachShader(program, glVertexShader);
    gl.attachShader(program, glFragmentShader);
    // Force a particular attribute to index 0.
    if (material.index0AttributeName !== undefined) gl.bindAttribLocation(program, 0, material.index0AttributeName);
    else if (parameters.morphTargets === true) // programs with morphTargets displace position out of attribute 0
    gl.bindAttribLocation(program, 0, "position");
    gl.linkProgram(program);
    var programLog = gl.getProgramInfoLog(program).trim();
    var vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
    var fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
    var runnable = true;
    var haveDiagnostics = true;
    // console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );
    // console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );
    if (gl.getProgramParameter(program, 35714) === false) {
        runnable = false;
        console.error("THREE.WebGLProgram: shader error: ", gl.getError(), "35715", gl.getProgramParameter(program, 35715), "gl.getProgramInfoLog", programLog, vertexLog, fragmentLog);
    } else if (programLog !== "") console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", programLog);
    else if (vertexLog === "" || fragmentLog === "") haveDiagnostics = false;
    if (haveDiagnostics) this.diagnostics = {
        runnable: runnable,
        material: material,
        programLog: programLog,
        vertexShader: {
            log: vertexLog,
            prefix: prefixVertex
        },
        fragmentShader: {
            log: fragmentLog,
            prefix: prefixFragment
        }
    };
    // clean up
    gl.deleteShader(glVertexShader);
    gl.deleteShader(glFragmentShader);
    // set up caching for uniform locations
    var cachedUniforms;
    this.getUniforms = function() {
        if (cachedUniforms === undefined) cachedUniforms = new WebGLUniforms(gl, program, renderer);
        return cachedUniforms;
    };
    // set up caching for attribute locations
    var cachedAttributes;
    this.getAttributes = function() {
        if (cachedAttributes === undefined) cachedAttributes = fetchAttributeLocations(gl, program);
        return cachedAttributes;
    };
    // free resource
    this.destroy = function() {
        gl.deleteProgram(program);
        this.program = undefined;
    };
    // DEPRECATED
    Object.defineProperties(this, {
        uniforms: {
            get: function() {
                console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms().");
                return this.getUniforms();
            }
        },
        attributes: {
            get: function() {
                console.warn("THREE.WebGLProgram: .attributes is now .getAttributes().");
                return this.getAttributes();
            }
        }
    });
    //
    this.name = shader.name;
    this.id = programIdCount++;
    this.code = code;
    this.usedTimes = 1;
    this.program = program;
    this.vertexShader = glVertexShader;
    this.fragmentShader = glFragmentShader;
    return this;
}
/**
 * @author mrdoob / http://mrdoob.com/
 */ function WebGLPrograms(renderer, extensions, capabilities) {
    var programs = [];
    var shaderIDs = {
        MeshDepthMaterial: "depth",
        MeshDistanceMaterial: "distanceRGBA",
        MeshNormalMaterial: "normal",
        MeshBasicMaterial: "basic",
        MeshLambertMaterial: "lambert",
        MeshPhongMaterial: "phong",
        MeshToonMaterial: "phong",
        MeshStandardMaterial: "physical",
        MeshPhysicalMaterial: "physical",
        MeshMatcapMaterial: "matcap",
        LineBasicMaterial: "basic",
        LineDashedMaterial: "dashed",
        PointsMaterial: "points",
        ShadowMaterial: "shadow",
        SpriteMaterial: "sprite"
    };
    var parameterNames = [
        "precision",
        "supportsVertexTextures",
        "map",
        "mapEncoding",
        "matcap",
        "matcapEncoding",
        "envMap",
        "envMapMode",
        "envMapEncoding",
        "lightMap",
        "aoMap",
        "emissiveMap",
        "emissiveMapEncoding",
        "bumpMap",
        "normalMap",
        "objectSpaceNormalMap",
        "displacementMap",
        "specularMap",
        "roughnessMap",
        "metalnessMap",
        "gradientMap",
        "alphaMap",
        "combine",
        "vertexColors",
        "fog",
        "useFog",
        "fogExp",
        "flatShading",
        "sizeAttenuation",
        "logarithmicDepthBuffer",
        "skinning",
        "maxBones",
        "useVertexTexture",
        "morphTargets",
        "morphNormals",
        "maxMorphTargets",
        "maxMorphNormals",
        "premultipliedAlpha",
        "numDirLights",
        "numPointLights",
        "numSpotLights",
        "numHemiLights",
        "numRectAreaLights",
        "shadowMapEnabled",
        "shadowMapType",
        "toneMapping",
        "physicallyCorrectLights",
        "alphaTest",
        "doubleSided",
        "flipSided",
        "numClippingPlanes",
        "numClipIntersection",
        "depthPacking",
        "dithering"
    ];
    function allocateBones(object) {
        var skeleton = object.skeleton;
        var bones = skeleton.bones;
        if (capabilities.floatVertexTextures) return 1024;
        else {
            // default for when object is not specified
            // ( for example when prebuilding shader to be used with multiple objects )
            //
            //  - leave some extra space for other uniforms
            //  - limit here is ANGLE's 254 max uniform vectors
            //    (up to 54 should be safe)
            var nVertexUniforms = capabilities.maxVertexUniforms;
            var nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
            var maxBones = Math.min(nVertexMatrices, bones.length);
            if (maxBones < bones.length) {
                console.warn("THREE.WebGLRenderer: Skeleton has " + bones.length + " bones. This GPU supports " + maxBones + ".");
                return 0;
            }
            return maxBones;
        }
    }
    function getTextureEncodingFromMap(map, gammaOverrideLinear) {
        var encoding;
        if (!map) encoding = LinearEncoding;
        else if (map.isTexture) encoding = map.encoding;
        else if (map.isWebGLRenderTarget) {
            console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.");
            encoding = map.texture.encoding;
        }
        // add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.
        if (encoding === LinearEncoding && gammaOverrideLinear) encoding = GammaEncoding;
        return encoding;
    }
    this.getParameters = function(material, lights, shadows, fog, nClipPlanes, nClipIntersection, object) {
        var shaderID = shaderIDs[material.type];
        // heuristics to create shader parameters according to lights in the scene
        // (not to blow over maxLights budget)
        var maxBones = object.isSkinnedMesh ? allocateBones(object) : 0;
        var precision = capabilities.precision;
        if (material.precision !== null) {
            precision = capabilities.getMaxPrecision(material.precision);
            if (precision !== material.precision) console.warn("THREE.WebGLProgram.getParameters:", material.precision, "not supported, using", precision, "instead.");
        }
        var currentRenderTarget = renderer.getRenderTarget();
        var parameters = {
            shaderID: shaderID,
            precision: precision,
            supportsVertexTextures: capabilities.vertexTextures,
            outputEncoding: getTextureEncodingFromMap(!currentRenderTarget ? null : currentRenderTarget.texture, renderer.gammaOutput),
            map: !!material.map,
            mapEncoding: getTextureEncodingFromMap(material.map, renderer.gammaInput),
            matcap: !!material.matcap,
            matcapEncoding: getTextureEncodingFromMap(material.matcap, renderer.gammaInput),
            envMap: !!material.envMap,
            envMapMode: material.envMap && material.envMap.mapping,
            envMapEncoding: getTextureEncodingFromMap(material.envMap, renderer.gammaInput),
            envMapCubeUV: !!material.envMap && (material.envMap.mapping === CubeUVReflectionMapping || material.envMap.mapping === CubeUVRefractionMapping),
            lightMap: !!material.lightMap,
            aoMap: !!material.aoMap,
            emissiveMap: !!material.emissiveMap,
            emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap, renderer.gammaInput),
            bumpMap: !!material.bumpMap,
            normalMap: !!material.normalMap,
            objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
            displacementMap: !!material.displacementMap,
            roughnessMap: !!material.roughnessMap,
            metalnessMap: !!material.metalnessMap,
            specularMap: !!material.specularMap,
            alphaMap: !!material.alphaMap,
            gradientMap: !!material.gradientMap,
            combine: material.combine,
            vertexColors: material.vertexColors,
            fog: !!fog,
            useFog: material.fog,
            fogExp: fog && fog.isFogExp2,
            flatShading: material.flatShading,
            sizeAttenuation: material.sizeAttenuation,
            logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,
            skinning: material.skinning && maxBones > 0,
            maxBones: maxBones,
            useVertexTexture: capabilities.floatVertexTextures,
            morphTargets: material.morphTargets,
            morphNormals: material.morphNormals,
            maxMorphTargets: renderer.maxMorphTargets,
            maxMorphNormals: renderer.maxMorphNormals,
            numDirLights: lights.directional.length,
            numPointLights: lights.point.length,
            numSpotLights: lights.spot.length,
            numRectAreaLights: lights.rectArea.length,
            numHemiLights: lights.hemi.length,
            numClippingPlanes: nClipPlanes,
            numClipIntersection: nClipIntersection,
            dithering: material.dithering,
            shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && shadows.length > 0,
            shadowMapType: renderer.shadowMap.type,
            toneMapping: renderer.toneMapping,
            physicallyCorrectLights: renderer.physicallyCorrectLights,
            premultipliedAlpha: material.premultipliedAlpha,
            alphaTest: material.alphaTest,
            doubleSided: material.side === DoubleSide,
            flipSided: material.side === BackSide,
            depthPacking: material.depthPacking !== undefined ? material.depthPacking : false
        };
        return parameters;
    };
    this.getProgramCode = function(material, parameters) {
        var array = [];
        if (parameters.shaderID) array.push(parameters.shaderID);
        else {
            array.push(material.fragmentShader);
            array.push(material.vertexShader);
        }
        if (material.defines !== undefined) for(var name in material.defines){
            array.push(name);
            array.push(material.defines[name]);
        }
        for(var i = 0; i < parameterNames.length; i++)array.push(parameters[parameterNames[i]]);
        array.push(material.onBeforeCompile.toString());
        array.push(renderer.gammaOutput);
        array.push(renderer.gammaFactor);
        return array.join();
    };
    this.acquireProgram = function(material, shader, parameters, code) {
        var program;
        // Check if code has been already compiled
        for(var p = 0, pl = programs.length; p < pl; p++){
            var programInfo = programs[p];
            if (programInfo.code === code) {
                program = programInfo;
                ++program.usedTimes;
                break;
            }
        }
        if (program === undefined) {
            program = new WebGLProgram(renderer, extensions, code, material, shader, parameters, capabilities);
            programs.push(program);
        }
        return program;
    };
    this.releaseProgram = function(program) {
        if (--program.usedTimes === 0) {
            // Remove from unordered set
            var i = programs.indexOf(program);
            programs[i] = programs[programs.length - 1];
            programs.pop();
            // Free WebGL resources
            program.destroy();
        }
    };
    // Exposed for resource monitoring & error feedback via renderer.info:
    this.programs = programs;
}
/**
 * @author fordacious / fordacious.github.io
 */ function WebGLProperties() {
    var properties = new WeakMap();
    function get(object) {
        var map = properties.get(object);
        if (map === undefined) {
            map = {};
            properties.set(object, map);
        }
        return map;
    }
    function remove(object) {
        properties.delete(object);
    }
    function update(object, key, value) {
        properties.get(object)[key] = value;
    }
    function dispose() {
        properties = new WeakMap();
    }
    return {
        get: get,
        remove: remove,
        update: update,
        dispose: dispose
    };
}
/**
 * @author mrdoob / http://mrdoob.com/
 */ function painterSortStable(a, b) {
    if (a.renderOrder !== b.renderOrder) return a.renderOrder - b.renderOrder;
    else if (a.program && b.program && a.program !== b.program) return a.program.id - b.program.id;
    else if (a.material.id !== b.material.id) return a.material.id - b.material.id;
    else if (a.z !== b.z) return a.z - b.z;
    else return a.id - b.id;
}
function reversePainterSortStable(a, b) {
    if (a.renderOrder !== b.renderOrder) return a.renderOrder - b.renderOrder;
    if (a.z !== b.z) return b.z - a.z;
    else return a.id - b.id;
}
function WebGLRenderList() {
    var renderItems = [];
    var renderItemsIndex = 0;
    var opaque = [];
    var transparent = [];
    function init() {
        renderItemsIndex = 0;
        opaque.length = 0;
        transparent.length = 0;
    }
    function getNextRenderItem(object, geometry, material, z, group) {
        var renderItem = renderItems[renderItemsIndex];
        if (renderItem === undefined) {
            renderItem = {
                id: object.id,
                object: object,
                geometry: geometry,
                material: material,
                program: material.program,
                renderOrder: object.renderOrder,
                z: z,
                group: group
            };
            renderItems[renderItemsIndex] = renderItem;
        } else {
            renderItem.id = object.id;
            renderItem.object = object;
            renderItem.geometry = geometry;
            renderItem.material = material;
            renderItem.program = material.program;
            renderItem.renderOrder = object.renderOrder;
            renderItem.z = z;
            renderItem.group = group;
        }
        renderItemsIndex++;
        return renderItem;
    }
    function push(object, geometry, material, z, group) {
        var renderItem = getNextRenderItem(object, geometry, material, z, group);
        (material.transparent === true ? transparent : opaque).push(renderItem);
    }
    function unshift(object, geometry, material, z, group) {
        var renderItem = getNextRenderItem(object, geometry, material, z, group);
        (material.transparent === true ? transparent : opaque).unshift(renderItem);
    }
    function sort() {
        if (opaque.length > 1) opaque.sort(painterSortStable);
        if (transparent.length > 1) transparent.sort(reversePainterSortStable);
    }
    return {
        opaque: opaque,
        transparent: transparent,
        init: init,
        push: push,
        unshift: unshift,
        sort: sort
    };
}
function WebGLRenderLists() {
    var lists = {};
    function get(scene, camera) {
        var cameras = lists[scene.id];
        var list;
        if (cameras === undefined) {
            list = new WebGLRenderList();
            lists[scene.id] = {};
            lists[scene.id][camera.id] = list;
        } else {
            list = cameras[camera.id];
            if (list === undefined) {
                list = new WebGLRenderList();
                cameras[camera.id] = list;
            }
        }
        return list;
    }
    function dispose() {
        lists = {};
    }
    return {
        get: get,
        dispose: dispose
    };
}
/**
 * @author mrdoob / http://mrdoob.com/
 */ function UniformsCache() {
    var lights = {};
    return {
        get: function(light) {
            if (lights[light.id] !== undefined) return lights[light.id];
            var uniforms;
            switch(light.type){
                case "DirectionalLight":
                    uniforms = {
                        direction: new Vector3(),
                        color: new Color(),
                        shadow: false,
                        shadowBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Vector2()
                    };
                    break;
                case "SpotLight":
                    uniforms = {
                        position: new Vector3(),
                        direction: new Vector3(),
                        color: new Color(),
                        distance: 0,
                        coneCos: 0,
                        penumbraCos: 0,
                        decay: 0,
                        shadow: false,
                        shadowBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Vector2()
                    };
                    break;
                case "PointLight":
                    uniforms = {
                        position: new Vector3(),
                        color: new Color(),
                        distance: 0,
                        decay: 0,
                        shadow: false,
                        shadowBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Vector2(),
                        shadowCameraNear: 1,
                        shadowCameraFar: 1000
                    };
                    break;
                case "HemisphereLight":
                    uniforms = {
                        direction: new Vector3(),
                        skyColor: new Color(),
                        groundColor: new Color()
                    };
                    break;
                case "RectAreaLight":
                    uniforms = {
                        color: new Color(),
                        position: new Vector3(),
                        halfWidth: new Vector3(),
                        halfHeight: new Vector3()
                    };
                    break;
            }
            lights[light.id] = uniforms;
            return uniforms;
        }
    };
}
var count = 0;
function WebGLLights() {
    var cache = new UniformsCache();
    var state = {
        id: count++,
        hash: {
            stateID: -1,
            directionalLength: -1,
            pointLength: -1,
            spotLength: -1,
            rectAreaLength: -1,
            hemiLength: -1,
            shadowsLength: -1
        },
        ambient: [
            0,
            0,
            0
        ],
        directional: [],
        directionalShadowMap: [],
        directionalShadowMatrix: [],
        spot: [],
        spotShadowMap: [],
        spotShadowMatrix: [],
        rectArea: [],
        point: [],
        pointShadowMap: [],
        pointShadowMatrix: [],
        hemi: []
    };
    var vector3 = new Vector3();
    var matrix4 = new Matrix4();
    var matrix42 = new Matrix4();
    function setup(lights, shadows, camera) {
        var r = 0, g = 0, b = 0;
        var directionalLength = 0;
        var pointLength = 0;
        var spotLength = 0;
        var rectAreaLength = 0;
        var hemiLength = 0;
        var viewMatrix = camera.matrixWorldInverse;
        for(var i = 0, l = lights.length; i < l; i++){
            var light = lights[i];
            var color = light.color;
            var intensity = light.intensity;
            var distance = light.distance;
            var shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;
            if (light.isAmbientLight) {
                r += color.r * intensity;
                g += color.g * intensity;
                b += color.b * intensity;
            } else if (light.isDirectionalLight) {
                var uniforms = cache.get(light);
                uniforms.color.copy(light.color).multiplyScalar(light.intensity);
                uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                vector3.setFromMatrixPosition(light.target.matrixWorld);
                uniforms.direction.sub(vector3);
                uniforms.direction.transformDirection(viewMatrix);
                uniforms.shadow = light.castShadow;
                if (light.castShadow) {
                    var shadow = light.shadow;
                    uniforms.shadowBias = shadow.bias;
                    uniforms.shadowRadius = shadow.radius;
                    uniforms.shadowMapSize = shadow.mapSize;
                }
                state.directionalShadowMap[directionalLength] = shadowMap;
                state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
                state.directional[directionalLength] = uniforms;
                directionalLength++;
            } else if (light.isSpotLight) {
                var uniforms = cache.get(light);
                uniforms.position.setFromMatrixPosition(light.matrixWorld);
                uniforms.position.applyMatrix4(viewMatrix);
                uniforms.color.copy(color).multiplyScalar(intensity);
                uniforms.distance = distance;
                uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                vector3.setFromMatrixPosition(light.target.matrixWorld);
                uniforms.direction.sub(vector3);
                uniforms.direction.transformDirection(viewMatrix);
                uniforms.coneCos = Math.cos(light.angle);
                uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
                uniforms.decay = light.decay;
                uniforms.shadow = light.castShadow;
                if (light.castShadow) {
                    var shadow = light.shadow;
                    uniforms.shadowBias = shadow.bias;
                    uniforms.shadowRadius = shadow.radius;
                    uniforms.shadowMapSize = shadow.mapSize;
                }
                state.spotShadowMap[spotLength] = shadowMap;
                state.spotShadowMatrix[spotLength] = light.shadow.matrix;
                state.spot[spotLength] = uniforms;
                spotLength++;
            } else if (light.isRectAreaLight) {
                var uniforms = cache.get(light);
                // (a) intensity is the total visible light emitted
                //uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );
                // (b) intensity is the brightness of the light
                uniforms.color.copy(color).multiplyScalar(intensity);
                uniforms.position.setFromMatrixPosition(light.matrixWorld);
                uniforms.position.applyMatrix4(viewMatrix);
                // extract local rotation of light to derive width/height half vectors
                matrix42.identity();
                matrix4.copy(light.matrixWorld);
                matrix4.premultiply(viewMatrix);
                matrix42.extractRotation(matrix4);
                uniforms.halfWidth.set(light.width * 0.5, 0.0, 0.0);
                uniforms.halfHeight.set(0.0, light.height * 0.5, 0.0);
                uniforms.halfWidth.applyMatrix4(matrix42);
                uniforms.halfHeight.applyMatrix4(matrix42);
                // TODO (abelnation): RectAreaLight distance?
                // uniforms.distance = distance;
                state.rectArea[rectAreaLength] = uniforms;
                rectAreaLength++;
            } else if (light.isPointLight) {
                var uniforms = cache.get(light);
                uniforms.position.setFromMatrixPosition(light.matrixWorld);
                uniforms.position.applyMatrix4(viewMatrix);
                uniforms.color.copy(light.color).multiplyScalar(light.intensity);
                uniforms.distance = light.distance;
                uniforms.decay = light.decay;
                uniforms.shadow = light.castShadow;
                if (light.castShadow) {
                    var shadow = light.shadow;
                    uniforms.shadowBias = shadow.bias;
                    uniforms.shadowRadius = shadow.radius;
                    uniforms.shadowMapSize = shadow.mapSize;
                    uniforms.shadowCameraNear = shadow.camera.near;
                    uniforms.shadowCameraFar = shadow.camera.far;
                }
                state.pointShadowMap[pointLength] = shadowMap;
                state.pointShadowMatrix[pointLength] = light.shadow.matrix;
                state.point[pointLength] = uniforms;
                pointLength++;
            } else if (light.isHemisphereLight) {
                var uniforms = cache.get(light);
                uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                uniforms.direction.transformDirection(viewMatrix);
                uniforms.direction.normalize();
                uniforms.skyColor.copy(light.color).multiplyScalar(intensity);
                uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);
                state.hemi[hemiLength] = uniforms;
                hemiLength++;
            }
        }
        state.ambient[0] = r;
        state.ambient[1] = g;
        state.ambient[2] = b;
        state.directional.length = directionalLength;
        state.spot.length = spotLength;
        state.rectArea.length = rectAreaLength;
        state.point.length = pointLength;
        state.hemi.length = hemiLength;
        state.hash.stateID = state.id;
        state.hash.directionalLength = directionalLength;
        state.hash.pointLength = pointLength;
        state.hash.spotLength = spotLength;
        state.hash.rectAreaLength = rectAreaLength;
        state.hash.hemiLength = hemiLength;
        state.hash.shadowsLength = shadows.length;
    }
    return {
        setup: setup,
        state: state
    };
}
/**
 * @author Mugen87 / https://github.com/Mugen87
 */ function WebGLRenderState() {
    var lights = new WebGLLights();
    var lightsArray = [];
    var shadowsArray = [];
    function init() {
        lightsArray.length = 0;
        shadowsArray.length = 0;
    }
    function pushLight(light) {
        lightsArray.push(light);
    }
    function pushShadow(shadowLight) {
        shadowsArray.push(shadowLight);
    }
    function setupLights(camera) {
        lights.setup(lightsArray, shadowsArray, camera);
    }
    var state = {
        lightsArray: lightsArray,
        shadowsArray: shadowsArray,
        lights: lights
    };
    return {
        init: init,
        state: state,
        setupLights: setupLights,
        pushLight: pushLight,
        pushShadow: pushShadow
    };
}
function WebGLRenderStates() {
    var renderStates = {};
    function get(scene, camera) {
        var renderState;
        if (renderStates[scene.id] === undefined) {
            renderState = new WebGLRenderState();
            renderStates[scene.id] = {};
            renderStates[scene.id][camera.id] = renderState;
        } else if (renderStates[scene.id][camera.id] === undefined) {
            renderState = new WebGLRenderState();
            renderStates[scene.id][camera.id] = renderState;
        } else renderState = renderStates[scene.id][camera.id];
        return renderState;
    }
    function dispose() {
        renderStates = {};
    }
    return {
        get: get,
        dispose: dispose
    };
}
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author bhouston / https://clara.io
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */ function MeshDepthMaterial(parameters) {
    Material.call(this);
    this.type = "MeshDepthMaterial";
    this.depthPacking = BasicDepthPacking;
    this.skinning = false;
    this.morphTargets = false;
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.lights = false;
    this.setValues(parameters);
}
MeshDepthMaterial.prototype = Object.create(Material.prototype);
MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;
MeshDepthMaterial.prototype.isMeshDepthMaterial = true;
MeshDepthMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.depthPacking = source.depthPacking;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    return this;
};
/**
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *
 *  referencePosition: <float>,
 *  nearDistance: <float>,
 *  farDistance: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>
 *
 * }
 */ function MeshDistanceMaterial(parameters) {
    Material.call(this);
    this.type = "MeshDistanceMaterial";
    this.referencePosition = new Vector3();
    this.nearDistance = 1;
    this.farDistance = 1000;
    this.skinning = false;
    this.morphTargets = false;
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.fog = false;
    this.lights = false;
    this.setValues(parameters);
}
MeshDistanceMaterial.prototype = Object.create(Material.prototype);
MeshDistanceMaterial.prototype.constructor = MeshDistanceMaterial;
MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;
MeshDistanceMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.referencePosition.copy(source.referencePosition);
    this.nearDistance = source.nearDistance;
    this.farDistance = source.farDistance;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    return this;
};
/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */ function WebGLShadowMap(_renderer, _objects, maxTextureSize) {
    var _frustum = new Frustum(), _projScreenMatrix = new Matrix4(), _shadowMapSize = new Vector2(), _maxShadowMapSize = new Vector2(maxTextureSize, maxTextureSize), _lookTarget = new Vector3(), _lightPositionWorld = new Vector3(), _MorphingFlag = 1, _SkinningFlag = 2, _NumberOfMaterialVariants = (_MorphingFlag | _SkinningFlag) + 1, _depthMaterials = new Array(_NumberOfMaterialVariants), _distanceMaterials = new Array(_NumberOfMaterialVariants), _materialCache = {};
    var shadowSide = {
        0: BackSide,
        1: FrontSide,
        2: DoubleSide
    };
    var cubeDirections = [
        new Vector3(1, 0, 0),
        new Vector3(-1, 0, 0),
        new Vector3(0, 0, 1),
        new Vector3(0, 0, -1),
        new Vector3(0, 1, 0),
        new Vector3(0, -1, 0)
    ];
    var cubeUps = [
        new Vector3(0, 1, 0),
        new Vector3(0, 1, 0),
        new Vector3(0, 1, 0),
        new Vector3(0, 1, 0),
        new Vector3(0, 0, 1),
        new Vector3(0, 0, -1)
    ];
    var cube2DViewPorts = [
        new Vector4(),
        new Vector4(),
        new Vector4(),
        new Vector4(),
        new Vector4(),
        new Vector4()
    ];
    // init
    for(var i = 0; i !== _NumberOfMaterialVariants; ++i){
        var useMorphing = (i & _MorphingFlag) !== 0;
        var useSkinning = (i & _SkinningFlag) !== 0;
        var depthMaterial = new MeshDepthMaterial({
            depthPacking: RGBADepthPacking,
            morphTargets: useMorphing,
            skinning: useSkinning
        });
        _depthMaterials[i] = depthMaterial;
        //
        var distanceMaterial = new MeshDistanceMaterial({
            morphTargets: useMorphing,
            skinning: useSkinning
        });
        _distanceMaterials[i] = distanceMaterial;
    }
    //
    var scope = this;
    this.enabled = false;
    this.autoUpdate = true;
    this.needsUpdate = false;
    this.type = PCFShadowMap;
    this.render = function(lights, scene, camera) {
        if (scope.enabled === false) return;
        if (scope.autoUpdate === false && scope.needsUpdate === false) return;
        if (lights.length === 0) return;
        // TODO Clean up (needed in case of contextlost)
        var _gl = _renderer.context;
        var _state = _renderer.state;
        // Set GL state for depth map.
        _state.disable(3042);
        _state.buffers.color.setClear(1, 1, 1, 1);
        _state.buffers.depth.setTest(true);
        _state.setScissorTest(false);
        // render depth map
        var faceCount;
        for(var i = 0, il = lights.length; i < il; i++){
            var light = lights[i];
            var shadow = light.shadow;
            var isPointLight = light && light.isPointLight;
            if (shadow === undefined) {
                console.warn("THREE.WebGLShadowMap:", light, "has no shadow.");
                continue;
            }
            var shadowCamera = shadow.camera;
            _shadowMapSize.copy(shadow.mapSize);
            _shadowMapSize.min(_maxShadowMapSize);
            if (isPointLight) {
                var vpWidth = _shadowMapSize.x;
                var vpHeight = _shadowMapSize.y;
                // These viewports map a cube-map onto a 2D texture with the
                // following orientation:
                //
                //  xzXZ
                //   y Y
                //
                // X - Positive x direction
                // x - Negative x direction
                // Y - Positive y direction
                // y - Negative y direction
                // Z - Positive z direction
                // z - Negative z direction
                // positive X
                cube2DViewPorts[0].set(vpWidth * 2, vpHeight, vpWidth, vpHeight);
                // negative X
                cube2DViewPorts[1].set(0, vpHeight, vpWidth, vpHeight);
                // positive Z
                cube2DViewPorts[2].set(vpWidth * 3, vpHeight, vpWidth, vpHeight);
                // negative Z
                cube2DViewPorts[3].set(vpWidth, vpHeight, vpWidth, vpHeight);
                // positive Y
                cube2DViewPorts[4].set(vpWidth * 3, 0, vpWidth, vpHeight);
                // negative Y
                cube2DViewPorts[5].set(vpWidth, 0, vpWidth, vpHeight);
                _shadowMapSize.x *= 4.0;
                _shadowMapSize.y *= 2.0;
            }
            if (shadow.map === null) {
                var pars = {
                    minFilter: NearestFilter,
                    magFilter: NearestFilter,
                    format: RGBAFormat
                };
                shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
                shadow.map.texture.name = light.name + ".shadowMap";
                shadowCamera.updateProjectionMatrix();
            }
            if (shadow.isSpotLightShadow) shadow.update(light);
            var shadowMap = shadow.map;
            var shadowMatrix = shadow.matrix;
            _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
            shadowCamera.position.copy(_lightPositionWorld);
            if (isPointLight) {
                faceCount = 6;
                // for point lights we set the shadow matrix to be a translation-only matrix
                // equal to inverse of the light's position
                shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);
            } else {
                faceCount = 1;
                _lookTarget.setFromMatrixPosition(light.target.matrixWorld);
                shadowCamera.lookAt(_lookTarget);
                shadowCamera.updateMatrixWorld();
                // compute shadow matrix
                shadowMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);
                shadowMatrix.multiply(shadowCamera.projectionMatrix);
                shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
            }
            _renderer.setRenderTarget(shadowMap);
            _renderer.clear();
            // render shadow map for each cube face (if omni-directional) or
            // run a single pass if not
            for(var face = 0; face < faceCount; face++){
                if (isPointLight) {
                    _lookTarget.copy(shadowCamera.position);
                    _lookTarget.add(cubeDirections[face]);
                    shadowCamera.up.copy(cubeUps[face]);
                    shadowCamera.lookAt(_lookTarget);
                    shadowCamera.updateMatrixWorld();
                    var vpDimensions = cube2DViewPorts[face];
                    _state.viewport(vpDimensions);
                }
                // update camera matrices and frustum
                _projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
                _frustum.setFromMatrix(_projScreenMatrix);
                // set object matrices & frustum culling
                renderObject(scene, camera, shadowCamera, isPointLight);
            }
        }
        scope.needsUpdate = false;
    };
    function getDepthMaterial(object, material, isPointLight, lightPositionWorld, shadowCameraNear, shadowCameraFar) {
        var geometry = object.geometry;
        var result = null;
        var materialVariants = _depthMaterials;
        var customMaterial = object.customDepthMaterial;
        if (isPointLight) {
            materialVariants = _distanceMaterials;
            customMaterial = object.customDistanceMaterial;
        }
        if (!customMaterial) {
            var useMorphing = false;
            if (material.morphTargets) {
                if (geometry && geometry.isBufferGeometry) useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;
                else if (geometry && geometry.isGeometry) useMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;
            }
            if (object.isSkinnedMesh && material.skinning === false) console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", object);
            var useSkinning = object.isSkinnedMesh && material.skinning;
            var variantIndex = 0;
            if (useMorphing) variantIndex |= _MorphingFlag;
            if (useSkinning) variantIndex |= _SkinningFlag;
            result = materialVariants[variantIndex];
        } else result = customMaterial;
        if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0) {
            // in this case we need a unique material instance reflecting the
            // appropriate state
            var keyA = result.uuid, keyB = material.uuid;
            var materialsForVariant = _materialCache[keyA];
            if (materialsForVariant === undefined) {
                materialsForVariant = {};
                _materialCache[keyA] = materialsForVariant;
            }
            var cachedMaterial = materialsForVariant[keyB];
            if (cachedMaterial === undefined) {
                cachedMaterial = result.clone();
                materialsForVariant[keyB] = cachedMaterial;
            }
            result = cachedMaterial;
        }
        result.visible = material.visible;
        result.wireframe = material.wireframe;
        result.side = material.shadowSide != null ? material.shadowSide : shadowSide[material.side];
        result.clipShadows = material.clipShadows;
        result.clippingPlanes = material.clippingPlanes;
        result.clipIntersection = material.clipIntersection;
        result.wireframeLinewidth = material.wireframeLinewidth;
        result.linewidth = material.linewidth;
        if (isPointLight && result.isMeshDistanceMaterial) {
            result.referencePosition.copy(lightPositionWorld);
            result.nearDistance = shadowCameraNear;
            result.farDistance = shadowCameraFar;
        }
        return result;
    }
    function renderObject(object, camera, shadowCamera, isPointLight) {
        if (object.visible === false) return;
        var visible = object.layers.test(camera.layers);
        if (visible && (object.isMesh || object.isLine || object.isPoints)) {
            if (object.castShadow && (!object.frustumCulled || _frustum.intersectsObject(object))) {
                object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
                var geometry = _objects.update(object);
                var material = object.material;
                if (Array.isArray(material)) {
                    var groups = geometry.groups;
                    for(var k = 0, kl = groups.length; k < kl; k++){
                        var group = groups[k];
                        var groupMaterial = material[group.materialIndex];
                        if (groupMaterial && groupMaterial.visible) {
                            var depthMaterial = getDepthMaterial(object, groupMaterial, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far);
                            _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
                        }
                    }
                } else if (material.visible) {
                    var depthMaterial = getDepthMaterial(object, material, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far);
                    _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
                }
            }
        }
        var children = object.children;
        for(var i = 0, l = children.length; i < l; i++)renderObject(children[i], camera, shadowCamera, isPointLight);
    }
}
/**
 * @author mrdoob / http://mrdoob.com/
 */ function WebGLState(gl, extensions, utils, capabilities) {
    function ColorBuffer() {
        var locked = false;
        var color = new Vector4();
        var currentColorMask = null;
        var currentColorClear = new Vector4(0, 0, 0, 0);
        return {
            setMask: function(colorMask) {
                if (currentColorMask !== colorMask && !locked) {
                    gl.colorMask(colorMask, colorMask, colorMask, colorMask);
                    currentColorMask = colorMask;
                }
            },
            setLocked: function(lock) {
                locked = lock;
            },
            setClear: function(r, g, b, a, premultipliedAlpha) {
                if (premultipliedAlpha === true) {
                    r *= a;
                    g *= a;
                    b *= a;
                }
                color.set(r, g, b, a);
                if (currentColorClear.equals(color) === false) {
                    gl.clearColor(r, g, b, a);
                    currentColorClear.copy(color);
                }
            },
            reset: function() {
                locked = false;
                currentColorMask = null;
                currentColorClear.set(-1, 0, 0, 0); // set to invalid state
            }
        };
    }
    function DepthBuffer() {
        var locked = false;
        var currentDepthMask = null;
        var currentDepthFunc = null;
        var currentDepthClear = null;
        return {
            setTest: function(depthTest) {
                if (depthTest) enable(2929);
                else disable(2929);
            },
            setMask: function(depthMask) {
                if (currentDepthMask !== depthMask && !locked) {
                    gl.depthMask(depthMask);
                    currentDepthMask = depthMask;
                }
            },
            setFunc: function(depthFunc) {
                if (currentDepthFunc !== depthFunc) {
                    if (depthFunc) switch(depthFunc){
                        case NeverDepth:
                            gl.depthFunc(512);
                            break;
                        case AlwaysDepth:
                            gl.depthFunc(519);
                            break;
                        case LessDepth:
                            gl.depthFunc(513);
                            break;
                        case LessEqualDepth:
                            gl.depthFunc(515);
                            break;
                        case EqualDepth:
                            gl.depthFunc(514);
                            break;
                        case GreaterEqualDepth:
                            gl.depthFunc(518);
                            break;
                        case GreaterDepth:
                            gl.depthFunc(516);
                            break;
                        case NotEqualDepth:
                            gl.depthFunc(517);
                            break;
                        default:
                            gl.depthFunc(515);
                    }
                    else gl.depthFunc(515);
                    currentDepthFunc = depthFunc;
                }
            },
            setLocked: function(lock) {
                locked = lock;
            },
            setClear: function(depth) {
                if (currentDepthClear !== depth) {
                    gl.clearDepth(depth);
                    currentDepthClear = depth;
                }
            },
            reset: function() {
                locked = false;
                currentDepthMask = null;
                currentDepthFunc = null;
                currentDepthClear = null;
            }
        };
    }
    function StencilBuffer() {
        var locked = false;
        var currentStencilMask = null;
        var currentStencilFunc = null;
        var currentStencilRef = null;
        var currentStencilFuncMask = null;
        var currentStencilFail = null;
        var currentStencilZFail = null;
        var currentStencilZPass = null;
        var currentStencilClear = null;
        return {
            setTest: function(stencilTest) {
                if (stencilTest) enable(2960);
                else disable(2960);
            },
            setMask: function(stencilMask) {
                if (currentStencilMask !== stencilMask && !locked) {
                    gl.stencilMask(stencilMask);
                    currentStencilMask = stencilMask;
                }
            },
            setFunc: function(stencilFunc, stencilRef, stencilMask) {
                if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
                    gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
                    currentStencilFunc = stencilFunc;
                    currentStencilRef = stencilRef;
                    currentStencilFuncMask = stencilMask;
                }
            },
            setOp: function(stencilFail, stencilZFail, stencilZPass) {
                if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
                    gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
                    currentStencilFail = stencilFail;
                    currentStencilZFail = stencilZFail;
                    currentStencilZPass = stencilZPass;
                }
            },
            setLocked: function(lock) {
                locked = lock;
            },
            setClear: function(stencil) {
                if (currentStencilClear !== stencil) {
                    gl.clearStencil(stencil);
                    currentStencilClear = stencil;
                }
            },
            reset: function() {
                locked = false;
                currentStencilMask = null;
                currentStencilFunc = null;
                currentStencilRef = null;
                currentStencilFuncMask = null;
                currentStencilFail = null;
                currentStencilZFail = null;
                currentStencilZPass = null;
                currentStencilClear = null;
            }
        };
    }
    //
    var colorBuffer = new ColorBuffer();
    var depthBuffer = new DepthBuffer();
    var stencilBuffer = new StencilBuffer();
    var maxVertexAttributes = gl.getParameter(34921);
    var newAttributes = new Uint8Array(maxVertexAttributes);
    var enabledAttributes = new Uint8Array(maxVertexAttributes);
    var attributeDivisors = new Uint8Array(maxVertexAttributes);
    var enabledCapabilities = {};
    var compressedTextureFormats = null;
    var currentProgram = null;
    var currentBlendingEnabled = null;
    var currentBlending = null;
    var currentBlendEquation = null;
    var currentBlendSrc = null;
    var currentBlendDst = null;
    var currentBlendEquationAlpha = null;
    var currentBlendSrcAlpha = null;
    var currentBlendDstAlpha = null;
    var currentPremultipledAlpha = false;
    var currentFlipSided = null;
    var currentCullFace = null;
    var currentLineWidth = null;
    var currentPolygonOffsetFactor = null;
    var currentPolygonOffsetUnits = null;
    var maxTextures = gl.getParameter(35661);
    var lineWidthAvailable = false;
    var version = 0;
    var glVersion = gl.getParameter(7938);
    if (glVersion.indexOf("WebGL") !== -1) {
        version = parseFloat(/^WebGL\ ([0-9])/.exec(glVersion)[1]);
        lineWidthAvailable = version >= 1.0;
    } else if (glVersion.indexOf("OpenGL ES") !== -1) {
        version = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(glVersion)[1]);
        lineWidthAvailable = version >= 2.0;
    }
    var currentTextureSlot = null;
    var currentBoundTextures = {};
    var currentScissor = new Vector4();
    var currentViewport = new Vector4();
    function createTexture(type, target, count) {
        var data = new Uint8Array(4); // 4 is required to match default unpack alignment of 4.
        var texture = gl.createTexture();
        gl.bindTexture(type, texture);
        gl.texParameteri(type, 10241, 9728);
        gl.texParameteri(type, 10240, 9728);
        for(var i = 0; i < count; i++)gl.texImage2D(target + i, 0, 6408, 1, 1, 0, 6408, 5121, data);
        return texture;
    }
    var emptyTextures = {};
    emptyTextures[3553] = createTexture(3553, 3553, 1);
    emptyTextures[34067] = createTexture(34067, 34069, 6);
    // init
    colorBuffer.setClear(0, 0, 0, 1);
    depthBuffer.setClear(1);
    stencilBuffer.setClear(0);
    enable(2929);
    depthBuffer.setFunc(LessEqualDepth);
    setFlipSided(false);
    setCullFace(CullFaceBack);
    enable(2884);
    setBlending(NoBlending);
    //
    function initAttributes() {
        for(var i = 0, l = newAttributes.length; i < l; i++)newAttributes[i] = 0;
    }
    function enableAttribute(attribute) {
        enableAttributeAndDivisor(attribute, 0);
    }
    function enableAttributeAndDivisor(attribute, meshPerAttribute) {
        newAttributes[attribute] = 1;
        if (enabledAttributes[attribute] === 0) {
            gl.enableVertexAttribArray(attribute);
            enabledAttributes[attribute] = 1;
        }
        if (attributeDivisors[attribute] !== meshPerAttribute) {
            var extension = capabilities.isWebGL2 ? gl : extensions.get("ANGLE_instanced_arrays");
            extension[capabilities.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](attribute, meshPerAttribute);
            attributeDivisors[attribute] = meshPerAttribute;
        }
    }
    function disableUnusedAttributes() {
        for(var i = 0, l = enabledAttributes.length; i !== l; ++i)if (enabledAttributes[i] !== newAttributes[i]) {
            gl.disableVertexAttribArray(i);
            enabledAttributes[i] = 0;
        }
    }
    function enable(id) {
        if (enabledCapabilities[id] !== true) {
            gl.enable(id);
            enabledCapabilities[id] = true;
        }
    }
    function disable(id) {
        if (enabledCapabilities[id] !== false) {
            gl.disable(id);
            enabledCapabilities[id] = false;
        }
    }
    function getCompressedTextureFormats() {
        if (compressedTextureFormats === null) {
            compressedTextureFormats = [];
            if (extensions.get("WEBGL_compressed_texture_pvrtc") || extensions.get("WEBGL_compressed_texture_s3tc") || extensions.get("WEBGL_compressed_texture_etc1") || extensions.get("WEBGL_compressed_texture_astc")) {
                var formats = gl.getParameter(34467);
                for(var i = 0; i < formats.length; i++)compressedTextureFormats.push(formats[i]);
            }
        }
        return compressedTextureFormats;
    }
    function useProgram(program) {
        if (currentProgram !== program) {
            gl.useProgram(program);
            currentProgram = program;
            return true;
        }
        return false;
    }
    function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
        if (blending === NoBlending) {
            if (currentBlendingEnabled) {
                disable(3042);
                currentBlendingEnabled = false;
            }
            return;
        }
        if (!currentBlendingEnabled) {
            enable(3042);
            currentBlendingEnabled = true;
        }
        if (blending !== CustomBlending) {
            if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
                if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
                    gl.blendEquation(32774);
                    currentBlendEquation = AddEquation;
                    currentBlendEquationAlpha = AddEquation;
                }
                if (premultipliedAlpha) switch(blending){
                    case NormalBlending:
                        gl.blendFuncSeparate(1, 771, 1, 771);
                        break;
                    case AdditiveBlending:
                        gl.blendFunc(1, 1);
                        break;
                    case SubtractiveBlending:
                        gl.blendFuncSeparate(0, 0, 769, 771);
                        break;
                    case MultiplyBlending:
                        gl.blendFuncSeparate(0, 768, 0, 770);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", blending);
                        break;
                }
                else switch(blending){
                    case NormalBlending:
                        gl.blendFuncSeparate(770, 771, 1, 771);
                        break;
                    case AdditiveBlending:
                        gl.blendFunc(770, 1);
                        break;
                    case SubtractiveBlending:
                        gl.blendFunc(0, 769);
                        break;
                    case MultiplyBlending:
                        gl.blendFunc(0, 768);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", blending);
                        break;
                }
                currentBlendSrc = null;
                currentBlendDst = null;
                currentBlendSrcAlpha = null;
                currentBlendDstAlpha = null;
                currentBlending = blending;
                currentPremultipledAlpha = premultipliedAlpha;
            }
            return;
        }
        // custom blending
        blendEquationAlpha = blendEquationAlpha || blendEquation;
        blendSrcAlpha = blendSrcAlpha || blendSrc;
        blendDstAlpha = blendDstAlpha || blendDst;
        if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
            gl.blendEquationSeparate(utils.convert(blendEquation), utils.convert(blendEquationAlpha));
            currentBlendEquation = blendEquation;
            currentBlendEquationAlpha = blendEquationAlpha;
        }
        if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
            gl.blendFuncSeparate(utils.convert(blendSrc), utils.convert(blendDst), utils.convert(blendSrcAlpha), utils.convert(blendDstAlpha));
            currentBlendSrc = blendSrc;
            currentBlendDst = blendDst;
            currentBlendSrcAlpha = blendSrcAlpha;
            currentBlendDstAlpha = blendDstAlpha;
        }
        currentBlending = blending;
        currentPremultipledAlpha = null;
    }
    function setMaterial(material, frontFaceCW) {
        material.side === DoubleSide ? disable(2884) : enable(2884);
        var flipSided = material.side === BackSide;
        if (frontFaceCW) flipSided = !flipSided;
        setFlipSided(flipSided);
        material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
        depthBuffer.setFunc(material.depthFunc);
        depthBuffer.setTest(material.depthTest);
        depthBuffer.setMask(material.depthWrite);
        colorBuffer.setMask(material.colorWrite);
        setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
    }
    //
    function setFlipSided(flipSided) {
        if (currentFlipSided !== flipSided) {
            if (flipSided) gl.frontFace(2304);
            else gl.frontFace(2305);
            currentFlipSided = flipSided;
        }
    }
    function setCullFace(cullFace) {
        if (cullFace !== CullFaceNone) {
            enable(2884);
            if (cullFace !== currentCullFace) {
                if (cullFace === CullFaceBack) gl.cullFace(1029);
                else if (cullFace === CullFaceFront) gl.cullFace(1028);
                else gl.cullFace(1032);
            }
        } else disable(2884);
        currentCullFace = cullFace;
    }
    function setLineWidth(width) {
        if (width !== currentLineWidth) {
            if (lineWidthAvailable) gl.lineWidth(width);
            currentLineWidth = width;
        }
    }
    function setPolygonOffset(polygonOffset, factor, units) {
        if (polygonOffset) {
            enable(32823);
            if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
                gl.polygonOffset(factor, units);
                currentPolygonOffsetFactor = factor;
                currentPolygonOffsetUnits = units;
            }
        } else disable(32823);
    }
    function setScissorTest(scissorTest) {
        if (scissorTest) enable(3089);
        else disable(3089);
    }
    // texture
    function activeTexture(webglSlot) {
        if (webglSlot === undefined) webglSlot = 33984 + maxTextures - 1;
        if (currentTextureSlot !== webglSlot) {
            gl.activeTexture(webglSlot);
            currentTextureSlot = webglSlot;
        }
    }
    function bindTexture(webglType, webglTexture) {
        if (currentTextureSlot === null) activeTexture();
        var boundTexture = currentBoundTextures[currentTextureSlot];
        if (boundTexture === undefined) {
            boundTexture = {
                type: undefined,
                texture: undefined
            };
            currentBoundTextures[currentTextureSlot] = boundTexture;
        }
        if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
            gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
            boundTexture.type = webglType;
            boundTexture.texture = webglTexture;
        }
    }
    function compressedTexImage2D() {
        try {
            gl.compressedTexImage2D.apply(gl, arguments);
        } catch (error) {
            console.error("THREE.WebGLState:", error);
        }
    }
    function texImage2D() {
        try {
            gl.texImage2D.apply(gl, arguments);
        } catch (error) {
            console.error("THREE.WebGLState:", error);
        }
    }
    function texImage3D() {
        try {
            gl.texImage3D.apply(gl, arguments);
        } catch (error) {
            console.error("THREE.WebGLState:", error);
        }
    }
    //
    function scissor(scissor) {
        if (currentScissor.equals(scissor) === false) {
            gl.scissor(scissor.x, scissor.y, scissor.z, scissor.w);
            currentScissor.copy(scissor);
        }
    }
    function viewport(viewport) {
        if (currentViewport.equals(viewport) === false) {
            gl.viewport(viewport.x, viewport.y, viewport.z, viewport.w);
            currentViewport.copy(viewport);
        }
    }
    //
    function reset() {
        for(var i = 0; i < enabledAttributes.length; i++)if (enabledAttributes[i] === 1) {
            gl.disableVertexAttribArray(i);
            enabledAttributes[i] = 0;
        }
        enabledCapabilities = {};
        compressedTextureFormats = null;
        currentTextureSlot = null;
        currentBoundTextures = {};
        currentProgram = null;
        currentBlending = null;
        currentFlipSided = null;
        currentCullFace = null;
        colorBuffer.reset();
        depthBuffer.reset();
        stencilBuffer.reset();
    }
    return {
        buffers: {
            color: colorBuffer,
            depth: depthBuffer,
            stencil: stencilBuffer
        },
        initAttributes: initAttributes,
        enableAttribute: enableAttribute,
        enableAttributeAndDivisor: enableAttributeAndDivisor,
        disableUnusedAttributes: disableUnusedAttributes,
        enable: enable,
        disable: disable,
        getCompressedTextureFormats: getCompressedTextureFormats,
        useProgram: useProgram,
        setBlending: setBlending,
        setMaterial: setMaterial,
        setFlipSided: setFlipSided,
        setCullFace: setCullFace,
        setLineWidth: setLineWidth,
        setPolygonOffset: setPolygonOffset,
        setScissorTest: setScissorTest,
        activeTexture: activeTexture,
        bindTexture: bindTexture,
        compressedTexImage2D: compressedTexImage2D,
        texImage2D: texImage2D,
        texImage3D: texImage3D,
        scissor: scissor,
        viewport: viewport,
        reset: reset
    };
}
/**
 * @author mrdoob / http://mrdoob.com/
 */ function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
    var _videoTextures = {};
    var _canvas;
    //
    function clampToMaxSize(image, maxSize) {
        if (image.width > maxSize || image.height > maxSize) {
            if ("data" in image) {
                console.warn("THREE.WebGLRenderer: image in DataTexture is too big (" + image.width + "x" + image.height + ").");
                return;
            }
            // Warning: Scaling through the canvas will only work with images that use
            // premultiplied alpha.
            var scale = maxSize / Math.max(image.width, image.height);
            var canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
            canvas.width = Math.floor(image.width * scale);
            canvas.height = Math.floor(image.height * scale);
            var context = canvas.getContext("2d");
            context.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);
            console.warn("THREE.WebGLRenderer: image is too big (" + image.width + "x" + image.height + "). Resized to " + canvas.width + "x" + canvas.height);
            return canvas;
        }
        return image;
    }
    function isPowerOfTwo(image) {
        return _Math.isPowerOfTwo(image.width) && _Math.isPowerOfTwo(image.height);
    }
    function makePowerOfTwo(image) {
        if (image instanceof HTMLImageElement || image instanceof HTMLCanvasElement || image instanceof ImageBitmap) {
            if (_canvas === undefined) _canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
            _canvas.width = _Math.floorPowerOfTwo(image.width);
            _canvas.height = _Math.floorPowerOfTwo(image.height);
            var context = _canvas.getContext("2d");
            context.drawImage(image, 0, 0, _canvas.width, _canvas.height);
            console.warn("THREE.WebGLRenderer: image is not power of two (" + image.width + "x" + image.height + "). Resized to " + _canvas.width + "x" + _canvas.height);
            return _canvas;
        }
        return image;
    }
    function textureNeedsPowerOfTwo(texture) {
        if (capabilities.isWebGL2) return false;
        return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
    }
    function textureNeedsGenerateMipmaps(texture, isPowerOfTwo) {
        return texture.generateMipmaps && isPowerOfTwo && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
    }
    function generateMipmap(target, texture, width, height) {
        _gl.generateMipmap(target);
        var textureProperties = properties.get(texture);
        // Note: Math.log( x ) * Math.LOG2E used instead of Math.log2( x ) which is not supported by IE11
        textureProperties.__maxMipLevel = Math.log(Math.max(width, height)) * Math.LOG2E;
    }
    function getInternalFormat(glFormat, glType) {
        if (!capabilities.isWebGL2) return glFormat;
        if (glFormat === 6403) {
            if (glType === 5126) return 33326;
            if (glType === 5131) return 33325;
            if (glType === 5121) return 33321;
        }
        if (glFormat === 6407) {
            if (glType === 5126) return 34837;
            if (glType === 5131) return 34843;
            if (glType === 5121) return 32849;
        }
        if (glFormat === 6408) {
            if (glType === 5126) return 34836;
            if (glType === 5131) return 34842;
            if (glType === 5121) return 32856;
        }
        return glFormat;
    }
    // Fallback filters for non-power-of-2 textures
    function filterFallback(f) {
        if (f === NearestFilter || f === NearestMipMapNearestFilter || f === NearestMipMapLinearFilter) return 9728;
        return 9729;
    }
    //
    function onTextureDispose(event) {
        var texture = event.target;
        texture.removeEventListener("dispose", onTextureDispose);
        deallocateTexture(texture);
        if (texture.isVideoTexture) delete _videoTextures[texture.id];
        info.memory.textures--;
    }
    function onRenderTargetDispose(event) {
        var renderTarget = event.target;
        renderTarget.removeEventListener("dispose", onRenderTargetDispose);
        deallocateRenderTarget(renderTarget);
        info.memory.textures--;
    }
    //
    function deallocateTexture(texture) {
        var textureProperties = properties.get(texture);
        if (texture.image && textureProperties.__image__webglTextureCube) // cube texture
        _gl.deleteTexture(textureProperties.__image__webglTextureCube);
        else {
            // 2D texture
            if (textureProperties.__webglInit === undefined) return;
            _gl.deleteTexture(textureProperties.__webglTexture);
        }
        // remove all webgl properties
        properties.remove(texture);
    }
    function deallocateRenderTarget(renderTarget) {
        var renderTargetProperties = properties.get(renderTarget);
        var textureProperties = properties.get(renderTarget.texture);
        if (!renderTarget) return;
        if (textureProperties.__webglTexture !== undefined) _gl.deleteTexture(textureProperties.__webglTexture);
        if (renderTarget.depthTexture) renderTarget.depthTexture.dispose();
        if (renderTarget.isWebGLRenderTargetCube) for(var i = 0; i < 6; i++){
            _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);
            if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);
        }
        else {
            _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
            if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
        }
        properties.remove(renderTarget.texture);
        properties.remove(renderTarget);
    }
    //
    function setTexture2D(texture, slot) {
        var textureProperties = properties.get(texture);
        if (texture.isVideoTexture) updateVideoTexture(texture);
        if (texture.version > 0 && textureProperties.__version !== texture.version) {
            var image = texture.image;
            if (image === undefined) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
            else if (image.complete === false) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
            else {
                uploadTexture(textureProperties, texture, slot);
                return;
            }
        }
        state.activeTexture(33984 + slot);
        state.bindTexture(3553, textureProperties.__webglTexture);
    }
    function setTexture3D(texture, slot) {
        var textureProperties = properties.get(texture);
        if (texture.version > 0 && textureProperties.__version !== texture.version) {
            uploadTexture(textureProperties, texture, slot);
            return;
        }
        state.activeTexture(33984 + slot);
        state.bindTexture(32879, textureProperties.__webglTexture);
    }
    function setTextureCube(texture, slot) {
        var textureProperties = properties.get(texture);
        if (texture.image.length === 6) {
            if (texture.version > 0 && textureProperties.__version !== texture.version) {
                if (!textureProperties.__image__webglTextureCube) {
                    texture.addEventListener("dispose", onTextureDispose);
                    textureProperties.__image__webglTextureCube = _gl.createTexture();
                    info.memory.textures++;
                }
                state.activeTexture(33984 + slot);
                state.bindTexture(34067, textureProperties.__image__webglTextureCube);
                _gl.pixelStorei(37440, texture.flipY);
                var isCompressed = texture && texture.isCompressedTexture;
                var isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
                var cubeImage = [];
                for(var i = 0; i < 6; i++)if (!isCompressed && !isDataTexture) cubeImage[i] = clampToMaxSize(texture.image[i], capabilities.maxCubemapSize);
                else cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];
                var image = cubeImage[0], isPowerOfTwoImage = isPowerOfTwo(image), glFormat = utils.convert(texture.format), glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(glFormat, glType);
                setTextureParameters(34067, texture, isPowerOfTwoImage);
                for(var i = 0; i < 6; i++)if (!isCompressed) {
                    if (isDataTexture) state.texImage2D(34069 + i, 0, glInternalFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);
                    else state.texImage2D(34069 + i, 0, glInternalFormat, glFormat, glType, cubeImage[i]);
                } else {
                    var mipmap, mipmaps = cubeImage[i].mipmaps;
                    for(var j = 0, jl = mipmaps.length; j < jl; j++){
                        mipmap = mipmaps[j];
                        if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
                            if (state.getCompressedTextureFormats().indexOf(glFormat) > -1) state.compressedTexImage2D(34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                            else console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()");
                        } else state.texImage2D(34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                    }
                }
                if (!isCompressed) textureProperties.__maxMipLevel = 0;
                else textureProperties.__maxMipLevel = mipmaps.length - 1;
                if (textureNeedsGenerateMipmaps(texture, isPowerOfTwoImage)) // We assume images for cube map have the same size.
                generateMipmap(34067, texture, image.width, image.height);
                textureProperties.__version = texture.version;
                if (texture.onUpdate) texture.onUpdate(texture);
            } else {
                state.activeTexture(33984 + slot);
                state.bindTexture(34067, textureProperties.__image__webglTextureCube);
            }
        }
    }
    function setTextureCubeDynamic(texture, slot) {
        state.activeTexture(33984 + slot);
        state.bindTexture(34067, properties.get(texture).__webglTexture);
    }
    function setTextureParameters(textureType, texture, isPowerOfTwoImage) {
        var extension;
        if (isPowerOfTwoImage) {
            _gl.texParameteri(textureType, 10242, utils.convert(texture.wrapS));
            _gl.texParameteri(textureType, 10243, utils.convert(texture.wrapT));
            _gl.texParameteri(textureType, 10240, utils.convert(texture.magFilter));
            _gl.texParameteri(textureType, 10241, utils.convert(texture.minFilter));
        } else {
            _gl.texParameteri(textureType, 10242, 33071);
            _gl.texParameteri(textureType, 10243, 33071);
            if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.");
            _gl.texParameteri(textureType, 10240, filterFallback(texture.magFilter));
            _gl.texParameteri(textureType, 10241, filterFallback(texture.minFilter));
            if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.");
        }
        extension = extensions.get("EXT_texture_filter_anisotropic");
        if (extension) {
            if (texture.type === FloatType && extensions.get("OES_texture_float_linear") === null) return;
            if (texture.type === HalfFloatType && (capabilities.isWebGL2 || extensions.get("OES_texture_half_float_linear")) === null) return;
            if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
                _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
                properties.get(texture).__currentAnisotropy = texture.anisotropy;
            }
        }
    }
    function uploadTexture(textureProperties, texture, slot) {
        var textureType;
        if (texture.isDataTexture3D) textureType = 32879;
        else textureType = 3553;
        if (textureProperties.__webglInit === undefined) {
            textureProperties.__webglInit = true;
            texture.addEventListener("dispose", onTextureDispose);
            textureProperties.__webglTexture = _gl.createTexture();
            info.memory.textures++;
        }
        state.activeTexture(33984 + slot);
        state.bindTexture(textureType, textureProperties.__webglTexture);
        _gl.pixelStorei(37440, texture.flipY);
        _gl.pixelStorei(37441, texture.premultiplyAlpha);
        _gl.pixelStorei(3317, texture.unpackAlignment);
        var image = clampToMaxSize(texture.image, capabilities.maxTextureSize);
        if (textureNeedsPowerOfTwo(texture) && isPowerOfTwo(image) === false) image = makePowerOfTwo(image);
        var isPowerOfTwoImage = isPowerOfTwo(image), glFormat = utils.convert(texture.format), glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(glFormat, glType);
        setTextureParameters(textureType, texture, isPowerOfTwoImage);
        var mipmap, mipmaps = texture.mipmaps;
        if (texture.isDepthTexture) {
            // populate depth texture with dummy data
            glInternalFormat = 6402;
            if (texture.type === FloatType) {
                if (!capabilities.isWebGL2) throw new Error("Float Depth Texture only supported in WebGL2.0");
                glInternalFormat = 36012;
            } else if (capabilities.isWebGL2) // WebGL 2.0 requires signed internalformat for glTexImage2D
            glInternalFormat = 33189;
            if (texture.format === DepthFormat && glInternalFormat === 6402) // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
            // DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
            // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
            {
                if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
                    console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.");
                    texture.type = UnsignedShortType;
                    glType = utils.convert(texture.type);
                }
            }
            // Depth stencil textures need the DEPTH_STENCIL internal format
            // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
            if (texture.format === DepthStencilFormat) {
                glInternalFormat = 34041;
                // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
                // DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
                // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
                if (texture.type !== UnsignedInt248Type) {
                    console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.");
                    texture.type = UnsignedInt248Type;
                    glType = utils.convert(texture.type);
                }
            }
            state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
        } else if (texture.isDataTexture) {
            // use manually created mipmaps if available
            // if there are no manual mipmaps
            // set 0 level mipmap and then use GL to generate other mipmap levels
            if (mipmaps.length > 0 && isPowerOfTwoImage) {
                for(var i = 0, il = mipmaps.length; i < il; i++){
                    mipmap = mipmaps[i];
                    state.texImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                }
                texture.generateMipmaps = false;
                textureProperties.__maxMipLevel = mipmaps.length - 1;
            } else {
                state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
                textureProperties.__maxMipLevel = 0;
            }
        } else if (texture.isCompressedTexture) {
            for(var i = 0, il = mipmaps.length; i < il; i++){
                mipmap = mipmaps[i];
                if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
                    if (state.getCompressedTextureFormats().indexOf(glFormat) > -1) state.compressedTexImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                    else console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
                } else state.texImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
            }
            textureProperties.__maxMipLevel = mipmaps.length - 1;
        } else if (texture.isDataTexture3D) {
            state.texImage3D(32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
            textureProperties.__maxMipLevel = 0;
        } else // regular Texture (image, video, canvas)
        // use manually created mipmaps if available
        // if there are no manual mipmaps
        // set 0 level mipmap and then use GL to generate other mipmap levels
        if (mipmaps.length > 0 && isPowerOfTwoImage) {
            for(var i = 0, il = mipmaps.length; i < il; i++){
                mipmap = mipmaps[i];
                state.texImage2D(3553, i, glInternalFormat, glFormat, glType, mipmap);
            }
            texture.generateMipmaps = false;
            textureProperties.__maxMipLevel = mipmaps.length - 1;
        } else {
            state.texImage2D(3553, 0, glInternalFormat, glFormat, glType, image);
            textureProperties.__maxMipLevel = 0;
        }
        if (textureNeedsGenerateMipmaps(texture, isPowerOfTwoImage)) generateMipmap(3553, texture, image.width, image.height);
        textureProperties.__version = texture.version;
        if (texture.onUpdate) texture.onUpdate(texture);
    }
    // Render targets
    // Setup storage for target texture and bind it to correct framebuffer
    function setupFrameBufferTexture(framebuffer, renderTarget, attachment, textureTarget) {
        var glFormat = utils.convert(renderTarget.texture.format);
        var glType = utils.convert(renderTarget.texture.type);
        var glInternalFormat = getInternalFormat(glFormat, glType);
        state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
        _gl.bindFramebuffer(36160, framebuffer);
        _gl.framebufferTexture2D(36160, attachment, textureTarget, properties.get(renderTarget.texture).__webglTexture, 0);
        _gl.bindFramebuffer(36160, null);
    }
    // Setup storage for internal depth/stencil buffers and bind to correct framebuffer
    function setupRenderBufferStorage(renderbuffer, renderTarget) {
        _gl.bindRenderbuffer(36161, renderbuffer);
        if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
            _gl.renderbufferStorage(36161, 33189, renderTarget.width, renderTarget.height);
            _gl.framebufferRenderbuffer(36160, 36096, 36161, renderbuffer);
        } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
            _gl.renderbufferStorage(36161, 34041, renderTarget.width, renderTarget.height);
            _gl.framebufferRenderbuffer(36160, 33306, 36161, renderbuffer);
        } else // FIXME: We don't support !depth !stencil
        _gl.renderbufferStorage(36161, 32854, renderTarget.width, renderTarget.height);
        _gl.bindRenderbuffer(36161, null);
    }
    // Setup resources for a Depth Texture for a FBO (needs an extension)
    function setupDepthTexture(framebuffer, renderTarget) {
        var isCube = renderTarget && renderTarget.isWebGLRenderTargetCube;
        if (isCube) throw new Error("Depth Texture with cube render targets is not supported");
        _gl.bindFramebuffer(36160, framebuffer);
        if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
        // upload an empty depth texture with framebuffer size
        if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
            renderTarget.depthTexture.image.width = renderTarget.width;
            renderTarget.depthTexture.image.height = renderTarget.height;
            renderTarget.depthTexture.needsUpdate = true;
        }
        setTexture2D(renderTarget.depthTexture, 0);
        var webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
        if (renderTarget.depthTexture.format === DepthFormat) _gl.framebufferTexture2D(36160, 36096, 3553, webglDepthTexture, 0);
        else if (renderTarget.depthTexture.format === DepthStencilFormat) _gl.framebufferTexture2D(36160, 33306, 3553, webglDepthTexture, 0);
        else throw new Error("Unknown depthTexture format");
    }
    // Setup GL resources for a non-texture depth buffer
    function setupDepthRenderbuffer(renderTarget) {
        var renderTargetProperties = properties.get(renderTarget);
        var isCube = renderTarget.isWebGLRenderTargetCube === true;
        if (renderTarget.depthTexture) {
            if (isCube) throw new Error("target.depthTexture not supported in Cube render targets");
            setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
        } else if (isCube) {
            renderTargetProperties.__webglDepthbuffer = [];
            for(var i = 0; i < 6; i++){
                _gl.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer[i]);
                renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();
                setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget);
            }
        } else {
            _gl.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer);
            renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
            setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget);
        }
        _gl.bindFramebuffer(36160, null);
    }
    // Set up GL resources for the render target
    function setupRenderTarget(renderTarget) {
        var renderTargetProperties = properties.get(renderTarget);
        var textureProperties = properties.get(renderTarget.texture);
        renderTarget.addEventListener("dispose", onRenderTargetDispose);
        textureProperties.__webglTexture = _gl.createTexture();
        info.memory.textures++;
        var isCube = renderTarget.isWebGLRenderTargetCube === true;
        var isTargetPowerOfTwo = isPowerOfTwo(renderTarget);
        // Setup framebuffer
        if (isCube) {
            renderTargetProperties.__webglFramebuffer = [];
            for(var i = 0; i < 6; i++)renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();
        } else renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
        // Setup color buffer
        if (isCube) {
            state.bindTexture(34067, textureProperties.__webglTexture);
            setTextureParameters(34067, renderTarget.texture, isTargetPowerOfTwo);
            for(var i = 0; i < 6; i++)setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, 36064, 34069 + i);
            if (textureNeedsGenerateMipmaps(renderTarget.texture, isTargetPowerOfTwo)) generateMipmap(34067, renderTarget.texture, renderTarget.width, renderTarget.height);
            state.bindTexture(34067, null);
        } else {
            state.bindTexture(3553, textureProperties.__webglTexture);
            setTextureParameters(3553, renderTarget.texture, isTargetPowerOfTwo);
            setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, 36064, 3553);
            if (textureNeedsGenerateMipmaps(renderTarget.texture, isTargetPowerOfTwo)) generateMipmap(3553, renderTarget.texture, renderTarget.width, renderTarget.height);
            state.bindTexture(3553, null);
        }
        // Setup depth and stencil buffers
        if (renderTarget.depthBuffer) setupDepthRenderbuffer(renderTarget);
    }
    function updateRenderTargetMipmap(renderTarget) {
        var texture = renderTarget.texture;
        var isTargetPowerOfTwo = isPowerOfTwo(renderTarget);
        if (textureNeedsGenerateMipmaps(texture, isTargetPowerOfTwo)) {
            var target = renderTarget.isWebGLRenderTargetCube ? 34067 : 3553;
            var webglTexture = properties.get(texture).__webglTexture;
            state.bindTexture(target, webglTexture);
            generateMipmap(target, texture, renderTarget.width, renderTarget.height);
            state.bindTexture(target, null);
        }
    }
    function updateVideoTexture(texture) {
        var id = texture.id;
        var frame = info.render.frame;
        // Check the last frame we updated the VideoTexture
        if (_videoTextures[id] !== frame) {
            _videoTextures[id] = frame;
            texture.update();
        }
    }
    this.setTexture2D = setTexture2D;
    this.setTexture3D = setTexture3D;
    this.setTextureCube = setTextureCube;
    this.setTextureCubeDynamic = setTextureCubeDynamic;
    this.setupRenderTarget = setupRenderTarget;
    this.updateRenderTargetMipmap = updateRenderTargetMipmap;
}
/**
 * @author thespite / http://www.twitter.com/thespite
 */ function WebGLUtils(gl, extensions, capabilities) {
    function convert(p) {
        var extension;
        if (p === RepeatWrapping) return 10497;
        if (p === ClampToEdgeWrapping) return 33071;
        if (p === MirroredRepeatWrapping) return 33648;
        if (p === NearestFilter) return 9728;
        if (p === NearestMipMapNearestFilter) return 9984;
        if (p === NearestMipMapLinearFilter) return 9986;
        if (p === LinearFilter) return 9729;
        if (p === LinearMipMapNearestFilter) return 9985;
        if (p === LinearMipMapLinearFilter) return 9987;
        if (p === UnsignedByteType) return 5121;
        if (p === UnsignedShort4444Type) return 32819;
        if (p === UnsignedShort5551Type) return 32820;
        if (p === UnsignedShort565Type) return 33635;
        if (p === ByteType) return 5120;
        if (p === ShortType) return 5122;
        if (p === UnsignedShortType) return 5123;
        if (p === IntType) return 5124;
        if (p === UnsignedIntType) return 5125;
        if (p === FloatType) return 5126;
        if (p === HalfFloatType) {
            if (capabilities.isWebGL2) return 5131;
            extension = extensions.get("OES_texture_half_float");
            if (extension !== null) return extension.HALF_FLOAT_OES;
        }
        if (p === AlphaFormat) return 6406;
        if (p === RGBFormat) return 6407;
        if (p === RGBAFormat) return 6408;
        if (p === LuminanceFormat) return 6409;
        if (p === LuminanceAlphaFormat) return 6410;
        if (p === DepthFormat) return 6402;
        if (p === DepthStencilFormat) return 34041;
        if (p === RedFormat) return 6403;
        if (p === AddEquation) return 32774;
        if (p === SubtractEquation) return 32778;
        if (p === ReverseSubtractEquation) return 32779;
        if (p === ZeroFactor) return 0;
        if (p === OneFactor) return 1;
        if (p === SrcColorFactor) return 768;
        if (p === OneMinusSrcColorFactor) return 769;
        if (p === SrcAlphaFactor) return 770;
        if (p === OneMinusSrcAlphaFactor) return 771;
        if (p === DstAlphaFactor) return 772;
        if (p === OneMinusDstAlphaFactor) return 773;
        if (p === DstColorFactor) return 774;
        if (p === OneMinusDstColorFactor) return 775;
        if (p === SrcAlphaSaturateFactor) return 776;
        if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {
            extension = extensions.get("WEBGL_compressed_texture_s3tc");
            if (extension !== null) {
                if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
            }
        }
        if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {
            extension = extensions.get("WEBGL_compressed_texture_pvrtc");
            if (extension !== null) {
                if (p === RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (p === RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (p === RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (p === RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
            }
        }
        if (p === RGB_ETC1_Format) {
            extension = extensions.get("WEBGL_compressed_texture_etc1");
            if (extension !== null) return extension.COMPRESSED_RGB_ETC1_WEBGL;
        }
        if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format) {
            extension = extensions.get("WEBGL_compressed_texture_astc");
            if (extension !== null) return p;
        }
        if (p === MinEquation || p === MaxEquation) {
            if (capabilities.isWebGL2) {
                if (p === MinEquation) return 32775;
                if (p === MaxEquation) return 32776;
            }
            extension = extensions.get("EXT_blend_minmax");
            if (extension !== null) {
                if (p === MinEquation) return extension.MIN_EXT;
                if (p === MaxEquation) return extension.MAX_EXT;
            }
        }
        if (p === UnsignedInt248Type) {
            if (capabilities.isWebGL2) return 34042;
            extension = extensions.get("WEBGL_depth_texture");
            if (extension !== null) return extension.UNSIGNED_INT_24_8_WEBGL;
        }
        return 0;
    }
    return {
        convert: convert
    };
}
/**
 * @author mrdoob / http://mrdoob.com/
 */ function Group() {
    Object3D.call(this);
    this.type = "Group";
}
Group.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Group,
    isGroup: true
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author WestLangley / http://github.com/WestLangley
*/ function Camera() {
    Object3D.call(this);
    this.type = "Camera";
    this.matrixWorldInverse = new Matrix4();
    this.projectionMatrix = new Matrix4();
    this.projectionMatrixInverse = new Matrix4();
}
Camera.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Camera,
    isCamera: true,
    copy: function(source, recursive) {
        Object3D.prototype.copy.call(this, source, recursive);
        this.matrixWorldInverse.copy(source.matrixWorldInverse);
        this.projectionMatrix.copy(source.projectionMatrix);
        this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
        return this;
    },
    getWorldDirection: function(target) {
        if (target === undefined) {
            console.warn("THREE.Camera: .getWorldDirection() target is now required");
            target = new Vector3();
        }
        this.updateMatrixWorld(true);
        var e = this.matrixWorld.elements;
        return target.set(-e[8], -e[9], -e[10]).normalize();
    },
    updateMatrixWorld: function(force) {
        Object3D.prototype.updateMatrixWorld.call(this, force);
        this.matrixWorldInverse.getInverse(this.matrixWorld);
    },
    clone: function() {
        return new this.constructor().copy(this);
    }
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author greggman / http://games.greggman.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author tschw
 */ function PerspectiveCamera(fov, aspect, near, far) {
    Camera.call(this);
    this.type = "PerspectiveCamera";
    this.fov = fov !== undefined ? fov : 50;
    this.zoom = 1;
    this.near = near !== undefined ? near : 0.1;
    this.far = far !== undefined ? far : 2000;
    this.focus = 10;
    this.aspect = aspect !== undefined ? aspect : 1;
    this.view = null;
    this.filmGauge = 35; // width of the film (default in millimeters)
    this.filmOffset = 0; // horizontal film offset (same unit as gauge)
    this.updateProjectionMatrix();
}
PerspectiveCamera.prototype = Object.assign(Object.create(Camera.prototype), {
    constructor: PerspectiveCamera,
    isPerspectiveCamera: true,
    copy: function(source, recursive) {
        Camera.prototype.copy.call(this, source, recursive);
        this.fov = source.fov;
        this.zoom = source.zoom;
        this.near = source.near;
        this.far = source.far;
        this.focus = source.focus;
        this.aspect = source.aspect;
        this.view = source.view === null ? null : Object.assign({}, source.view);
        this.filmGauge = source.filmGauge;
        this.filmOffset = source.filmOffset;
        return this;
    },
    /**
	 * Sets the FOV by focal length in respect to the current .filmGauge.
	 *
	 * The default film gauge is 35, so that the focal length can be specified for
	 * a 35mm (full frame) camera.
	 *
	 * Values for focal length and film gauge must have the same unit.
	 */ setFocalLength: function(focalLength) {
        // see http://www.bobatkins.com/photography/technical/field_of_view.html
        var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
        this.fov = _Math.RAD2DEG * 2 * Math.atan(vExtentSlope);
        this.updateProjectionMatrix();
    },
    /**
	 * Calculates the focal length from the current .fov and .filmGauge.
	 */ getFocalLength: function() {
        var vExtentSlope = Math.tan(_Math.DEG2RAD * 0.5 * this.fov);
        return 0.5 * this.getFilmHeight() / vExtentSlope;
    },
    getEffectiveFOV: function() {
        return _Math.RAD2DEG * 2 * Math.atan(Math.tan(_Math.DEG2RAD * 0.5 * this.fov) / this.zoom);
    },
    getFilmWidth: function() {
        // film not completely covered in portrait format (aspect < 1)
        return this.filmGauge * Math.min(this.aspect, 1);
    },
    getFilmHeight: function() {
        // film not completely covered in landscape format (aspect > 1)
        return this.filmGauge / Math.max(this.aspect, 1);
    },
    /**
	 * Sets an offset in a larger frustum. This is useful for multi-window or
	 * multi-monitor/multi-machine setups.
	 *
	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
	 * the monitors are in grid like this
	 *
	 *   +---+---+---+
	 *   | A | B | C |
	 *   +---+---+---+
	 *   | D | E | F |
	 *   +---+---+---+
	 *
	 * then for each monitor you would call it like this
	 *
	 *   var w = 1920;
	 *   var h = 1080;
	 *   var fullWidth = w * 3;
	 *   var fullHeight = h * 2;
	 *
	 *   --A--
	 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
	 *   --B--
	 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
	 *   --C--
	 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
	 *   --D--
	 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
	 *   --E--
	 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
	 *   --F--
	 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
	 *
	 *   Note there is no reason monitors have to be the same size or in a grid.
	 */ setViewOffset: function(fullWidth, fullHeight, x, y, width, height) {
        this.aspect = fullWidth / fullHeight;
        if (this.view === null) this.view = {
            enabled: true,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        };
        this.view.enabled = true;
        this.view.fullWidth = fullWidth;
        this.view.fullHeight = fullHeight;
        this.view.offsetX = x;
        this.view.offsetY = y;
        this.view.width = width;
        this.view.height = height;
        this.updateProjectionMatrix();
    },
    clearViewOffset: function() {
        if (this.view !== null) this.view.enabled = false;
        this.updateProjectionMatrix();
    },
    updateProjectionMatrix: function() {
        var near = this.near, top = near * Math.tan(_Math.DEG2RAD * 0.5 * this.fov) / this.zoom, height = 2 * top, width = this.aspect * height, left = -0.5 * width, view = this.view;
        if (this.view !== null && this.view.enabled) {
            var fullWidth = view.fullWidth, fullHeight = view.fullHeight;
            left += view.offsetX * width / fullWidth;
            top -= view.offsetY * height / fullHeight;
            width *= view.width / fullWidth;
            height *= view.height / fullHeight;
        }
        var skew = this.filmOffset;
        if (skew !== 0) left += near * skew / this.getFilmWidth();
        this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
        this.projectionMatrixInverse.getInverse(this.projectionMatrix);
    },
    toJSON: function(meta) {
        var data = Object3D.prototype.toJSON.call(this, meta);
        data.object.fov = this.fov;
        data.object.zoom = this.zoom;
        data.object.near = this.near;
        data.object.far = this.far;
        data.object.focus = this.focus;
        data.object.aspect = this.aspect;
        if (this.view !== null) data.object.view = Object.assign({}, this.view);
        data.object.filmGauge = this.filmGauge;
        data.object.filmOffset = this.filmOffset;
        return data;
    }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */ function ArrayCamera(array) {
    PerspectiveCamera.call(this);
    this.cameras = array || [];
}
ArrayCamera.prototype = Object.assign(Object.create(PerspectiveCamera.prototype), {
    constructor: ArrayCamera,
    isArrayCamera: true
});
/**
 * @author jsantell / https://www.jsantell.com/
 * @author mrdoob / http://mrdoob.com/
 */ var cameraLPos = new Vector3();
var cameraRPos = new Vector3();
/**
 * Assumes 2 cameras that are parallel and share an X-axis, and that
 * the cameras' projection and world matrices have already been set.
 * And that near and far planes are identical for both cameras.
 * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
 */ function setProjectionFromUnion(camera, cameraL, cameraR) {
    cameraLPos.setFromMatrixPosition(cameraL.matrixWorld);
    cameraRPos.setFromMatrixPosition(cameraR.matrixWorld);
    var ipd = cameraLPos.distanceTo(cameraRPos);
    var projL = cameraL.projectionMatrix.elements;
    var projR = cameraR.projectionMatrix.elements;
    // VR systems will have identical far and near planes, and
    // most likely identical top and bottom frustum extents.
    // Use the left camera for these values.
    var near = projL[14] / (projL[10] - 1);
    var far = projL[14] / (projL[10] + 1);
    var topFov = (projL[9] + 1) / projL[5];
    var bottomFov = (projL[9] - 1) / projL[5];
    var leftFov = (projL[8] - 1) / projL[0];
    var rightFov = (projR[8] + 1) / projR[0];
    var left = near * leftFov;
    var right = near * rightFov;
    // Calculate the new camera's position offset from the
    // left camera. xOffset should be roughly half `ipd`.
    var zOffset = ipd / (-leftFov + rightFov);
    var xOffset = zOffset * -leftFov;
    // TODO: Better way to apply this offset?
    cameraL.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
    camera.translateX(xOffset);
    camera.translateZ(zOffset);
    camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
    camera.matrixWorldInverse.getInverse(camera.matrixWorld);
    // Find the union of the frustum values of the cameras and scale
    // the values so that the near plane's position does not change in world space,
    // although must now be relative to the new union camera.
    var near2 = near + zOffset;
    var far2 = far + zOffset;
    var left2 = left - xOffset;
    var right2 = right + (ipd - xOffset);
    var top2 = topFov * far / far2 * near2;
    var bottom2 = bottomFov * far / far2 * near2;
    camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
}
/**
 * @author mrdoob / http://mrdoob.com/
 */ function WebVRManager(renderer) {
    var scope = this;
    var device = null;
    var frameData = null;
    var poseTarget = null;
    var controllers = [];
    var standingMatrix = new Matrix4();
    var standingMatrixInverse = new Matrix4();
    var framebufferScaleFactor = 1.0;
    var frameOfReferenceType = "stage";
    if (typeof window !== "undefined" && "VRFrameData" in window) {
        frameData = new window.VRFrameData();
        window.addEventListener("vrdisplaypresentchange", onVRDisplayPresentChange, false);
    }
    var matrixWorldInverse = new Matrix4();
    var tempQuaternion = new Quaternion();
    var tempPosition = new Vector3();
    var cameraL = new PerspectiveCamera();
    cameraL.bounds = new Vector4(0.0, 0.0, 0.5, 1.0);
    cameraL.layers.enable(1);
    var cameraR = new PerspectiveCamera();
    cameraR.bounds = new Vector4(0.5, 0.0, 0.5, 1.0);
    cameraR.layers.enable(2);
    var cameraVR = new ArrayCamera([
        cameraL,
        cameraR
    ]);
    cameraVR.layers.enable(1);
    cameraVR.layers.enable(2);
    //
    function isPresenting() {
        return device !== null && device.isPresenting === true;
    }
    var currentSize, currentPixelRatio;
    function onVRDisplayPresentChange() {
        if (isPresenting()) {
            var eyeParameters = device.getEyeParameters("left");
            var renderWidth = eyeParameters.renderWidth * framebufferScaleFactor;
            var renderHeight = eyeParameters.renderHeight * framebufferScaleFactor;
            currentPixelRatio = renderer.getPixelRatio();
            currentSize = renderer.getSize();
            renderer.setDrawingBufferSize(renderWidth * 2, renderHeight, 1);
            animation.start();
        } else {
            if (scope.enabled) renderer.setDrawingBufferSize(currentSize.width, currentSize.height, currentPixelRatio);
            animation.stop();
        }
    }
    //
    var triggers = [];
    function findGamepad(id) {
        var gamepads = navigator.getGamepads && navigator.getGamepads();
        for(var i = 0, j = 0, l = gamepads.length; i < l; i++){
            var gamepad = gamepads[i];
            if (gamepad && (gamepad.id === "Daydream Controller" || gamepad.id === "Gear VR Controller" || gamepad.id === "Oculus Go Controller" || gamepad.id === "OpenVR Gamepad" || gamepad.id.startsWith("Oculus Touch") || gamepad.id.startsWith("Spatial Controller"))) {
                if (j === id) return gamepad;
                j++;
            }
        }
    }
    function updateControllers() {
        for(var i = 0; i < controllers.length; i++){
            var controller = controllers[i];
            var gamepad = findGamepad(i);
            if (gamepad !== undefined && gamepad.pose !== undefined) {
                if (gamepad.pose === null) return;
                //  Pose
                var pose = gamepad.pose;
                if (pose.hasPosition === false) controller.position.set(0.2, -0.6, -0.05);
                if (pose.position !== null) controller.position.fromArray(pose.position);
                if (pose.orientation !== null) controller.quaternion.fromArray(pose.orientation);
                controller.matrix.compose(controller.position, controller.quaternion, controller.scale);
                controller.matrix.premultiply(standingMatrix);
                controller.matrix.decompose(controller.position, controller.quaternion, controller.scale);
                controller.matrixWorldNeedsUpdate = true;
                controller.visible = true;
                //  Trigger
                var buttonId = gamepad.id === "Daydream Controller" ? 0 : 1;
                if (triggers[i] !== gamepad.buttons[buttonId].pressed) {
                    triggers[i] = gamepad.buttons[buttonId].pressed;
                    if (triggers[i] === true) controller.dispatchEvent({
                        type: "selectstart"
                    });
                    else {
                        controller.dispatchEvent({
                            type: "selectend"
                        });
                        controller.dispatchEvent({
                            type: "select"
                        });
                    }
                }
            } else controller.visible = false;
        }
    }
    //
    this.enabled = false;
    this.getController = function(id) {
        var controller = controllers[id];
        if (controller === undefined) {
            controller = new Group();
            controller.matrixAutoUpdate = false;
            controller.visible = false;
            controllers[id] = controller;
        }
        return controller;
    };
    this.getDevice = function() {
        return device;
    };
    this.setDevice = function(value) {
        if (value !== undefined) device = value;
        animation.setContext(value);
    };
    this.setFramebufferScaleFactor = function(value) {
        framebufferScaleFactor = value;
    };
    this.setFrameOfReferenceType = function(value) {
        frameOfReferenceType = value;
    };
    this.setPoseTarget = function(object) {
        if (object !== undefined) poseTarget = object;
    };
    this.getCamera = function(camera) {
        var userHeight = frameOfReferenceType === "stage" ? 1.6 : 0;
        if (device === null) {
            camera.position.set(0, userHeight, 0);
            return camera;
        }
        device.depthNear = camera.near;
        device.depthFar = camera.far;
        device.getFrameData(frameData);
        //
        if (frameOfReferenceType === "stage") {
            var stageParameters = device.stageParameters;
            if (stageParameters) standingMatrix.fromArray(stageParameters.sittingToStandingTransform);
            else standingMatrix.makeTranslation(0, userHeight, 0);
        }
        var pose = frameData.pose;
        var poseObject = poseTarget !== null ? poseTarget : camera;
        // We want to manipulate poseObject by its position and quaternion components since users may rely on them.
        poseObject.matrix.copy(standingMatrix);
        poseObject.matrix.decompose(poseObject.position, poseObject.quaternion, poseObject.scale);
        if (pose.orientation !== null) {
            tempQuaternion.fromArray(pose.orientation);
            poseObject.quaternion.multiply(tempQuaternion);
        }
        if (pose.position !== null) {
            tempQuaternion.setFromRotationMatrix(standingMatrix);
            tempPosition.fromArray(pose.position);
            tempPosition.applyQuaternion(tempQuaternion);
            poseObject.position.add(tempPosition);
        }
        poseObject.updateMatrixWorld();
        if (device.isPresenting === false) return camera;
        //
        cameraL.near = camera.near;
        cameraR.near = camera.near;
        cameraL.far = camera.far;
        cameraR.far = camera.far;
        cameraL.matrixWorldInverse.fromArray(frameData.leftViewMatrix);
        cameraR.matrixWorldInverse.fromArray(frameData.rightViewMatrix);
        // TODO (mrdoob) Double check this code
        standingMatrixInverse.getInverse(standingMatrix);
        if (frameOfReferenceType === "stage") {
            cameraL.matrixWorldInverse.multiply(standingMatrixInverse);
            cameraR.matrixWorldInverse.multiply(standingMatrixInverse);
        }
        var parent = poseObject.parent;
        if (parent !== null) {
            matrixWorldInverse.getInverse(parent.matrixWorld);
            cameraL.matrixWorldInverse.multiply(matrixWorldInverse);
            cameraR.matrixWorldInverse.multiply(matrixWorldInverse);
        }
        // envMap and Mirror needs camera.matrixWorld
        cameraL.matrixWorld.getInverse(cameraL.matrixWorldInverse);
        cameraR.matrixWorld.getInverse(cameraR.matrixWorldInverse);
        cameraL.projectionMatrix.fromArray(frameData.leftProjectionMatrix);
        cameraR.projectionMatrix.fromArray(frameData.rightProjectionMatrix);
        setProjectionFromUnion(cameraVR, cameraL, cameraR);
        //
        var layers = device.getLayers();
        if (layers.length) {
            var layer = layers[0];
            if (layer.leftBounds !== null && layer.leftBounds.length === 4) cameraL.bounds.fromArray(layer.leftBounds);
            if (layer.rightBounds !== null && layer.rightBounds.length === 4) cameraR.bounds.fromArray(layer.rightBounds);
        }
        updateControllers();
        return cameraVR;
    };
    this.getStandingMatrix = function() {
        return standingMatrix;
    };
    this.isPresenting = isPresenting;
    // Animation Loop
    var animation = new WebGLAnimation();
    this.setAnimationLoop = function(callback) {
        animation.setAnimationLoop(callback);
    };
    this.submitFrame = function() {
        if (isPresenting()) device.submitFrame();
    };
    this.dispose = function() {
        if (typeof window !== "undefined") window.removeEventListener("vrdisplaypresentchange", onVRDisplayPresentChange);
    };
}
/**
 * @author mrdoob / http://mrdoob.com/
 */ function WebXRManager(renderer) {
    var gl = renderer.context;
    var device = null;
    var session = null;
    var framebufferScaleFactor = 1.0;
    var frameOfReference = null;
    var frameOfReferenceType = "stage";
    var pose = null;
    var controllers = [];
    var inputSources = [];
    function isPresenting() {
        return session !== null && frameOfReference !== null;
    }
    //
    var cameraL = new PerspectiveCamera();
    cameraL.layers.enable(1);
    cameraL.viewport = new Vector4();
    var cameraR = new PerspectiveCamera();
    cameraR.layers.enable(2);
    cameraR.viewport = new Vector4();
    var cameraVR = new ArrayCamera([
        cameraL,
        cameraR
    ]);
    cameraVR.layers.enable(1);
    cameraVR.layers.enable(2);
    //
    this.enabled = false;
    this.getController = function(id) {
        var controller = controllers[id];
        if (controller === undefined) {
            controller = new Group();
            controller.matrixAutoUpdate = false;
            controller.visible = false;
            controllers[id] = controller;
        }
        return controller;
    };
    this.getDevice = function() {
        return device;
    };
    this.setDevice = function(value) {
        if (value !== undefined) device = value;
        if (value instanceof XRDevice) gl.setCompatibleXRDevice(value);
    };
    //
    function onSessionEvent(event) {
        var controller = controllers[inputSources.indexOf(event.inputSource)];
        if (controller) controller.dispatchEvent({
            type: event.type
        });
    }
    function onSessionEnd() {
        renderer.setFramebuffer(null);
        animation.stop();
    }
    this.setFramebufferScaleFactor = function(value) {
        framebufferScaleFactor = value;
    };
    this.setFrameOfReferenceType = function(value) {
        frameOfReferenceType = value;
    };
    this.setSession = function(value) {
        session = value;
        if (session !== null) {
            session.addEventListener("select", onSessionEvent);
            session.addEventListener("selectstart", onSessionEvent);
            session.addEventListener("selectend", onSessionEvent);
            session.addEventListener("end", onSessionEnd);
            session.baseLayer = new XRWebGLLayer(session, gl, {
                framebufferScaleFactor: framebufferScaleFactor
            });
            session.requestFrameOfReference(frameOfReferenceType).then(function(value) {
                frameOfReference = value;
                renderer.setFramebuffer(session.baseLayer.framebuffer);
                animation.setContext(session);
                animation.start();
            });
            //
            inputSources = session.getInputSources();
            session.addEventListener("inputsourceschange", function() {
                inputSources = session.getInputSources();
                console.log(inputSources);
                for(var i = 0; i < controllers.length; i++){
                    var controller = controllers[i];
                    controller.userData.inputSource = inputSources[i];
                }
            });
        }
    };
    function updateCamera(camera, parent) {
        if (parent === null) camera.matrixWorld.copy(camera.matrix);
        else camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
        camera.matrixWorldInverse.getInverse(camera.matrixWorld);
    }
    this.getCamera = function(camera) {
        if (isPresenting()) {
            var parent = camera.parent;
            var cameras = cameraVR.cameras;
            updateCamera(cameraVR, parent);
            for(var i = 0; i < cameras.length; i++)updateCamera(cameras[i], parent);
            // update camera and its children
            camera.matrixWorld.copy(cameraVR.matrixWorld);
            var children = camera.children;
            for(var i = 0, l = children.length; i < l; i++)children[i].updateMatrixWorld(true);
            setProjectionFromUnion(cameraVR, cameraL, cameraR);
            return cameraVR;
        }
        return camera;
    };
    this.isPresenting = isPresenting;
    // Animation Loop
    var onAnimationFrameCallback = null;
    function onAnimationFrame(time, frame) {
        pose = frame.getDevicePose(frameOfReference);
        if (pose !== null) {
            var layer = session.baseLayer;
            var views = frame.views;
            for(var i = 0; i < views.length; i++){
                var view = views[i];
                var viewport = layer.getViewport(view);
                var viewMatrix = pose.getViewMatrix(view);
                var camera = cameraVR.cameras[i];
                camera.matrix.fromArray(viewMatrix).getInverse(camera.matrix);
                camera.projectionMatrix.fromArray(view.projectionMatrix);
                camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
                if (i === 0) cameraVR.matrix.copy(camera.matrix);
            }
        }
        //
        for(var i = 0; i < controllers.length; i++){
            var controller = controllers[i];
            var inputSource = inputSources[i];
            if (inputSource) {
                var inputPose = frame.getInputPose(inputSource, frameOfReference);
                if (inputPose !== null) {
                    if ("targetRay" in inputPose) controller.matrix.elements = inputPose.targetRay.transformMatrix;
                    else if ("pointerMatrix" in inputPose) // DEPRECATED
                    controller.matrix.elements = inputPose.pointerMatrix;
                    controller.matrix.decompose(controller.position, controller.rotation, controller.scale);
                    controller.visible = true;
                    continue;
                }
            }
            controller.visible = false;
        }
        if (onAnimationFrameCallback) onAnimationFrameCallback(time);
    }
    var animation = new WebGLAnimation();
    animation.setAnimationLoop(onAnimationFrame);
    this.setAnimationLoop = function(callback) {
        onAnimationFrameCallback = callback;
    };
    this.dispose = function() {};
    // DEPRECATED
    this.getStandingMatrix = function() {
        console.warn("THREE.WebXRManager: getStandingMatrix() is no longer needed.");
        return new THREE.Matrix4();
    };
    this.submitFrame = function() {};
}
/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 * @author tschw
 */ function WebGLRenderer(parameters) {
    console.log("THREE.WebGLRenderer", REVISION);
    parameters = parameters || {};
    var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), _context = parameters.context !== undefined ? parameters.context : null, _alpha = parameters.alpha !== undefined ? parameters.alpha : false, _depth = parameters.depth !== undefined ? parameters.depth : true, _stencil = parameters.stencil !== undefined ? parameters.stencil : true, _antialias = parameters.antialias !== undefined ? parameters.antialias : false, _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true, _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false, _powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : "default";
    var currentRenderList = null;
    var currentRenderState = null;
    // public properties
    this.domElement = _canvas;
    this.context = null;
    // clearing
    this.autoClear = true;
    this.autoClearColor = true;
    this.autoClearDepth = true;
    this.autoClearStencil = true;
    // scene graph
    this.sortObjects = true;
    // user-defined clipping
    this.clippingPlanes = [];
    this.localClippingEnabled = false;
    // physically based shading
    this.gammaFactor = 2.0; // for backwards compatibility
    this.gammaInput = false;
    this.gammaOutput = false;
    // physical lights
    this.physicallyCorrectLights = false;
    // tone mapping
    this.toneMapping = LinearToneMapping;
    this.toneMappingExposure = 1.0;
    this.toneMappingWhitePoint = 1.0;
    // morphs
    this.maxMorphTargets = 8;
    this.maxMorphNormals = 4;
    // internal properties
    var _this = this, _isContextLost = false, // internal state cache
    _framebuffer = null, _currentRenderTarget = null, _currentFramebuffer = null, _currentMaterialId = -1, // geometry and program caching
    _currentGeometryProgram = {
        geometry: null,
        program: null,
        wireframe: false
    }, _currentCamera = null, _currentArrayCamera = null, _currentViewport = new Vector4(), _currentScissor = new Vector4(), _currentScissorTest = null, //
    _usedTextureUnits = 0, //
    _width = _canvas.width, _height = _canvas.height, _pixelRatio = 1, _viewport = new Vector4(0, 0, _width, _height), _scissor = new Vector4(0, 0, _width, _height), _scissorTest = false, // frustum
    _frustum = new Frustum(), // clipping
    _clipping = new WebGLClipping(), _clippingEnabled = false, _localClippingEnabled = false, // camera matrices cache
    _projScreenMatrix = new Matrix4(), _vector3 = new Vector3();
    function getTargetPixelRatio() {
        return _currentRenderTarget === null ? _pixelRatio : 1;
    }
    // initialize
    var _gl;
    try {
        var contextAttributes = {
            alpha: _alpha,
            depth: _depth,
            stencil: _stencil,
            antialias: _antialias,
            premultipliedAlpha: _premultipliedAlpha,
            preserveDrawingBuffer: _preserveDrawingBuffer,
            powerPreference: _powerPreference
        };
        // event listeners must be registered before WebGL context is created, see #12753
        _canvas.addEventListener("webglcontextlost", onContextLost, false);
        _canvas.addEventListener("webglcontextrestored", onContextRestore, false);
        _gl = _context || _canvas.getContext("webgl", contextAttributes) || _canvas.getContext("experimental-webgl", contextAttributes);
        if (_gl === null) {
            if (_canvas.getContext("webgl") !== null) throw new Error("Error creating WebGL context with your selected attributes.");
            else throw new Error("Error creating WebGL context.");
        }
        // Some experimental-webgl implementations do not have getShaderPrecisionFormat
        if (_gl.getShaderPrecisionFormat === undefined) _gl.getShaderPrecisionFormat = function() {
            return {
                "rangeMin": 1,
                "rangeMax": 1,
                "precision": 1
            };
        };
    } catch (error) {
        console.error("THREE.WebGLRenderer: " + error.message);
    }
    var extensions, capabilities, state, info;
    var properties, textures, attributes, geometries, objects;
    var programCache, renderLists, renderStates;
    var background, morphtargets, bufferRenderer, indexedBufferRenderer;
    var utils;
    function initGLContext() {
        extensions = new WebGLExtensions(_gl);
        capabilities = new WebGLCapabilities(_gl, extensions, parameters);
        if (!capabilities.isWebGL2) {
            extensions.get("WEBGL_depth_texture");
            extensions.get("OES_texture_float");
            extensions.get("OES_texture_half_float");
            extensions.get("OES_texture_half_float_linear");
            extensions.get("OES_standard_derivatives");
            extensions.get("OES_element_index_uint");
            extensions.get("ANGLE_instanced_arrays");
        }
        extensions.get("OES_texture_float_linear");
        utils = new WebGLUtils(_gl, extensions, capabilities);
        state = new WebGLState(_gl, extensions, utils, capabilities);
        state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio));
        state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio));
        info = new WebGLInfo(_gl);
        properties = new WebGLProperties();
        textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);
        attributes = new WebGLAttributes(_gl);
        geometries = new WebGLGeometries(_gl, attributes, info);
        objects = new WebGLObjects(geometries, info);
        morphtargets = new WebGLMorphtargets(_gl);
        programCache = new WebGLPrograms(_this, extensions, capabilities);
        renderLists = new WebGLRenderLists();
        renderStates = new WebGLRenderStates();
        background = new WebGLBackground(_this, state, objects, _premultipliedAlpha);
        bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities);
        indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);
        info.programs = programCache.programs;
        _this.context = _gl;
        _this.capabilities = capabilities;
        _this.extensions = extensions;
        _this.properties = properties;
        _this.renderLists = renderLists;
        _this.state = state;
        _this.info = info;
    }
    initGLContext();
    // vr
    var vr = null;
    if (typeof navigator !== "undefined") vr = "xr" in navigator ? new WebXRManager(_this) : new WebVRManager(_this);
    this.vr = vr;
    // shadow map
    var shadowMap = new WebGLShadowMap(_this, objects, capabilities.maxTextureSize);
    this.shadowMap = shadowMap;
    // API
    this.getContext = function() {
        return _gl;
    };
    this.getContextAttributes = function() {
        return _gl.getContextAttributes();
    };
    this.forceContextLoss = function() {
        var extension = extensions.get("WEBGL_lose_context");
        if (extension) extension.loseContext();
    };
    this.forceContextRestore = function() {
        var extension = extensions.get("WEBGL_lose_context");
        if (extension) extension.restoreContext();
    };
    this.getPixelRatio = function() {
        return _pixelRatio;
    };
    this.setPixelRatio = function(value) {
        if (value === undefined) return;
        _pixelRatio = value;
        this.setSize(_width, _height, false);
    };
    this.getSize = function() {
        return {
            width: _width,
            height: _height
        };
    };
    this.setSize = function(width, height, updateStyle) {
        if (vr.isPresenting()) {
            console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
            return;
        }
        _width = width;
        _height = height;
        _canvas.width = width * _pixelRatio;
        _canvas.height = height * _pixelRatio;
        if (updateStyle !== false) {
            _canvas.style.width = width + "px";
            _canvas.style.height = height + "px";
        }
        this.setViewport(0, 0, width, height);
    };
    this.getDrawingBufferSize = function() {
        return {
            width: _width * _pixelRatio,
            height: _height * _pixelRatio
        };
    };
    this.setDrawingBufferSize = function(width, height, pixelRatio) {
        _width = width;
        _height = height;
        _pixelRatio = pixelRatio;
        _canvas.width = width * pixelRatio;
        _canvas.height = height * pixelRatio;
        this.setViewport(0, 0, width, height);
    };
    this.getCurrentViewport = function() {
        return _currentViewport;
    };
    this.setViewport = function(x, y, width, height) {
        _viewport.set(x, _height - y - height, width, height);
        state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio));
    };
    this.setScissor = function(x, y, width, height) {
        _scissor.set(x, _height - y - height, width, height);
        state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio));
    };
    this.setScissorTest = function(boolean) {
        state.setScissorTest(_scissorTest = boolean);
    };
    // Clearing
    this.getClearColor = function() {
        return background.getClearColor();
    };
    this.setClearColor = function() {
        background.setClearColor.apply(background, arguments);
    };
    this.getClearAlpha = function() {
        return background.getClearAlpha();
    };
    this.setClearAlpha = function() {
        background.setClearAlpha.apply(background, arguments);
    };
    this.clear = function(color, depth, stencil) {
        var bits = 0;
        if (color === undefined || color) bits |= 16384;
        if (depth === undefined || depth) bits |= 256;
        if (stencil === undefined || stencil) bits |= 1024;
        _gl.clear(bits);
    };
    this.clearColor = function() {
        this.clear(true, false, false);
    };
    this.clearDepth = function() {
        this.clear(false, true, false);
    };
    this.clearStencil = function() {
        this.clear(false, false, true);
    };
    //
    this.dispose = function() {
        _canvas.removeEventListener("webglcontextlost", onContextLost, false);
        _canvas.removeEventListener("webglcontextrestored", onContextRestore, false);
        renderLists.dispose();
        renderStates.dispose();
        properties.dispose();
        objects.dispose();
        vr.dispose();
        animation.stop();
    };
    // Events
    function onContextLost(event) {
        event.preventDefault();
        console.log("THREE.WebGLRenderer: Context Lost.");
        _isContextLost = true;
    }
    function onContextRestore() {
        console.log("THREE.WebGLRenderer: Context Restored.");
        _isContextLost = false;
        initGLContext();
    }
    function onMaterialDispose(event) {
        var material = event.target;
        material.removeEventListener("dispose", onMaterialDispose);
        deallocateMaterial(material);
    }
    // Buffer deallocation
    function deallocateMaterial(material) {
        releaseMaterialProgramReference(material);
        properties.remove(material);
    }
    function releaseMaterialProgramReference(material) {
        var programInfo = properties.get(material).program;
        material.program = undefined;
        if (programInfo !== undefined) programCache.releaseProgram(programInfo);
    }
    // Buffer rendering
    function renderObjectImmediate(object, program) {
        object.render(function(object) {
            _this.renderBufferImmediate(object, program);
        });
    }
    this.renderBufferImmediate = function(object, program) {
        state.initAttributes();
        var buffers = properties.get(object);
        if (object.hasPositions && !buffers.position) buffers.position = _gl.createBuffer();
        if (object.hasNormals && !buffers.normal) buffers.normal = _gl.createBuffer();
        if (object.hasUvs && !buffers.uv) buffers.uv = _gl.createBuffer();
        if (object.hasColors && !buffers.color) buffers.color = _gl.createBuffer();
        var programAttributes = program.getAttributes();
        if (object.hasPositions) {
            _gl.bindBuffer(34962, buffers.position);
            _gl.bufferData(34962, object.positionArray, 35048);
            state.enableAttribute(programAttributes.position);
            _gl.vertexAttribPointer(programAttributes.position, 3, 5126, false, 0, 0);
        }
        if (object.hasNormals) {
            _gl.bindBuffer(34962, buffers.normal);
            _gl.bufferData(34962, object.normalArray, 35048);
            state.enableAttribute(programAttributes.normal);
            _gl.vertexAttribPointer(programAttributes.normal, 3, 5126, false, 0, 0);
        }
        if (object.hasUvs) {
            _gl.bindBuffer(34962, buffers.uv);
            _gl.bufferData(34962, object.uvArray, 35048);
            state.enableAttribute(programAttributes.uv);
            _gl.vertexAttribPointer(programAttributes.uv, 2, 5126, false, 0, 0);
        }
        if (object.hasColors) {
            _gl.bindBuffer(34962, buffers.color);
            _gl.bufferData(34962, object.colorArray, 35048);
            state.enableAttribute(programAttributes.color);
            _gl.vertexAttribPointer(programAttributes.color, 3, 5126, false, 0, 0);
        }
        state.disableUnusedAttributes();
        _gl.drawArrays(4, 0, object.count);
        object.count = 0;
    };
    this.renderBufferDirect = function(camera, fog, geometry, material, object, group) {
        var frontFaceCW = object.isMesh && object.normalMatrix.determinant() < 0;
        state.setMaterial(material, frontFaceCW);
        var program = setProgram(camera, fog, material, object);
        var updateBuffers = false;
        if (_currentGeometryProgram.geometry !== geometry.id || _currentGeometryProgram.program !== program.id || _currentGeometryProgram.wireframe !== (material.wireframe === true)) {
            _currentGeometryProgram.geometry = geometry.id;
            _currentGeometryProgram.program = program.id;
            _currentGeometryProgram.wireframe = material.wireframe === true;
            updateBuffers = true;
        }
        if (object.morphTargetInfluences) {
            morphtargets.update(object, geometry, material, program);
            updateBuffers = true;
        }
        //
        var index = geometry.index;
        var position = geometry.attributes.position;
        var rangeFactor = 1;
        if (material.wireframe === true) {
            index = geometries.getWireframeAttribute(geometry);
            rangeFactor = 2;
        }
        var attribute;
        var renderer = bufferRenderer;
        if (index !== null) {
            attribute = attributes.get(index);
            renderer = indexedBufferRenderer;
            renderer.setIndex(attribute);
        }
        if (updateBuffers) {
            setupVertexAttributes(material, program, geometry);
            if (index !== null) _gl.bindBuffer(34963, attribute.buffer);
        }
        //
        var dataCount = Infinity;
        if (index !== null) dataCount = index.count;
        else if (position !== undefined) dataCount = position.count;
        var rangeStart = geometry.drawRange.start * rangeFactor;
        var rangeCount = geometry.drawRange.count * rangeFactor;
        var groupStart = group !== null ? group.start * rangeFactor : 0;
        var groupCount = group !== null ? group.count * rangeFactor : Infinity;
        var drawStart = Math.max(rangeStart, groupStart);
        var drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
        var drawCount = Math.max(0, drawEnd - drawStart + 1);
        if (drawCount === 0) return;
        //
        if (object.isMesh) {
            if (material.wireframe === true) {
                state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
                renderer.setMode(1);
            } else switch(object.drawMode){
                case TrianglesDrawMode:
                    renderer.setMode(4);
                    break;
                case TriangleStripDrawMode:
                    renderer.setMode(5);
                    break;
                case TriangleFanDrawMode:
                    renderer.setMode(6);
                    break;
            }
        } else if (object.isLine) {
            var lineWidth = material.linewidth;
            if (lineWidth === undefined) lineWidth = 1; // Not using Line*Material
            state.setLineWidth(lineWidth * getTargetPixelRatio());
            if (object.isLineSegments) renderer.setMode(1);
            else if (object.isLineLoop) renderer.setMode(2);
            else renderer.setMode(3);
        } else if (object.isPoints) renderer.setMode(0);
        else if (object.isSprite) renderer.setMode(4);
        if (geometry && geometry.isInstancedBufferGeometry) {
            if (geometry.maxInstancedCount > 0) renderer.renderInstances(geometry, drawStart, drawCount);
        } else renderer.render(drawStart, drawCount);
    };
    function setupVertexAttributes(material, program, geometry) {
        if (geometry && geometry.isInstancedBufferGeometry & !capabilities.isWebGL2) {
            if (extensions.get("ANGLE_instanced_arrays") === null) {
                console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                return;
            }
        }
        state.initAttributes();
        var geometryAttributes = geometry.attributes;
        var programAttributes = program.getAttributes();
        var materialDefaultAttributeValues = material.defaultAttributeValues;
        for(var name in programAttributes){
            var programAttribute = programAttributes[name];
            if (programAttribute >= 0) {
                var geometryAttribute = geometryAttributes[name];
                if (geometryAttribute !== undefined) {
                    var normalized = geometryAttribute.normalized;
                    var size = geometryAttribute.itemSize;
                    var attribute = attributes.get(geometryAttribute);
                    // TODO Attribute may not be available on context restore
                    if (attribute === undefined) continue;
                    var buffer = attribute.buffer;
                    var type = attribute.type;
                    var bytesPerElement = attribute.bytesPerElement;
                    if (geometryAttribute.isInterleavedBufferAttribute) {
                        var data = geometryAttribute.data;
                        var stride = data.stride;
                        var offset = geometryAttribute.offset;
                        if (data && data.isInstancedInterleavedBuffer) {
                            state.enableAttributeAndDivisor(programAttribute, data.meshPerAttribute);
                            if (geometry.maxInstancedCount === undefined) geometry.maxInstancedCount = data.meshPerAttribute * data.count;
                        } else state.enableAttribute(programAttribute);
                        _gl.bindBuffer(34962, buffer);
                        _gl.vertexAttribPointer(programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement);
                    } else {
                        if (geometryAttribute.isInstancedBufferAttribute) {
                            state.enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute);
                            if (geometry.maxInstancedCount === undefined) geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
                        } else state.enableAttribute(programAttribute);
                        _gl.bindBuffer(34962, buffer);
                        _gl.vertexAttribPointer(programAttribute, size, type, normalized, 0, 0);
                    }
                } else if (materialDefaultAttributeValues !== undefined) {
                    var value = materialDefaultAttributeValues[name];
                    if (value !== undefined) switch(value.length){
                        case 2:
                            _gl.vertexAttrib2fv(programAttribute, value);
                            break;
                        case 3:
                            _gl.vertexAttrib3fv(programAttribute, value);
                            break;
                        case 4:
                            _gl.vertexAttrib4fv(programAttribute, value);
                            break;
                        default:
                            _gl.vertexAttrib1fv(programAttribute, value);
                    }
                }
            }
        }
        state.disableUnusedAttributes();
    }
    // Compile
    this.compile = function(scene, camera) {
        currentRenderState = renderStates.get(scene, camera);
        currentRenderState.init();
        scene.traverse(function(object) {
            if (object.isLight) {
                currentRenderState.pushLight(object);
                if (object.castShadow) currentRenderState.pushShadow(object);
            }
        });
        currentRenderState.setupLights(camera);
        scene.traverse(function(object) {
            if (object.material) {
                if (Array.isArray(object.material)) for(var i = 0; i < object.material.length; i++)initMaterial(object.material[i], scene.fog, object);
                else initMaterial(object.material, scene.fog, object);
            }
        });
    };
    // Animation Loop
    var onAnimationFrameCallback = null;
    function onAnimationFrame(time) {
        if (vr.isPresenting()) return;
        if (onAnimationFrameCallback) onAnimationFrameCallback(time);
    }
    var animation = new WebGLAnimation();
    animation.setAnimationLoop(onAnimationFrame);
    if (typeof window !== "undefined") animation.setContext(window);
    this.setAnimationLoop = function(callback) {
        onAnimationFrameCallback = callback;
        vr.setAnimationLoop(callback);
        animation.start();
    };
    // Rendering
    this.render = function(scene, camera, renderTarget, forceClear) {
        if (!(camera && camera.isCamera)) {
            console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
            return;
        }
        if (_isContextLost) return;
        // reset caching for this frame
        _currentGeometryProgram.geometry = null;
        _currentGeometryProgram.program = null;
        _currentGeometryProgram.wireframe = false;
        _currentMaterialId = -1;
        _currentCamera = null;
        // update scene graph
        if (scene.autoUpdate === true) scene.updateMatrixWorld();
        // update camera matrices and frustum
        if (camera.parent === null) camera.updateMatrixWorld();
        if (vr.enabled) camera = vr.getCamera(camera);
        //
        currentRenderState = renderStates.get(scene, camera);
        currentRenderState.init();
        scene.onBeforeRender(_this, scene, camera, renderTarget);
        _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
        _frustum.setFromMatrix(_projScreenMatrix);
        _localClippingEnabled = this.localClippingEnabled;
        _clippingEnabled = _clipping.init(this.clippingPlanes, _localClippingEnabled, camera);
        currentRenderList = renderLists.get(scene, camera);
        currentRenderList.init();
        projectObject(scene, camera, _this.sortObjects);
        if (_this.sortObjects === true) currentRenderList.sort();
        //
        if (_clippingEnabled) _clipping.beginShadows();
        var shadowsArray = currentRenderState.state.shadowsArray;
        shadowMap.render(shadowsArray, scene, camera);
        currentRenderState.setupLights(camera);
        if (_clippingEnabled) _clipping.endShadows();
        //
        if (this.info.autoReset) this.info.reset();
        if (renderTarget === undefined) renderTarget = null;
        this.setRenderTarget(renderTarget);
        //
        background.render(currentRenderList, scene, camera, forceClear);
        // render scene
        var opaqueObjects = currentRenderList.opaque;
        var transparentObjects = currentRenderList.transparent;
        if (scene.overrideMaterial) {
            var overrideMaterial = scene.overrideMaterial;
            if (opaqueObjects.length) renderObjects(opaqueObjects, scene, camera, overrideMaterial);
            if (transparentObjects.length) renderObjects(transparentObjects, scene, camera, overrideMaterial);
        } else {
            // opaque pass (front-to-back order)
            if (opaqueObjects.length) renderObjects(opaqueObjects, scene, camera);
            // transparent pass (back-to-front order)
            if (transparentObjects.length) renderObjects(transparentObjects, scene, camera);
        }
        // Generate mipmap if we're using any kind of mipmap filtering
        if (renderTarget) textures.updateRenderTargetMipmap(renderTarget);
        // Ensure depth buffer writing is enabled so it can be cleared on next render
        state.buffers.depth.setTest(true);
        state.buffers.depth.setMask(true);
        state.buffers.color.setMask(true);
        state.setPolygonOffset(false);
        scene.onAfterRender(_this, scene, camera);
        if (vr.enabled) vr.submitFrame();
        // _gl.finish();
        currentRenderList = null;
        currentRenderState = null;
    };
    function projectObject(object, camera, sortObjects) {
        if (object.visible === false) return;
        var visible = object.layers.test(camera.layers);
        if (visible) {
            if (object.isLight) {
                currentRenderState.pushLight(object);
                if (object.castShadow) currentRenderState.pushShadow(object);
            } else if (object.isSprite) {
                if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
                    if (sortObjects) _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
                    var geometry = objects.update(object);
                    var material = object.material;
                    currentRenderList.push(object, geometry, material, _vector3.z, null);
                }
            } else if (object.isImmediateRenderObject) {
                if (sortObjects) _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
                currentRenderList.push(object, null, object.material, _vector3.z, null);
            } else if (object.isMesh || object.isLine || object.isPoints) {
                if (object.isSkinnedMesh) object.skeleton.update();
                if (!object.frustumCulled || _frustum.intersectsObject(object)) {
                    if (sortObjects) _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
                    var geometry = objects.update(object);
                    var material = object.material;
                    if (Array.isArray(material)) {
                        var groups = geometry.groups;
                        for(var i = 0, l = groups.length; i < l; i++){
                            var group = groups[i];
                            var groupMaterial = material[group.materialIndex];
                            if (groupMaterial && groupMaterial.visible) currentRenderList.push(object, geometry, groupMaterial, _vector3.z, group);
                        }
                    } else if (material.visible) currentRenderList.push(object, geometry, material, _vector3.z, null);
                }
            }
        }
        var children = object.children;
        for(var i = 0, l = children.length; i < l; i++)projectObject(children[i], camera, sortObjects);
    }
    function renderObjects(renderList, scene, camera, overrideMaterial) {
        for(var i = 0, l = renderList.length; i < l; i++){
            var renderItem = renderList[i];
            var object = renderItem.object;
            var geometry = renderItem.geometry;
            var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
            var group = renderItem.group;
            if (camera.isArrayCamera) {
                _currentArrayCamera = camera;
                var cameras = camera.cameras;
                for(var j = 0, jl = cameras.length; j < jl; j++){
                    var camera2 = cameras[j];
                    if (object.layers.test(camera2.layers)) {
                        if ("viewport" in camera2) state.viewport(_currentViewport.copy(camera2.viewport));
                        else {
                            var bounds = camera2.bounds;
                            var x = bounds.x * _width;
                            var y = bounds.y * _height;
                            var width = bounds.z * _width;
                            var height = bounds.w * _height;
                            state.viewport(_currentViewport.set(x, y, width, height).multiplyScalar(_pixelRatio));
                        }
                        currentRenderState.setupLights(camera2);
                        renderObject(object, scene, camera2, geometry, material, group);
                    }
                }
            } else {
                _currentArrayCamera = null;
                renderObject(object, scene, camera, geometry, material, group);
            }
        }
    }
    function renderObject(object, scene, camera, geometry, material, group) {
        object.onBeforeRender(_this, scene, camera, geometry, material, group);
        currentRenderState = renderStates.get(scene, _currentArrayCamera || camera);
        object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
        object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
        if (object.isImmediateRenderObject) {
            state.setMaterial(material);
            var program = setProgram(camera, scene.fog, material, object);
            _currentGeometryProgram.geometry = null;
            _currentGeometryProgram.program = null;
            _currentGeometryProgram.wireframe = false;
            renderObjectImmediate(object, program);
        } else _this.renderBufferDirect(camera, scene.fog, geometry, material, object, group);
        object.onAfterRender(_this, scene, camera, geometry, material, group);
        currentRenderState = renderStates.get(scene, _currentArrayCamera || camera);
    }
    function initMaterial(material, fog, object) {
        var materialProperties = properties.get(material);
        var lights = currentRenderState.state.lights;
        var shadowsArray = currentRenderState.state.shadowsArray;
        var lightsHash = materialProperties.lightsHash;
        var lightsStateHash = lights.state.hash;
        var parameters = programCache.getParameters(material, lights.state, shadowsArray, fog, _clipping.numPlanes, _clipping.numIntersection, object);
        var code = programCache.getProgramCode(material, parameters);
        var program = materialProperties.program;
        var programChange = true;
        if (program === undefined) // new material
        material.addEventListener("dispose", onMaterialDispose);
        else if (program.code !== code) // changed glsl or parameters
        releaseMaterialProgramReference(material);
        else if (lightsHash.stateID !== lightsStateHash.stateID || lightsHash.directionalLength !== lightsStateHash.directionalLength || lightsHash.pointLength !== lightsStateHash.pointLength || lightsHash.spotLength !== lightsStateHash.spotLength || lightsHash.rectAreaLength !== lightsStateHash.rectAreaLength || lightsHash.hemiLength !== lightsStateHash.hemiLength || lightsHash.shadowsLength !== lightsStateHash.shadowsLength) {
            lightsHash.stateID = lightsStateHash.stateID;
            lightsHash.directionalLength = lightsStateHash.directionalLength;
            lightsHash.pointLength = lightsStateHash.pointLength;
            lightsHash.spotLength = lightsStateHash.spotLength;
            lightsHash.rectAreaLength = lightsStateHash.rectAreaLength;
            lightsHash.hemiLength = lightsStateHash.hemiLength;
            lightsHash.shadowsLength = lightsStateHash.shadowsLength;
            programChange = false;
        } else if (parameters.shaderID !== undefined) // same glsl and uniform list
        return;
        else // only rebuild uniform list
        programChange = false;
        if (programChange) {
            if (parameters.shaderID) {
                var shader = ShaderLib[parameters.shaderID];
                materialProperties.shader = {
                    name: material.type,
                    uniforms: cloneUniforms(shader.uniforms),
                    vertexShader: shader.vertexShader,
                    fragmentShader: shader.fragmentShader
                };
            } else materialProperties.shader = {
                name: material.type,
                uniforms: material.uniforms,
                vertexShader: material.vertexShader,
                fragmentShader: material.fragmentShader
            };
            material.onBeforeCompile(materialProperties.shader, _this);
            // Computing code again as onBeforeCompile may have changed the shaders
            code = programCache.getProgramCode(material, parameters);
            program = programCache.acquireProgram(material, materialProperties.shader, parameters, code);
            materialProperties.program = program;
            material.program = program;
        }
        var programAttributes = program.getAttributes();
        if (material.morphTargets) {
            material.numSupportedMorphTargets = 0;
            for(var i = 0; i < _this.maxMorphTargets; i++)if (programAttributes["morphTarget" + i] >= 0) material.numSupportedMorphTargets++;
        }
        if (material.morphNormals) {
            material.numSupportedMorphNormals = 0;
            for(var i = 0; i < _this.maxMorphNormals; i++)if (programAttributes["morphNormal" + i] >= 0) material.numSupportedMorphNormals++;
        }
        var uniforms = materialProperties.shader.uniforms;
        if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
            materialProperties.numClippingPlanes = _clipping.numPlanes;
            materialProperties.numIntersection = _clipping.numIntersection;
            uniforms.clippingPlanes = _clipping.uniform;
        }
        materialProperties.fog = fog;
        // store the light setup it was created for
        if (lightsHash === undefined) materialProperties.lightsHash = lightsHash = {};
        lightsHash.stateID = lightsStateHash.stateID;
        lightsHash.directionalLength = lightsStateHash.directionalLength;
        lightsHash.pointLength = lightsStateHash.pointLength;
        lightsHash.spotLength = lightsStateHash.spotLength;
        lightsHash.rectAreaLength = lightsStateHash.rectAreaLength;
        lightsHash.hemiLength = lightsStateHash.hemiLength;
        lightsHash.shadowsLength = lightsStateHash.shadowsLength;
        if (material.lights) {
            // wire up the material to this renderer's lighting state
            uniforms.ambientLightColor.value = lights.state.ambient;
            uniforms.directionalLights.value = lights.state.directional;
            uniforms.spotLights.value = lights.state.spot;
            uniforms.rectAreaLights.value = lights.state.rectArea;
            uniforms.pointLights.value = lights.state.point;
            uniforms.hemisphereLights.value = lights.state.hemi;
            uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
            uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
            uniforms.spotShadowMap.value = lights.state.spotShadowMap;
            uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
            uniforms.pointShadowMap.value = lights.state.pointShadowMap;
            uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
        // TODO (abelnation): add area lights shadow info to uniforms
        }
        var progUniforms = materialProperties.program.getUniforms(), uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
        materialProperties.uniformsList = uniformsList;
    }
    function setProgram(camera, fog, material, object) {
        _usedTextureUnits = 0;
        var materialProperties = properties.get(material);
        var lights = currentRenderState.state.lights;
        var lightsHash = materialProperties.lightsHash;
        var lightsStateHash = lights.state.hash;
        if (_clippingEnabled) {
            if (_localClippingEnabled || camera !== _currentCamera) {
                var useCache = camera === _currentCamera && material.id === _currentMaterialId;
                // we might want to call this function with some ClippingGroup
                // object instead of the material, once it becomes feasible
                // (#8465, #8379)
                _clipping.setState(material.clippingPlanes, material.clipIntersection, material.clipShadows, camera, materialProperties, useCache);
            }
        }
        if (material.needsUpdate === false) {
            if (materialProperties.program === undefined) material.needsUpdate = true;
            else if (material.fog && materialProperties.fog !== fog) material.needsUpdate = true;
            else if (material.lights && (lightsHash.stateID !== lightsStateHash.stateID || lightsHash.directionalLength !== lightsStateHash.directionalLength || lightsHash.pointLength !== lightsStateHash.pointLength || lightsHash.spotLength !== lightsStateHash.spotLength || lightsHash.rectAreaLength !== lightsStateHash.rectAreaLength || lightsHash.hemiLength !== lightsStateHash.hemiLength || lightsHash.shadowsLength !== lightsStateHash.shadowsLength)) material.needsUpdate = true;
            else if (materialProperties.numClippingPlanes !== undefined && (materialProperties.numClippingPlanes !== _clipping.numPlanes || materialProperties.numIntersection !== _clipping.numIntersection)) material.needsUpdate = true;
        }
        if (material.needsUpdate) {
            initMaterial(material, fog, object);
            material.needsUpdate = false;
        }
        var refreshProgram = false;
        var refreshMaterial = false;
        var refreshLights = false;
        var program = materialProperties.program, p_uniforms = program.getUniforms(), m_uniforms = materialProperties.shader.uniforms;
        if (state.useProgram(program.program)) {
            refreshProgram = true;
            refreshMaterial = true;
            refreshLights = true;
        }
        if (material.id !== _currentMaterialId) {
            _currentMaterialId = material.id;
            refreshMaterial = true;
        }
        if (refreshProgram || _currentCamera !== camera) {
            p_uniforms.setValue(_gl, "projectionMatrix", camera.projectionMatrix);
            if (capabilities.logarithmicDepthBuffer) p_uniforms.setValue(_gl, "logDepthBufFC", 2.0 / (Math.log(camera.far + 1.0) / Math.LN2));
            if (_currentCamera !== camera) {
                _currentCamera = camera;
                // lighting uniforms depend on the camera so enforce an update
                // now, in case this material supports lights - or later, when
                // the next material that does gets activated:
                refreshMaterial = true; // set to true on material change
                refreshLights = true; // remains set until update done
            }
            // load material specific uniforms
            // (shader material also gets them for the sake of genericity)
            if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.envMap) {
                var uCamPos = p_uniforms.map.cameraPosition;
                if (uCamPos !== undefined) uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));
            }
            if (material.isMeshPhongMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.skinning) p_uniforms.setValue(_gl, "viewMatrix", camera.matrixWorldInverse);
        }
        // skinning uniforms must be set even if material didn't change
        // auto-setting of texture unit for bone texture must go before other textures
        // not sure why, but otherwise weird things happen
        if (material.skinning) {
            p_uniforms.setOptional(_gl, object, "bindMatrix");
            p_uniforms.setOptional(_gl, object, "bindMatrixInverse");
            var skeleton = object.skeleton;
            if (skeleton) {
                var bones = skeleton.bones;
                if (capabilities.floatVertexTextures) {
                    if (skeleton.boneTexture === undefined) {
                        // layout (1 matrix = 4 pixels)
                        //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
                        //  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
                        //       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
                        //       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
                        //       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)
                        var size = Math.sqrt(bones.length * 4); // 4 pixels needed for 1 matrix
                        size = _Math.ceilPowerOfTwo(size);
                        size = Math.max(size, 4);
                        var boneMatrices = new Float32Array(size * size * 4); // 4 floats per RGBA pixel
                        boneMatrices.set(skeleton.boneMatrices); // copy current values
                        var boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);
                        boneTexture.needsUpdate = true;
                        skeleton.boneMatrices = boneMatrices;
                        skeleton.boneTexture = boneTexture;
                        skeleton.boneTextureSize = size;
                    }
                    p_uniforms.setValue(_gl, "boneTexture", skeleton.boneTexture);
                    p_uniforms.setValue(_gl, "boneTextureSize", skeleton.boneTextureSize);
                } else p_uniforms.setOptional(_gl, skeleton, "boneMatrices");
            }
        }
        if (refreshMaterial) {
            p_uniforms.setValue(_gl, "toneMappingExposure", _this.toneMappingExposure);
            p_uniforms.setValue(_gl, "toneMappingWhitePoint", _this.toneMappingWhitePoint);
            if (material.lights) // the current material requires lighting info
            // note: all lighting uniforms are always set correctly
            // they simply reference the renderer's state for their
            // values
            //
            // use the current material's .needsUpdate flags to set
            // the GL state when required
            markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
            // refresh uniforms common to several materials
            if (fog && material.fog) refreshUniformsFog(m_uniforms, fog);
            if (material.isMeshBasicMaterial) refreshUniformsCommon(m_uniforms, material);
            else if (material.isMeshLambertMaterial) {
                refreshUniformsCommon(m_uniforms, material);
                refreshUniformsLambert(m_uniforms, material);
            } else if (material.isMeshPhongMaterial) {
                refreshUniformsCommon(m_uniforms, material);
                if (material.isMeshToonMaterial) refreshUniformsToon(m_uniforms, material);
                else refreshUniformsPhong(m_uniforms, material);
            } else if (material.isMeshStandardMaterial) {
                refreshUniformsCommon(m_uniforms, material);
                if (material.isMeshPhysicalMaterial) refreshUniformsPhysical(m_uniforms, material);
                else refreshUniformsStandard(m_uniforms, material);
            } else if (material.isMeshMatcapMaterial) {
                refreshUniformsCommon(m_uniforms, material);
                refreshUniformsMatcap(m_uniforms, material);
            } else if (material.isMeshDepthMaterial) {
                refreshUniformsCommon(m_uniforms, material);
                refreshUniformsDepth(m_uniforms, material);
            } else if (material.isMeshDistanceMaterial) {
                refreshUniformsCommon(m_uniforms, material);
                refreshUniformsDistance(m_uniforms, material);
            } else if (material.isMeshNormalMaterial) {
                refreshUniformsCommon(m_uniforms, material);
                refreshUniformsNormal(m_uniforms, material);
            } else if (material.isLineBasicMaterial) {
                refreshUniformsLine(m_uniforms, material);
                if (material.isLineDashedMaterial) refreshUniformsDash(m_uniforms, material);
            } else if (material.isPointsMaterial) refreshUniformsPoints(m_uniforms, material);
            else if (material.isSpriteMaterial) refreshUniformsSprites(m_uniforms, material);
            else if (material.isShadowMaterial) {
                m_uniforms.color.value = material.color;
                m_uniforms.opacity.value = material.opacity;
            }
            // RectAreaLight Texture
            // TODO (mrdoob): Find a nicer implementation
            if (m_uniforms.ltc_1 !== undefined) m_uniforms.ltc_1.value = UniformsLib.LTC_1;
            if (m_uniforms.ltc_2 !== undefined) m_uniforms.ltc_2.value = UniformsLib.LTC_2;
            WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, _this);
        }
        if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
            WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, _this);
            material.uniformsNeedUpdate = false;
        }
        if (material.isSpriteMaterial) p_uniforms.setValue(_gl, "center", object.center);
        // common matrices
        p_uniforms.setValue(_gl, "modelViewMatrix", object.modelViewMatrix);
        p_uniforms.setValue(_gl, "normalMatrix", object.normalMatrix);
        p_uniforms.setValue(_gl, "modelMatrix", object.matrixWorld);
        return program;
    }
    // Uniforms (refresh uniforms objects)
    function refreshUniformsCommon(uniforms, material) {
        uniforms.opacity.value = material.opacity;
        if (material.color) uniforms.diffuse.value = material.color;
        if (material.emissive) uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
        if (material.map) uniforms.map.value = material.map;
        if (material.alphaMap) uniforms.alphaMap.value = material.alphaMap;
        if (material.specularMap) uniforms.specularMap.value = material.specularMap;
        if (material.envMap) {
            uniforms.envMap.value = material.envMap;
            // don't flip CubeTexture envMaps, flip everything else:
            //  WebGLRenderTargetCube will be flipped for backwards compatibility
            //  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture
            // this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future
            uniforms.flipEnvMap.value = material.envMap.isCubeTexture ? -1 : 1;
            uniforms.reflectivity.value = material.reflectivity;
            uniforms.refractionRatio.value = material.refractionRatio;
            uniforms.maxMipLevel.value = properties.get(material.envMap).__maxMipLevel;
        }
        if (material.lightMap) {
            uniforms.lightMap.value = material.lightMap;
            uniforms.lightMapIntensity.value = material.lightMapIntensity;
        }
        if (material.aoMap) {
            uniforms.aoMap.value = material.aoMap;
            uniforms.aoMapIntensity.value = material.aoMapIntensity;
        }
        // uv repeat and offset setting priorities
        // 1. color map
        // 2. specular map
        // 3. normal map
        // 4. bump map
        // 5. alpha map
        // 6. emissive map
        var uvScaleMap;
        if (material.map) uvScaleMap = material.map;
        else if (material.specularMap) uvScaleMap = material.specularMap;
        else if (material.displacementMap) uvScaleMap = material.displacementMap;
        else if (material.normalMap) uvScaleMap = material.normalMap;
        else if (material.bumpMap) uvScaleMap = material.bumpMap;
        else if (material.roughnessMap) uvScaleMap = material.roughnessMap;
        else if (material.metalnessMap) uvScaleMap = material.metalnessMap;
        else if (material.alphaMap) uvScaleMap = material.alphaMap;
        else if (material.emissiveMap) uvScaleMap = material.emissiveMap;
        if (uvScaleMap !== undefined) {
            // backwards compatibility
            if (uvScaleMap.isWebGLRenderTarget) uvScaleMap = uvScaleMap.texture;
            if (uvScaleMap.matrixAutoUpdate === true) uvScaleMap.updateMatrix();
            uniforms.uvTransform.value.copy(uvScaleMap.matrix);
        }
    }
    function refreshUniformsLine(uniforms, material) {
        uniforms.diffuse.value = material.color;
        uniforms.opacity.value = material.opacity;
    }
    function refreshUniformsDash(uniforms, material) {
        uniforms.dashSize.value = material.dashSize;
        uniforms.totalSize.value = material.dashSize + material.gapSize;
        uniforms.scale.value = material.scale;
    }
    function refreshUniformsPoints(uniforms, material) {
        uniforms.diffuse.value = material.color;
        uniforms.opacity.value = material.opacity;
        uniforms.size.value = material.size * _pixelRatio;
        uniforms.scale.value = _height * 0.5;
        uniforms.map.value = material.map;
        if (material.map !== null) {
            if (material.map.matrixAutoUpdate === true) material.map.updateMatrix();
            uniforms.uvTransform.value.copy(material.map.matrix);
        }
    }
    function refreshUniformsSprites(uniforms, material) {
        uniforms.diffuse.value = material.color;
        uniforms.opacity.value = material.opacity;
        uniforms.rotation.value = material.rotation;
        uniforms.map.value = material.map;
        if (material.map !== null) {
            if (material.map.matrixAutoUpdate === true) material.map.updateMatrix();
            uniforms.uvTransform.value.copy(material.map.matrix);
        }
    }
    function refreshUniformsFog(uniforms, fog) {
        uniforms.fogColor.value = fog.color;
        if (fog.isFog) {
            uniforms.fogNear.value = fog.near;
            uniforms.fogFar.value = fog.far;
        } else if (fog.isFogExp2) uniforms.fogDensity.value = fog.density;
    }
    function refreshUniformsLambert(uniforms, material) {
        if (material.emissiveMap) uniforms.emissiveMap.value = material.emissiveMap;
    }
    function refreshUniformsPhong(uniforms, material) {
        uniforms.specular.value = material.specular;
        uniforms.shininess.value = Math.max(material.shininess, 1e-4); // to prevent pow( 0.0, 0.0 )
        if (material.emissiveMap) uniforms.emissiveMap.value = material.emissiveMap;
        if (material.bumpMap) {
            uniforms.bumpMap.value = material.bumpMap;
            uniforms.bumpScale.value = material.bumpScale;
            if (material.side === BackSide) uniforms.bumpScale.value *= -1;
        }
        if (material.normalMap) {
            uniforms.normalMap.value = material.normalMap;
            uniforms.normalScale.value.copy(material.normalScale);
            if (material.side === BackSide) uniforms.normalScale.value.negate();
        }
        if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
        }
    }
    function refreshUniformsToon(uniforms, material) {
        refreshUniformsPhong(uniforms, material);
        if (material.gradientMap) uniforms.gradientMap.value = material.gradientMap;
    }
    function refreshUniformsStandard(uniforms, material) {
        uniforms.roughness.value = material.roughness;
        uniforms.metalness.value = material.metalness;
        if (material.roughnessMap) uniforms.roughnessMap.value = material.roughnessMap;
        if (material.metalnessMap) uniforms.metalnessMap.value = material.metalnessMap;
        if (material.emissiveMap) uniforms.emissiveMap.value = material.emissiveMap;
        if (material.bumpMap) {
            uniforms.bumpMap.value = material.bumpMap;
            uniforms.bumpScale.value = material.bumpScale;
            if (material.side === BackSide) uniforms.bumpScale.value *= -1;
        }
        if (material.normalMap) {
            uniforms.normalMap.value = material.normalMap;
            uniforms.normalScale.value.copy(material.normalScale);
            if (material.side === BackSide) uniforms.normalScale.value.negate();
        }
        if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
        }
        if (material.envMap) //uniforms.envMap.value = material.envMap; // part of uniforms common
        uniforms.envMapIntensity.value = material.envMapIntensity;
    }
    function refreshUniformsPhysical(uniforms, material) {
        refreshUniformsStandard(uniforms, material);
        uniforms.reflectivity.value = material.reflectivity; // also part of uniforms common
        uniforms.clearCoat.value = material.clearCoat;
        uniforms.clearCoatRoughness.value = material.clearCoatRoughness;
    }
    function refreshUniformsMatcap(uniforms, material) {
        if (material.matcap) uniforms.matcap.value = material.matcap;
        if (material.bumpMap) {
            uniforms.bumpMap.value = material.bumpMap;
            uniforms.bumpScale.value = material.bumpScale;
            if (material.side === BackSide) uniforms.bumpScale.value *= -1;
        }
        if (material.normalMap) {
            uniforms.normalMap.value = material.normalMap;
            uniforms.normalScale.value.copy(material.normalScale);
            if (material.side === BackSide) uniforms.normalScale.value.negate();
        }
        if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
        }
    }
    function refreshUniformsDepth(uniforms, material) {
        if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
        }
    }
    function refreshUniformsDistance(uniforms, material) {
        if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
        }
        uniforms.referencePosition.value.copy(material.referencePosition);
        uniforms.nearDistance.value = material.nearDistance;
        uniforms.farDistance.value = material.farDistance;
    }
    function refreshUniformsNormal(uniforms, material) {
        if (material.bumpMap) {
            uniforms.bumpMap.value = material.bumpMap;
            uniforms.bumpScale.value = material.bumpScale;
            if (material.side === BackSide) uniforms.bumpScale.value *= -1;
        }
        if (material.normalMap) {
            uniforms.normalMap.value = material.normalMap;
            uniforms.normalScale.value.copy(material.normalScale);
            if (material.side === BackSide) uniforms.normalScale.value.negate();
        }
        if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
        }
    }
    // If uniforms are marked as clean, they don't need to be loaded to the GPU.
    function markUniformsLightsNeedsUpdate(uniforms, value) {
        uniforms.ambientLightColor.needsUpdate = value;
        uniforms.directionalLights.needsUpdate = value;
        uniforms.pointLights.needsUpdate = value;
        uniforms.spotLights.needsUpdate = value;
        uniforms.rectAreaLights.needsUpdate = value;
        uniforms.hemisphereLights.needsUpdate = value;
    }
    // Textures
    function allocTextureUnit() {
        var textureUnit = _usedTextureUnits;
        if (textureUnit >= capabilities.maxTextures) console.warn("THREE.WebGLRenderer: Trying to use " + textureUnit + " texture units while this GPU supports only " + capabilities.maxTextures);
        _usedTextureUnits += 1;
        return textureUnit;
    }
    this.allocTextureUnit = allocTextureUnit;
    // this.setTexture2D = setTexture2D;
    this.setTexture2D = function() {
        var warned = false;
        // backwards compatibility: peel texture.texture
        return function setTexture2D(texture, slot) {
            if (texture && texture.isWebGLRenderTarget) {
                if (!warned) {
                    console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead.");
                    warned = true;
                }
                texture = texture.texture;
            }
            textures.setTexture2D(texture, slot);
        };
    }();
    this.setTexture3D = function() {
        // backwards compatibility: peel texture.texture
        return function setTexture3D(texture, slot) {
            textures.setTexture3D(texture, slot);
        };
    }();
    this.setTexture = function() {
        var warned = false;
        return function setTexture(texture, slot) {
            if (!warned) {
                console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead.");
                warned = true;
            }
            textures.setTexture2D(texture, slot);
        };
    }();
    this.setTextureCube = function() {
        var warned = false;
        return function setTextureCube(texture, slot) {
            // backwards compatibility: peel texture.texture
            if (texture && texture.isWebGLRenderTargetCube) {
                if (!warned) {
                    console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead.");
                    warned = true;
                }
                texture = texture.texture;
            }
            // currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture
            // TODO: unify these code paths
            if (texture && texture.isCubeTexture || Array.isArray(texture.image) && texture.image.length === 6) // CompressedTexture can have Array in image :/
            // this function alone should take care of cube textures
            textures.setTextureCube(texture, slot);
            else // assumed: texture property of THREE.WebGLRenderTargetCube
            textures.setTextureCubeDynamic(texture, slot);
        };
    }();
    //
    this.setFramebuffer = function(value) {
        _framebuffer = value;
    };
    this.getRenderTarget = function() {
        return _currentRenderTarget;
    };
    this.setRenderTarget = function(renderTarget) {
        _currentRenderTarget = renderTarget;
        if (renderTarget && properties.get(renderTarget).__webglFramebuffer === undefined) textures.setupRenderTarget(renderTarget);
        var framebuffer = _framebuffer;
        var isCube = false;
        if (renderTarget) {
            var __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
            if (renderTarget.isWebGLRenderTargetCube) {
                framebuffer = __webglFramebuffer[renderTarget.activeCubeFace];
                isCube = true;
            } else framebuffer = __webglFramebuffer;
            _currentViewport.copy(renderTarget.viewport);
            _currentScissor.copy(renderTarget.scissor);
            _currentScissorTest = renderTarget.scissorTest;
        } else {
            _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio);
            _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio);
            _currentScissorTest = _scissorTest;
        }
        if (_currentFramebuffer !== framebuffer) {
            _gl.bindFramebuffer(36160, framebuffer);
            _currentFramebuffer = framebuffer;
        }
        state.viewport(_currentViewport);
        state.scissor(_currentScissor);
        state.setScissorTest(_currentScissorTest);
        if (isCube) {
            var textureProperties = properties.get(renderTarget.texture);
            _gl.framebufferTexture2D(36160, 36064, 34069 + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel);
        }
    };
    this.readRenderTargetPixels = function(renderTarget, x, y, width, height, buffer) {
        if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
            return;
        }
        var framebuffer = properties.get(renderTarget).__webglFramebuffer;
        if (framebuffer) {
            var restore = false;
            if (framebuffer !== _currentFramebuffer) {
                _gl.bindFramebuffer(36160, framebuffer);
                restore = true;
            }
            try {
                var texture = renderTarget.texture;
                var textureFormat = texture.format;
                var textureType = texture.type;
                if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(35739)) {
                    console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                    return;
                }
                if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(35738) && // IE11, Edge and Chrome Mac < 52 (#9513)
                !(textureType === FloatType && (capabilities.isWebGL2 || extensions.get("OES_texture_float") || extensions.get("WEBGL_color_buffer_float"))) && // Chrome Mac >= 52 and Firefox
                !(textureType === HalfFloatType && (capabilities.isWebGL2 ? extensions.get("EXT_color_buffer_float") : extensions.get("EXT_color_buffer_half_float")))) {
                    console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                    return;
                }
                if (_gl.checkFramebufferStatus(36160) === 36053) // the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)
                {
                    if (x >= 0 && x <= renderTarget.width - width && y >= 0 && y <= renderTarget.height - height) _gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
                } else console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.");
            } finally{
                if (restore) _gl.bindFramebuffer(36160, _currentFramebuffer);
            }
        }
    };
    this.copyFramebufferToTexture = function(position, texture, level) {
        var width = texture.image.width;
        var height = texture.image.height;
        var glFormat = utils.convert(texture.format);
        this.setTexture2D(texture, 0);
        _gl.copyTexImage2D(3553, level || 0, glFormat, position.x, position.y, width, height, 0);
    };
    this.copyTextureToTexture = function(position, srcTexture, dstTexture, level) {
        var width = srcTexture.image.width;
        var height = srcTexture.image.height;
        var glFormat = utils.convert(dstTexture.format);
        var glType = utils.convert(dstTexture.type);
        this.setTexture2D(dstTexture, 0);
        if (srcTexture.isDataTexture) _gl.texSubImage2D(3553, level || 0, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);
        else _gl.texSubImage2D(3553, level || 0, position.x, position.y, glFormat, glType, srcTexture.image);
    };
}
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */ function FogExp2(color, density) {
    this.name = "";
    this.color = new Color(color);
    this.density = density !== undefined ? density : 0.00025;
}
FogExp2.prototype.isFogExp2 = true;
FogExp2.prototype.clone = function() {
    return new FogExp2(this.color, this.density);
};
FogExp2.prototype.toJSON = function() {
    return {
        type: "FogExp2",
        color: this.color.getHex(),
        density: this.density
    };
};
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */ function Fog(color, near, far) {
    this.name = "";
    this.color = new Color(color);
    this.near = near !== undefined ? near : 1;
    this.far = far !== undefined ? far : 1000;
}
Fog.prototype.isFog = true;
Fog.prototype.clone = function() {
    return new Fog(this.color, this.near, this.far);
};
Fog.prototype.toJSON = function() {
    return {
        type: "Fog",
        color: this.color.getHex(),
        near: this.near,
        far: this.far
    };
};
/**
 * @author mrdoob / http://mrdoob.com/
 */ function Scene() {
    Object3D.call(this);
    this.type = "Scene";
    this.background = null;
    this.fog = null;
    this.overrideMaterial = null;
    this.autoUpdate = true; // checked by the renderer
}
Scene.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Scene,
    copy: function(source, recursive) {
        Object3D.prototype.copy.call(this, source, recursive);
        if (source.background !== null) this.background = source.background.clone();
        if (source.fog !== null) this.fog = source.fog.clone();
        if (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();
        this.autoUpdate = source.autoUpdate;
        this.matrixAutoUpdate = source.matrixAutoUpdate;
        return this;
    },
    toJSON: function(meta) {
        var data = Object3D.prototype.toJSON.call(this, meta);
        if (this.background !== null) data.object.background = this.background.toJSON(meta);
        if (this.fog !== null) data.object.fog = this.fog.toJSON();
        return data;
    }
});
/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */ function InterleavedBuffer(array, stride) {
    this.array = array;
    this.stride = stride;
    this.count = array !== undefined ? array.length / stride : 0;
    this.dynamic = false;
    this.updateRange = {
        offset: 0,
        count: -1
    };
    this.version = 0;
}
Object.defineProperty(InterleavedBuffer.prototype, "needsUpdate", {
    set: function(value) {
        if (value === true) this.version++;
    }
});
Object.assign(InterleavedBuffer.prototype, {
    isInterleavedBuffer: true,
    onUploadCallback: function() {},
    setArray: function(array) {
        if (Array.isArray(array)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.count = array !== undefined ? array.length / this.stride : 0;
        this.array = array;
        return this;
    },
    setDynamic: function(value) {
        this.dynamic = value;
        return this;
    },
    copy: function(source) {
        this.array = new source.array.constructor(source.array);
        this.count = source.count;
        this.stride = source.stride;
        this.dynamic = source.dynamic;
        return this;
    },
    copyAt: function(index1, attribute, index2) {
        index1 *= this.stride;
        index2 *= attribute.stride;
        for(var i = 0, l = this.stride; i < l; i++)this.array[index1 + i] = attribute.array[index2 + i];
        return this;
    },
    set: function(value, offset) {
        if (offset === undefined) offset = 0;
        this.array.set(value, offset);
        return this;
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    onUpload: function(callback) {
        this.onUploadCallback = callback;
        return this;
    }
});
/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */ function InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, normalized) {
    this.data = interleavedBuffer;
    this.itemSize = itemSize;
    this.offset = offset;
    this.normalized = normalized === true;
}
Object.defineProperties(InterleavedBufferAttribute.prototype, {
    count: {
        get: function() {
            return this.data.count;
        }
    },
    array: {
        get: function() {
            return this.data.array;
        }
    }
});
Object.assign(InterleavedBufferAttribute.prototype, {
    isInterleavedBufferAttribute: true,
    setX: function(index, x) {
        this.data.array[index * this.data.stride + this.offset] = x;
        return this;
    },
    setY: function(index, y) {
        this.data.array[index * this.data.stride + this.offset + 1] = y;
        return this;
    },
    setZ: function(index, z) {
        this.data.array[index * this.data.stride + this.offset + 2] = z;
        return this;
    },
    setW: function(index, w) {
        this.data.array[index * this.data.stride + this.offset + 3] = w;
        return this;
    },
    getX: function(index) {
        return this.data.array[index * this.data.stride + this.offset];
    },
    getY: function(index) {
        return this.data.array[index * this.data.stride + this.offset + 1];
    },
    getZ: function(index) {
        return this.data.array[index * this.data.stride + this.offset + 2];
    },
    getW: function(index) {
        return this.data.array[index * this.data.stride + this.offset + 3];
    },
    setXY: function(index, x, y) {
        index = index * this.data.stride + this.offset;
        this.data.array[index + 0] = x;
        this.data.array[index + 1] = y;
        return this;
    },
    setXYZ: function(index, x, y, z) {
        index = index * this.data.stride + this.offset;
        this.data.array[index + 0] = x;
        this.data.array[index + 1] = y;
        this.data.array[index + 2] = z;
        return this;
    },
    setXYZW: function(index, x, y, z, w) {
        index = index * this.data.stride + this.offset;
        this.data.array[index + 0] = x;
        this.data.array[index + 1] = y;
        this.data.array[index + 2] = z;
        this.data.array[index + 3] = w;
        return this;
    }
});
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  map: new THREE.Texture( <Image> ),
 *  rotation: <float>,
 *  sizeAttenuation: <bool>
 * }
 */ function SpriteMaterial(parameters) {
    Material.call(this);
    this.type = "SpriteMaterial";
    this.color = new Color(0xffffff);
    this.map = null;
    this.rotation = 0;
    this.sizeAttenuation = true;
    this.lights = false;
    this.transparent = true;
    this.setValues(parameters);
}
SpriteMaterial.prototype = Object.create(Material.prototype);
SpriteMaterial.prototype.constructor = SpriteMaterial;
SpriteMaterial.prototype.isSpriteMaterial = true;
SpriteMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.map = source.map;
    this.rotation = source.rotation;
    this.sizeAttenuation = source.sizeAttenuation;
    return this;
};
/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */ var geometry;
function Sprite(material) {
    Object3D.call(this);
    this.type = "Sprite";
    if (geometry === undefined) {
        geometry = new BufferGeometry();
        var float32Array = new Float32Array([
            -0.5,
            -0.5,
            0,
            0,
            0,
            0.5,
            -0.5,
            0,
            1,
            0,
            0.5,
            0.5,
            0,
            1,
            1,
            -0.5,
            0.5,
            0,
            0,
            1
        ]);
        var interleavedBuffer = new InterleavedBuffer(float32Array, 5);
        geometry.setIndex([
            0,
            1,
            2,
            0,
            2,
            3
        ]);
        geometry.addAttribute("position", new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));
        geometry.addAttribute("uv", new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));
    }
    this.geometry = geometry;
    this.material = material !== undefined ? material : new SpriteMaterial();
    this.center = new Vector2(0.5, 0.5);
}
Sprite.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Sprite,
    isSprite: true,
    raycast: function() {
        var intersectPoint = new Vector3();
        var worldScale = new Vector3();
        var mvPosition = new Vector3();
        var alignedPosition = new Vector2();
        var rotatedPosition = new Vector2();
        var viewWorldMatrix = new Matrix4();
        var vA = new Vector3();
        var vB = new Vector3();
        var vC = new Vector3();
        var uvA = new Vector2();
        var uvB = new Vector2();
        var uvC = new Vector2();
        function transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {
            // compute position in camera space
            alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale);
            // to check if rotation is not zero
            if (sin !== undefined) {
                rotatedPosition.x = cos * alignedPosition.x - sin * alignedPosition.y;
                rotatedPosition.y = sin * alignedPosition.x + cos * alignedPosition.y;
            } else rotatedPosition.copy(alignedPosition);
            vertexPosition.copy(mvPosition);
            vertexPosition.x += rotatedPosition.x;
            vertexPosition.y += rotatedPosition.y;
            // transform to world space
            vertexPosition.applyMatrix4(viewWorldMatrix);
        }
        return function raycast(raycaster, intersects) {
            worldScale.setFromMatrixScale(this.matrixWorld);
            viewWorldMatrix.getInverse(this.modelViewMatrix).premultiply(this.matrixWorld);
            mvPosition.setFromMatrixPosition(this.modelViewMatrix);
            var rotation = this.material.rotation;
            var sin, cos;
            if (rotation !== 0) {
                cos = Math.cos(rotation);
                sin = Math.sin(rotation);
            }
            var center = this.center;
            transformVertex(vA.set(-0.5, -0.5, 0), mvPosition, center, worldScale, sin, cos);
            transformVertex(vB.set(0.5, -0.5, 0), mvPosition, center, worldScale, sin, cos);
            transformVertex(vC.set(0.5, 0.5, 0), mvPosition, center, worldScale, sin, cos);
            uvA.set(0, 0);
            uvB.set(1, 0);
            uvC.set(1, 1);
            // check first triangle
            var intersect = raycaster.ray.intersectTriangle(vA, vB, vC, false, intersectPoint);
            if (intersect === null) {
                // check second triangle
                transformVertex(vB.set(-0.5, 0.5, 0), mvPosition, center, worldScale, sin, cos);
                uvB.set(0, 1);
                intersect = raycaster.ray.intersectTriangle(vA, vC, vB, false, intersectPoint);
                if (intersect === null) return;
            }
            var distance = raycaster.ray.origin.distanceTo(intersectPoint);
            if (distance < raycaster.near || distance > raycaster.far) return;
            intersects.push({
                distance: distance,
                point: intersectPoint.clone(),
                uv: Triangle.getUV(intersectPoint, vA, vB, vC, uvA, uvB, uvC, new Vector2()),
                face: null,
                object: this
            });
        };
    }(),
    clone: function() {
        return new this.constructor(this.material).copy(this);
    },
    copy: function(source) {
        Object3D.prototype.copy.call(this, source);
        if (source.center !== undefined) this.center.copy(source.center);
        return this;
    }
});
/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */ function LOD() {
    Object3D.call(this);
    this.type = "LOD";
    Object.defineProperties(this, {
        levels: {
            enumerable: true,
            value: []
        }
    });
}
LOD.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: LOD,
    copy: function(source) {
        Object3D.prototype.copy.call(this, source, false);
        var levels = source.levels;
        for(var i = 0, l = levels.length; i < l; i++){
            var level = levels[i];
            this.addLevel(level.object.clone(), level.distance);
        }
        return this;
    },
    addLevel: function(object, distance) {
        if (distance === undefined) distance = 0;
        distance = Math.abs(distance);
        var levels = this.levels;
        for(var l = 0; l < levels.length; l++){
            if (distance < levels[l].distance) break;
        }
        levels.splice(l, 0, {
            distance: distance,
            object: object
        });
        this.add(object);
    },
    getObjectForDistance: function(distance) {
        var levels = this.levels;
        for(var i = 1, l = levels.length; i < l; i++){
            if (distance < levels[i].distance) break;
        }
        return levels[i - 1].object;
    },
    raycast: function() {
        var matrixPosition = new Vector3();
        return function raycast(raycaster, intersects) {
            matrixPosition.setFromMatrixPosition(this.matrixWorld);
            var distance = raycaster.ray.origin.distanceTo(matrixPosition);
            this.getObjectForDistance(distance).raycast(raycaster, intersects);
        };
    }(),
    update: function() {
        var v1 = new Vector3();
        var v2 = new Vector3();
        return function update(camera) {
            var levels = this.levels;
            if (levels.length > 1) {
                v1.setFromMatrixPosition(camera.matrixWorld);
                v2.setFromMatrixPosition(this.matrixWorld);
                var distance = v1.distanceTo(v2);
                levels[0].object.visible = true;
                for(var i = 1, l = levels.length; i < l; i++){
                    if (distance >= levels[i].distance) {
                        levels[i - 1].object.visible = false;
                        levels[i].object.visible = true;
                    } else break;
                }
                for(; i < l; i++)levels[i].object.visible = false;
            }
        };
    }(),
    toJSON: function(meta) {
        var data = Object3D.prototype.toJSON.call(this, meta);
        data.object.levels = [];
        var levels = this.levels;
        for(var i = 0, l = levels.length; i < l; i++){
            var level = levels[i];
            data.object.levels.push({
                object: level.object.uuid,
                distance: level.distance
            });
        }
        return data;
    }
});
/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */ function SkinnedMesh(geometry, material) {
    if (geometry && geometry.isGeometry) console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    Mesh.call(this, geometry, material);
    this.type = "SkinnedMesh";
    this.bindMode = "attached";
    this.bindMatrix = new Matrix4();
    this.bindMatrixInverse = new Matrix4();
}
SkinnedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {
    constructor: SkinnedMesh,
    isSkinnedMesh: true,
    bind: function(skeleton, bindMatrix) {
        this.skeleton = skeleton;
        if (bindMatrix === undefined) {
            this.updateMatrixWorld(true);
            this.skeleton.calculateInverses();
            bindMatrix = this.matrixWorld;
        }
        this.bindMatrix.copy(bindMatrix);
        this.bindMatrixInverse.getInverse(bindMatrix);
    },
    pose: function() {
        this.skeleton.pose();
    },
    normalizeSkinWeights: function() {
        var vector = new Vector4();
        var skinWeight = this.geometry.attributes.skinWeight;
        for(var i = 0, l = skinWeight.count; i < l; i++){
            vector.x = skinWeight.getX(i);
            vector.y = skinWeight.getY(i);
            vector.z = skinWeight.getZ(i);
            vector.w = skinWeight.getW(i);
            var scale = 1.0 / vector.manhattanLength();
            if (scale !== Infinity) vector.multiplyScalar(scale);
            else vector.set(1, 0, 0, 0); // do something reasonable
            skinWeight.setXYZW(i, vector.x, vector.y, vector.z, vector.w);
        }
    },
    updateMatrixWorld: function(force) {
        Mesh.prototype.updateMatrixWorld.call(this, force);
        if (this.bindMode === "attached") this.bindMatrixInverse.getInverse(this.matrixWorld);
        else if (this.bindMode === "detached") this.bindMatrixInverse.getInverse(this.bindMatrix);
        else console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
    },
    clone: function() {
        return new this.constructor(this.geometry, this.material).copy(this);
    }
});
/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author michael guerrero / http://realitymeltdown.com
 * @author ikerr / http://verold.com
 */ function Skeleton(bones, boneInverses) {
    // copy the bone array
    bones = bones || [];
    this.bones = bones.slice(0);
    this.boneMatrices = new Float32Array(this.bones.length * 16);
    // use the supplied bone inverses or calculate the inverses
    if (boneInverses === undefined) this.calculateInverses();
    else if (this.bones.length === boneInverses.length) this.boneInverses = boneInverses.slice(0);
    else {
        console.warn("THREE.Skeleton boneInverses is the wrong length.");
        this.boneInverses = [];
        for(var i = 0, il = this.bones.length; i < il; i++)this.boneInverses.push(new Matrix4());
    }
}
Object.assign(Skeleton.prototype, {
    calculateInverses: function() {
        this.boneInverses = [];
        for(var i = 0, il = this.bones.length; i < il; i++){
            var inverse = new Matrix4();
            if (this.bones[i]) inverse.getInverse(this.bones[i].matrixWorld);
            this.boneInverses.push(inverse);
        }
    },
    pose: function() {
        var bone, i, il;
        // recover the bind-time world matrices
        for(i = 0, il = this.bones.length; i < il; i++){
            bone = this.bones[i];
            if (bone) bone.matrixWorld.getInverse(this.boneInverses[i]);
        }
        // compute the local matrices, positions, rotations and scales
        for(i = 0, il = this.bones.length; i < il; i++){
            bone = this.bones[i];
            if (bone) {
                if (bone.parent && bone.parent.isBone) {
                    bone.matrix.getInverse(bone.parent.matrixWorld);
                    bone.matrix.multiply(bone.matrixWorld);
                } else bone.matrix.copy(bone.matrixWorld);
                bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
            }
        }
    },
    update: function() {
        var offsetMatrix = new Matrix4();
        var identityMatrix = new Matrix4();
        return function update() {
            var bones = this.bones;
            var boneInverses = this.boneInverses;
            var boneMatrices = this.boneMatrices;
            var boneTexture = this.boneTexture;
            // flatten bone matrices to array
            for(var i = 0, il = bones.length; i < il; i++){
                // compute the offset between the current and the original transform
                var matrix = bones[i] ? bones[i].matrixWorld : identityMatrix;
                offsetMatrix.multiplyMatrices(matrix, boneInverses[i]);
                offsetMatrix.toArray(boneMatrices, i * 16);
            }
            if (boneTexture !== undefined) boneTexture.needsUpdate = true;
        };
    }(),
    clone: function() {
        return new Skeleton(this.bones, this.boneInverses);
    },
    getBoneByName: function(name) {
        for(var i = 0, il = this.bones.length; i < il; i++){
            var bone = this.bones[i];
            if (bone.name === name) return bone;
        }
        return undefined;
    }
});
/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */ function Bone() {
    Object3D.call(this);
    this.type = "Bone";
}
Bone.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Bone,
    isBone: true
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  linewidth: <float>,
 *  linecap: "round",
 *  linejoin: "round"
 * }
 */ function LineBasicMaterial(parameters) {
    Material.call(this);
    this.type = "LineBasicMaterial";
    this.color = new Color(0xffffff);
    this.linewidth = 1;
    this.linecap = "round";
    this.linejoin = "round";
    this.lights = false;
    this.setValues(parameters);
}
LineBasicMaterial.prototype = Object.create(Material.prototype);
LineBasicMaterial.prototype.constructor = LineBasicMaterial;
LineBasicMaterial.prototype.isLineBasicMaterial = true;
LineBasicMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.linewidth = source.linewidth;
    this.linecap = source.linecap;
    this.linejoin = source.linejoin;
    return this;
};
/**
 * @author mrdoob / http://mrdoob.com/
 */ function Line(geometry, material, mode) {
    if (mode === 1) console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead.");
    Object3D.call(this);
    this.type = "Line";
    this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
    this.material = material !== undefined ? material : new LineBasicMaterial({
        color: Math.random() * 0xffffff
    });
}
Line.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Line,
    isLine: true,
    computeLineDistances: function() {
        var start = new Vector3();
        var end = new Vector3();
        return function computeLineDistances() {
            var geometry = this.geometry;
            if (geometry.isBufferGeometry) {
                // we assume non-indexed geometry
                if (geometry.index === null) {
                    var positionAttribute = geometry.attributes.position;
                    var lineDistances = [
                        0
                    ];
                    for(var i = 1, l = positionAttribute.count; i < l; i++){
                        start.fromBufferAttribute(positionAttribute, i - 1);
                        end.fromBufferAttribute(positionAttribute, i);
                        lineDistances[i] = lineDistances[i - 1];
                        lineDistances[i] += start.distanceTo(end);
                    }
                    geometry.addAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
                } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
            } else if (geometry.isGeometry) {
                var vertices = geometry.vertices;
                var lineDistances = geometry.lineDistances;
                lineDistances[0] = 0;
                for(var i = 1, l = vertices.length; i < l; i++){
                    lineDistances[i] = lineDistances[i - 1];
                    lineDistances[i] += vertices[i - 1].distanceTo(vertices[i]);
                }
            }
            return this;
        };
    }(),
    raycast: function() {
        var inverseMatrix = new Matrix4();
        var ray = new Ray();
        var sphere = new Sphere();
        return function raycast(raycaster, intersects) {
            var precision = raycaster.linePrecision;
            var geometry = this.geometry;
            var matrixWorld = this.matrixWorld;
            // Checking boundingSphere distance to ray
            if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
            sphere.copy(geometry.boundingSphere);
            sphere.applyMatrix4(matrixWorld);
            sphere.radius += precision;
            if (raycaster.ray.intersectsSphere(sphere) === false) return;
            //
            inverseMatrix.getInverse(matrixWorld);
            ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
            var localPrecision = precision / ((this.scale.x + this.scale.y + this.scale.z) / 3);
            var localPrecisionSq = localPrecision * localPrecision;
            var vStart = new Vector3();
            var vEnd = new Vector3();
            var interSegment = new Vector3();
            var interRay = new Vector3();
            var step = this && this.isLineSegments ? 2 : 1;
            if (geometry.isBufferGeometry) {
                var index = geometry.index;
                var attributes = geometry.attributes;
                var positions = attributes.position.array;
                if (index !== null) {
                    var indices = index.array;
                    for(var i = 0, l = indices.length - 1; i < l; i += step){
                        var a = indices[i];
                        var b = indices[i + 1];
                        vStart.fromArray(positions, a * 3);
                        vEnd.fromArray(positions, b * 3);
                        var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
                        if (distSq > localPrecisionSq) continue;
                        interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation
                        var distance = raycaster.ray.origin.distanceTo(interRay);
                        if (distance < raycaster.near || distance > raycaster.far) continue;
                        intersects.push({
                            distance: distance,
                            // What do we want? intersection point on the ray or on the segment??
                            // point: raycaster.ray.at( distance ),
                            point: interSegment.clone().applyMatrix4(this.matrixWorld),
                            index: i,
                            face: null,
                            faceIndex: null,
                            object: this
                        });
                    }
                } else for(var i = 0, l = positions.length / 3 - 1; i < l; i += step){
                    vStart.fromArray(positions, 3 * i);
                    vEnd.fromArray(positions, 3 * i + 3);
                    var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
                    if (distSq > localPrecisionSq) continue;
                    interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation
                    var distance = raycaster.ray.origin.distanceTo(interRay);
                    if (distance < raycaster.near || distance > raycaster.far) continue;
                    intersects.push({
                        distance: distance,
                        // What do we want? intersection point on the ray or on the segment??
                        // point: raycaster.ray.at( distance ),
                        point: interSegment.clone().applyMatrix4(this.matrixWorld),
                        index: i,
                        face: null,
                        faceIndex: null,
                        object: this
                    });
                }
            } else if (geometry.isGeometry) {
                var vertices = geometry.vertices;
                var nbVertices = vertices.length;
                for(var i = 0; i < nbVertices - 1; i += step){
                    var distSq = ray.distanceSqToSegment(vertices[i], vertices[i + 1], interRay, interSegment);
                    if (distSq > localPrecisionSq) continue;
                    interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation
                    var distance = raycaster.ray.origin.distanceTo(interRay);
                    if (distance < raycaster.near || distance > raycaster.far) continue;
                    intersects.push({
                        distance: distance,
                        // What do we want? intersection point on the ray or on the segment??
                        // point: raycaster.ray.at( distance ),
                        point: interSegment.clone().applyMatrix4(this.matrixWorld),
                        index: i,
                        face: null,
                        faceIndex: null,
                        object: this
                    });
                }
            }
        };
    }(),
    copy: function(source) {
        Object3D.prototype.copy.call(this, source);
        this.geometry.copy(source.geometry);
        this.material.copy(source.material);
        return this;
    },
    clone: function() {
        return new this.constructor().copy(this);
    }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */ function LineSegments(geometry, material) {
    Line.call(this, geometry, material);
    this.type = "LineSegments";
}
LineSegments.prototype = Object.assign(Object.create(Line.prototype), {
    constructor: LineSegments,
    isLineSegments: true,
    computeLineDistances: function() {
        var start = new Vector3();
        var end = new Vector3();
        return function computeLineDistances() {
            var geometry = this.geometry;
            if (geometry.isBufferGeometry) {
                // we assume non-indexed geometry
                if (geometry.index === null) {
                    var positionAttribute = geometry.attributes.position;
                    var lineDistances = [];
                    for(var i = 0, l = positionAttribute.count; i < l; i += 2){
                        start.fromBufferAttribute(positionAttribute, i);
                        end.fromBufferAttribute(positionAttribute, i + 1);
                        lineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];
                        lineDistances[i + 1] = lineDistances[i] + start.distanceTo(end);
                    }
                    geometry.addAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
                } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
            } else if (geometry.isGeometry) {
                var vertices = geometry.vertices;
                var lineDistances = geometry.lineDistances;
                for(var i = 0, l = vertices.length; i < l; i += 2){
                    start.copy(vertices[i]);
                    end.copy(vertices[i + 1]);
                    lineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];
                    lineDistances[i + 1] = lineDistances[i] + start.distanceTo(end);
                }
            }
            return this;
        };
    }()
});
/**
 * @author mgreter / http://github.com/mgreter
 */ function LineLoop(geometry, material) {
    Line.call(this, geometry, material);
    this.type = "LineLoop";
}
LineLoop.prototype = Object.assign(Object.create(Line.prototype), {
    constructor: LineLoop,
    isLineLoop: true
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  size: <float>,
 *  sizeAttenuation: <bool>
 *
 *  morphTargets: <bool>
 * }
 */ function PointsMaterial(parameters) {
    Material.call(this);
    this.type = "PointsMaterial";
    this.color = new Color(0xffffff);
    this.map = null;
    this.size = 1;
    this.sizeAttenuation = true;
    this.morphTargets = false;
    this.lights = false;
    this.setValues(parameters);
}
PointsMaterial.prototype = Object.create(Material.prototype);
PointsMaterial.prototype.constructor = PointsMaterial;
PointsMaterial.prototype.isPointsMaterial = true;
PointsMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.map = source.map;
    this.size = source.size;
    this.sizeAttenuation = source.sizeAttenuation;
    this.morphTargets = source.morphTargets;
    return this;
};
/**
 * @author alteredq / http://alteredqualia.com/
 */ function Points(geometry, material) {
    Object3D.call(this);
    this.type = "Points";
    this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
    this.material = material !== undefined ? material : new PointsMaterial({
        color: Math.random() * 0xffffff
    });
}
Points.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Points,
    isPoints: true,
    raycast: function() {
        var inverseMatrix = new Matrix4();
        var ray = new Ray();
        var sphere = new Sphere();
        return function raycast(raycaster, intersects) {
            var object = this;
            var geometry = this.geometry;
            var matrixWorld = this.matrixWorld;
            var threshold = raycaster.params.Points.threshold;
            // Checking boundingSphere distance to ray
            if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
            sphere.copy(geometry.boundingSphere);
            sphere.applyMatrix4(matrixWorld);
            sphere.radius += threshold;
            if (raycaster.ray.intersectsSphere(sphere) === false) return;
            //
            inverseMatrix.getInverse(matrixWorld);
            ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
            var localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
            var localThresholdSq = localThreshold * localThreshold;
            var position = new Vector3();
            var intersectPoint = new Vector3();
            function testPoint(point, index) {
                var rayPointDistanceSq = ray.distanceSqToPoint(point);
                if (rayPointDistanceSq < localThresholdSq) {
                    ray.closestPointToPoint(point, intersectPoint);
                    intersectPoint.applyMatrix4(matrixWorld);
                    var distance = raycaster.ray.origin.distanceTo(intersectPoint);
                    if (distance < raycaster.near || distance > raycaster.far) return;
                    intersects.push({
                        distance: distance,
                        distanceToRay: Math.sqrt(rayPointDistanceSq),
                        point: intersectPoint.clone(),
                        index: index,
                        face: null,
                        object: object
                    });
                }
            }
            if (geometry.isBufferGeometry) {
                var index = geometry.index;
                var attributes = geometry.attributes;
                var positions = attributes.position.array;
                if (index !== null) {
                    var indices = index.array;
                    for(var i = 0, il = indices.length; i < il; i++){
                        var a = indices[i];
                        position.fromArray(positions, a * 3);
                        testPoint(position, a);
                    }
                } else for(var i = 0, l = positions.length / 3; i < l; i++){
                    position.fromArray(positions, i * 3);
                    testPoint(position, i);
                }
            } else {
                var vertices = geometry.vertices;
                for(var i = 0, l = vertices.length; i < l; i++)testPoint(vertices[i], i);
            }
        };
    }(),
    clone: function() {
        return new this.constructor(this.geometry, this.material).copy(this);
    }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */ function VideoTexture(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
    Texture.call(this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.format = format !== undefined ? format : RGBFormat;
    this.minFilter = minFilter !== undefined ? minFilter : LinearFilter;
    this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
    this.generateMipmaps = false;
}
VideoTexture.prototype = Object.assign(Object.create(Texture.prototype), {
    constructor: VideoTexture,
    isVideoTexture: true,
    update: function() {
        var video = this.image;
        if (video.readyState >= video.HAVE_CURRENT_DATA) this.needsUpdate = true;
    }
});
/**
 * @author alteredq / http://alteredqualia.com/
 */ function CompressedTexture(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
    Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
    this.image = {
        width: width,
        height: height
    };
    this.mipmaps = mipmaps;
    // no flipping for cube textures
    // (also flipping doesn't work for compressed textures )
    this.flipY = false;
    // can't generate mipmaps for compressed textures
    // mips must be embedded in DDS files
    this.generateMipmaps = false;
}
CompressedTexture.prototype = Object.create(Texture.prototype);
CompressedTexture.prototype.constructor = CompressedTexture;
CompressedTexture.prototype.isCompressedTexture = true;
/**
 * @author mrdoob / http://mrdoob.com/
 */ function CanvasTexture(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
    Texture.call(this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.needsUpdate = true;
}
CanvasTexture.prototype = Object.create(Texture.prototype);
CanvasTexture.prototype.constructor = CanvasTexture;
CanvasTexture.prototype.isCanvasTexture = true;
/**
 * @author Matt DesLauriers / @mattdesl
 * @author atix / arthursilber.de
 */ function DepthTexture(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
    format = format !== undefined ? format : DepthFormat;
    if (format !== DepthFormat && format !== DepthStencilFormat) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    if (type === undefined && format === DepthFormat) type = UnsignedShortType;
    if (type === undefined && format === DepthStencilFormat) type = UnsignedInt248Type;
    Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.image = {
        width: width,
        height: height
    };
    this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
    this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
    this.flipY = false;
    this.generateMipmaps = false;
}
DepthTexture.prototype = Object.create(Texture.prototype);
DepthTexture.prototype.constructor = DepthTexture;
DepthTexture.prototype.isDepthTexture = true;
/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */ function WireframeGeometry(geometry) {
    BufferGeometry.call(this);
    this.type = "WireframeGeometry";
    // buffer
    var vertices = [];
    // helper variables
    var i, j, l, o, ol;
    var edge = [
        0,
        0
    ], edges = {}, e, edge1, edge2;
    var key, keys = [
        "a",
        "b",
        "c"
    ];
    var vertex;
    // different logic for Geometry and BufferGeometry
    if (geometry && geometry.isGeometry) {
        // create a data structure that contains all edges without duplicates
        var faces = geometry.faces;
        for(i = 0, l = faces.length; i < l; i++){
            var face = faces[i];
            for(j = 0; j < 3; j++){
                edge1 = face[keys[j]];
                edge2 = face[keys[(j + 1) % 3]];
                edge[0] = Math.min(edge1, edge2); // sorting prevents duplicates
                edge[1] = Math.max(edge1, edge2);
                key = edge[0] + "," + edge[1];
                if (edges[key] === undefined) edges[key] = {
                    index1: edge[0],
                    index2: edge[1]
                };
            }
        }
        // generate vertices
        for(key in edges){
            e = edges[key];
            vertex = geometry.vertices[e.index1];
            vertices.push(vertex.x, vertex.y, vertex.z);
            vertex = geometry.vertices[e.index2];
            vertices.push(vertex.x, vertex.y, vertex.z);
        }
    } else if (geometry && geometry.isBufferGeometry) {
        var position, indices, groups;
        var group, start, count;
        var index1, index2;
        vertex = new Vector3();
        if (geometry.index !== null) {
            // indexed BufferGeometry
            position = geometry.attributes.position;
            indices = geometry.index;
            groups = geometry.groups;
            if (groups.length === 0) groups = [
                {
                    start: 0,
                    count: indices.count,
                    materialIndex: 0
                }
            ];
            // create a data structure that contains all eges without duplicates
            for(o = 0, ol = groups.length; o < ol; ++o){
                group = groups[o];
                start = group.start;
                count = group.count;
                for(i = start, l = start + count; i < l; i += 3)for(j = 0; j < 3; j++){
                    edge1 = indices.getX(i + j);
                    edge2 = indices.getX(i + (j + 1) % 3);
                    edge[0] = Math.min(edge1, edge2); // sorting prevents duplicates
                    edge[1] = Math.max(edge1, edge2);
                    key = edge[0] + "," + edge[1];
                    if (edges[key] === undefined) edges[key] = {
                        index1: edge[0],
                        index2: edge[1]
                    };
                }
            }
            // generate vertices
            for(key in edges){
                e = edges[key];
                vertex.fromBufferAttribute(position, e.index1);
                vertices.push(vertex.x, vertex.y, vertex.z);
                vertex.fromBufferAttribute(position, e.index2);
                vertices.push(vertex.x, vertex.y, vertex.z);
            }
        } else {
            // non-indexed BufferGeometry
            position = geometry.attributes.position;
            for(i = 0, l = position.count / 3; i < l; i++)for(j = 0; j < 3; j++){
                // three edges per triangle, an edge is represented as (index1, index2)
                // e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)
                index1 = 3 * i + j;
                vertex.fromBufferAttribute(position, index1);
                vertices.push(vertex.x, vertex.y, vertex.z);
                index2 = 3 * i + (j + 1) % 3;
                vertex.fromBufferAttribute(position, index2);
                vertices.push(vertex.x, vertex.y, vertex.z);
            }
        }
    }
    // build geometry
    this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
}
WireframeGeometry.prototype = Object.create(BufferGeometry.prototype);
WireframeGeometry.prototype.constructor = WireframeGeometry;
/**
 * @author zz85 / https://github.com/zz85
 * @author Mugen87 / https://github.com/Mugen87
 *
 * Parametric Surfaces Geometry
 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
 */ // ParametricGeometry
function ParametricGeometry(func, slices, stacks) {
    Geometry.call(this);
    this.type = "ParametricGeometry";
    this.parameters = {
        func: func,
        slices: slices,
        stacks: stacks
    };
    this.fromBufferGeometry(new ParametricBufferGeometry(func, slices, stacks));
    this.mergeVertices();
}
ParametricGeometry.prototype = Object.create(Geometry.prototype);
ParametricGeometry.prototype.constructor = ParametricGeometry;
// ParametricBufferGeometry
function ParametricBufferGeometry(func, slices, stacks) {
    BufferGeometry.call(this);
    this.type = "ParametricBufferGeometry";
    this.parameters = {
        func: func,
        slices: slices,
        stacks: stacks
    };
    // buffers
    var indices = [];
    var vertices = [];
    var normals = [];
    var uvs = [];
    var EPS = 0.00001;
    var normal = new Vector3();
    var p0 = new Vector3(), p1 = new Vector3();
    var pu = new Vector3(), pv = new Vector3();
    var i, j;
    if (func.length < 3) console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
    // generate vertices, normals and uvs
    var sliceCount = slices + 1;
    for(i = 0; i <= stacks; i++){
        var v = i / stacks;
        for(j = 0; j <= slices; j++){
            var u = j / slices;
            // vertex
            func(u, v, p0);
            vertices.push(p0.x, p0.y, p0.z);
            // normal
            // approximate tangent vectors via finite differences
            if (u - EPS >= 0) {
                func(u - EPS, v, p1);
                pu.subVectors(p0, p1);
            } else {
                func(u + EPS, v, p1);
                pu.subVectors(p1, p0);
            }
            if (v - EPS >= 0) {
                func(u, v - EPS, p1);
                pv.subVectors(p0, p1);
            } else {
                func(u, v + EPS, p1);
                pv.subVectors(p1, p0);
            }
            // cross product of tangent vectors returns surface normal
            normal.crossVectors(pu, pv).normalize();
            normals.push(normal.x, normal.y, normal.z);
            // uv
            uvs.push(u, v);
        }
    }
    // generate indices
    for(i = 0; i < stacks; i++)for(j = 0; j < slices; j++){
        var a = i * sliceCount + j;
        var b = i * sliceCount + j + 1;
        var c = (i + 1) * sliceCount + j + 1;
        var d = (i + 1) * sliceCount + j;
        // faces one and two
        indices.push(a, b, d);
        indices.push(b, c, d);
    }
    // build geometry
    this.setIndex(indices);
    this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
}
ParametricBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
ParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;
/**
 * @author clockworkgeek / https://github.com/clockworkgeek
 * @author timothypratley / https://github.com/timothypratley
 * @author WestLangley / http://github.com/WestLangley
 * @author Mugen87 / https://github.com/Mugen87
 */ // PolyhedronGeometry
function PolyhedronGeometry(vertices, indices, radius, detail) {
    Geometry.call(this);
    this.type = "PolyhedronGeometry";
    this.parameters = {
        vertices: vertices,
        indices: indices,
        radius: radius,
        detail: detail
    };
    this.fromBufferGeometry(new PolyhedronBufferGeometry(vertices, indices, radius, detail));
    this.mergeVertices();
}
PolyhedronGeometry.prototype = Object.create(Geometry.prototype);
PolyhedronGeometry.prototype.constructor = PolyhedronGeometry;
// PolyhedronBufferGeometry
function PolyhedronBufferGeometry(vertices, indices, radius, detail) {
    BufferGeometry.call(this);
    this.type = "PolyhedronBufferGeometry";
    this.parameters = {
        vertices: vertices,
        indices: indices,
        radius: radius,
        detail: detail
    };
    radius = radius || 1;
    detail = detail || 0;
    // default buffer data
    var vertexBuffer = [];
    var uvBuffer = [];
    // the subdivision creates the vertex buffer data
    subdivide(detail);
    // all vertices should lie on a conceptual sphere with a given radius
    appplyRadius(radius);
    // finally, create the uv data
    generateUVs();
    // build non-indexed geometry
    this.addAttribute("position", new Float32BufferAttribute(vertexBuffer, 3));
    this.addAttribute("normal", new Float32BufferAttribute(vertexBuffer.slice(), 3));
    this.addAttribute("uv", new Float32BufferAttribute(uvBuffer, 2));
    if (detail === 0) this.computeVertexNormals(); // flat normals
    else this.normalizeNormals(); // smooth normals
    // helper functions
    function subdivide(detail) {
        var a = new Vector3();
        var b = new Vector3();
        var c = new Vector3();
        // iterate over all faces and apply a subdivison with the given detail value
        for(var i = 0; i < indices.length; i += 3){
            // get the vertices of the face
            getVertexByIndex(indices[i + 0], a);
            getVertexByIndex(indices[i + 1], b);
            getVertexByIndex(indices[i + 2], c);
            // perform subdivision
            subdivideFace(a, b, c, detail);
        }
    }
    function subdivideFace(a, b, c, detail) {
        var cols = Math.pow(2, detail);
        // we use this multidimensional array as a data structure for creating the subdivision
        var v = [];
        var i, j;
        // construct all of the vertices for this subdivision
        for(i = 0; i <= cols; i++){
            v[i] = [];
            var aj = a.clone().lerp(c, i / cols);
            var bj = b.clone().lerp(c, i / cols);
            var rows = cols - i;
            for(j = 0; j <= rows; j++)if (j === 0 && i === cols) v[i][j] = aj;
            else v[i][j] = aj.clone().lerp(bj, j / rows);
        }
        // construct all of the faces
        for(i = 0; i < cols; i++)for(j = 0; j < 2 * (cols - i) - 1; j++){
            var k = Math.floor(j / 2);
            if (j % 2 === 0) {
                pushVertex(v[i][k + 1]);
                pushVertex(v[i + 1][k]);
                pushVertex(v[i][k]);
            } else {
                pushVertex(v[i][k + 1]);
                pushVertex(v[i + 1][k + 1]);
                pushVertex(v[i + 1][k]);
            }
        }
    }
    function appplyRadius(radius) {
        var vertex = new Vector3();
        // iterate over the entire buffer and apply the radius to each vertex
        for(var i = 0; i < vertexBuffer.length; i += 3){
            vertex.x = vertexBuffer[i + 0];
            vertex.y = vertexBuffer[i + 1];
            vertex.z = vertexBuffer[i + 2];
            vertex.normalize().multiplyScalar(radius);
            vertexBuffer[i + 0] = vertex.x;
            vertexBuffer[i + 1] = vertex.y;
            vertexBuffer[i + 2] = vertex.z;
        }
    }
    function generateUVs() {
        var vertex = new Vector3();
        for(var i = 0; i < vertexBuffer.length; i += 3){
            vertex.x = vertexBuffer[i + 0];
            vertex.y = vertexBuffer[i + 1];
            vertex.z = vertexBuffer[i + 2];
            var u = azimuth(vertex) / 2 / Math.PI + 0.5;
            var v = inclination(vertex) / Math.PI + 0.5;
            uvBuffer.push(u, 1 - v);
        }
        correctUVs();
        correctSeam();
    }
    function correctSeam() {
        // handle case when face straddles the seam, see #3269
        for(var i = 0; i < uvBuffer.length; i += 6){
            // uv data of a single face
            var x0 = uvBuffer[i + 0];
            var x1 = uvBuffer[i + 2];
            var x2 = uvBuffer[i + 4];
            var max = Math.max(x0, x1, x2);
            var min = Math.min(x0, x1, x2);
            // 0.9 is somewhat arbitrary
            if (max > 0.9 && min < 0.1) {
                if (x0 < 0.2) uvBuffer[i + 0] += 1;
                if (x1 < 0.2) uvBuffer[i + 2] += 1;
                if (x2 < 0.2) uvBuffer[i + 4] += 1;
            }
        }
    }
    function pushVertex(vertex) {
        vertexBuffer.push(vertex.x, vertex.y, vertex.z);
    }
    function getVertexByIndex(index, vertex) {
        var stride = index * 3;
        vertex.x = vertices[stride + 0];
        vertex.y = vertices[stride + 1];
        vertex.z = vertices[stride + 2];
    }
    function correctUVs() {
        var a = new Vector3();
        var b = new Vector3();
        var c = new Vector3();
        var centroid = new Vector3();
        var uvA = new Vector2();
        var uvB = new Vector2();
        var uvC = new Vector2();
        for(var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6){
            a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);
            b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);
            c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);
            uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
            uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
            uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);
            centroid.copy(a).add(b).add(c).divideScalar(3);
            var azi = azimuth(centroid);
            correctUV(uvA, j + 0, a, azi);
            correctUV(uvB, j + 2, b, azi);
            correctUV(uvC, j + 4, c, azi);
        }
    }
    function correctUV(uv, stride, vector, azimuth) {
        if (azimuth < 0 && uv.x === 1) uvBuffer[stride] = uv.x - 1;
        if (vector.x === 0 && vector.z === 0) uvBuffer[stride] = azimuth / 2 / Math.PI + 0.5;
    }
    // Angle around the Y axis, counter-clockwise when looking from above.
    function azimuth(vector) {
        return Math.atan2(vector.z, -vector.x);
    }
    // Angle above the XZ plane.
    function inclination(vector) {
        return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
    }
}
PolyhedronBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
PolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;
/**
 * @author timothypratley / https://github.com/timothypratley
 * @author Mugen87 / https://github.com/Mugen87
 */ // TetrahedronGeometry
function TetrahedronGeometry(radius, detail) {
    Geometry.call(this);
    this.type = "TetrahedronGeometry";
    this.parameters = {
        radius: radius,
        detail: detail
    };
    this.fromBufferGeometry(new TetrahedronBufferGeometry(radius, detail));
    this.mergeVertices();
}
TetrahedronGeometry.prototype = Object.create(Geometry.prototype);
TetrahedronGeometry.prototype.constructor = TetrahedronGeometry;
// TetrahedronBufferGeometry
function TetrahedronBufferGeometry(radius, detail) {
    var vertices = [
        1,
        1,
        1,
        -1,
        -1,
        1,
        -1,
        1,
        -1,
        1,
        -1,
        -1
    ];
    var indices = [
        2,
        1,
        0,
        0,
        3,
        2,
        1,
        3,
        0,
        2,
        3,
        1
    ];
    PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
    this.type = "TetrahedronBufferGeometry";
    this.parameters = {
        radius: radius,
        detail: detail
    };
}
TetrahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
TetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;
/**
 * @author timothypratley / https://github.com/timothypratley
 * @author Mugen87 / https://github.com/Mugen87
 */ // OctahedronGeometry
function OctahedronGeometry(radius, detail) {
    Geometry.call(this);
    this.type = "OctahedronGeometry";
    this.parameters = {
        radius: radius,
        detail: detail
    };
    this.fromBufferGeometry(new OctahedronBufferGeometry(radius, detail));
    this.mergeVertices();
}
OctahedronGeometry.prototype = Object.create(Geometry.prototype);
OctahedronGeometry.prototype.constructor = OctahedronGeometry;
// OctahedronBufferGeometry
function OctahedronBufferGeometry(radius, detail) {
    var vertices = [
        1,
        0,
        0,
        -1,
        0,
        0,
        0,
        1,
        0,
        0,
        -1,
        0,
        0,
        0,
        1,
        0,
        0,
        -1
    ];
    var indices = [
        0,
        2,
        4,
        0,
        4,
        3,
        0,
        3,
        5,
        0,
        5,
        2,
        1,
        2,
        5,
        1,
        5,
        3,
        1,
        3,
        4,
        1,
        4,
        2
    ];
    PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
    this.type = "OctahedronBufferGeometry";
    this.parameters = {
        radius: radius,
        detail: detail
    };
}
OctahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
OctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;
/**
 * @author timothypratley / https://github.com/timothypratley
 * @author Mugen87 / https://github.com/Mugen87
 */ // IcosahedronGeometry
function IcosahedronGeometry(radius, detail) {
    Geometry.call(this);
    this.type = "IcosahedronGeometry";
    this.parameters = {
        radius: radius,
        detail: detail
    };
    this.fromBufferGeometry(new IcosahedronBufferGeometry(radius, detail));
    this.mergeVertices();
}
IcosahedronGeometry.prototype = Object.create(Geometry.prototype);
IcosahedronGeometry.prototype.constructor = IcosahedronGeometry;
// IcosahedronBufferGeometry
function IcosahedronBufferGeometry(radius, detail) {
    var t = (1 + Math.sqrt(5)) / 2;
    var vertices = [
        -1,
        t,
        0,
        1,
        t,
        0,
        -1,
        -t,
        0,
        1,
        -t,
        0,
        0,
        -1,
        t,
        0,
        1,
        t,
        0,
        -1,
        -t,
        0,
        1,
        -t,
        t,
        0,
        -1,
        t,
        0,
        1,
        -t,
        0,
        -1,
        -t,
        0,
        1
    ];
    var indices = [
        0,
        11,
        5,
        0,
        5,
        1,
        0,
        1,
        7,
        0,
        7,
        10,
        0,
        10,
        11,
        1,
        5,
        9,
        5,
        11,
        4,
        11,
        10,
        2,
        10,
        7,
        6,
        7,
        1,
        8,
        3,
        9,
        4,
        3,
        4,
        2,
        3,
        2,
        6,
        3,
        6,
        8,
        3,
        8,
        9,
        4,
        9,
        5,
        2,
        4,
        11,
        6,
        2,
        10,
        8,
        6,
        7,
        9,
        8,
        1
    ];
    PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
    this.type = "IcosahedronBufferGeometry";
    this.parameters = {
        radius: radius,
        detail: detail
    };
}
IcosahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
IcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;
/**
 * @author Abe Pazos / https://hamoid.com
 * @author Mugen87 / https://github.com/Mugen87
 */ // DodecahedronGeometry
function DodecahedronGeometry(radius, detail) {
    Geometry.call(this);
    this.type = "DodecahedronGeometry";
    this.parameters = {
        radius: radius,
        detail: detail
    };
    this.fromBufferGeometry(new DodecahedronBufferGeometry(radius, detail));
    this.mergeVertices();
}
DodecahedronGeometry.prototype = Object.create(Geometry.prototype);
DodecahedronGeometry.prototype.constructor = DodecahedronGeometry;
// DodecahedronBufferGeometry
function DodecahedronBufferGeometry(radius, detail) {
    var t = (1 + Math.sqrt(5)) / 2;
    var r = 1 / t;
    var vertices = [
        // (1, 1, 1)
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        1,
        -1,
        -1,
        1,
        1,
        1,
        -1,
        -1,
        1,
        -1,
        1,
        1,
        1,
        -1,
        1,
        1,
        1,
        // (0, 1/, )
        0,
        -r,
        -t,
        0,
        -r,
        t,
        0,
        r,
        -t,
        0,
        r,
        t,
        // (1/, , 0)
        -r,
        -t,
        0,
        -r,
        t,
        0,
        r,
        -t,
        0,
        r,
        t,
        0,
        // (, 0, 1/)
        -t,
        0,
        -r,
        t,
        0,
        -r,
        -t,
        0,
        r,
        t,
        0,
        r
    ];
    var indices = [
        3,
        11,
        7,
        3,
        7,
        15,
        3,
        15,
        13,
        7,
        19,
        17,
        7,
        17,
        6,
        7,
        6,
        15,
        17,
        4,
        8,
        17,
        8,
        10,
        17,
        10,
        6,
        8,
        0,
        16,
        8,
        16,
        2,
        8,
        2,
        10,
        0,
        12,
        1,
        0,
        1,
        18,
        0,
        18,
        16,
        6,
        10,
        2,
        6,
        2,
        13,
        6,
        13,
        15,
        2,
        16,
        18,
        2,
        18,
        3,
        2,
        3,
        13,
        18,
        1,
        9,
        18,
        9,
        11,
        18,
        11,
        3,
        4,
        14,
        12,
        4,
        12,
        0,
        4,
        0,
        8,
        11,
        9,
        5,
        11,
        5,
        19,
        11,
        19,
        7,
        19,
        5,
        14,
        19,
        14,
        4,
        19,
        4,
        17,
        1,
        12,
        14,
        1,
        14,
        5,
        1,
        5,
        9
    ];
    PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
    this.type = "DodecahedronBufferGeometry";
    this.parameters = {
        radius: radius,
        detail: detail
    };
}
DodecahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
DodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;
/**
 * @author oosmoxiecode / https://github.com/oosmoxiecode
 * @author WestLangley / https://github.com/WestLangley
 * @author zz85 / https://github.com/zz85
 * @author miningold / https://github.com/miningold
 * @author jonobr1 / https://github.com/jonobr1
 * @author Mugen87 / https://github.com/Mugen87
 *
 */ // TubeGeometry
function TubeGeometry(path, tubularSegments, radius, radialSegments, closed, taper) {
    Geometry.call(this);
    this.type = "TubeGeometry";
    this.parameters = {
        path: path,
        tubularSegments: tubularSegments,
        radius: radius,
        radialSegments: radialSegments,
        closed: closed
    };
    if (taper !== undefined) console.warn("THREE.TubeGeometry: taper has been removed.");
    var bufferGeometry = new TubeBufferGeometry(path, tubularSegments, radius, radialSegments, closed);
    // expose internals
    this.tangents = bufferGeometry.tangents;
    this.normals = bufferGeometry.normals;
    this.binormals = bufferGeometry.binormals;
    // create geometry
    this.fromBufferGeometry(bufferGeometry);
    this.mergeVertices();
}
TubeGeometry.prototype = Object.create(Geometry.prototype);
TubeGeometry.prototype.constructor = TubeGeometry;
// TubeBufferGeometry
function TubeBufferGeometry(path, tubularSegments, radius, radialSegments, closed) {
    BufferGeometry.call(this);
    this.type = "TubeBufferGeometry";
    this.parameters = {
        path: path,
        tubularSegments: tubularSegments,
        radius: radius,
        radialSegments: radialSegments,
        closed: closed
    };
    tubularSegments = tubularSegments || 64;
    radius = radius || 1;
    radialSegments = radialSegments || 8;
    closed = closed || false;
    var frames = path.computeFrenetFrames(tubularSegments, closed);
    // expose internals
    this.tangents = frames.tangents;
    this.normals = frames.normals;
    this.binormals = frames.binormals;
    // helper variables
    var vertex = new Vector3();
    var normal = new Vector3();
    var uv = new Vector2();
    var P = new Vector3();
    var i, j;
    // buffer
    var vertices = [];
    var normals = [];
    var uvs = [];
    var indices = [];
    // create buffer data
    generateBufferData();
    // build geometry
    this.setIndex(indices);
    this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
    // functions
    function generateBufferData() {
        for(i = 0; i < tubularSegments; i++)generateSegment(i);
        // if the geometry is not closed, generate the last row of vertices and normals
        // at the regular position on the given path
        //
        // if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)
        generateSegment(closed === false ? tubularSegments : 0);
        // uvs are generated in a separate function.
        // this makes it easy compute correct values for closed geometries
        generateUVs();
        // finally create faces
        generateIndices();
    }
    function generateSegment(i) {
        // we use getPointAt to sample evenly distributed points from the given path
        P = path.getPointAt(i / tubularSegments, P);
        // retrieve corresponding normal and binormal
        var N = frames.normals[i];
        var B = frames.binormals[i];
        // generate normals and vertices for the current segment
        for(j = 0; j <= radialSegments; j++){
            var v = j / radialSegments * Math.PI * 2;
            var sin = Math.sin(v);
            var cos = -Math.cos(v);
            // normal
            normal.x = cos * N.x + sin * B.x;
            normal.y = cos * N.y + sin * B.y;
            normal.z = cos * N.z + sin * B.z;
            normal.normalize();
            normals.push(normal.x, normal.y, normal.z);
            // vertex
            vertex.x = P.x + radius * normal.x;
            vertex.y = P.y + radius * normal.y;
            vertex.z = P.z + radius * normal.z;
            vertices.push(vertex.x, vertex.y, vertex.z);
        }
    }
    function generateIndices() {
        for(j = 1; j <= tubularSegments; j++)for(i = 1; i <= radialSegments; i++){
            var a = (radialSegments + 1) * (j - 1) + (i - 1);
            var b = (radialSegments + 1) * j + (i - 1);
            var c = (radialSegments + 1) * j + i;
            var d = (radialSegments + 1) * (j - 1) + i;
            // faces
            indices.push(a, b, d);
            indices.push(b, c, d);
        }
    }
    function generateUVs() {
        for(i = 0; i <= tubularSegments; i++)for(j = 0; j <= radialSegments; j++){
            uv.x = i / tubularSegments;
            uv.y = j / radialSegments;
            uvs.push(uv.x, uv.y);
        }
    }
}
TubeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
TubeBufferGeometry.prototype.constructor = TubeBufferGeometry;
/**
 * @author oosmoxiecode
 * @author Mugen87 / https://github.com/Mugen87
 *
 * based on http://www.blackpawn.com/texts/pqtorus/
 */ // TorusKnotGeometry
function TorusKnotGeometry(radius, tube, tubularSegments, radialSegments, p, q, heightScale) {
    Geometry.call(this);
    this.type = "TorusKnotGeometry";
    this.parameters = {
        radius: radius,
        tube: tube,
        tubularSegments: tubularSegments,
        radialSegments: radialSegments,
        p: p,
        q: q
    };
    if (heightScale !== undefined) console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.");
    this.fromBufferGeometry(new TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q));
    this.mergeVertices();
}
TorusKnotGeometry.prototype = Object.create(Geometry.prototype);
TorusKnotGeometry.prototype.constructor = TorusKnotGeometry;
// TorusKnotBufferGeometry
function TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q) {
    BufferGeometry.call(this);
    this.type = "TorusKnotBufferGeometry";
    this.parameters = {
        radius: radius,
        tube: tube,
        tubularSegments: tubularSegments,
        radialSegments: radialSegments,
        p: p,
        q: q
    };
    radius = radius || 1;
    tube = tube || 0.4;
    tubularSegments = Math.floor(tubularSegments) || 64;
    radialSegments = Math.floor(radialSegments) || 8;
    p = p || 2;
    q = q || 3;
    // buffers
    var indices = [];
    var vertices = [];
    var normals = [];
    var uvs = [];
    // helper variables
    var i, j;
    var vertex = new Vector3();
    var normal = new Vector3();
    var P1 = new Vector3();
    var P2 = new Vector3();
    var B = new Vector3();
    var T = new Vector3();
    var N = new Vector3();
    // generate vertices, normals and uvs
    for(i = 0; i <= tubularSegments; ++i){
        // the radian "u" is used to calculate the position on the torus curve of the current tubular segement
        var u = i / tubularSegments * p * Math.PI * 2;
        // now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
        // these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions
        calculatePositionOnCurve(u, p, q, radius, P1);
        calculatePositionOnCurve(u + 0.01, p, q, radius, P2);
        // calculate orthonormal basis
        T.subVectors(P2, P1);
        N.addVectors(P2, P1);
        B.crossVectors(T, N);
        N.crossVectors(B, T);
        // normalize B, N. T can be ignored, we don't use it
        B.normalize();
        N.normalize();
        for(j = 0; j <= radialSegments; ++j){
            // now calculate the vertices. they are nothing more than an extrusion of the torus curve.
            // because we extrude a shape in the xy-plane, there is no need to calculate a z-value.
            var v = j / radialSegments * Math.PI * 2;
            var cx = -tube * Math.cos(v);
            var cy = tube * Math.sin(v);
            // now calculate the final vertex position.
            // first we orient the extrusion with our basis vectos, then we add it to the current position on the curve
            vertex.x = P1.x + (cx * N.x + cy * B.x);
            vertex.y = P1.y + (cx * N.y + cy * B.y);
            vertex.z = P1.z + (cx * N.z + cy * B.z);
            vertices.push(vertex.x, vertex.y, vertex.z);
            // normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)
            normal.subVectors(vertex, P1).normalize();
            normals.push(normal.x, normal.y, normal.z);
            // uv
            uvs.push(i / tubularSegments);
            uvs.push(j / radialSegments);
        }
    }
    // generate indices
    for(j = 1; j <= tubularSegments; j++)for(i = 1; i <= radialSegments; i++){
        // indices
        var a = (radialSegments + 1) * (j - 1) + (i - 1);
        var b = (radialSegments + 1) * j + (i - 1);
        var c = (radialSegments + 1) * j + i;
        var d = (radialSegments + 1) * (j - 1) + i;
        // faces
        indices.push(a, b, d);
        indices.push(b, c, d);
    }
    // build geometry
    this.setIndex(indices);
    this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
    // this function calculates the current position on the torus curve
    function calculatePositionOnCurve(u, p, q, radius, position) {
        var cu = Math.cos(u);
        var su = Math.sin(u);
        var quOverP = q / p * u;
        var cs = Math.cos(quOverP);
        position.x = radius * (2 + cs) * 0.5 * cu;
        position.y = radius * (2 + cs) * su * 0.5;
        position.z = radius * Math.sin(quOverP) * 0.5;
    }
}
TorusKnotBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
TorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;
/**
 * @author oosmoxiecode
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */ // TorusGeometry
function TorusGeometry(radius, tube, radialSegments, tubularSegments, arc) {
    Geometry.call(this);
    this.type = "TorusGeometry";
    this.parameters = {
        radius: radius,
        tube: tube,
        radialSegments: radialSegments,
        tubularSegments: tubularSegments,
        arc: arc
    };
    this.fromBufferGeometry(new TorusBufferGeometry(radius, tube, radialSegments, tubularSegments, arc));
    this.mergeVertices();
}
TorusGeometry.prototype = Object.create(Geometry.prototype);
TorusGeometry.prototype.constructor = TorusGeometry;
// TorusBufferGeometry
function TorusBufferGeometry(radius, tube, radialSegments, tubularSegments, arc) {
    BufferGeometry.call(this);
    this.type = "TorusBufferGeometry";
    this.parameters = {
        radius: radius,
        tube: tube,
        radialSegments: radialSegments,
        tubularSegments: tubularSegments,
        arc: arc
    };
    radius = radius || 1;
    tube = tube || 0.4;
    radialSegments = Math.floor(radialSegments) || 8;
    tubularSegments = Math.floor(tubularSegments) || 6;
    arc = arc || Math.PI * 2;
    // buffers
    var indices = [];
    var vertices = [];
    var normals = [];
    var uvs = [];
    // helper variables
    var center = new Vector3();
    var vertex = new Vector3();
    var normal = new Vector3();
    var j, i;
    // generate vertices, normals and uvs
    for(j = 0; j <= radialSegments; j++)for(i = 0; i <= tubularSegments; i++){
        var u = i / tubularSegments * arc;
        var v = j / radialSegments * Math.PI * 2;
        // vertex
        vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
        vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);
        vertex.z = tube * Math.sin(v);
        vertices.push(vertex.x, vertex.y, vertex.z);
        // normal
        center.x = radius * Math.cos(u);
        center.y = radius * Math.sin(u);
        normal.subVectors(vertex, center).normalize();
        normals.push(normal.x, normal.y, normal.z);
        // uv
        uvs.push(i / tubularSegments);
        uvs.push(j / radialSegments);
    }
    // generate indices
    for(j = 1; j <= radialSegments; j++)for(i = 1; i <= tubularSegments; i++){
        // indices
        var a = (tubularSegments + 1) * j + i - 1;
        var b = (tubularSegments + 1) * (j - 1) + i - 1;
        var c = (tubularSegments + 1) * (j - 1) + i;
        var d = (tubularSegments + 1) * j + i;
        // faces
        indices.push(a, b, d);
        indices.push(b, c, d);
    }
    // build geometry
    this.setIndex(indices);
    this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
}
TorusBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
TorusBufferGeometry.prototype.constructor = TorusBufferGeometry;
/**
 * @author Mugen87 / https://github.com/Mugen87
 * Port from https://github.com/mapbox/earcut (v2.1.2)
 */ var Earcut = {
    triangulate: function(data, holeIndices, dim) {
        dim = dim || 2;
        var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
        if (!outerNode) return triangles;
        var minX, minY, maxX, maxY, x, y, invSize;
        if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
        // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
        if (data.length > 80 * dim) {
            minX = maxX = data[0];
            minY = maxY = data[1];
            for(var i = dim; i < outerLen; i += dim){
                x = data[i];
                y = data[i + 1];
                if (x < minX) minX = x;
                if (y < minY) minY = y;
                if (x > maxX) maxX = x;
                if (y > maxY) maxY = y;
            }
            // minX, minY and invSize are later used to transform coords into integers for z-order calculation
            invSize = Math.max(maxX - minX, maxY - minY);
            invSize = invSize !== 0 ? 1 / invSize : 0;
        }
        earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
        return triangles;
    }
};
// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
    var i, last;
    if (clockwise === signedArea(data, start, end, dim) > 0) for(i = start; i < end; i += dim)last = insertNode(i, data[i], data[i + 1], last);
    else for(i = end - dim; i >= start; i -= dim)last = insertNode(i, data[i], data[i + 1], last);
    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }
    return last;
}
// eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;
    var p = start, again;
    do {
        again = false;
        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) break;
            again = true;
        } else p = p.next;
    }while (again || p !== end);
    return end;
}
// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear) return;
    // interlink polygon nodes in z-order
    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
    var stop = ear, prev, next;
    // iterate through ears, slicing them one by one
    while(ear.prev !== ear.next){
        prev = ear.prev;
        next = ear.next;
        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim);
            triangles.push(ear.i / dim);
            triangles.push(next.i / dim);
            removeNode(ear);
            // skipping the next vertice leads to less sliver triangles
            ear = next.next;
            stop = next.next;
            continue;
        }
        ear = next;
        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
            else if (pass === 1) {
                ear = cureLocalIntersections(ear, triangles, dim);
                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
            // as a last resort, try splitting the remaining polygon into two
            } else if (pass === 2) splitEarcut(ear, triangles, dim, minX, minY, invSize);
            break;
        }
    }
}
// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    var a = ear.prev, b = ear, c = ear.next;
    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
    // now make sure we don't have other points inside the potential ear
    var p = ear.next.next;
    while(p !== ear.prev){
        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
    }
    return true;
}
function isEarHashed(ear, minX, minY, invSize) {
    var a = ear.prev, b = ear, c = ear.next;
    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
    // triangle bbox; min & max are calculated like this for speed
    var minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x, minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y, maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x, maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;
    // z-order range for the current triangle bbox;
    var minZ = zOrder(minTX, minTY, minX, minY, invSize), maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
    // first look for points inside the triangle in increasing z-order
    var p = ear.nextZ;
    while(p && p.z <= maxZ){
        if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.nextZ;
    }
    // then look for points in decreasing z-order
    p = ear.prevZ;
    while(p && p.z >= minZ){
        if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
    }
    return true;
}
// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
    var p = start;
    do {
        var a = p.prev, b = p.next.next;
        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
            triangles.push(a.i / dim);
            triangles.push(p.i / dim);
            triangles.push(b.i / dim);
            // remove two nodes involved
            removeNode(p);
            removeNode(p.next);
            p = start = b;
        }
        p = p.next;
    }while (p !== start);
    return p;
}
// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    // look for a valid diagonal that divides the polygon into two
    var a = start;
    do {
        var b = a.next.next;
        while(b !== a.prev){
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                var c = splitPolygon(a, b);
                // filter colinear points around the cuts
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next);
                // run earcut on each half
                earcutLinked(a, triangles, dim, minX, minY, invSize);
                earcutLinked(c, triangles, dim, minX, minY, invSize);
                return;
            }
            b = b.next;
        }
        a = a.next;
    }while (a !== start);
}
// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [], i, len, start, end, list;
    for(i = 0, len = holeIndices.length; i < len; i++){
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
    }
    queue.sort(compareX);
    // process holes from left to right
    for(i = 0; i < queue.length; i++){
        eliminateHole(queue[i], outerNode);
        outerNode = filterPoints(outerNode, outerNode.next);
    }
    return outerNode;
}
function compareX(a, b) {
    return a.x - b.x;
}
// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
    outerNode = findHoleBridge(hole, outerNode);
    if (outerNode) {
        var b = splitPolygon(outerNode, hole);
        filterPoints(b, b.next);
    }
}
// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;
    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                if (x === hx) {
                    if (hy === p.y) return p;
                    if (hy === p.next.y) return p.next;
                }
                m = p.x < p.next.x ? p : p.next;
            }
        }
        p = p.next;
    }while (p !== outerNode);
    if (!m) return null;
    if (hx === qx) return m.prev; // hole touches outer segment; pick lower endpoint
    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point
    var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan;
    p = m.next;
    while(p !== stop){
        if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential
            if ((tan < tanMin || tan === tanMin && p.x > m.x) && locallyInside(p, hole)) {
                m = p;
                tanMin = tan;
            }
        }
        p = p.next;
    }
    return m;
}
// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, invSize) {
    var p = start;
    do {
        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    }while (p !== start);
    p.prevZ.nextZ = null;
    p.prevZ = null;
    sortLinked(p);
}
// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
    do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;
        while(p){
            numMerges++;
            q = p;
            pSize = 0;
            for(i = 0; i < inSize; i++){
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }
            qSize = inSize;
            while(pSize > 0 || qSize > 0 && q){
                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }
                if (tail) tail.nextZ = e;
                else list = e;
                e.prevZ = tail;
                tail = e;
            }
            p = q;
        }
        tail.nextZ = null;
        inSize *= 2;
    }while (numMerges > 1);
    return list;
}
// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder(x, y, minX, minY, invSize) {
    // coords are transformed into non-negative 15-bit integer range
    x = 32767 * (x - minX) * invSize;
    y = 32767 * (y - minY) * invSize;
    x = (x | x << 8) & 0x00FF00FF;
    x = (x | x << 4) & 0x0F0F0F0F;
    x = (x | x << 2) & 0x33333333;
    x = (x | x << 1) & 0x55555555;
    y = (y | y << 8) & 0x00FF00FF;
    y = (y | y << 4) & 0x0F0F0F0F;
    y = (y | y << 2) & 0x33333333;
    y = (y | y << 1) & 0x55555555;
    return x | y << 1;
}
// find the leftmost node of a polygon ring
function getLeftmost(start) {
    var p = start, leftmost = start;
    do {
        if (p.x < leftmost.x) leftmost = p;
        p = p.next;
    }while (p !== start);
    return leftmost;
}
// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
}
// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);
}
// signed area of a triangle
function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}
// check if two points are equal
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}
// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    if (equals(p1, q1) && equals(p2, q2) || equals(p1, q2) && equals(p2, q1)) return true;
    return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 && area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;
}
// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
    var p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;
        p = p.next;
    }while (p !== a);
    return false;
}
// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}
// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
    var p = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
    do {
        if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;
        p = p.next;
    }while (p !== a);
    return inside;
}
// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
    var a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;
    a.next = b;
    b.prev = a;
    a2.next = an;
    an.prev = a2;
    b2.next = a2;
    a2.prev = b2;
    bp.next = b2;
    b2.prev = bp;
    return b2;
}
// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
    var p = new Node(i, x, y);
    if (!last) {
        p.prev = p;
        p.next = p;
    } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}
function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;
    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}
function Node(i, x, y) {
    // vertice index in coordinates array
    this.i = i;
    // vertex coordinates
    this.x = x;
    this.y = y;
    // previous and next vertice nodes in a polygon ring
    this.prev = null;
    this.next = null;
    // z-order curve value
    this.z = null;
    // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null;
    // indicates whether this is a steiner point
    this.steiner = false;
}
function signedArea(data, start, end, dim) {
    var sum = 0;
    for(var i = start, j = end - dim; i < end; i += dim){
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
    }
    return sum;
}
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */ var ShapeUtils = {
    // calculate area of the contour polygon
    area: function(contour) {
        var n = contour.length;
        var a = 0.0;
        for(var p = n - 1, q = 0; q < n; p = q++)a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
        return a * 0.5;
    },
    isClockWise: function(pts) {
        return ShapeUtils.area(pts) < 0;
    },
    triangulateShape: function(contour, holes) {
        var vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
        var holeIndices = []; // array of hole indices
        var faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]
        removeDupEndPts(contour);
        addContour(vertices, contour);
        //
        var holeIndex = contour.length;
        holes.forEach(removeDupEndPts);
        for(var i = 0; i < holes.length; i++){
            holeIndices.push(holeIndex);
            holeIndex += holes[i].length;
            addContour(vertices, holes[i]);
        }
        //
        var triangles = Earcut.triangulate(vertices, holeIndices);
        //
        for(var i = 0; i < triangles.length; i += 3)faces.push(triangles.slice(i, i + 3));
        return faces;
    }
};
function removeDupEndPts(points) {
    var l = points.length;
    if (l > 2 && points[l - 1].equals(points[0])) points.pop();
}
function addContour(vertices, contour) {
    for(var i = 0; i < contour.length; i++){
        vertices.push(contour[i].x);
        vertices.push(contour[i].y);
    }
}
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 * Creates extruded geometry from a path shape.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves
 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
 *  depth: <float>, // Depth to extrude the shape
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into the original shape bevel goes
 *  bevelSize: <float>, // how far from shape outline is bevel
 *  bevelSegments: <int>, // number of bevel layers
 *
 *  extrudePath: <THREE.Curve> // curve to extrude shape along
 *
 *  UVGenerator: <Object> // object that provides UV generator functions
 *
 * }
 */ // ExtrudeGeometry
function ExtrudeGeometry(shapes, options) {
    Geometry.call(this);
    this.type = "ExtrudeGeometry";
    this.parameters = {
        shapes: shapes,
        options: options
    };
    this.fromBufferGeometry(new ExtrudeBufferGeometry(shapes, options));
    this.mergeVertices();
}
ExtrudeGeometry.prototype = Object.create(Geometry.prototype);
ExtrudeGeometry.prototype.constructor = ExtrudeGeometry;
ExtrudeGeometry.prototype.toJSON = function() {
    var data = Geometry.prototype.toJSON.call(this);
    var shapes = this.parameters.shapes;
    var options = this.parameters.options;
    return toJSON(shapes, options, data);
};
// ExtrudeBufferGeometry
function ExtrudeBufferGeometry(shapes, options) {
    BufferGeometry.call(this);
    this.type = "ExtrudeBufferGeometry";
    this.parameters = {
        shapes: shapes,
        options: options
    };
    shapes = Array.isArray(shapes) ? shapes : [
        shapes
    ];
    var scope = this;
    var verticesArray = [];
    var uvArray = [];
    for(var i = 0, l = shapes.length; i < l; i++){
        var shape = shapes[i];
        addShape(shape);
    }
    // build geometry
    this.addAttribute("position", new Float32BufferAttribute(verticesArray, 3));
    this.addAttribute("uv", new Float32BufferAttribute(uvArray, 2));
    this.computeVertexNormals();
    // functions
    function addShape(shape) {
        var placeholder = [];
        // options
        var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
        var steps = options.steps !== undefined ? options.steps : 1;
        var depth = options.depth !== undefined ? options.depth : 100;
        var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
        var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;
        var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;
        var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;
        var extrudePath = options.extrudePath;
        var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;
        // deprecated options
        if (options.amount !== undefined) {
            console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth.");
            depth = options.amount;
        }
        //
        var extrudePts, extrudeByPath = false;
        var splineTube, binormal, normal, position2;
        if (extrudePath) {
            extrudePts = extrudePath.getSpacedPoints(steps);
            extrudeByPath = true;
            bevelEnabled = false; // bevels not supported for path extrusion
            // SETUP TNB variables
            // TODO1 - have a .isClosed in spline?
            splineTube = extrudePath.computeFrenetFrames(steps, false);
            // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);
            binormal = new Vector3();
            normal = new Vector3();
            position2 = new Vector3();
        }
        // Safeguards if bevels are not enabled
        if (!bevelEnabled) {
            bevelSegments = 0;
            bevelThickness = 0;
            bevelSize = 0;
        }
        // Variables initialization
        var ahole, h, hl; // looping of holes
        var shapePoints = shape.extractPoints(curveSegments);
        var vertices = shapePoints.shape;
        var holes = shapePoints.holes;
        var reverse = !ShapeUtils.isClockWise(vertices);
        if (reverse) {
            vertices = vertices.reverse();
            // Maybe we should also check if holes are in the opposite direction, just to be safe ...
            for(h = 0, hl = holes.length; h < hl; h++){
                ahole = holes[h];
                if (ShapeUtils.isClockWise(ahole)) holes[h] = ahole.reverse();
            }
        }
        var faces = ShapeUtils.triangulateShape(vertices, holes);
        /* Vertices */ var contour = vertices; // vertices has all points but contour has only points of circumference
        for(h = 0, hl = holes.length; h < hl; h++){
            ahole = holes[h];
            vertices = vertices.concat(ahole);
        }
        function scalePt2(pt, vec, size) {
            if (!vec) console.error("THREE.ExtrudeGeometry: vec does not exist");
            return vec.clone().multiplyScalar(size).add(pt);
        }
        var b, bs, t, z, vert, vlen = vertices.length, face, flen = faces.length;
        // Find directions for point movement
        function getBevelVec(inPt, inPrev, inNext) {
            // computes for inPt the corresponding point inPt' on a new contour
            //   shifted by 1 unit (length of normalized vector) to the left
            // if we walk along contour clockwise, this new contour is outside the old one
            //
            // inPt' is the intersection of the two lines parallel to the two
            //  adjacent edges of inPt at a distance of 1 unit on the left side.
            var v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt
            // good reading for geometry algorithms (here: line-line intersection)
            // http://geomalgorithms.com/a05-_intersect-1.html
            var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
            var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
            var v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y;
            // check for collinear edges
            var collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;
            if (Math.abs(collinear0) > Number.EPSILON) {
                // not collinear
                // length of vectors for normalizing
                var v_prev_len = Math.sqrt(v_prev_lensq);
                var v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
                // shift adjacent points by unit vectors to the left
                var ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
                var ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
                var ptNextShift_x = inNext.x - v_next_y / v_next_len;
                var ptNextShift_y = inNext.y + v_next_x / v_next_len;
                // scaling factor for v_prev to intersection point
                var sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);
                // vector from inPt to intersection point
                v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
                v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;
                // Don't normalize!, otherwise sharp corners become ugly
                //  but prevent crazy spikes
                var v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;
                if (v_trans_lensq <= 2) return new Vector2(v_trans_x, v_trans_y);
                else shrink_by = Math.sqrt(v_trans_lensq / 2);
            } else {
                // handle special case of collinear edges
                var direction_eq = false; // assumes: opposite
                if (v_prev_x > Number.EPSILON) {
                    if (v_next_x > Number.EPSILON) direction_eq = true;
                } else {
                    if (v_prev_x < -Number.EPSILON) {
                        if (v_next_x < -Number.EPSILON) direction_eq = true;
                    } else if (Math.sign(v_prev_y) === Math.sign(v_next_y)) direction_eq = true;
                }
                if (direction_eq) {
                    // console.log("Warning: lines are a straight sequence");
                    v_trans_x = -v_prev_y;
                    v_trans_y = v_prev_x;
                    shrink_by = Math.sqrt(v_prev_lensq);
                } else {
                    // console.log("Warning: lines are a straight spike");
                    v_trans_x = v_prev_x;
                    v_trans_y = v_prev_y;
                    shrink_by = Math.sqrt(v_prev_lensq / 2);
                }
            }
            return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
        }
        var contourMovements = [];
        for(var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++){
            if (j === il) j = 0;
            if (k === il) k = 0;
            //  (j)---(i)---(k)
            // console.log('i,j,k', i, j , k)
            contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);
        }
        var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();
        for(h = 0, hl = holes.length; h < hl; h++){
            ahole = holes[h];
            oneHoleMovements = [];
            for(i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++){
                if (j === il) j = 0;
                if (k === il) k = 0;
                //  (j)---(i)---(k)
                oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);
            }
            holesMovements.push(oneHoleMovements);
            verticesMovements = verticesMovements.concat(oneHoleMovements);
        }
        // Loop bevelSegments, 1 for the front, 1 for the back
        for(b = 0; b < bevelSegments; b++){
            //for ( b = bevelSegments; b > 0; b -- ) {
            t = b / bevelSegments;
            z = bevelThickness * Math.cos(t * Math.PI / 2);
            bs = bevelSize * Math.sin(t * Math.PI / 2);
            // contract shape
            for(i = 0, il = contour.length; i < il; i++){
                vert = scalePt2(contour[i], contourMovements[i], bs);
                v(vert.x, vert.y, -z);
            }
            // expand holes
            for(h = 0, hl = holes.length; h < hl; h++){
                ahole = holes[h];
                oneHoleMovements = holesMovements[h];
                for(i = 0, il = ahole.length; i < il; i++){
                    vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
                    v(vert.x, vert.y, -z);
                }
            }
        }
        bs = bevelSize;
        // Back facing vertices
        for(i = 0; i < vlen; i++){
            vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
            if (!extrudeByPath) v(vert.x, vert.y, 0);
            else {
                // v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );
                normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
                binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
                position2.copy(extrudePts[0]).add(normal).add(binormal);
                v(position2.x, position2.y, position2.z);
            }
        }
        // Add stepped vertices...
        // Including front facing vertices
        var s;
        for(s = 1; s <= steps; s++)for(i = 0; i < vlen; i++){
            vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
            if (!extrudeByPath) v(vert.x, vert.y, depth / steps * s);
            else {
                // v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );
                normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);
                binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);
                position2.copy(extrudePts[s]).add(normal).add(binormal);
                v(position2.x, position2.y, position2.z);
            }
        }
        // Add bevel segments planes
        //for ( b = 1; b <= bevelSegments; b ++ ) {
        for(b = bevelSegments - 1; b >= 0; b--){
            t = b / bevelSegments;
            z = bevelThickness * Math.cos(t * Math.PI / 2);
            bs = bevelSize * Math.sin(t * Math.PI / 2);
            // contract shape
            for(i = 0, il = contour.length; i < il; i++){
                vert = scalePt2(contour[i], contourMovements[i], bs);
                v(vert.x, vert.y, depth + z);
            }
            // expand holes
            for(h = 0, hl = holes.length; h < hl; h++){
                ahole = holes[h];
                oneHoleMovements = holesMovements[h];
                for(i = 0, il = ahole.length; i < il; i++){
                    vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
                    if (!extrudeByPath) v(vert.x, vert.y, depth + z);
                    else v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);
                }
            }
        }
        /* Faces */ // Top and bottom faces
        buildLidFaces();
        // Sides faces
        buildSideFaces();
        /////  Internal functions
        function buildLidFaces() {
            var start = verticesArray.length / 3;
            if (bevelEnabled) {
                var layer = 0; // steps + 1
                var offset = vlen * layer;
                // Bottom faces
                for(i = 0; i < flen; i++){
                    face = faces[i];
                    f3(face[2] + offset, face[1] + offset, face[0] + offset);
                }
                layer = steps + bevelSegments * 2;
                offset = vlen * layer;
                // Top faces
                for(i = 0; i < flen; i++){
                    face = faces[i];
                    f3(face[0] + offset, face[1] + offset, face[2] + offset);
                }
            } else {
                // Bottom faces
                for(i = 0; i < flen; i++){
                    face = faces[i];
                    f3(face[2], face[1], face[0]);
                }
                // Top faces
                for(i = 0; i < flen; i++){
                    face = faces[i];
                    f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
                }
            }
            scope.addGroup(start, verticesArray.length / 3 - start, 0);
        }
        // Create faces for the z-sides of the shape
        function buildSideFaces() {
            var start = verticesArray.length / 3;
            var layeroffset = 0;
            sidewalls(contour, layeroffset);
            layeroffset += contour.length;
            for(h = 0, hl = holes.length; h < hl; h++){
                ahole = holes[h];
                sidewalls(ahole, layeroffset);
                //, true
                layeroffset += ahole.length;
            }
            scope.addGroup(start, verticesArray.length / 3 - start, 1);
        }
        function sidewalls(contour, layeroffset) {
            var j, k;
            i = contour.length;
            while(--i >= 0){
                j = i;
                k = i - 1;
                if (k < 0) k = contour.length - 1;
                //console.log('b', i,j, i-1, k,vertices.length);
                var s = 0, sl = steps + bevelSegments * 2;
                for(s = 0; s < sl; s++){
                    var slen1 = vlen * s;
                    var slen2 = vlen * (s + 1);
                    var a = layeroffset + j + slen1, b = layeroffset + k + slen1, c = layeroffset + k + slen2, d = layeroffset + j + slen2;
                    f4(a, b, c, d);
                }
            }
        }
        function v(x, y, z) {
            placeholder.push(x);
            placeholder.push(y);
            placeholder.push(z);
        }
        function f3(a, b, c) {
            addVertex(a);
            addVertex(b);
            addVertex(c);
            var nextIndex = verticesArray.length / 3;
            var uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
            addUV(uvs[0]);
            addUV(uvs[1]);
            addUV(uvs[2]);
        }
        function f4(a, b, c, d) {
            addVertex(a);
            addVertex(b);
            addVertex(d);
            addVertex(b);
            addVertex(c);
            addVertex(d);
            var nextIndex = verticesArray.length / 3;
            var uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
            addUV(uvs[0]);
            addUV(uvs[1]);
            addUV(uvs[3]);
            addUV(uvs[1]);
            addUV(uvs[2]);
            addUV(uvs[3]);
        }
        function addVertex(index) {
            verticesArray.push(placeholder[index * 3 + 0]);
            verticesArray.push(placeholder[index * 3 + 1]);
            verticesArray.push(placeholder[index * 3 + 2]);
        }
        function addUV(vector2) {
            uvArray.push(vector2.x);
            uvArray.push(vector2.y);
        }
    }
}
ExtrudeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
ExtrudeBufferGeometry.prototype.constructor = ExtrudeBufferGeometry;
ExtrudeBufferGeometry.prototype.toJSON = function() {
    var data = BufferGeometry.prototype.toJSON.call(this);
    var shapes = this.parameters.shapes;
    var options = this.parameters.options;
    return toJSON(shapes, options, data);
};
//
var WorldUVGenerator = {
    generateTopUV: function(geometry, vertices, indexA, indexB, indexC) {
        var a_x = vertices[indexA * 3];
        var a_y = vertices[indexA * 3 + 1];
        var b_x = vertices[indexB * 3];
        var b_y = vertices[indexB * 3 + 1];
        var c_x = vertices[indexC * 3];
        var c_y = vertices[indexC * 3 + 1];
        return [
            new Vector2(a_x, a_y),
            new Vector2(b_x, b_y),
            new Vector2(c_x, c_y)
        ];
    },
    generateSideWallUV: function(geometry, vertices, indexA, indexB, indexC, indexD) {
        var a_x = vertices[indexA * 3];
        var a_y = vertices[indexA * 3 + 1];
        var a_z = vertices[indexA * 3 + 2];
        var b_x = vertices[indexB * 3];
        var b_y = vertices[indexB * 3 + 1];
        var b_z = vertices[indexB * 3 + 2];
        var c_x = vertices[indexC * 3];
        var c_y = vertices[indexC * 3 + 1];
        var c_z = vertices[indexC * 3 + 2];
        var d_x = vertices[indexD * 3];
        var d_y = vertices[indexD * 3 + 1];
        var d_z = vertices[indexD * 3 + 2];
        if (Math.abs(a_y - b_y) < 0.01) return [
            new Vector2(a_x, 1 - a_z),
            new Vector2(b_x, 1 - b_z),
            new Vector2(c_x, 1 - c_z),
            new Vector2(d_x, 1 - d_z)
        ];
        else return [
            new Vector2(a_y, 1 - a_z),
            new Vector2(b_y, 1 - b_z),
            new Vector2(c_y, 1 - c_z),
            new Vector2(d_y, 1 - d_z)
        ];
    }
};
function toJSON(shapes, options, data) {
    //
    data.shapes = [];
    if (Array.isArray(shapes)) for(var i = 0, l = shapes.length; i < l; i++){
        var shape = shapes[i];
        data.shapes.push(shape.uuid);
    }
    else data.shapes.push(shapes.uuid);
    //
    if (options.extrudePath !== undefined) data.options.extrudePath = options.extrudePath.toJSON();
    return data;
}
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author alteredq / http://alteredqualia.com/
 *
 * Text = 3D Text
 *
 * parameters = {
 *  font: <THREE.Font>, // font
 *
 *  size: <float>, // size of the text
 *  height: <float>, // thickness to extrude text
 *  curveSegments: <int>, // number of points on the curves
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into text bevel goes
 *  bevelSize: <float> // how far from text outline is bevel
 * }
 */ // TextGeometry
function TextGeometry(text, parameters) {
    Geometry.call(this);
    this.type = "TextGeometry";
    this.parameters = {
        text: text,
        parameters: parameters
    };
    this.fromBufferGeometry(new TextBufferGeometry(text, parameters));
    this.mergeVertices();
}
TextGeometry.prototype = Object.create(Geometry.prototype);
TextGeometry.prototype.constructor = TextGeometry;
// TextBufferGeometry
function TextBufferGeometry(text, parameters) {
    parameters = parameters || {};
    var font = parameters.font;
    if (!(font && font.isFont)) {
        console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font.");
        return new Geometry();
    }
    var shapes = font.generateShapes(text, parameters.size);
    // translate parameters to ExtrudeGeometry API
    parameters.depth = parameters.height !== undefined ? parameters.height : 50;
    // defaults
    if (parameters.bevelThickness === undefined) parameters.bevelThickness = 10;
    if (parameters.bevelSize === undefined) parameters.bevelSize = 8;
    if (parameters.bevelEnabled === undefined) parameters.bevelEnabled = false;
    ExtrudeBufferGeometry.call(this, shapes, parameters);
    this.type = "TextBufferGeometry";
}
TextBufferGeometry.prototype = Object.create(ExtrudeBufferGeometry.prototype);
TextBufferGeometry.prototype.constructor = TextBufferGeometry;
/**
 * @author mrdoob / http://mrdoob.com/
 * @author benaadams / https://twitter.com/ben_a_adams
 * @author Mugen87 / https://github.com/Mugen87
 */ // SphereGeometry
function SphereGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
    Geometry.call(this);
    this.type = "SphereGeometry";
    this.parameters = {
        radius: radius,
        widthSegments: widthSegments,
        heightSegments: heightSegments,
        phiStart: phiStart,
        phiLength: phiLength,
        thetaStart: thetaStart,
        thetaLength: thetaLength
    };
    this.fromBufferGeometry(new SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength));
    this.mergeVertices();
}
SphereGeometry.prototype = Object.create(Geometry.prototype);
SphereGeometry.prototype.constructor = SphereGeometry;
// SphereBufferGeometry
function SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
    BufferGeometry.call(this);
    this.type = "SphereBufferGeometry";
    this.parameters = {
        radius: radius,
        widthSegments: widthSegments,
        heightSegments: heightSegments,
        phiStart: phiStart,
        phiLength: phiLength,
        thetaStart: thetaStart,
        thetaLength: thetaLength
    };
    radius = radius || 1;
    widthSegments = Math.max(3, Math.floor(widthSegments) || 8);
    heightSegments = Math.max(2, Math.floor(heightSegments) || 6);
    phiStart = phiStart !== undefined ? phiStart : 0;
    phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;
    thetaStart = thetaStart !== undefined ? thetaStart : 0;
    thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;
    var thetaEnd = thetaStart + thetaLength;
    var ix, iy;
    var index = 0;
    var grid = [];
    var vertex = new Vector3();
    var normal = new Vector3();
    // buffers
    var indices = [];
    var vertices = [];
    var normals = [];
    var uvs = [];
    // generate vertices, normals and uvs
    for(iy = 0; iy <= heightSegments; iy++){
        var verticesRow = [];
        var v = iy / heightSegments;
        for(ix = 0; ix <= widthSegments; ix++){
            var u = ix / widthSegments;
            // vertex
            vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
            vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
            vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
            vertices.push(vertex.x, vertex.y, vertex.z);
            // normal
            normal.set(vertex.x, vertex.y, vertex.z).normalize();
            normals.push(normal.x, normal.y, normal.z);
            // uv
            uvs.push(u, 1 - v);
            verticesRow.push(index++);
        }
        grid.push(verticesRow);
    }
    // indices
    for(iy = 0; iy < heightSegments; iy++)for(ix = 0; ix < widthSegments; ix++){
        var a = grid[iy][ix + 1];
        var b = grid[iy][ix];
        var c = grid[iy + 1][ix];
        var d = grid[iy + 1][ix + 1];
        if (iy !== 0 || thetaStart > 0) indices.push(a, b, d);
        if (iy !== heightSegments - 1 || thetaEnd < Math.PI) indices.push(b, c, d);
    }
    // build geometry
    this.setIndex(indices);
    this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
}
SphereBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
SphereBufferGeometry.prototype.constructor = SphereBufferGeometry;
/**
 * @author Kaleb Murphy
 * @author Mugen87 / https://github.com/Mugen87
 */ // RingGeometry
function RingGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
    Geometry.call(this);
    this.type = "RingGeometry";
    this.parameters = {
        innerRadius: innerRadius,
        outerRadius: outerRadius,
        thetaSegments: thetaSegments,
        phiSegments: phiSegments,
        thetaStart: thetaStart,
        thetaLength: thetaLength
    };
    this.fromBufferGeometry(new RingBufferGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength));
    this.mergeVertices();
}
RingGeometry.prototype = Object.create(Geometry.prototype);
RingGeometry.prototype.constructor = RingGeometry;
// RingBufferGeometry
function RingBufferGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
    BufferGeometry.call(this);
    this.type = "RingBufferGeometry";
    this.parameters = {
        innerRadius: innerRadius,
        outerRadius: outerRadius,
        thetaSegments: thetaSegments,
        phiSegments: phiSegments,
        thetaStart: thetaStart,
        thetaLength: thetaLength
    };
    innerRadius = innerRadius || 0.5;
    outerRadius = outerRadius || 1;
    thetaStart = thetaStart !== undefined ? thetaStart : 0;
    thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
    thetaSegments = thetaSegments !== undefined ? Math.max(3, thetaSegments) : 8;
    phiSegments = phiSegments !== undefined ? Math.max(1, phiSegments) : 1;
    // buffers
    var indices = [];
    var vertices = [];
    var normals = [];
    var uvs = [];
    // some helper variables
    var segment;
    var radius = innerRadius;
    var radiusStep = (outerRadius - innerRadius) / phiSegments;
    var vertex = new Vector3();
    var uv = new Vector2();
    var j, i;
    // generate vertices, normals and uvs
    for(j = 0; j <= phiSegments; j++){
        for(i = 0; i <= thetaSegments; i++){
            // values are generate from the inside of the ring to the outside
            segment = thetaStart + i / thetaSegments * thetaLength;
            // vertex
            vertex.x = radius * Math.cos(segment);
            vertex.y = radius * Math.sin(segment);
            vertices.push(vertex.x, vertex.y, vertex.z);
            // normal
            normals.push(0, 0, 1);
            // uv
            uv.x = (vertex.x / outerRadius + 1) / 2;
            uv.y = (vertex.y / outerRadius + 1) / 2;
            uvs.push(uv.x, uv.y);
        }
        // increase the radius for next row of vertices
        radius += radiusStep;
    }
    // indices
    for(j = 0; j < phiSegments; j++){
        var thetaSegmentLevel = j * (thetaSegments + 1);
        for(i = 0; i < thetaSegments; i++){
            segment = i + thetaSegmentLevel;
            var a = segment;
            var b = segment + thetaSegments + 1;
            var c = segment + thetaSegments + 2;
            var d = segment + 1;
            // faces
            indices.push(a, b, d);
            indices.push(b, c, d);
        }
    }
    // build geometry
    this.setIndex(indices);
    this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
}
RingBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
RingBufferGeometry.prototype.constructor = RingBufferGeometry;
/**
 * @author zz85 / https://github.com/zz85
 * @author bhouston / http://clara.io
 * @author Mugen87 / https://github.com/Mugen87
 */ // LatheGeometry
function LatheGeometry(points, segments, phiStart, phiLength) {
    Geometry.call(this);
    this.type = "LatheGeometry";
    this.parameters = {
        points: points,
        segments: segments,
        phiStart: phiStart,
        phiLength: phiLength
    };
    this.fromBufferGeometry(new LatheBufferGeometry(points, segments, phiStart, phiLength));
    this.mergeVertices();
}
LatheGeometry.prototype = Object.create(Geometry.prototype);
LatheGeometry.prototype.constructor = LatheGeometry;
// LatheBufferGeometry
function LatheBufferGeometry(points, segments, phiStart, phiLength) {
    BufferGeometry.call(this);
    this.type = "LatheBufferGeometry";
    this.parameters = {
        points: points,
        segments: segments,
        phiStart: phiStart,
        phiLength: phiLength
    };
    segments = Math.floor(segments) || 12;
    phiStart = phiStart || 0;
    phiLength = phiLength || Math.PI * 2;
    // clamp phiLength so it's in range of [ 0, 2PI ]
    phiLength = _Math.clamp(phiLength, 0, Math.PI * 2);
    // buffers
    var indices = [];
    var vertices = [];
    var uvs = [];
    // helper variables
    var base;
    var inverseSegments = 1.0 / segments;
    var vertex = new Vector3();
    var uv = new Vector2();
    var i, j;
    // generate vertices and uvs
    for(i = 0; i <= segments; i++){
        var phi = phiStart + i * inverseSegments * phiLength;
        var sin = Math.sin(phi);
        var cos = Math.cos(phi);
        for(j = 0; j <= points.length - 1; j++){
            // vertex
            vertex.x = points[j].x * sin;
            vertex.y = points[j].y;
            vertex.z = points[j].x * cos;
            vertices.push(vertex.x, vertex.y, vertex.z);
            // uv
            uv.x = i / segments;
            uv.y = j / (points.length - 1);
            uvs.push(uv.x, uv.y);
        }
    }
    // indices
    for(i = 0; i < segments; i++)for(j = 0; j < points.length - 1; j++){
        base = j + i * points.length;
        var a = base;
        var b = base + points.length;
        var c = base + points.length + 1;
        var d = base + 1;
        // faces
        indices.push(a, b, d);
        indices.push(b, c, d);
    }
    // build geometry
    this.setIndex(indices);
    this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
    // generate normals
    this.computeVertexNormals();
    // if the geometry is closed, we need to average the normals along the seam.
    // because the corresponding vertices are identical (but still have different UVs).
    if (phiLength === Math.PI * 2) {
        var normals = this.attributes.normal.array;
        var n1 = new Vector3();
        var n2 = new Vector3();
        var n = new Vector3();
        // this is the buffer offset for the last line of vertices
        base = segments * points.length * 3;
        for(i = 0, j = 0; i < points.length; i++, j += 3){
            // select the normal of the vertex in the first line
            n1.x = normals[j + 0];
            n1.y = normals[j + 1];
            n1.z = normals[j + 2];
            // select the normal of the vertex in the last line
            n2.x = normals[base + j + 0];
            n2.y = normals[base + j + 1];
            n2.z = normals[base + j + 2];
            // average normals
            n.addVectors(n1, n2).normalize();
            // assign the new values to both normals
            normals[j + 0] = normals[base + j + 0] = n.x;
            normals[j + 1] = normals[base + j + 1] = n.y;
            normals[j + 2] = normals[base + j + 2] = n.z;
        }
    }
}
LatheBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
LatheBufferGeometry.prototype.constructor = LatheBufferGeometry;
/**
 * @author jonobr1 / http://jonobr1.com
 * @author Mugen87 / https://github.com/Mugen87
 */ // ShapeGeometry
function ShapeGeometry(shapes, curveSegments) {
    Geometry.call(this);
    this.type = "ShapeGeometry";
    if (typeof curveSegments === "object") {
        console.warn("THREE.ShapeGeometry: Options parameter has been removed.");
        curveSegments = curveSegments.curveSegments;
    }
    this.parameters = {
        shapes: shapes,
        curveSegments: curveSegments
    };
    this.fromBufferGeometry(new ShapeBufferGeometry(shapes, curveSegments));
    this.mergeVertices();
}
ShapeGeometry.prototype = Object.create(Geometry.prototype);
ShapeGeometry.prototype.constructor = ShapeGeometry;
ShapeGeometry.prototype.toJSON = function() {
    var data = Geometry.prototype.toJSON.call(this);
    var shapes = this.parameters.shapes;
    return toJSON$1(shapes, data);
};
// ShapeBufferGeometry
function ShapeBufferGeometry(shapes, curveSegments) {
    BufferGeometry.call(this);
    this.type = "ShapeBufferGeometry";
    this.parameters = {
        shapes: shapes,
        curveSegments: curveSegments
    };
    curveSegments = curveSegments || 12;
    // buffers
    var indices = [];
    var vertices = [];
    var normals = [];
    var uvs = [];
    // helper variables
    var groupStart = 0;
    var groupCount = 0;
    // allow single and array values for "shapes" parameter
    if (Array.isArray(shapes) === false) addShape(shapes);
    else for(var i = 0; i < shapes.length; i++){
        addShape(shapes[i]);
        this.addGroup(groupStart, groupCount, i); // enables MultiMaterial support
        groupStart += groupCount;
        groupCount = 0;
    }
    // build geometry
    this.setIndex(indices);
    this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
    // helper functions
    function addShape(shape) {
        var i, l, shapeHole;
        var indexOffset = vertices.length / 3;
        var points = shape.extractPoints(curveSegments);
        var shapeVertices = points.shape;
        var shapeHoles = points.holes;
        // check direction of vertices
        if (ShapeUtils.isClockWise(shapeVertices) === false) shapeVertices = shapeVertices.reverse();
        for(i = 0, l = shapeHoles.length; i < l; i++){
            shapeHole = shapeHoles[i];
            if (ShapeUtils.isClockWise(shapeHole) === true) shapeHoles[i] = shapeHole.reverse();
        }
        var faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);
        // join vertices of inner and outer paths to a single array
        for(i = 0, l = shapeHoles.length; i < l; i++){
            shapeHole = shapeHoles[i];
            shapeVertices = shapeVertices.concat(shapeHole);
        }
        // vertices, normals, uvs
        for(i = 0, l = shapeVertices.length; i < l; i++){
            var vertex = shapeVertices[i];
            vertices.push(vertex.x, vertex.y, 0);
            normals.push(0, 0, 1);
            uvs.push(vertex.x, vertex.y); // world uvs
        }
        // incides
        for(i = 0, l = faces.length; i < l; i++){
            var face = faces[i];
            var a = face[0] + indexOffset;
            var b = face[1] + indexOffset;
            var c = face[2] + indexOffset;
            indices.push(a, b, c);
            groupCount += 3;
        }
    }
}
ShapeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
ShapeBufferGeometry.prototype.constructor = ShapeBufferGeometry;
ShapeBufferGeometry.prototype.toJSON = function() {
    var data = BufferGeometry.prototype.toJSON.call(this);
    var shapes = this.parameters.shapes;
    return toJSON$1(shapes, data);
};
//
function toJSON$1(shapes, data) {
    data.shapes = [];
    if (Array.isArray(shapes)) for(var i = 0, l = shapes.length; i < l; i++){
        var shape = shapes[i];
        data.shapes.push(shape.uuid);
    }
    else data.shapes.push(shapes.uuid);
    return data;
}
/**
 * @author WestLangley / http://github.com/WestLangley
 * @author Mugen87 / https://github.com/Mugen87
 */ function EdgesGeometry(geometry, thresholdAngle) {
    BufferGeometry.call(this);
    this.type = "EdgesGeometry";
    this.parameters = {
        thresholdAngle: thresholdAngle
    };
    thresholdAngle = thresholdAngle !== undefined ? thresholdAngle : 1;
    // buffer
    var vertices = [];
    // helper variables
    var thresholdDot = Math.cos(_Math.DEG2RAD * thresholdAngle);
    var edge = [
        0,
        0
    ], edges = {}, edge1, edge2;
    var key, keys = [
        "a",
        "b",
        "c"
    ];
    // prepare source geometry
    var geometry2;
    if (geometry.isBufferGeometry) {
        geometry2 = new Geometry();
        geometry2.fromBufferGeometry(geometry);
    } else geometry2 = geometry.clone();
    geometry2.mergeVertices();
    geometry2.computeFaceNormals();
    var sourceVertices = geometry2.vertices;
    var faces = geometry2.faces;
    // now create a data structure where each entry represents an edge with its adjoining faces
    for(var i = 0, l = faces.length; i < l; i++){
        var face = faces[i];
        for(var j = 0; j < 3; j++){
            edge1 = face[keys[j]];
            edge2 = face[keys[(j + 1) % 3]];
            edge[0] = Math.min(edge1, edge2);
            edge[1] = Math.max(edge1, edge2);
            key = edge[0] + "," + edge[1];
            if (edges[key] === undefined) edges[key] = {
                index1: edge[0],
                index2: edge[1],
                face1: i,
                face2: undefined
            };
            else edges[key].face2 = i;
        }
    }
    // generate vertices
    for(key in edges){
        var e = edges[key];
        // an edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.
        if (e.face2 === undefined || faces[e.face1].normal.dot(faces[e.face2].normal) <= thresholdDot) {
            var vertex = sourceVertices[e.index1];
            vertices.push(vertex.x, vertex.y, vertex.z);
            vertex = sourceVertices[e.index2];
            vertices.push(vertex.x, vertex.y, vertex.z);
        }
    }
    // build geometry
    this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
}
EdgesGeometry.prototype = Object.create(BufferGeometry.prototype);
EdgesGeometry.prototype.constructor = EdgesGeometry;
/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */ // CylinderGeometry
function CylinderGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
    Geometry.call(this);
    this.type = "CylinderGeometry";
    this.parameters = {
        radiusTop: radiusTop,
        radiusBottom: radiusBottom,
        height: height,
        radialSegments: radialSegments,
        heightSegments: heightSegments,
        openEnded: openEnded,
        thetaStart: thetaStart,
        thetaLength: thetaLength
    };
    this.fromBufferGeometry(new CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength));
    this.mergeVertices();
}
CylinderGeometry.prototype = Object.create(Geometry.prototype);
CylinderGeometry.prototype.constructor = CylinderGeometry;
// CylinderBufferGeometry
function CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
    BufferGeometry.call(this);
    this.type = "CylinderBufferGeometry";
    this.parameters = {
        radiusTop: radiusTop,
        radiusBottom: radiusBottom,
        height: height,
        radialSegments: radialSegments,
        heightSegments: heightSegments,
        openEnded: openEnded,
        thetaStart: thetaStart,
        thetaLength: thetaLength
    };
    var scope = this;
    radiusTop = radiusTop !== undefined ? radiusTop : 1;
    radiusBottom = radiusBottom !== undefined ? radiusBottom : 1;
    height = height || 1;
    radialSegments = Math.floor(radialSegments) || 8;
    heightSegments = Math.floor(heightSegments) || 1;
    openEnded = openEnded !== undefined ? openEnded : false;
    thetaStart = thetaStart !== undefined ? thetaStart : 0.0;
    thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
    // buffers
    var indices = [];
    var vertices = [];
    var normals = [];
    var uvs = [];
    // helper variables
    var index = 0;
    var indexArray = [];
    var halfHeight = height / 2;
    var groupStart = 0;
    // generate geometry
    generateTorso();
    if (openEnded === false) {
        if (radiusTop > 0) generateCap(true);
        if (radiusBottom > 0) generateCap(false);
    }
    // build geometry
    this.setIndex(indices);
    this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function generateTorso() {
        var x, y;
        var normal = new Vector3();
        var vertex = new Vector3();
        var groupCount = 0;
        // this will be used to calculate the normal
        var slope = (radiusBottom - radiusTop) / height;
        // generate vertices, normals and uvs
        for(y = 0; y <= heightSegments; y++){
            var indexRow = [];
            var v = y / heightSegments;
            // calculate the radius of the current row
            var radius = v * (radiusBottom - radiusTop) + radiusTop;
            for(x = 0; x <= radialSegments; x++){
                var u = x / radialSegments;
                var theta = u * thetaLength + thetaStart;
                var sinTheta = Math.sin(theta);
                var cosTheta = Math.cos(theta);
                // vertex
                vertex.x = radius * sinTheta;
                vertex.y = -v * height + halfHeight;
                vertex.z = radius * cosTheta;
                vertices.push(vertex.x, vertex.y, vertex.z);
                // normal
                normal.set(sinTheta, slope, cosTheta).normalize();
                normals.push(normal.x, normal.y, normal.z);
                // uv
                uvs.push(u, 1 - v);
                // save index of vertex in respective row
                indexRow.push(index++);
            }
            // now save vertices of the row in our index array
            indexArray.push(indexRow);
        }
        // generate indices
        for(x = 0; x < radialSegments; x++)for(y = 0; y < heightSegments; y++){
            // we use the index array to access the correct indices
            var a = indexArray[y][x];
            var b = indexArray[y + 1][x];
            var c = indexArray[y + 1][x + 1];
            var d = indexArray[y][x + 1];
            // faces
            indices.push(a, b, d);
            indices.push(b, c, d);
            // update group counter
            groupCount += 6;
        }
        // add a group to the geometry. this will ensure multi material support
        scope.addGroup(groupStart, groupCount, 0);
        // calculate new start value for groups
        groupStart += groupCount;
    }
    function generateCap(top) {
        var x, centerIndexStart, centerIndexEnd;
        var uv = new Vector2();
        var vertex = new Vector3();
        var groupCount = 0;
        var radius = top === true ? radiusTop : radiusBottom;
        var sign = top === true ? 1 : -1;
        // save the index of the first center vertex
        centerIndexStart = index;
        // first we generate the center vertex data of the cap.
        // because the geometry needs one set of uvs per face,
        // we must generate a center vertex per face/segment
        for(x = 1; x <= radialSegments; x++){
            // vertex
            vertices.push(0, halfHeight * sign, 0);
            // normal
            normals.push(0, sign, 0);
            // uv
            uvs.push(0.5, 0.5);
            // increase index
            index++;
        }
        // save the index of the last center vertex
        centerIndexEnd = index;
        // now we generate the surrounding vertices, normals and uvs
        for(x = 0; x <= radialSegments; x++){
            var u = x / radialSegments;
            var theta = u * thetaLength + thetaStart;
            var cosTheta = Math.cos(theta);
            var sinTheta = Math.sin(theta);
            // vertex
            vertex.x = radius * sinTheta;
            vertex.y = halfHeight * sign;
            vertex.z = radius * cosTheta;
            vertices.push(vertex.x, vertex.y, vertex.z);
            // normal
            normals.push(0, sign, 0);
            // uv
            uv.x = cosTheta * 0.5 + 0.5;
            uv.y = sinTheta * 0.5 * sign + 0.5;
            uvs.push(uv.x, uv.y);
            // increase index
            index++;
        }
        // generate indices
        for(x = 0; x < radialSegments; x++){
            var c = centerIndexStart + x;
            var i = centerIndexEnd + x;
            if (top === true) // face top
            indices.push(i, i + 1, c);
            else // face bottom
            indices.push(i + 1, i, c);
            groupCount += 3;
        }
        // add a group to the geometry. this will ensure multi material support
        scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);
        // calculate new start value for groups
        groupStart += groupCount;
    }
}
CylinderBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
CylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;
/**
 * @author abelnation / http://github.com/abelnation
 */ // ConeGeometry
function ConeGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
    CylinderGeometry.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
    this.type = "ConeGeometry";
    this.parameters = {
        radius: radius,
        height: height,
        radialSegments: radialSegments,
        heightSegments: heightSegments,
        openEnded: openEnded,
        thetaStart: thetaStart,
        thetaLength: thetaLength
    };
}
ConeGeometry.prototype = Object.create(CylinderGeometry.prototype);
ConeGeometry.prototype.constructor = ConeGeometry;
// ConeBufferGeometry
function ConeBufferGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
    CylinderBufferGeometry.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
    this.type = "ConeBufferGeometry";
    this.parameters = {
        radius: radius,
        height: height,
        radialSegments: radialSegments,
        heightSegments: heightSegments,
        openEnded: openEnded,
        thetaStart: thetaStart,
        thetaLength: thetaLength
    };
}
ConeBufferGeometry.prototype = Object.create(CylinderBufferGeometry.prototype);
ConeBufferGeometry.prototype.constructor = ConeBufferGeometry;
/**
 * @author benaadams / https://twitter.com/ben_a_adams
 * @author Mugen87 / https://github.com/Mugen87
 * @author hughes
 */ // CircleGeometry
function CircleGeometry(radius, segments, thetaStart, thetaLength) {
    Geometry.call(this);
    this.type = "CircleGeometry";
    this.parameters = {
        radius: radius,
        segments: segments,
        thetaStart: thetaStart,
        thetaLength: thetaLength
    };
    this.fromBufferGeometry(new CircleBufferGeometry(radius, segments, thetaStart, thetaLength));
    this.mergeVertices();
}
CircleGeometry.prototype = Object.create(Geometry.prototype);
CircleGeometry.prototype.constructor = CircleGeometry;
// CircleBufferGeometry
function CircleBufferGeometry(radius, segments, thetaStart, thetaLength) {
    BufferGeometry.call(this);
    this.type = "CircleBufferGeometry";
    this.parameters = {
        radius: radius,
        segments: segments,
        thetaStart: thetaStart,
        thetaLength: thetaLength
    };
    radius = radius || 1;
    segments = segments !== undefined ? Math.max(3, segments) : 8;
    thetaStart = thetaStart !== undefined ? thetaStart : 0;
    thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
    // buffers
    var indices = [];
    var vertices = [];
    var normals = [];
    var uvs = [];
    // helper variables
    var i, s;
    var vertex = new Vector3();
    var uv = new Vector2();
    // center point
    vertices.push(0, 0, 0);
    normals.push(0, 0, 1);
    uvs.push(0.5, 0.5);
    for(s = 0, i = 3; s <= segments; s++, i += 3){
        var segment = thetaStart + s / segments * thetaLength;
        // vertex
        vertex.x = radius * Math.cos(segment);
        vertex.y = radius * Math.sin(segment);
        vertices.push(vertex.x, vertex.y, vertex.z);
        // normal
        normals.push(0, 0, 1);
        // uvs
        uv.x = (vertices[i] / radius + 1) / 2;
        uv.y = (vertices[i + 1] / radius + 1) / 2;
        uvs.push(uv.x, uv.y);
    }
    // indices
    for(i = 1; i <= segments; i++)indices.push(i, i + 1, 0);
    // build geometry
    this.setIndex(indices);
    this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
}
CircleBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
CircleBufferGeometry.prototype.constructor = CircleBufferGeometry;
var Geometries = /*#__PURE__*/ Object.freeze({
    WireframeGeometry: WireframeGeometry,
    ParametricGeometry: ParametricGeometry,
    ParametricBufferGeometry: ParametricBufferGeometry,
    TetrahedronGeometry: TetrahedronGeometry,
    TetrahedronBufferGeometry: TetrahedronBufferGeometry,
    OctahedronGeometry: OctahedronGeometry,
    OctahedronBufferGeometry: OctahedronBufferGeometry,
    IcosahedronGeometry: IcosahedronGeometry,
    IcosahedronBufferGeometry: IcosahedronBufferGeometry,
    DodecahedronGeometry: DodecahedronGeometry,
    DodecahedronBufferGeometry: DodecahedronBufferGeometry,
    PolyhedronGeometry: PolyhedronGeometry,
    PolyhedronBufferGeometry: PolyhedronBufferGeometry,
    TubeGeometry: TubeGeometry,
    TubeBufferGeometry: TubeBufferGeometry,
    TorusKnotGeometry: TorusKnotGeometry,
    TorusKnotBufferGeometry: TorusKnotBufferGeometry,
    TorusGeometry: TorusGeometry,
    TorusBufferGeometry: TorusBufferGeometry,
    TextGeometry: TextGeometry,
    TextBufferGeometry: TextBufferGeometry,
    SphereGeometry: SphereGeometry,
    SphereBufferGeometry: SphereBufferGeometry,
    RingGeometry: RingGeometry,
    RingBufferGeometry: RingBufferGeometry,
    PlaneGeometry: PlaneGeometry,
    PlaneBufferGeometry: PlaneBufferGeometry,
    LatheGeometry: LatheGeometry,
    LatheBufferGeometry: LatheBufferGeometry,
    ShapeGeometry: ShapeGeometry,
    ShapeBufferGeometry: ShapeBufferGeometry,
    ExtrudeGeometry: ExtrudeGeometry,
    ExtrudeBufferGeometry: ExtrudeBufferGeometry,
    EdgesGeometry: EdgesGeometry,
    ConeGeometry: ConeGeometry,
    ConeBufferGeometry: ConeBufferGeometry,
    CylinderGeometry: CylinderGeometry,
    CylinderBufferGeometry: CylinderBufferGeometry,
    CircleGeometry: CircleGeometry,
    CircleBufferGeometry: CircleBufferGeometry,
    BoxGeometry: BoxGeometry,
    BoxBufferGeometry: BoxBufferGeometry
});
/**
 * @author mrdoob / http://mrdoob.com/
 *
 * parameters = {
 *  color: <THREE.Color>
 * }
 */ function ShadowMaterial(parameters) {
    Material.call(this);
    this.type = "ShadowMaterial";
    this.color = new Color(0x000000);
    this.transparent = true;
    this.setValues(parameters);
}
ShadowMaterial.prototype = Object.create(Material.prototype);
ShadowMaterial.prototype.constructor = ShadowMaterial;
ShadowMaterial.prototype.isShadowMaterial = true;
ShadowMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.color.copy(source.color);
    return this;
};
/**
 * @author mrdoob / http://mrdoob.com/
 */ function RawShaderMaterial(parameters) {
    ShaderMaterial.call(this, parameters);
    this.type = "RawShaderMaterial";
}
RawShaderMaterial.prototype = Object.create(ShaderMaterial.prototype);
RawShaderMaterial.prototype.constructor = RawShaderMaterial;
RawShaderMaterial.prototype.isRawShaderMaterial = true;
/**
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *  color: <hex>,
 *  roughness: <float>,
 *  metalness: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  roughnessMap: new THREE.Texture( <Image> ),
 *
 *  metalnessMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  envMapIntensity: <float>
 *
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */ function MeshStandardMaterial(parameters) {
    Material.call(this);
    this.defines = {
        "STANDARD": ""
    };
    this.type = "MeshStandardMaterial";
    this.color = new Color(0xffffff); // diffuse
    this.roughness = 0.5;
    this.metalness = 0.5;
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1.0;
    this.aoMap = null;
    this.aoMapIntensity = 1.0;
    this.emissive = new Color(0x000000);
    this.emissiveIntensity = 1.0;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.roughnessMap = null;
    this.metalnessMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.envMapIntensity = 1.0;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.setValues(parameters);
}
MeshStandardMaterial.prototype = Object.create(Material.prototype);
MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;
MeshStandardMaterial.prototype.isMeshStandardMaterial = true;
MeshStandardMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.defines = {
        "STANDARD": ""
    };
    this.color.copy(source.color);
    this.roughness = source.roughness;
    this.metalness = source.metalness;
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.roughnessMap = source.roughnessMap;
    this.metalnessMap = source.metalnessMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.envMapIntensity = source.envMapIntensity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    return this;
};
/**
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *  reflectivity: <float>
 * }
 */ function MeshPhysicalMaterial(parameters) {
    MeshStandardMaterial.call(this);
    this.defines = {
        "PHYSICAL": ""
    };
    this.type = "MeshPhysicalMaterial";
    this.reflectivity = 0.5; // maps to F0 = 0.04
    this.clearCoat = 0.0;
    this.clearCoatRoughness = 0.0;
    this.setValues(parameters);
}
MeshPhysicalMaterial.prototype = Object.create(MeshStandardMaterial.prototype);
MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;
MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;
MeshPhysicalMaterial.prototype.copy = function(source) {
    MeshStandardMaterial.prototype.copy.call(this, source);
    this.defines = {
        "PHYSICAL": ""
    };
    this.reflectivity = source.reflectivity;
    this.clearCoat = source.clearCoat;
    this.clearCoatRoughness = source.clearCoatRoughness;
    return this;
};
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  specular: <hex>,
 *  shininess: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */ function MeshPhongMaterial(parameters) {
    Material.call(this);
    this.type = "MeshPhongMaterial";
    this.color = new Color(0xffffff); // diffuse
    this.specular = new Color(0x111111);
    this.shininess = 30;
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1.0;
    this.aoMap = null;
    this.aoMapIntensity = 1.0;
    this.emissive = new Color(0x000000);
    this.emissiveIntensity = 1.0;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.setValues(parameters);
}
MeshPhongMaterial.prototype = Object.create(Material.prototype);
MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;
MeshPhongMaterial.prototype.isMeshPhongMaterial = true;
MeshPhongMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.specular.copy(source.specular);
    this.shininess = source.shininess;
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    return this;
};
/**
 * @author takahirox / http://github.com/takahirox
 *
 * parameters = {
 *  gradientMap: new THREE.Texture( <Image> )
 * }
 */ function MeshToonMaterial(parameters) {
    MeshPhongMaterial.call(this);
    this.defines = {
        "TOON": ""
    };
    this.type = "MeshToonMaterial";
    this.gradientMap = null;
    this.setValues(parameters);
}
MeshToonMaterial.prototype = Object.create(MeshPhongMaterial.prototype);
MeshToonMaterial.prototype.constructor = MeshToonMaterial;
MeshToonMaterial.prototype.isMeshToonMaterial = true;
MeshToonMaterial.prototype.copy = function(source) {
    MeshPhongMaterial.prototype.copy.call(this, source);
    this.gradientMap = source.gradientMap;
    return this;
};
/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *  opacity: <float>,
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */ function MeshNormalMaterial(parameters) {
    Material.call(this);
    this.type = "MeshNormalMaterial";
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.lights = false;
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.setValues(parameters);
}
MeshNormalMaterial.prototype = Object.create(Material.prototype);
MeshNormalMaterial.prototype.constructor = MeshNormalMaterial;
MeshNormalMaterial.prototype.isMeshNormalMaterial = true;
MeshNormalMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    return this;
};
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */ function MeshLambertMaterial(parameters) {
    Material.call(this);
    this.type = "MeshLambertMaterial";
    this.color = new Color(0xffffff); // diffuse
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1.0;
    this.aoMap = null;
    this.aoMapIntensity = 1.0;
    this.emissive = new Color(0x000000);
    this.emissiveIntensity = 1.0;
    this.emissiveMap = null;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.setValues(parameters);
}
MeshLambertMaterial.prototype = Object.create(Material.prototype);
MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;
MeshLambertMaterial.prototype.isMeshLambertMaterial = true;
MeshLambertMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    return this;
};
/**
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  matcap: new THREE.Texture( <Image> ),
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */ function MeshMatcapMaterial(parameters) {
    Material.call(this);
    this.defines = {
        "MATCAP": ""
    };
    this.type = "MeshMatcapMaterial";
    this.color = new Color(0xffffff); // diffuse
    this.matcap = null;
    this.map = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.alphaMap = null;
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.lights = false;
    this.setValues(parameters);
}
MeshMatcapMaterial.prototype = Object.create(Material.prototype);
MeshMatcapMaterial.prototype.constructor = MeshMatcapMaterial;
MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;
MeshMatcapMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.defines = {
        "MATCAP": ""
    };
    this.color.copy(source.color);
    this.matcap = source.matcap;
    this.map = source.map;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.alphaMap = source.alphaMap;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    return this;
};
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  linewidth: <float>,
 *
 *  scale: <float>,
 *  dashSize: <float>,
 *  gapSize: <float>
 * }
 */ function LineDashedMaterial(parameters) {
    LineBasicMaterial.call(this);
    this.type = "LineDashedMaterial";
    this.scale = 1;
    this.dashSize = 3;
    this.gapSize = 1;
    this.setValues(parameters);
}
LineDashedMaterial.prototype = Object.create(LineBasicMaterial.prototype);
LineDashedMaterial.prototype.constructor = LineDashedMaterial;
LineDashedMaterial.prototype.isLineDashedMaterial = true;
LineDashedMaterial.prototype.copy = function(source) {
    LineBasicMaterial.prototype.copy.call(this, source);
    this.scale = source.scale;
    this.dashSize = source.dashSize;
    this.gapSize = source.gapSize;
    return this;
};
var Materials = /*#__PURE__*/ Object.freeze({
    ShadowMaterial: ShadowMaterial,
    SpriteMaterial: SpriteMaterial,
    RawShaderMaterial: RawShaderMaterial,
    ShaderMaterial: ShaderMaterial,
    PointsMaterial: PointsMaterial,
    MeshPhysicalMaterial: MeshPhysicalMaterial,
    MeshStandardMaterial: MeshStandardMaterial,
    MeshPhongMaterial: MeshPhongMaterial,
    MeshToonMaterial: MeshToonMaterial,
    MeshNormalMaterial: MeshNormalMaterial,
    MeshLambertMaterial: MeshLambertMaterial,
    MeshDepthMaterial: MeshDepthMaterial,
    MeshDistanceMaterial: MeshDistanceMaterial,
    MeshBasicMaterial: MeshBasicMaterial,
    MeshMatcapMaterial: MeshMatcapMaterial,
    LineDashedMaterial: LineDashedMaterial,
    LineBasicMaterial: LineBasicMaterial,
    Material: Material
});
/**
 * @author tschw
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */ var AnimationUtils = {
    // same as Array.prototype.slice, but also works on typed arrays
    arraySlice: function(array, from, to) {
        if (AnimationUtils.isTypedArray(array)) // in ios9 array.subarray(from, undefined) will return empty array
        // but array.subarray(from) or array.subarray(from, len) is correct
        return new array.constructor(array.subarray(from, to !== undefined ? to : array.length));
        return array.slice(from, to);
    },
    // converts an array to a specific type
    convertArray: function(array, type, forceClone) {
        if (!array || // let 'undefined' and 'null' pass
        !forceClone && array.constructor === type) return array;
        if (typeof type.BYTES_PER_ELEMENT === "number") return new type(array); // create typed array
        return Array.prototype.slice.call(array); // create Array
    },
    isTypedArray: function(object) {
        return ArrayBuffer.isView(object) && !(object instanceof DataView);
    },
    // returns an array by which times and values can be sorted
    getKeyframeOrder: function(times) {
        function compareTime(i, j) {
            return times[i] - times[j];
        }
        var n = times.length;
        var result = new Array(n);
        for(var i = 0; i !== n; ++i)result[i] = i;
        result.sort(compareTime);
        return result;
    },
    // uses the array previously returned by 'getKeyframeOrder' to sort data
    sortedArray: function(values, stride, order) {
        var nValues = values.length;
        var result = new values.constructor(nValues);
        for(var i = 0, dstOffset = 0; dstOffset !== nValues; ++i){
            var srcOffset = order[i] * stride;
            for(var j = 0; j !== stride; ++j)result[dstOffset++] = values[srcOffset + j];
        }
        return result;
    },
    // function for parsing AOS keyframe formats
    flattenJSON: function(jsonKeys, times, values, valuePropertyName) {
        var i = 1, key = jsonKeys[0];
        while(key !== undefined && key[valuePropertyName] === undefined)key = jsonKeys[i++];
        if (key === undefined) return; // no data
        var value = key[valuePropertyName];
        if (value === undefined) return; // no data
        if (Array.isArray(value)) do {
            value = key[valuePropertyName];
            if (value !== undefined) {
                times.push(key.time);
                values.push.apply(values, value); // push all elements
            }
            key = jsonKeys[i++];
        }while (key !== undefined);
        else if (value.toArray !== undefined) // ...assume THREE.Math-ish
        do {
            value = key[valuePropertyName];
            if (value !== undefined) {
                times.push(key.time);
                value.toArray(values, values.length);
            }
            key = jsonKeys[i++];
        }while (key !== undefined);
        else // otherwise push as-is
        do {
            value = key[valuePropertyName];
            if (value !== undefined) {
                times.push(key.time);
                values.push(value);
            }
            key = jsonKeys[i++];
        }while (key !== undefined);
    }
};
/**
 * Abstract base class of interpolants over parametric samples.
 *
 * The parameter domain is one dimensional, typically the time or a path
 * along a curve defined by the data.
 *
 * The sample values can have any dimensionality and derived classes may
 * apply special interpretations to the data.
 *
 * This class provides the interval seek in a Template Method, deferring
 * the actual interpolation to derived classes.
 *
 * Time complexity is O(1) for linear access crossing at most two points
 * and O(log N) for random access, where N is the number of positions.
 *
 * References:
 *
 * 		http://www.oodesign.com/template-method-pattern.html
 *
 * @author tschw
 */ function Interpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    this.parameterPositions = parameterPositions;
    this._cachedIndex = 0;
    this.resultBuffer = resultBuffer !== undefined ? resultBuffer : new sampleValues.constructor(sampleSize);
    this.sampleValues = sampleValues;
    this.valueSize = sampleSize;
}
Object.assign(Interpolant.prototype, {
    evaluate: function(t) {
        var pp = this.parameterPositions, i1 = this._cachedIndex, t1 = pp[i1], t0 = pp[i1 - 1];
        validate_interval: {
            seek: {
                var right;
                linear_scan: {
                    //- See http://jsperf.com/comparison-to-undefined/3
                    //- slower code:
                    //-
                    //- 				if ( t >= t1 || t1 === undefined ) {
                    forward_scan: if (!(t < t1)) {
                        for(var giveUpAt = i1 + 2;;){
                            if (t1 === undefined) {
                                if (t < t0) break forward_scan;
                                // after end
                                i1 = pp.length;
                                this._cachedIndex = i1;
                                return this.afterEnd_(i1 - 1, t, t0);
                            }
                            if (i1 === giveUpAt) break; // this loop
                            t0 = t1;
                            t1 = pp[++i1];
                            if (t < t1) break seek;
                        }
                        // prepare binary search on the right side of the index
                        right = pp.length;
                        break linear_scan;
                    }
                    //- slower code:
                    //-					if ( t < t0 || t0 === undefined ) {
                    if (!(t >= t0)) {
                        // looping?
                        var t1global = pp[1];
                        if (t < t1global) {
                            i1 = 2; // + 1, using the scan for the details
                            t0 = t1global;
                        }
                        // linear reverse scan
                        for(var giveUpAt = i1 - 2;;){
                            if (t0 === undefined) {
                                // before start
                                this._cachedIndex = 0;
                                return this.beforeStart_(0, t, t1);
                            }
                            if (i1 === giveUpAt) break; // this loop
                            t1 = t0;
                            t0 = pp[--i1 - 1];
                            if (t >= t0) break seek;
                        }
                        // prepare binary search on the left side of the index
                        right = i1;
                        i1 = 0;
                        break linear_scan;
                    }
                    break validate_interval;
                } // linear scan
                // binary search
                while(i1 < right){
                    var mid = i1 + right >>> 1;
                    if (t < pp[mid]) right = mid;
                    else i1 = mid + 1;
                }
                t1 = pp[i1];
                t0 = pp[i1 - 1];
                // check boundary cases, again
                if (t0 === undefined) {
                    this._cachedIndex = 0;
                    return this.beforeStart_(0, t, t1);
                }
                if (t1 === undefined) {
                    i1 = pp.length;
                    this._cachedIndex = i1;
                    return this.afterEnd_(i1 - 1, t0, t);
                }
            } // seek
            this._cachedIndex = i1;
            this.intervalChanged_(i1, t0, t1);
        } // validate_interval
        return this.interpolate_(i1, t0, t, t1);
    },
    settings: null,
    // Note: The indirection allows central control of many interpolants.
    // --- Protected interface
    DefaultSettings_: {},
    getSettings_: function() {
        return this.settings || this.DefaultSettings_;
    },
    copySampleValue_: function(index) {
        // copies a sample value to the result buffer
        var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = index * stride;
        for(var i = 0; i !== stride; ++i)result[i] = values[offset + i];
        return result;
    },
    // Template methods for derived classes:
    interpolate_: function() {
        throw new Error("call to abstract method");
    // implementations shall return this.resultBuffer
    },
    intervalChanged_: function() {
    // empty
    }
});
//!\ DECLARE ALIAS AFTER assign prototype !
Object.assign(Interpolant.prototype, {
    //( 0, t, t0 ), returns this.resultBuffer
    beforeStart_: Interpolant.prototype.copySampleValue_,
    //( N-1, tN-1, t ), returns this.resultBuffer
    afterEnd_: Interpolant.prototype.copySampleValue_
});
/**
 * Fast and simple cubic spline interpolant.
 *
 * It was derived from a Hermitian construction setting the first derivative
 * at each sample position to the linear slope between neighboring positions
 * over their parameter interval.
 *
 * @author tschw
 */ function CubicInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
    this._weightPrev = -0;
    this._offsetPrev = -0;
    this._weightNext = -0;
    this._offsetNext = -0;
}
CubicInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
    constructor: CubicInterpolant,
    DefaultSettings_: {
        endingStart: ZeroCurvatureEnding,
        endingEnd: ZeroCurvatureEnding
    },
    intervalChanged_: function(i1, t0, t1) {
        var pp = this.parameterPositions, iPrev = i1 - 2, iNext = i1 + 1, tPrev = pp[iPrev], tNext = pp[iNext];
        if (tPrev === undefined) switch(this.getSettings_().endingStart){
            case ZeroSlopeEnding:
                // f'(t0) = 0
                iPrev = i1;
                tPrev = 2 * t0 - t1;
                break;
            case WrapAroundEnding:
                // use the other end of the curve
                iPrev = pp.length - 2;
                tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
                break;
            default:
                // f''(t0) = 0 a.k.a. Natural Spline
                iPrev = i1;
                tPrev = t1;
        }
        if (tNext === undefined) switch(this.getSettings_().endingEnd){
            case ZeroSlopeEnding:
                // f'(tN) = 0
                iNext = i1;
                tNext = 2 * t1 - t0;
                break;
            case WrapAroundEnding:
                // use the other end of the curve
                iNext = 1;
                tNext = t1 + pp[1] - pp[0];
                break;
            default:
                // f''(tN) = 0, a.k.a. Natural Spline
                iNext = i1 - 1;
                tNext = t0;
        }
        var halfDt = (t1 - t0) * 0.5, stride = this.valueSize;
        this._weightPrev = halfDt / (t0 - tPrev);
        this._weightNext = halfDt / (tNext - t1);
        this._offsetPrev = iPrev * stride;
        this._offsetNext = iNext * stride;
    },
    interpolate_: function(i1, t0, t, t1) {
        var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i1 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p = (t - t0) / (t1 - t0), pp = p * p, ppp = pp * p;
        // evaluate polynomials
        var sP = -wP * ppp + 2 * wP * pp - wP * p;
        var s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
        var s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
        var sN = wN * ppp - wN * pp;
        // combine data linearly
        for(var i = 0; i !== stride; ++i)result[i] = sP * values[oP + i] + s0 * values[o0 + i] + s1 * values[o1 + i] + sN * values[oN + i];
        return result;
    }
});
/**
 * @author tschw
 */ function LinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
}
LinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
    constructor: LinearInterpolant,
    interpolate_: function(i1, t0, t, t1) {
        var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i1 * stride, offset0 = offset1 - stride, weight1 = (t - t0) / (t1 - t0), weight0 = 1 - weight1;
        for(var i = 0; i !== stride; ++i)result[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1;
        return result;
    }
});
/**
 *
 * Interpolant that evaluates to the sample value at the position preceeding
 * the parameter.
 *
 * @author tschw
 */ function DiscreteInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
}
DiscreteInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
    constructor: DiscreteInterpolant,
    interpolate_: function(i1 /*, t0, t, t1 */ ) {
        return this.copySampleValue_(i1 - 1);
    }
});
/**
 *
 * A timed sequence of keyframes for a specific property.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */ function KeyframeTrack(name, times, values, interpolation) {
    if (name === undefined) throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (times === undefined || times.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + name);
    this.name = name;
    this.times = AnimationUtils.convertArray(times, this.TimeBufferType);
    this.values = AnimationUtils.convertArray(values, this.ValueBufferType);
    this.setInterpolation(interpolation || this.DefaultInterpolation);
}
// Static methods
Object.assign(KeyframeTrack, {
    // Serialization (in static context, because of constructor invocation
    // and automatic invocation of .toJSON):
    toJSON: function(track) {
        var trackType = track.constructor;
        var json;
        // derived classes can define a static toJSON method
        if (trackType.toJSON !== undefined) json = trackType.toJSON(track);
        else {
            // by default, we assume the data can be serialized as-is
            json = {
                "name": track.name,
                "times": AnimationUtils.convertArray(track.times, Array),
                "values": AnimationUtils.convertArray(track.values, Array)
            };
            var interpolation = track.getInterpolation();
            if (interpolation !== track.DefaultInterpolation) json.interpolation = interpolation;
        }
        json.type = track.ValueTypeName; // mandatory
        return json;
    }
});
Object.assign(KeyframeTrack.prototype, {
    constructor: KeyframeTrack,
    TimeBufferType: Float32Array,
    ValueBufferType: Float32Array,
    DefaultInterpolation: InterpolateLinear,
    InterpolantFactoryMethodDiscrete: function(result) {
        return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
    },
    InterpolantFactoryMethodLinear: function(result) {
        return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
    },
    InterpolantFactoryMethodSmooth: function(result) {
        return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
    },
    setInterpolation: function(interpolation) {
        var factoryMethod;
        switch(interpolation){
            case InterpolateDiscrete:
                factoryMethod = this.InterpolantFactoryMethodDiscrete;
                break;
            case InterpolateLinear:
                factoryMethod = this.InterpolantFactoryMethodLinear;
                break;
            case InterpolateSmooth:
                factoryMethod = this.InterpolantFactoryMethodSmooth;
                break;
        }
        if (factoryMethod === undefined) {
            var message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
            if (this.createInterpolant === undefined) {
                // fall back to default, unless the default itself is messed up
                if (interpolation !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation);
                else throw new Error(message); // fatal, in this case
            }
            console.warn("THREE.KeyframeTrack:", message);
            return this;
        }
        this.createInterpolant = factoryMethod;
        return this;
    },
    getInterpolation: function() {
        switch(this.createInterpolant){
            case this.InterpolantFactoryMethodDiscrete:
                return InterpolateDiscrete;
            case this.InterpolantFactoryMethodLinear:
                return InterpolateLinear;
            case this.InterpolantFactoryMethodSmooth:
                return InterpolateSmooth;
        }
    },
    getValueSize: function() {
        return this.values.length / this.times.length;
    },
    // move all keyframes either forwards or backwards in time
    shift: function(timeOffset) {
        if (timeOffset !== 0.0) {
            var times = this.times;
            for(var i = 0, n = times.length; i !== n; ++i)times[i] += timeOffset;
        }
        return this;
    },
    // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
    scale: function(timeScale) {
        if (timeScale !== 1.0) {
            var times = this.times;
            for(var i = 0, n = times.length; i !== n; ++i)times[i] *= timeScale;
        }
        return this;
    },
    // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
    // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
    trim: function(startTime, endTime) {
        var times = this.times, nKeys = times.length, from = 0, to = nKeys - 1;
        while(from !== nKeys && times[from] < startTime)++from;
        while(to !== -1 && times[to] > endTime)--to;
        ++to; // inclusive -> exclusive bound
        if (from !== 0 || to !== nKeys) {
            // empty tracks are forbidden, so keep at least one keyframe
            if (from >= to) to = Math.max(to, 1), from = to - 1;
            var stride = this.getValueSize();
            this.times = AnimationUtils.arraySlice(times, from, to);
            this.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride);
        }
        return this;
    },
    // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
    validate: function() {
        var valid = true;
        var valueSize = this.getValueSize();
        if (valueSize - Math.floor(valueSize) !== 0) {
            console.error("THREE.KeyframeTrack: Invalid value size in track.", this);
            valid = false;
        }
        var times = this.times, values = this.values, nKeys = times.length;
        if (nKeys === 0) {
            console.error("THREE.KeyframeTrack: Track is empty.", this);
            valid = false;
        }
        var prevTime = null;
        for(var i = 0; i !== nKeys; i++){
            var currTime = times[i];
            if (typeof currTime === "number" && isNaN(currTime)) {
                console.error("THREE.KeyframeTrack: Time is not a valid number.", this, i, currTime);
                valid = false;
                break;
            }
            if (prevTime !== null && prevTime > currTime) {
                console.error("THREE.KeyframeTrack: Out of order keys.", this, i, currTime, prevTime);
                valid = false;
                break;
            }
            prevTime = currTime;
        }
        if (values !== undefined) {
            if (AnimationUtils.isTypedArray(values)) for(var i = 0, n = values.length; i !== n; ++i){
                var value = values[i];
                if (isNaN(value)) {
                    console.error("THREE.KeyframeTrack: Value is not a valid number.", this, i, value);
                    valid = false;
                    break;
                }
            }
        }
        return valid;
    },
    // removes equivalent sequential keys as common in morph target sequences
    // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
    optimize: function() {
        var times = this.times, values = this.values, stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === InterpolateSmooth, writeIndex = 1, lastIndex = times.length - 1;
        for(var i = 1; i < lastIndex; ++i){
            var keep = false;
            var time = times[i];
            var timeNext = times[i + 1];
            // remove adjacent keyframes scheduled at the same time
            if (time !== timeNext && (i !== 1 || time !== time[0])) {
                if (!smoothInterpolation) {
                    // remove unnecessary keyframes same as their neighbors
                    var offset = i * stride, offsetP = offset - stride, offsetN = offset + stride;
                    for(var j = 0; j !== stride; ++j){
                        var value = values[offset + j];
                        if (value !== values[offsetP + j] || value !== values[offsetN + j]) {
                            keep = true;
                            break;
                        }
                    }
                } else keep = true;
            }
            // in-place compaction
            if (keep) {
                if (i !== writeIndex) {
                    times[writeIndex] = times[i];
                    var readOffset = i * stride, writeOffset = writeIndex * stride;
                    for(var j = 0; j !== stride; ++j)values[writeOffset + j] = values[readOffset + j];
                }
                ++writeIndex;
            }
        }
        // flush last keyframe (compaction looks ahead)
        if (lastIndex > 0) {
            times[writeIndex] = times[lastIndex];
            for(var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j)values[writeOffset + j] = values[readOffset + j];
            ++writeIndex;
        }
        if (writeIndex !== times.length) {
            this.times = AnimationUtils.arraySlice(times, 0, writeIndex);
            this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);
        }
        return this;
    }
});
/**
 *
 * A Track of Boolean keyframe values.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */ function BooleanKeyframeTrack(name, times, values) {
    KeyframeTrack.call(this, name, times, values);
}
BooleanKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
    constructor: BooleanKeyframeTrack,
    ValueTypeName: "bool",
    ValueBufferType: Array,
    DefaultInterpolation: InterpolateDiscrete,
    InterpolantFactoryMethodLinear: undefined,
    InterpolantFactoryMethodSmooth: undefined
});
/**
 *
 * A Track of keyframe values that represent color.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */ function ColorKeyframeTrack(name, times, values, interpolation) {
    KeyframeTrack.call(this, name, times, values, interpolation);
}
ColorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
    constructor: ColorKeyframeTrack,
    ValueTypeName: "color"
});
/**
 *
 * A Track of numeric keyframe values.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */ function NumberKeyframeTrack(name, times, values, interpolation) {
    KeyframeTrack.call(this, name, times, values, interpolation);
}
NumberKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
    constructor: NumberKeyframeTrack,
    ValueTypeName: "number"
});
/**
 * Spherical linear unit quaternion interpolant.
 *
 * @author tschw
 */ function QuaternionLinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
}
QuaternionLinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
    constructor: QuaternionLinearInterpolant,
    interpolate_: function(i1, t0, t, t1) {
        var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = i1 * stride, alpha = (t - t0) / (t1 - t0);
        for(var end = offset + stride; offset !== end; offset += 4)Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
        return result;
    }
});
/**
 *
 * A Track of quaternion keyframe values.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */ function QuaternionKeyframeTrack(name, times, values, interpolation) {
    KeyframeTrack.call(this, name, times, values, interpolation);
}
QuaternionKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
    constructor: QuaternionKeyframeTrack,
    ValueTypeName: "quaternion",
    // ValueBufferType is inherited
    DefaultInterpolation: InterpolateLinear,
    InterpolantFactoryMethodLinear: function(result) {
        return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
    },
    InterpolantFactoryMethodSmooth: undefined // not yet implemented
});
/**
 *
 * A Track that interpolates Strings
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */ function StringKeyframeTrack(name, times, values, interpolation) {
    KeyframeTrack.call(this, name, times, values, interpolation);
}
StringKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
    constructor: StringKeyframeTrack,
    ValueTypeName: "string",
    ValueBufferType: Array,
    DefaultInterpolation: InterpolateDiscrete,
    InterpolantFactoryMethodLinear: undefined,
    InterpolantFactoryMethodSmooth: undefined
});
/**
 *
 * A Track of vectored keyframe values.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */ function VectorKeyframeTrack(name, times, values, interpolation) {
    KeyframeTrack.call(this, name, times, values, interpolation);
}
VectorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
    constructor: VectorKeyframeTrack,
    ValueTypeName: "vector"
});
/**
 *
 * Reusable set of Tracks that represent an animation.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */ function AnimationClip(name, duration, tracks) {
    this.name = name;
    this.tracks = tracks;
    this.duration = duration !== undefined ? duration : -1;
    this.uuid = _Math.generateUUID();
    // this means it should figure out its duration by scanning the tracks
    if (this.duration < 0) this.resetDuration();
}
function getTrackTypeForValueTypeName(typeName) {
    switch(typeName.toLowerCase()){
        case "scalar":
        case "double":
        case "float":
        case "number":
        case "integer":
            return NumberKeyframeTrack;
        case "vector":
        case "vector2":
        case "vector3":
        case "vector4":
            return VectorKeyframeTrack;
        case "color":
            return ColorKeyframeTrack;
        case "quaternion":
            return QuaternionKeyframeTrack;
        case "bool":
        case "boolean":
            return BooleanKeyframeTrack;
        case "string":
            return StringKeyframeTrack;
    }
    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + typeName);
}
function parseKeyframeTrack(json) {
    if (json.type === undefined) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
    var trackType = getTrackTypeForValueTypeName(json.type);
    if (json.times === undefined) {
        var times = [], values = [];
        AnimationUtils.flattenJSON(json.keys, times, values, "value");
        json.times = times;
        json.values = values;
    }
    // derived classes can define a static parse method
    if (trackType.parse !== undefined) return trackType.parse(json);
    else // by default, we assume a constructor compatible with the base
    return new trackType(json.name, json.times, json.values, json.interpolation);
}
Object.assign(AnimationClip, {
    parse: function(json) {
        var tracks = [], jsonTracks = json.tracks, frameTime = 1.0 / (json.fps || 1.0);
        for(var i = 0, n = jsonTracks.length; i !== n; ++i)tracks.push(parseKeyframeTrack(jsonTracks[i]).scale(frameTime));
        return new AnimationClip(json.name, json.duration, tracks);
    },
    toJSON: function(clip) {
        var tracks = [], clipTracks = clip.tracks;
        var json = {
            "name": clip.name,
            "duration": clip.duration,
            "tracks": tracks,
            "uuid": clip.uuid
        };
        for(var i = 0, n = clipTracks.length; i !== n; ++i)tracks.push(KeyframeTrack.toJSON(clipTracks[i]));
        return json;
    },
    CreateFromMorphTargetSequence: function(name, morphTargetSequence, fps, noLoop) {
        var numMorphTargets = morphTargetSequence.length;
        var tracks = [];
        for(var i = 0; i < numMorphTargets; i++){
            var times = [];
            var values = [];
            times.push((i + numMorphTargets - 1) % numMorphTargets, i, (i + 1) % numMorphTargets);
            values.push(0, 1, 0);
            var order = AnimationUtils.getKeyframeOrder(times);
            times = AnimationUtils.sortedArray(times, 1, order);
            values = AnimationUtils.sortedArray(values, 1, order);
            // if there is a key at the first frame, duplicate it as the
            // last frame as well for perfect loop.
            if (!noLoop && times[0] === 0) {
                times.push(numMorphTargets);
                values.push(values[0]);
            }
            tracks.push(new NumberKeyframeTrack(".morphTargetInfluences[" + morphTargetSequence[i].name + "]", times, values).scale(1.0 / fps));
        }
        return new AnimationClip(name, -1, tracks);
    },
    findByName: function(objectOrClipArray, name) {
        var clipArray = objectOrClipArray;
        if (!Array.isArray(objectOrClipArray)) {
            var o = objectOrClipArray;
            clipArray = o.geometry && o.geometry.animations || o.animations;
        }
        for(var i = 0; i < clipArray.length; i++){
            if (clipArray[i].name === name) return clipArray[i];
        }
        return null;
    },
    CreateClipsFromMorphTargetSequences: function(morphTargets, fps, noLoop) {
        var animationToMorphTargets = {};
        // tested with https://regex101.com/ on trick sequences
        // such flamingo_flyA_003, flamingo_run1_003, crdeath0059
        var pattern = /^([\w-]*?)([\d]+)$/;
        // sort morph target names into animation groups based
        // patterns like Walk_001, Walk_002, Run_001, Run_002
        for(var i = 0, il = morphTargets.length; i < il; i++){
            var morphTarget = morphTargets[i];
            var parts = morphTarget.name.match(pattern);
            if (parts && parts.length > 1) {
                var name = parts[1];
                var animationMorphTargets = animationToMorphTargets[name];
                if (!animationMorphTargets) animationToMorphTargets[name] = animationMorphTargets = [];
                animationMorphTargets.push(morphTarget);
            }
        }
        var clips = [];
        for(var name in animationToMorphTargets)clips.push(AnimationClip.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
        return clips;
    },
    // parse the animation.hierarchy format
    parseAnimation: function(animation, bones) {
        if (!animation) {
            console.error("THREE.AnimationClip: No animation in JSONLoader data.");
            return null;
        }
        var addNonemptyTrack = function(trackType, trackName, animationKeys, propertyName, destTracks) {
            // only return track if there are actually keys.
            if (animationKeys.length !== 0) {
                var times = [];
                var values = [];
                AnimationUtils.flattenJSON(animationKeys, times, values, propertyName);
                // empty keys are filtered out, so check again
                if (times.length !== 0) destTracks.push(new trackType(trackName, times, values));
            }
        };
        var tracks = [];
        var clipName = animation.name || "default";
        // automatic length determination in AnimationClip.
        var duration = animation.length || -1;
        var fps = animation.fps || 30;
        var hierarchyTracks = animation.hierarchy || [];
        for(var h = 0; h < hierarchyTracks.length; h++){
            var animationKeys = hierarchyTracks[h].keys;
            // skip empty tracks
            if (!animationKeys || animationKeys.length === 0) continue;
            // process morph targets
            if (animationKeys[0].morphTargets) {
                // figure out all morph targets used in this track
                var morphTargetNames = {};
                for(var k = 0; k < animationKeys.length; k++){
                    if (animationKeys[k].morphTargets) for(var m = 0; m < animationKeys[k].morphTargets.length; m++)morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
                }
                // create a track for each morph target with all zero
                // morphTargetInfluences except for the keys in which
                // the morphTarget is named.
                for(var morphTargetName in morphTargetNames){
                    var times = [];
                    var values = [];
                    for(var m = 0; m !== animationKeys[k].morphTargets.length; ++m){
                        var animationKey = animationKeys[k];
                        times.push(animationKey.time);
                        values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
                    }
                    tracks.push(new NumberKeyframeTrack(".morphTargetInfluence[" + morphTargetName + "]", times, values));
                }
                duration = morphTargetNames.length * (fps || 1.0);
            } else {
                // ...assume skeletal animation
                var boneName = ".bones[" + bones[h].name + "]";
                addNonemptyTrack(VectorKeyframeTrack, boneName + ".position", animationKeys, "pos", tracks);
                addNonemptyTrack(QuaternionKeyframeTrack, boneName + ".quaternion", animationKeys, "rot", tracks);
                addNonemptyTrack(VectorKeyframeTrack, boneName + ".scale", animationKeys, "scl", tracks);
            }
        }
        if (tracks.length === 0) return null;
        var clip = new AnimationClip(clipName, duration, tracks);
        return clip;
    }
});
Object.assign(AnimationClip.prototype, {
    resetDuration: function() {
        var tracks = this.tracks, duration = 0;
        for(var i = 0, n = tracks.length; i !== n; ++i){
            var track = this.tracks[i];
            duration = Math.max(duration, track.times[track.times.length - 1]);
        }
        this.duration = duration;
        return this;
    },
    trim: function() {
        for(var i = 0; i < this.tracks.length; i++)this.tracks[i].trim(0, this.duration);
        return this;
    },
    validate: function() {
        var valid = true;
        for(var i = 0; i < this.tracks.length; i++)valid = valid && this.tracks[i].validate();
        return valid;
    },
    optimize: function() {
        for(var i = 0; i < this.tracks.length; i++)this.tracks[i].optimize();
        return this;
    }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */ var Cache = {
    enabled: false,
    files: {},
    add: function(key, file) {
        if (this.enabled === false) return;
        // console.log( 'THREE.Cache', 'Adding key:', key );
        this.files[key] = file;
    },
    get: function(key) {
        if (this.enabled === false) return;
        // console.log( 'THREE.Cache', 'Checking key:', key );
        return this.files[key];
    },
    remove: function(key) {
        delete this.files[key];
    },
    clear: function() {
        this.files = {};
    }
};
/**
 * @author mrdoob / http://mrdoob.com/
 */ function LoadingManager(onLoad, onProgress, onError) {
    var scope = this;
    var isLoading = false;
    var itemsLoaded = 0;
    var itemsTotal = 0;
    var urlModifier = undefined;
    // Refer to #5689 for the reason why we don't set .onStart
    // in the constructor
    this.onStart = undefined;
    this.onLoad = onLoad;
    this.onProgress = onProgress;
    this.onError = onError;
    this.itemStart = function(url) {
        itemsTotal++;
        if (isLoading === false) {
            if (scope.onStart !== undefined) scope.onStart(url, itemsLoaded, itemsTotal);
        }
        isLoading = true;
    };
    this.itemEnd = function(url) {
        itemsLoaded++;
        if (scope.onProgress !== undefined) scope.onProgress(url, itemsLoaded, itemsTotal);
        if (itemsLoaded === itemsTotal) {
            isLoading = false;
            if (scope.onLoad !== undefined) scope.onLoad();
        }
    };
    this.itemError = function(url) {
        if (scope.onError !== undefined) scope.onError(url);
    };
    this.resolveURL = function(url) {
        if (urlModifier) return urlModifier(url);
        return url;
    };
    this.setURLModifier = function(transform) {
        urlModifier = transform;
        return this;
    };
}
var DefaultLoadingManager = new LoadingManager();
/**
 * @author mrdoob / http://mrdoob.com/
 */ var loading = {};
function FileLoader(manager) {
    this.manager = manager !== undefined ? manager : DefaultLoadingManager;
}
Object.assign(FileLoader.prototype, {
    load: function(url, onLoad, onProgress, onError) {
        if (url === undefined) url = "";
        if (this.path !== undefined) url = this.path + url;
        url = this.manager.resolveURL(url);
        var scope = this;
        var cached = Cache.get(url);
        if (cached !== undefined) {
            scope.manager.itemStart(url);
            setTimeout(function() {
                if (onLoad) onLoad(cached);
                scope.manager.itemEnd(url);
            }, 0);
            return cached;
        }
        // Check if request is duplicate
        if (loading[url] !== undefined) {
            loading[url].push({
                onLoad: onLoad,
                onProgress: onProgress,
                onError: onError
            });
            return;
        }
        // Check for data: URI
        var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
        var dataUriRegexResult = url.match(dataUriRegex);
        // Safari can not handle Data URIs through XMLHttpRequest so process manually
        if (dataUriRegexResult) {
            var mimeType = dataUriRegexResult[1];
            var isBase64 = !!dataUriRegexResult[2];
            var data = dataUriRegexResult[3];
            data = decodeURIComponent(data);
            if (isBase64) data = atob(data);
            try {
                var response;
                var responseType = (this.responseType || "").toLowerCase();
                switch(responseType){
                    case "arraybuffer":
                    case "blob":
                        var view = new Uint8Array(data.length);
                        for(var i = 0; i < data.length; i++)view[i] = data.charCodeAt(i);
                        if (responseType === "blob") response = new Blob([
                            view.buffer
                        ], {
                            type: mimeType
                        });
                        else response = view.buffer;
                        break;
                    case "document":
                        var parser = new DOMParser();
                        response = parser.parseFromString(data, mimeType);
                        break;
                    case "json":
                        response = JSON.parse(data);
                        break;
                    default:
                        response = data;
                        break;
                }
                // Wait for next browser tick like standard XMLHttpRequest event dispatching does
                setTimeout(function() {
                    if (onLoad) onLoad(response);
                    scope.manager.itemEnd(url);
                }, 0);
            } catch (error) {
                // Wait for next browser tick like standard XMLHttpRequest event dispatching does
                setTimeout(function() {
                    if (onError) onError(error);
                    scope.manager.itemError(url);
                    scope.manager.itemEnd(url);
                }, 0);
            }
        } else {
            // Initialise array for duplicate requests
            loading[url] = [];
            loading[url].push({
                onLoad: onLoad,
                onProgress: onProgress,
                onError: onError
            });
            var request = new XMLHttpRequest();
            request.open("GET", url, true);
            request.addEventListener("load", function(event) {
                var response = this.response;
                Cache.add(url, response);
                var callbacks = loading[url];
                delete loading[url];
                if (this.status === 200 || this.status === 0) {
                    // Some browsers return HTTP Status 0 when using non-http protocol
                    // e.g. 'file://' or 'data://'. Handle as success.
                    if (this.status === 0) console.warn("THREE.FileLoader: HTTP Status 0 received.");
                    for(var i = 0, il = callbacks.length; i < il; i++){
                        var callback = callbacks[i];
                        if (callback.onLoad) callback.onLoad(response);
                    }
                    scope.manager.itemEnd(url);
                } else {
                    for(var i = 0, il = callbacks.length; i < il; i++){
                        var callback = callbacks[i];
                        if (callback.onError) callback.onError(event);
                    }
                    scope.manager.itemError(url);
                    scope.manager.itemEnd(url);
                }
            }, false);
            request.addEventListener("progress", function(event) {
                var callbacks = loading[url];
                for(var i = 0, il = callbacks.length; i < il; i++){
                    var callback = callbacks[i];
                    if (callback.onProgress) callback.onProgress(event);
                }
            }, false);
            request.addEventListener("error", function(event) {
                var callbacks = loading[url];
                delete loading[url];
                for(var i = 0, il = callbacks.length; i < il; i++){
                    var callback = callbacks[i];
                    if (callback.onError) callback.onError(event);
                }
                scope.manager.itemError(url);
                scope.manager.itemEnd(url);
            }, false);
            request.addEventListener("abort", function(event) {
                var callbacks = loading[url];
                delete loading[url];
                for(var i = 0, il = callbacks.length; i < il; i++){
                    var callback = callbacks[i];
                    if (callback.onError) callback.onError(event);
                }
                scope.manager.itemError(url);
                scope.manager.itemEnd(url);
            }, false);
            if (this.responseType !== undefined) request.responseType = this.responseType;
            if (this.withCredentials !== undefined) request.withCredentials = this.withCredentials;
            if (request.overrideMimeType) request.overrideMimeType(this.mimeType !== undefined ? this.mimeType : "text/plain");
            for(var header in this.requestHeader)request.setRequestHeader(header, this.requestHeader[header]);
            request.send(null);
        }
        scope.manager.itemStart(url);
        return request;
    },
    setPath: function(value) {
        this.path = value;
        return this;
    },
    setResponseType: function(value) {
        this.responseType = value;
        return this;
    },
    setWithCredentials: function(value) {
        this.withCredentials = value;
        return this;
    },
    setMimeType: function(value) {
        this.mimeType = value;
        return this;
    },
    setRequestHeader: function(value) {
        this.requestHeader = value;
        return this;
    }
});
/**
 * @author bhouston / http://clara.io/
 */ function AnimationLoader(manager) {
    this.manager = manager !== undefined ? manager : DefaultLoadingManager;
}
Object.assign(AnimationLoader.prototype, {
    load: function(url, onLoad, onProgress, onError) {
        var scope = this;
        var loader = new FileLoader(scope.manager);
        loader.setPath(scope.path);
        loader.load(url, function(text) {
            onLoad(scope.parse(JSON.parse(text)));
        }, onProgress, onError);
    },
    parse: function(json, onLoad) {
        var animations = [];
        for(var i = 0; i < json.length; i++){
            var clip = AnimationClip.parse(json[i]);
            animations.push(clip);
        }
        onLoad(animations);
    },
    setPath: function(value) {
        this.path = value;
        return this;
    }
});
/**
 * @author mrdoob / http://mrdoob.com/
 *
 * Abstract Base class to block based textures loader (dds, pvr, ...)
 */ function CompressedTextureLoader(manager) {
    this.manager = manager !== undefined ? manager : DefaultLoadingManager;
    // override in sub classes
    this._parser = null;
}
Object.assign(CompressedTextureLoader.prototype, {
    load: function(url, onLoad, onProgress, onError) {
        var scope = this;
        var images = [];
        var texture = new CompressedTexture();
        texture.image = images;
        var loader = new FileLoader(this.manager);
        loader.setPath(this.path);
        loader.setResponseType("arraybuffer");
        function loadTexture(i) {
            loader.load(url[i], function(buffer) {
                var texDatas = scope._parser(buffer, true);
                images[i] = {
                    width: texDatas.width,
                    height: texDatas.height,
                    format: texDatas.format,
                    mipmaps: texDatas.mipmaps
                };
                loaded += 1;
                if (loaded === 6) {
                    if (texDatas.mipmapCount === 1) texture.minFilter = LinearFilter;
                    texture.format = texDatas.format;
                    texture.needsUpdate = true;
                    if (onLoad) onLoad(texture);
                }
            }, onProgress, onError);
        }
        if (Array.isArray(url)) {
            var loaded = 0;
            for(var i = 0, il = url.length; i < il; ++i)loadTexture(i);
        } else // compressed cubemap texture stored in a single DDS file
        loader.load(url, function(buffer) {
            var texDatas = scope._parser(buffer, true);
            if (texDatas.isCubemap) {
                var faces = texDatas.mipmaps.length / texDatas.mipmapCount;
                for(var f = 0; f < faces; f++){
                    images[f] = {
                        mipmaps: []
                    };
                    for(var i = 0; i < texDatas.mipmapCount; i++){
                        images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i]);
                        images[f].format = texDatas.format;
                        images[f].width = texDatas.width;
                        images[f].height = texDatas.height;
                    }
                }
            } else {
                texture.image.width = texDatas.width;
                texture.image.height = texDatas.height;
                texture.mipmaps = texDatas.mipmaps;
            }
            if (texDatas.mipmapCount === 1) texture.minFilter = LinearFilter;
            texture.format = texDatas.format;
            texture.needsUpdate = true;
            if (onLoad) onLoad(texture);
        }, onProgress, onError);
        return texture;
    },
    setPath: function(value) {
        this.path = value;
        return this;
    }
});
/**
 * @author Nikos M. / https://github.com/foo123/
 *
 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
 */ function DataTextureLoader(manager) {
    this.manager = manager !== undefined ? manager : DefaultLoadingManager;
    // override in sub classes
    this._parser = null;
}
Object.assign(DataTextureLoader.prototype, {
    load: function(url, onLoad, onProgress, onError) {
        var scope = this;
        var texture = new DataTexture();
        var loader = new FileLoader(this.manager);
        loader.setResponseType("arraybuffer");
        loader.setPath(this.path);
        loader.load(url, function(buffer) {
            var texData = scope._parser(buffer);
            if (!texData) return;
            if (texData.image !== undefined) texture.image = texData.image;
            else if (texData.data !== undefined) {
                texture.image.width = texData.width;
                texture.image.height = texData.height;
                texture.image.data = texData.data;
            }
            texture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;
            texture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;
            texture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;
            texture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearMipMapLinearFilter;
            texture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;
            if (texData.format !== undefined) texture.format = texData.format;
            if (texData.type !== undefined) texture.type = texData.type;
            if (texData.mipmaps !== undefined) texture.mipmaps = texData.mipmaps;
            if (texData.mipmapCount === 1) texture.minFilter = LinearFilter;
            texture.needsUpdate = true;
            if (onLoad) onLoad(texture, texData);
        }, onProgress, onError);
        return texture;
    },
    setPath: function(value) {
        this.path = value;
        return this;
    }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */ function ImageLoader(manager) {
    this.manager = manager !== undefined ? manager : DefaultLoadingManager;
}
Object.assign(ImageLoader.prototype, {
    crossOrigin: "anonymous",
    load: function(url, onLoad, onProgress, onError) {
        if (url === undefined) url = "";
        if (this.path !== undefined) url = this.path + url;
        url = this.manager.resolveURL(url);
        var scope = this;
        var cached = Cache.get(url);
        if (cached !== undefined) {
            scope.manager.itemStart(url);
            setTimeout(function() {
                if (onLoad) onLoad(cached);
                scope.manager.itemEnd(url);
            }, 0);
            return cached;
        }
        var image = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
        function onImageLoad() {
            image.removeEventListener("load", onImageLoad, false);
            image.removeEventListener("error", onImageError, false);
            Cache.add(url, this);
            if (onLoad) onLoad(this);
            scope.manager.itemEnd(url);
        }
        function onImageError(event) {
            image.removeEventListener("load", onImageLoad, false);
            image.removeEventListener("error", onImageError, false);
            if (onError) onError(event);
            scope.manager.itemError(url);
            scope.manager.itemEnd(url);
        }
        image.addEventListener("load", onImageLoad, false);
        image.addEventListener("error", onImageError, false);
        if (url.substr(0, 5) !== "data:") {
            if (this.crossOrigin !== undefined) image.crossOrigin = this.crossOrigin;
        }
        scope.manager.itemStart(url);
        image.src = url;
        return image;
    },
    setCrossOrigin: function(value) {
        this.crossOrigin = value;
        return this;
    },
    setPath: function(value) {
        this.path = value;
        return this;
    }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */ function CubeTextureLoader(manager) {
    this.manager = manager !== undefined ? manager : DefaultLoadingManager;
}
Object.assign(CubeTextureLoader.prototype, {
    crossOrigin: "anonymous",
    load: function(urls, onLoad, onProgress, onError) {
        var texture = new CubeTexture();
        var loader = new ImageLoader(this.manager);
        loader.setCrossOrigin(this.crossOrigin);
        loader.setPath(this.path);
        var loaded = 0;
        function loadTexture(i) {
            loader.load(urls[i], function(image) {
                texture.images[i] = image;
                loaded++;
                if (loaded === 6) {
                    texture.needsUpdate = true;
                    if (onLoad) onLoad(texture);
                }
            }, undefined, onError);
        }
        for(var i = 0; i < urls.length; ++i)loadTexture(i);
        return texture;
    },
    setCrossOrigin: function(value) {
        this.crossOrigin = value;
        return this;
    },
    setPath: function(value) {
        this.path = value;
        return this;
    }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */ function TextureLoader(manager) {
    this.manager = manager !== undefined ? manager : DefaultLoadingManager;
}
Object.assign(TextureLoader.prototype, {
    crossOrigin: "anonymous",
    load: function(url, onLoad, onProgress, onError) {
        var texture = new Texture();
        var loader = new ImageLoader(this.manager);
        loader.setCrossOrigin(this.crossOrigin);
        loader.setPath(this.path);
        loader.load(url, function(image) {
            texture.image = image;
            // JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
            var isJPEG = url.search(/\.jpe?g($|\?)/i) > 0 || url.search(/^data\:image\/jpeg/) === 0;
            texture.format = isJPEG ? RGBFormat : RGBAFormat;
            texture.needsUpdate = true;
            if (onLoad !== undefined) onLoad(texture);
        }, onProgress, onError);
        return texture;
    },
    setCrossOrigin: function(value) {
        this.crossOrigin = value;
        return this;
    },
    setPath: function(value) {
        this.path = value;
        return this;
    }
});
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Extensible curve object
 *
 * Some common of curve methods:
 * .getPoint( t, optionalTarget ), .getTangent( t )
 * .getPointAt( u, optionalTarget ), .getTangentAt( u )
 * .getPoints(), .getSpacedPoints()
 * .getLength()
 * .updateArcLengths()
 *
 * This following curves inherit from THREE.Curve:
 *
 * -- 2D curves --
 * THREE.ArcCurve
 * THREE.CubicBezierCurve
 * THREE.EllipseCurve
 * THREE.LineCurve
 * THREE.QuadraticBezierCurve
 * THREE.SplineCurve
 *
 * -- 3D curves --
 * THREE.CatmullRomCurve3
 * THREE.CubicBezierCurve3
 * THREE.LineCurve3
 * THREE.QuadraticBezierCurve3
 *
 * A series of curves can be represented as a THREE.CurvePath.
 *
 **/ /**************************************************************
 *	Abstract Curve base class
 **************************************************************/ function Curve() {
    this.type = "Curve";
    this.arcLengthDivisions = 200;
}
Object.assign(Curve.prototype, {
    // Virtual base class method to overwrite and implement in subclasses
    //	- t [0 .. 1]
    getPoint: function() {
        console.warn("THREE.Curve: .getPoint() not implemented.");
        return null;
    },
    // Get point at relative position in curve according to arc length
    // - u [0 .. 1]
    getPointAt: function(u, optionalTarget) {
        var t = this.getUtoTmapping(u);
        return this.getPoint(t, optionalTarget);
    },
    // Get sequence of points using getPoint( t )
    getPoints: function(divisions) {
        if (divisions === undefined) divisions = 5;
        var points = [];
        for(var d = 0; d <= divisions; d++)points.push(this.getPoint(d / divisions));
        return points;
    },
    // Get sequence of points using getPointAt( u )
    getSpacedPoints: function(divisions) {
        if (divisions === undefined) divisions = 5;
        var points = [];
        for(var d = 0; d <= divisions; d++)points.push(this.getPointAt(d / divisions));
        return points;
    },
    // Get total curve arc length
    getLength: function() {
        var lengths = this.getLengths();
        return lengths[lengths.length - 1];
    },
    // Get list of cumulative segment lengths
    getLengths: function(divisions) {
        if (divisions === undefined) divisions = this.arcLengthDivisions;
        if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) return this.cacheArcLengths;
        this.needsUpdate = false;
        var cache = [];
        var current, last = this.getPoint(0);
        var p, sum = 0;
        cache.push(0);
        for(p = 1; p <= divisions; p++){
            current = this.getPoint(p / divisions);
            sum += current.distanceTo(last);
            cache.push(sum);
            last = current;
        }
        this.cacheArcLengths = cache;
        return cache; // { sums: cache, sum: sum }; Sum is in the last element.
    },
    updateArcLengths: function() {
        this.needsUpdate = true;
        this.getLengths();
    },
    // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
    getUtoTmapping: function(u, distance) {
        var arcLengths = this.getLengths();
        var i = 0, il = arcLengths.length;
        var targetArcLength; // The targeted u distance value to get
        if (distance) targetArcLength = distance;
        else targetArcLength = u * arcLengths[il - 1];
        // binary search for the index with largest value smaller than target u distance
        var low = 0, high = il - 1, comparison;
        while(low <= high){
            i = Math.floor(low + (high - low) / 2); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats
            comparison = arcLengths[i] - targetArcLength;
            if (comparison < 0) low = i + 1;
            else if (comparison > 0) high = i - 1;
            else {
                high = i;
                break;
            // DONE
            }
        }
        i = high;
        if (arcLengths[i] === targetArcLength) return i / (il - 1);
        // we could get finer grain at lengths, or use simple interpolation between two points
        var lengthBefore = arcLengths[i];
        var lengthAfter = arcLengths[i + 1];
        var segmentLength = lengthAfter - lengthBefore;
        // determine where we are between the 'before' and 'after' points
        var segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
        // add that fractional amount to t
        var t = (i + segmentFraction) / (il - 1);
        return t;
    },
    // Returns a unit vector tangent at t
    // In case any sub curve does not implement its tangent derivation,
    // 2 points a small delta apart will be used to find its gradient
    // which seems to give a reasonable approximation
    getTangent: function(t) {
        var delta = 0.0001;
        var t1 = t - delta;
        var t2 = t + delta;
        // Capping in case of danger
        if (t1 < 0) t1 = 0;
        if (t2 > 1) t2 = 1;
        var pt1 = this.getPoint(t1);
        var pt2 = this.getPoint(t2);
        var vec = pt2.clone().sub(pt1);
        return vec.normalize();
    },
    getTangentAt: function(u) {
        var t = this.getUtoTmapping(u);
        return this.getTangent(t);
    },
    computeFrenetFrames: function(segments, closed) {
        // see http://www.cs.indiana.edu/pub/techreports/TR425.pdf
        var normal = new Vector3();
        var tangents = [];
        var normals = [];
        var binormals = [];
        var vec = new Vector3();
        var mat = new Matrix4();
        var i, u, theta;
        // compute the tangent vectors for each segment on the curve
        for(i = 0; i <= segments; i++){
            u = i / segments;
            tangents[i] = this.getTangentAt(u);
            tangents[i].normalize();
        }
        // select an initial normal vector perpendicular to the first tangent vector,
        // and in the direction of the minimum tangent xyz component
        normals[0] = new Vector3();
        binormals[0] = new Vector3();
        var min = Number.MAX_VALUE;
        var tx = Math.abs(tangents[0].x);
        var ty = Math.abs(tangents[0].y);
        var tz = Math.abs(tangents[0].z);
        if (tx <= min) {
            min = tx;
            normal.set(1, 0, 0);
        }
        if (ty <= min) {
            min = ty;
            normal.set(0, 1, 0);
        }
        if (tz <= min) normal.set(0, 0, 1);
        vec.crossVectors(tangents[0], normal).normalize();
        normals[0].crossVectors(tangents[0], vec);
        binormals[0].crossVectors(tangents[0], normals[0]);
        // compute the slowly-varying normal and binormal vectors for each segment on the curve
        for(i = 1; i <= segments; i++){
            normals[i] = normals[i - 1].clone();
            binormals[i] = binormals[i - 1].clone();
            vec.crossVectors(tangents[i - 1], tangents[i]);
            if (vec.length() > Number.EPSILON) {
                vec.normalize();
                theta = Math.acos(_Math.clamp(tangents[i - 1].dot(tangents[i]), -1, 1)); // clamp for floating pt errors
                normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));
            }
            binormals[i].crossVectors(tangents[i], normals[i]);
        }
        // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same
        if (closed === true) {
            theta = Math.acos(_Math.clamp(normals[0].dot(normals[segments]), -1, 1));
            theta /= segments;
            if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) theta = -theta;
            for(i = 1; i <= segments; i++){
                // twist a little...
                normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));
                binormals[i].crossVectors(tangents[i], normals[i]);
            }
        }
        return {
            tangents: tangents,
            normals: normals,
            binormals: binormals
        };
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(source) {
        this.arcLengthDivisions = source.arcLengthDivisions;
        return this;
    },
    toJSON: function() {
        var data = {
            metadata: {
                version: 4.5,
                type: "Curve",
                generator: "Curve.toJSON"
            }
        };
        data.arcLengthDivisions = this.arcLengthDivisions;
        data.type = this.type;
        return data;
    },
    fromJSON: function(json) {
        this.arcLengthDivisions = json.arcLengthDivisions;
        return this;
    }
});
function EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    Curve.call(this);
    this.type = "EllipseCurve";
    this.aX = aX || 0;
    this.aY = aY || 0;
    this.xRadius = xRadius || 1;
    this.yRadius = yRadius || 1;
    this.aStartAngle = aStartAngle || 0;
    this.aEndAngle = aEndAngle || 2 * Math.PI;
    this.aClockwise = aClockwise || false;
    this.aRotation = aRotation || 0;
}
EllipseCurve.prototype = Object.create(Curve.prototype);
EllipseCurve.prototype.constructor = EllipseCurve;
EllipseCurve.prototype.isEllipseCurve = true;
EllipseCurve.prototype.getPoint = function(t, optionalTarget) {
    var point = optionalTarget || new Vector2();
    var twoPi = Math.PI * 2;
    var deltaAngle = this.aEndAngle - this.aStartAngle;
    var samePoints = Math.abs(deltaAngle) < Number.EPSILON;
    // ensures that deltaAngle is 0 .. 2 PI
    while(deltaAngle < 0)deltaAngle += twoPi;
    while(deltaAngle > twoPi)deltaAngle -= twoPi;
    if (deltaAngle < Number.EPSILON) {
        if (samePoints) deltaAngle = 0;
        else deltaAngle = twoPi;
    }
    if (this.aClockwise === true && !samePoints) {
        if (deltaAngle === twoPi) deltaAngle = -twoPi;
        else deltaAngle = deltaAngle - twoPi;
    }
    var angle = this.aStartAngle + t * deltaAngle;
    var x = this.aX + this.xRadius * Math.cos(angle);
    var y = this.aY + this.yRadius * Math.sin(angle);
    if (this.aRotation !== 0) {
        var cos = Math.cos(this.aRotation);
        var sin = Math.sin(this.aRotation);
        var tx = x - this.aX;
        var ty = y - this.aY;
        // Rotate the point about the center of the ellipse.
        x = tx * cos - ty * sin + this.aX;
        y = tx * sin + ty * cos + this.aY;
    }
    return point.set(x, y);
};
EllipseCurve.prototype.copy = function(source) {
    Curve.prototype.copy.call(this, source);
    this.aX = source.aX;
    this.aY = source.aY;
    this.xRadius = source.xRadius;
    this.yRadius = source.yRadius;
    this.aStartAngle = source.aStartAngle;
    this.aEndAngle = source.aEndAngle;
    this.aClockwise = source.aClockwise;
    this.aRotation = source.aRotation;
    return this;
};
EllipseCurve.prototype.toJSON = function() {
    var data = Curve.prototype.toJSON.call(this);
    data.aX = this.aX;
    data.aY = this.aY;
    data.xRadius = this.xRadius;
    data.yRadius = this.yRadius;
    data.aStartAngle = this.aStartAngle;
    data.aEndAngle = this.aEndAngle;
    data.aClockwise = this.aClockwise;
    data.aRotation = this.aRotation;
    return data;
};
EllipseCurve.prototype.fromJSON = function(json) {
    Curve.prototype.fromJSON.call(this, json);
    this.aX = json.aX;
    this.aY = json.aY;
    this.xRadius = json.xRadius;
    this.yRadius = json.yRadius;
    this.aStartAngle = json.aStartAngle;
    this.aEndAngle = json.aEndAngle;
    this.aClockwise = json.aClockwise;
    this.aRotation = json.aRotation;
    return this;
};
function ArcCurve(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    EllipseCurve.call(this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    this.type = "ArcCurve";
}
ArcCurve.prototype = Object.create(EllipseCurve.prototype);
ArcCurve.prototype.constructor = ArcCurve;
ArcCurve.prototype.isArcCurve = true;
/**
 * @author zz85 https://github.com/zz85
 *
 * Centripetal CatmullRom Curve - which is useful for avoiding
 * cusps and self-intersections in non-uniform catmull rom curves.
 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
 *
 * curve.type accepts centripetal(default), chordal and catmullrom
 * curve.tension is used for catmullrom which defaults to 0.5
 */ /*
Based on an optimized c++ solution in
 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
 - http://ideone.com/NoEbVM

This CubicPoly class could be used for reusing some variables and calculations,
but for three.js curve use, it could be possible inlined and flatten into a single function call
which can be placed in CurveUtils.
*/ function CubicPoly() {
    var c0 = 0, c1 = 0, c2 = 0, c3 = 0;
    /*
	 * Compute coefficients for a cubic polynomial
	 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
	 * such that
	 *   p(0) = x0, p(1) = x1
	 *  and
	 *   p'(0) = t0, p'(1) = t1.
	 */ function init(x0, x1, t0, t1) {
        c0 = x0;
        c1 = t0;
        c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
        c3 = 2 * x0 - 2 * x1 + t0 + t1;
    }
    return {
        initCatmullRom: function(x0, x1, x2, x3, tension) {
            init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
        },
        initNonuniformCatmullRom: function(x0, x1, x2, x3, dt0, dt1, dt2) {
            // compute tangents when parameterized in [t1,t2]
            var t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
            var t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
            // rescale tangents for parametrization in [0,1]
            t1 *= dt1;
            t2 *= dt1;
            init(x1, x2, t1, t2);
        },
        calc: function(t) {
            var t2 = t * t;
            var t3 = t2 * t;
            return c0 + c1 * t + c2 * t2 + c3 * t3;
        }
    };
}
//
var tmp = new Vector3();
var px = new CubicPoly(), py = new CubicPoly(), pz = new CubicPoly();
function CatmullRomCurve3(points, closed, curveType, tension) {
    Curve.call(this);
    this.type = "CatmullRomCurve3";
    this.points = points || [];
    this.closed = closed || false;
    this.curveType = curveType || "centripetal";
    this.tension = tension || 0.5;
}
CatmullRomCurve3.prototype = Object.create(Curve.prototype);
CatmullRomCurve3.prototype.constructor = CatmullRomCurve3;
CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;
CatmullRomCurve3.prototype.getPoint = function(t, optionalTarget) {
    var point = optionalTarget || new Vector3();
    var points = this.points;
    var l = points.length;
    var p = (l - (this.closed ? 0 : 1)) * t;
    var intPoint = Math.floor(p);
    var weight = p - intPoint;
    if (this.closed) intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;
    else if (weight === 0 && intPoint === l - 1) {
        intPoint = l - 2;
        weight = 1;
    }
    var p0, p1, p2, p3; // 4 points
    if (this.closed || intPoint > 0) p0 = points[(intPoint - 1) % l];
    else {
        // extrapolate first point
        tmp.subVectors(points[0], points[1]).add(points[0]);
        p0 = tmp;
    }
    p1 = points[intPoint % l];
    p2 = points[(intPoint + 1) % l];
    if (this.closed || intPoint + 2 < l) p3 = points[(intPoint + 2) % l];
    else {
        // extrapolate last point
        tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
        p3 = tmp;
    }
    if (this.curveType === "centripetal" || this.curveType === "chordal") {
        // init Centripetal / Chordal Catmull-Rom
        var pow = this.curveType === "chordal" ? 0.5 : 0.25;
        var dt0 = Math.pow(p0.distanceToSquared(p1), pow);
        var dt1 = Math.pow(p1.distanceToSquared(p2), pow);
        var dt2 = Math.pow(p2.distanceToSquared(p3), pow);
        // safety check for repeated points
        if (dt1 < 1e-4) dt1 = 1.0;
        if (dt0 < 1e-4) dt0 = dt1;
        if (dt2 < 1e-4) dt2 = dt1;
        px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
        py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
        pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
    } else if (this.curveType === "catmullrom") {
        px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);
        py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);
        pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);
    }
    point.set(px.calc(weight), py.calc(weight), pz.calc(weight));
    return point;
};
CatmullRomCurve3.prototype.copy = function(source) {
    Curve.prototype.copy.call(this, source);
    this.points = [];
    for(var i = 0, l = source.points.length; i < l; i++){
        var point = source.points[i];
        this.points.push(point.clone());
    }
    this.closed = source.closed;
    this.curveType = source.curveType;
    this.tension = source.tension;
    return this;
};
CatmullRomCurve3.prototype.toJSON = function() {
    var data = Curve.prototype.toJSON.call(this);
    data.points = [];
    for(var i = 0, l = this.points.length; i < l; i++){
        var point = this.points[i];
        data.points.push(point.toArray());
    }
    data.closed = this.closed;
    data.curveType = this.curveType;
    data.tension = this.tension;
    return data;
};
CatmullRomCurve3.prototype.fromJSON = function(json) {
    Curve.prototype.fromJSON.call(this, json);
    this.points = [];
    for(var i = 0, l = json.points.length; i < l; i++){
        var point = json.points[i];
        this.points.push(new Vector3().fromArray(point));
    }
    this.closed = json.closed;
    this.curveType = json.curveType;
    this.tension = json.tension;
    return this;
};
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 * Bezier Curves formulas obtained from
 * http://en.wikipedia.org/wiki/Bzier_curve
 */ function CatmullRom(t, p0, p1, p2, p3) {
    var v0 = (p2 - p0) * 0.5;
    var v1 = (p3 - p1) * 0.5;
    var t2 = t * t;
    var t3 = t * t2;
    return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
}
//
function QuadraticBezierP0(t, p) {
    var k = 1 - t;
    return k * k * p;
}
function QuadraticBezierP1(t, p) {
    return 2 * (1 - t) * t * p;
}
function QuadraticBezierP2(t, p) {
    return t * t * p;
}
function QuadraticBezier(t, p0, p1, p2) {
    return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) + QuadraticBezierP2(t, p2);
}
//
function CubicBezierP0(t, p) {
    var k = 1 - t;
    return k * k * k * p;
}
function CubicBezierP1(t, p) {
    var k = 1 - t;
    return 3 * k * k * t * p;
}
function CubicBezierP2(t, p) {
    return 3 * (1 - t) * t * t * p;
}
function CubicBezierP3(t, p) {
    return t * t * t * p;
}
function CubicBezier(t, p0, p1, p2, p3) {
    return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) + CubicBezierP3(t, p3);
}
function CubicBezierCurve(v0, v1, v2, v3) {
    Curve.call(this);
    this.type = "CubicBezierCurve";
    this.v0 = v0 || new Vector2();
    this.v1 = v1 || new Vector2();
    this.v2 = v2 || new Vector2();
    this.v3 = v3 || new Vector2();
}
CubicBezierCurve.prototype = Object.create(Curve.prototype);
CubicBezierCurve.prototype.constructor = CubicBezierCurve;
CubicBezierCurve.prototype.isCubicBezierCurve = true;
CubicBezierCurve.prototype.getPoint = function(t, optionalTarget) {
    var point = optionalTarget || new Vector2();
    var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
    point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y));
    return point;
};
CubicBezierCurve.prototype.copy = function(source) {
    Curve.prototype.copy.call(this, source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    this.v3.copy(source.v3);
    return this;
};
CubicBezierCurve.prototype.toJSON = function() {
    var data = Curve.prototype.toJSON.call(this);
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    data.v3 = this.v3.toArray();
    return data;
};
CubicBezierCurve.prototype.fromJSON = function(json) {
    Curve.prototype.fromJSON.call(this, json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    this.v3.fromArray(json.v3);
    return this;
};
function CubicBezierCurve3(v0, v1, v2, v3) {
    Curve.call(this);
    this.type = "CubicBezierCurve3";
    this.v0 = v0 || new Vector3();
    this.v1 = v1 || new Vector3();
    this.v2 = v2 || new Vector3();
    this.v3 = v3 || new Vector3();
}
CubicBezierCurve3.prototype = Object.create(Curve.prototype);
CubicBezierCurve3.prototype.constructor = CubicBezierCurve3;
CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;
CubicBezierCurve3.prototype.getPoint = function(t, optionalTarget) {
    var point = optionalTarget || new Vector3();
    var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
    point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y), CubicBezier(t, v0.z, v1.z, v2.z, v3.z));
    return point;
};
CubicBezierCurve3.prototype.copy = function(source) {
    Curve.prototype.copy.call(this, source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    this.v3.copy(source.v3);
    return this;
};
CubicBezierCurve3.prototype.toJSON = function() {
    var data = Curve.prototype.toJSON.call(this);
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    data.v3 = this.v3.toArray();
    return data;
};
CubicBezierCurve3.prototype.fromJSON = function(json) {
    Curve.prototype.fromJSON.call(this, json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    this.v3.fromArray(json.v3);
    return this;
};
function LineCurve(v1, v2) {
    Curve.call(this);
    this.type = "LineCurve";
    this.v1 = v1 || new Vector2();
    this.v2 = v2 || new Vector2();
}
LineCurve.prototype = Object.create(Curve.prototype);
LineCurve.prototype.constructor = LineCurve;
LineCurve.prototype.isLineCurve = true;
LineCurve.prototype.getPoint = function(t, optionalTarget) {
    var point = optionalTarget || new Vector2();
    if (t === 1) point.copy(this.v2);
    else {
        point.copy(this.v2).sub(this.v1);
        point.multiplyScalar(t).add(this.v1);
    }
    return point;
};
// Line curve is linear, so we can overwrite default getPointAt
LineCurve.prototype.getPointAt = function(u, optionalTarget) {
    return this.getPoint(u, optionalTarget);
};
LineCurve.prototype.getTangent = function() {
    var tangent = this.v2.clone().sub(this.v1);
    return tangent.normalize();
};
LineCurve.prototype.copy = function(source) {
    Curve.prototype.copy.call(this, source);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
};
LineCurve.prototype.toJSON = function() {
    var data = Curve.prototype.toJSON.call(this);
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
};
LineCurve.prototype.fromJSON = function(json) {
    Curve.prototype.fromJSON.call(this, json);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
};
function LineCurve3(v1, v2) {
    Curve.call(this);
    this.type = "LineCurve3";
    this.v1 = v1 || new Vector3();
    this.v2 = v2 || new Vector3();
}
LineCurve3.prototype = Object.create(Curve.prototype);
LineCurve3.prototype.constructor = LineCurve3;
LineCurve3.prototype.isLineCurve3 = true;
LineCurve3.prototype.getPoint = function(t, optionalTarget) {
    var point = optionalTarget || new Vector3();
    if (t === 1) point.copy(this.v2);
    else {
        point.copy(this.v2).sub(this.v1);
        point.multiplyScalar(t).add(this.v1);
    }
    return point;
};
// Line curve is linear, so we can overwrite default getPointAt
LineCurve3.prototype.getPointAt = function(u, optionalTarget) {
    return this.getPoint(u, optionalTarget);
};
LineCurve3.prototype.copy = function(source) {
    Curve.prototype.copy.call(this, source);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
};
LineCurve3.prototype.toJSON = function() {
    var data = Curve.prototype.toJSON.call(this);
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
};
LineCurve3.prototype.fromJSON = function(json) {
    Curve.prototype.fromJSON.call(this, json);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
};
function QuadraticBezierCurve(v0, v1, v2) {
    Curve.call(this);
    this.type = "QuadraticBezierCurve";
    this.v0 = v0 || new Vector2();
    this.v1 = v1 || new Vector2();
    this.v2 = v2 || new Vector2();
}
QuadraticBezierCurve.prototype = Object.create(Curve.prototype);
QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;
QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;
QuadraticBezierCurve.prototype.getPoint = function(t, optionalTarget) {
    var point = optionalTarget || new Vector2();
    var v0 = this.v0, v1 = this.v1, v2 = this.v2;
    point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y));
    return point;
};
QuadraticBezierCurve.prototype.copy = function(source) {
    Curve.prototype.copy.call(this, source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
};
QuadraticBezierCurve.prototype.toJSON = function() {
    var data = Curve.prototype.toJSON.call(this);
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
};
QuadraticBezierCurve.prototype.fromJSON = function(json) {
    Curve.prototype.fromJSON.call(this, json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
};
function QuadraticBezierCurve3(v0, v1, v2) {
    Curve.call(this);
    this.type = "QuadraticBezierCurve3";
    this.v0 = v0 || new Vector3();
    this.v1 = v1 || new Vector3();
    this.v2 = v2 || new Vector3();
}
QuadraticBezierCurve3.prototype = Object.create(Curve.prototype);
QuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;
QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;
QuadraticBezierCurve3.prototype.getPoint = function(t, optionalTarget) {
    var point = optionalTarget || new Vector3();
    var v0 = this.v0, v1 = this.v1, v2 = this.v2;
    point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y), QuadraticBezier(t, v0.z, v1.z, v2.z));
    return point;
};
QuadraticBezierCurve3.prototype.copy = function(source) {
    Curve.prototype.copy.call(this, source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
};
QuadraticBezierCurve3.prototype.toJSON = function() {
    var data = Curve.prototype.toJSON.call(this);
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
};
QuadraticBezierCurve3.prototype.fromJSON = function(json) {
    Curve.prototype.fromJSON.call(this, json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
};
function SplineCurve(points /* array of Vector2 */ ) {
    Curve.call(this);
    this.type = "SplineCurve";
    this.points = points || [];
}
SplineCurve.prototype = Object.create(Curve.prototype);
SplineCurve.prototype.constructor = SplineCurve;
SplineCurve.prototype.isSplineCurve = true;
SplineCurve.prototype.getPoint = function(t, optionalTarget) {
    var point = optionalTarget || new Vector2();
    var points = this.points;
    var p = (points.length - 1) * t;
    var intPoint = Math.floor(p);
    var weight = p - intPoint;
    var p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
    var p1 = points[intPoint];
    var p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
    var p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
    point.set(CatmullRom(weight, p0.x, p1.x, p2.x, p3.x), CatmullRom(weight, p0.y, p1.y, p2.y, p3.y));
    return point;
};
SplineCurve.prototype.copy = function(source) {
    Curve.prototype.copy.call(this, source);
    this.points = [];
    for(var i = 0, l = source.points.length; i < l; i++){
        var point = source.points[i];
        this.points.push(point.clone());
    }
    return this;
};
SplineCurve.prototype.toJSON = function() {
    var data = Curve.prototype.toJSON.call(this);
    data.points = [];
    for(var i = 0, l = this.points.length; i < l; i++){
        var point = this.points[i];
        data.points.push(point.toArray());
    }
    return data;
};
SplineCurve.prototype.fromJSON = function(json) {
    Curve.prototype.fromJSON.call(this, json);
    this.points = [];
    for(var i = 0, l = json.points.length; i < l; i++){
        var point = json.points[i];
        this.points.push(new Vector2().fromArray(point));
    }
    return this;
};
var Curves = /*#__PURE__*/ Object.freeze({
    ArcCurve: ArcCurve,
    CatmullRomCurve3: CatmullRomCurve3,
    CubicBezierCurve: CubicBezierCurve,
    CubicBezierCurve3: CubicBezierCurve3,
    EllipseCurve: EllipseCurve,
    LineCurve: LineCurve,
    LineCurve3: LineCurve3,
    QuadraticBezierCurve: QuadraticBezierCurve,
    QuadraticBezierCurve3: QuadraticBezierCurve3,
    SplineCurve: SplineCurve
});
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 **/ /**************************************************************
 *	Curved Path - a curve path is simply a array of connected
 *  curves, but retains the api of a curve
 **************************************************************/ function CurvePath() {
    Curve.call(this);
    this.type = "CurvePath";
    this.curves = [];
    this.autoClose = false; // Automatically closes the path
}
CurvePath.prototype = Object.assign(Object.create(Curve.prototype), {
    constructor: CurvePath,
    add: function(curve) {
        this.curves.push(curve);
    },
    closePath: function() {
        // Add a line curve if start and end of lines are not connected
        var startPoint = this.curves[0].getPoint(0);
        var endPoint = this.curves[this.curves.length - 1].getPoint(1);
        if (!startPoint.equals(endPoint)) this.curves.push(new LineCurve(endPoint, startPoint));
    },
    // To get accurate point with reference to
    // entire path distance at time t,
    // following has to be done:
    // 1. Length of each sub path have to be known
    // 2. Locate and identify type of curve
    // 3. Get t for the curve
    // 4. Return curve.getPointAt(t')
    getPoint: function(t) {
        var d = t * this.getLength();
        var curveLengths = this.getCurveLengths();
        var i = 0;
        // To think about boundaries points.
        while(i < curveLengths.length){
            if (curveLengths[i] >= d) {
                var diff = curveLengths[i] - d;
                var curve = this.curves[i];
                var segmentLength = curve.getLength();
                var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
                return curve.getPointAt(u);
            }
            i++;
        }
        return null;
    // loop where sum != 0, sum > d , sum+1 <d
    },
    // We cannot use the default THREE.Curve getPoint() with getLength() because in
    // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
    // getPoint() depends on getLength
    getLength: function() {
        var lens = this.getCurveLengths();
        return lens[lens.length - 1];
    },
    // cacheLengths must be recalculated.
    updateArcLengths: function() {
        this.needsUpdate = true;
        this.cacheLengths = null;
        this.getCurveLengths();
    },
    // Compute lengths and cache them
    // We cannot overwrite getLengths() because UtoT mapping uses it.
    getCurveLengths: function() {
        // We use cache values if curves and cache array are same length
        if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
        // Get length of sub-curve
        // Push sums into cached array
        var lengths = [], sums = 0;
        for(var i = 0, l = this.curves.length; i < l; i++){
            sums += this.curves[i].getLength();
            lengths.push(sums);
        }
        this.cacheLengths = lengths;
        return lengths;
    },
    getSpacedPoints: function(divisions) {
        if (divisions === undefined) divisions = 40;
        var points = [];
        for(var i = 0; i <= divisions; i++)points.push(this.getPoint(i / divisions));
        if (this.autoClose) points.push(points[0]);
        return points;
    },
    getPoints: function(divisions) {
        divisions = divisions || 12;
        var points = [], last;
        for(var i = 0, curves = this.curves; i < curves.length; i++){
            var curve = curves[i];
            var resolution = curve && curve.isEllipseCurve ? divisions * 2 : curve && (curve.isLineCurve || curve.isLineCurve3) ? 1 : curve && curve.isSplineCurve ? divisions * curve.points.length : divisions;
            var pts = curve.getPoints(resolution);
            for(var j = 0; j < pts.length; j++){
                var point = pts[j];
                if (last && last.equals(point)) continue; // ensures no consecutive points are duplicates
                points.push(point);
                last = point;
            }
        }
        if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) points.push(points[0]);
        return points;
    },
    copy: function(source) {
        Curve.prototype.copy.call(this, source);
        this.curves = [];
        for(var i = 0, l = source.curves.length; i < l; i++){
            var curve = source.curves[i];
            this.curves.push(curve.clone());
        }
        this.autoClose = source.autoClose;
        return this;
    },
    toJSON: function() {
        var data = Curve.prototype.toJSON.call(this);
        data.autoClose = this.autoClose;
        data.curves = [];
        for(var i = 0, l = this.curves.length; i < l; i++){
            var curve = this.curves[i];
            data.curves.push(curve.toJSON());
        }
        return data;
    },
    fromJSON: function(json) {
        Curve.prototype.fromJSON.call(this, json);
        this.autoClose = json.autoClose;
        this.curves = [];
        for(var i = 0, l = json.curves.length; i < l; i++){
            var curve = json.curves[i];
            this.curves.push(new Curves[curve.type]().fromJSON(curve));
        }
        return this;
    }
});
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Creates free form 2d path using series of points, lines or curves.
 **/ function Path(points) {
    CurvePath.call(this);
    this.type = "Path";
    this.currentPoint = new Vector2();
    if (points) this.setFromPoints(points);
}
Path.prototype = Object.assign(Object.create(CurvePath.prototype), {
    constructor: Path,
    setFromPoints: function(points) {
        this.moveTo(points[0].x, points[0].y);
        for(var i = 1, l = points.length; i < l; i++)this.lineTo(points[i].x, points[i].y);
    },
    moveTo: function(x, y) {
        this.currentPoint.set(x, y); // TODO consider referencing vectors instead of copying?
    },
    lineTo: function(x, y) {
        var curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));
        this.curves.push(curve);
        this.currentPoint.set(x, y);
    },
    quadraticCurveTo: function(aCPx, aCPy, aX, aY) {
        var curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));
        this.curves.push(curve);
        this.currentPoint.set(aX, aY);
    },
    bezierCurveTo: function(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
        var curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));
        this.curves.push(curve);
        this.currentPoint.set(aX, aY);
    },
    splineThru: function(pts /*Array of Vector*/ ) {
        var npts = [
            this.currentPoint.clone()
        ].concat(pts);
        var curve = new SplineCurve(npts);
        this.curves.push(curve);
        this.currentPoint.copy(pts[pts.length - 1]);
    },
    arc: function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
        var x0 = this.currentPoint.x;
        var y0 = this.currentPoint.y;
        this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
    },
    absarc: function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
        this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    },
    ellipse: function(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
        var x0 = this.currentPoint.x;
        var y0 = this.currentPoint.y;
        this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
    },
    absellipse: function(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
        var curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
        if (this.curves.length > 0) {
            // if a previous curve is present, attempt to join
            var firstPoint = curve.getPoint(0);
            if (!firstPoint.equals(this.currentPoint)) this.lineTo(firstPoint.x, firstPoint.y);
        }
        this.curves.push(curve);
        var lastPoint = curve.getPoint(1);
        this.currentPoint.copy(lastPoint);
    },
    copy: function(source) {
        CurvePath.prototype.copy.call(this, source);
        this.currentPoint.copy(source.currentPoint);
        return this;
    },
    toJSON: function() {
        var data = CurvePath.prototype.toJSON.call(this);
        data.currentPoint = this.currentPoint.toArray();
        return data;
    },
    fromJSON: function(json) {
        CurvePath.prototype.fromJSON.call(this, json);
        this.currentPoint.fromArray(json.currentPoint);
        return this;
    }
});
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Defines a 2d shape plane using paths.
 **/ // STEP 1 Create a path.
// STEP 2 Turn path into shape.
// STEP 3 ExtrudeGeometry takes in Shape/Shapes
// STEP 3a - Extract points from each shape, turn to vertices
// STEP 3b - Triangulate each shape, add faces.
function Shape(points) {
    Path.call(this, points);
    this.uuid = _Math.generateUUID();
    this.type = "Shape";
    this.holes = [];
}
Shape.prototype = Object.assign(Object.create(Path.prototype), {
    constructor: Shape,
    getPointsHoles: function(divisions) {
        var holesPts = [];
        for(var i = 0, l = this.holes.length; i < l; i++)holesPts[i] = this.holes[i].getPoints(divisions);
        return holesPts;
    },
    // get points of shape and holes (keypoints based on segments parameter)
    extractPoints: function(divisions) {
        return {
            shape: this.getPoints(divisions),
            holes: this.getPointsHoles(divisions)
        };
    },
    copy: function(source) {
        Path.prototype.copy.call(this, source);
        this.holes = [];
        for(var i = 0, l = source.holes.length; i < l; i++){
            var hole = source.holes[i];
            this.holes.push(hole.clone());
        }
        return this;
    },
    toJSON: function() {
        var data = Path.prototype.toJSON.call(this);
        data.uuid = this.uuid;
        data.holes = [];
        for(var i = 0, l = this.holes.length; i < l; i++){
            var hole = this.holes[i];
            data.holes.push(hole.toJSON());
        }
        return data;
    },
    fromJSON: function(json) {
        Path.prototype.fromJSON.call(this, json);
        this.uuid = json.uuid;
        this.holes = [];
        for(var i = 0, l = json.holes.length; i < l; i++){
            var hole = json.holes[i];
            this.holes.push(new Path().fromJSON(hole));
        }
        return this;
    }
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */ function Light(color, intensity) {
    Object3D.call(this);
    this.type = "Light";
    this.color = new Color(color);
    this.intensity = intensity !== undefined ? intensity : 1;
    this.receiveShadow = undefined;
}
Light.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Light,
    isLight: true,
    copy: function(source) {
        Object3D.prototype.copy.call(this, source);
        this.color.copy(source.color);
        this.intensity = source.intensity;
        return this;
    },
    toJSON: function(meta) {
        var data = Object3D.prototype.toJSON.call(this, meta);
        data.object.color = this.color.getHex();
        data.object.intensity = this.intensity;
        if (this.groundColor !== undefined) data.object.groundColor = this.groundColor.getHex();
        if (this.distance !== undefined) data.object.distance = this.distance;
        if (this.angle !== undefined) data.object.angle = this.angle;
        if (this.decay !== undefined) data.object.decay = this.decay;
        if (this.penumbra !== undefined) data.object.penumbra = this.penumbra;
        if (this.shadow !== undefined) data.object.shadow = this.shadow.toJSON();
        return data;
    }
});
/**
 * @author alteredq / http://alteredqualia.com/
 */ function HemisphereLight(skyColor, groundColor, intensity) {
    Light.call(this, skyColor, intensity);
    this.type = "HemisphereLight";
    this.castShadow = undefined;
    this.position.copy(Object3D.DefaultUp);
    this.updateMatrix();
    this.groundColor = new Color(groundColor);
}
HemisphereLight.prototype = Object.assign(Object.create(Light.prototype), {
    constructor: HemisphereLight,
    isHemisphereLight: true,
    copy: function(source) {
        Light.prototype.copy.call(this, source);
        this.groundColor.copy(source.groundColor);
        return this;
    }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */ function LightShadow(camera) {
    this.camera = camera;
    this.bias = 0;
    this.radius = 1;
    this.mapSize = new Vector2(512, 512);
    this.map = null;
    this.matrix = new Matrix4();
}
Object.assign(LightShadow.prototype, {
    copy: function(source) {
        this.camera = source.camera.clone();
        this.bias = source.bias;
        this.radius = source.radius;
        this.mapSize.copy(source.mapSize);
        return this;
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    toJSON: function() {
        var object = {};
        if (this.bias !== 0) object.bias = this.bias;
        if (this.radius !== 1) object.radius = this.radius;
        if (this.mapSize.x !== 512 || this.mapSize.y !== 512) object.mapSize = this.mapSize.toArray();
        object.camera = this.camera.toJSON(false).object;
        delete object.camera.matrix;
        return object;
    }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */ function SpotLightShadow() {
    LightShadow.call(this, new PerspectiveCamera(50, 1, 0.5, 500));
}
SpotLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
    constructor: SpotLightShadow,
    isSpotLightShadow: true,
    update: function(light) {
        var camera = this.camera;
        var fov = _Math.RAD2DEG * 2 * light.angle;
        var aspect = this.mapSize.width / this.mapSize.height;
        var far = light.distance || camera.far;
        if (fov !== camera.fov || aspect !== camera.aspect || far !== camera.far) {
            camera.fov = fov;
            camera.aspect = aspect;
            camera.far = far;
            camera.updateProjectionMatrix();
        }
    }
});
/**
 * @author alteredq / http://alteredqualia.com/
 */ function SpotLight(color, intensity, distance, angle, penumbra, decay) {
    Light.call(this, color, intensity);
    this.type = "SpotLight";
    this.position.copy(Object3D.DefaultUp);
    this.updateMatrix();
    this.target = new Object3D();
    Object.defineProperty(this, "power", {
        get: function() {
            // intensity = power per solid angle.
            // ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
            return this.intensity * Math.PI;
        },
        set: function(power) {
            // intensity = power per solid angle.
            // ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
            this.intensity = power / Math.PI;
        }
    });
    this.distance = distance !== undefined ? distance : 0;
    this.angle = angle !== undefined ? angle : Math.PI / 3;
    this.penumbra = penumbra !== undefined ? penumbra : 0;
    this.decay = decay !== undefined ? decay : 1; // for physically correct lights, should be 2.
    this.shadow = new SpotLightShadow();
}
SpotLight.prototype = Object.assign(Object.create(Light.prototype), {
    constructor: SpotLight,
    isSpotLight: true,
    copy: function(source) {
        Light.prototype.copy.call(this, source);
        this.distance = source.distance;
        this.angle = source.angle;
        this.penumbra = source.penumbra;
        this.decay = source.decay;
        this.target = source.target.clone();
        this.shadow = source.shadow.clone();
        return this;
    }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */ function PointLight(color, intensity, distance, decay) {
    Light.call(this, color, intensity);
    this.type = "PointLight";
    Object.defineProperty(this, "power", {
        get: function() {
            // intensity = power per solid angle.
            // ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
            return this.intensity * 4 * Math.PI;
        },
        set: function(power) {
            // intensity = power per solid angle.
            // ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
            this.intensity = power / (4 * Math.PI);
        }
    });
    this.distance = distance !== undefined ? distance : 0;
    this.decay = decay !== undefined ? decay : 1; // for physically correct lights, should be 2.
    this.shadow = new LightShadow(new PerspectiveCamera(90, 1, 0.5, 500));
}
PointLight.prototype = Object.assign(Object.create(Light.prototype), {
    constructor: PointLight,
    isPointLight: true,
    copy: function(source) {
        Light.prototype.copy.call(this, source);
        this.distance = source.distance;
        this.decay = source.decay;
        this.shadow = source.shadow.clone();
        return this;
    }
});
/**
 * @author alteredq / http://alteredqualia.com/
 * @author arose / http://github.com/arose
 */ function OrthographicCamera(left, right, top, bottom, near, far) {
    Camera.call(this);
    this.type = "OrthographicCamera";
    this.zoom = 1;
    this.view = null;
    this.left = left !== undefined ? left : -1;
    this.right = right !== undefined ? right : 1;
    this.top = top !== undefined ? top : 1;
    this.bottom = bottom !== undefined ? bottom : -1;
    this.near = near !== undefined ? near : 0.1;
    this.far = far !== undefined ? far : 2000;
    this.updateProjectionMatrix();
}
OrthographicCamera.prototype = Object.assign(Object.create(Camera.prototype), {
    constructor: OrthographicCamera,
    isOrthographicCamera: true,
    copy: function(source, recursive) {
        Camera.prototype.copy.call(this, source, recursive);
        this.left = source.left;
        this.right = source.right;
        this.top = source.top;
        this.bottom = source.bottom;
        this.near = source.near;
        this.far = source.far;
        this.zoom = source.zoom;
        this.view = source.view === null ? null : Object.assign({}, source.view);
        return this;
    },
    setViewOffset: function(fullWidth, fullHeight, x, y, width, height) {
        if (this.view === null) this.view = {
            enabled: true,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        };
        this.view.enabled = true;
        this.view.fullWidth = fullWidth;
        this.view.fullHeight = fullHeight;
        this.view.offsetX = x;
        this.view.offsetY = y;
        this.view.width = width;
        this.view.height = height;
        this.updateProjectionMatrix();
    },
    clearViewOffset: function() {
        if (this.view !== null) this.view.enabled = false;
        this.updateProjectionMatrix();
    },
    updateProjectionMatrix: function() {
        var dx = (this.right - this.left) / (2 * this.zoom);
        var dy = (this.top - this.bottom) / (2 * this.zoom);
        var cx = (this.right + this.left) / 2;
        var cy = (this.top + this.bottom) / 2;
        var left = cx - dx;
        var right = cx + dx;
        var top = cy + dy;
        var bottom = cy - dy;
        if (this.view !== null && this.view.enabled) {
            var zoomW = this.zoom / (this.view.width / this.view.fullWidth);
            var zoomH = this.zoom / (this.view.height / this.view.fullHeight);
            var scaleW = (this.right - this.left) / this.view.width;
            var scaleH = (this.top - this.bottom) / this.view.height;
            left += scaleW * (this.view.offsetX / zoomW);
            right = left + scaleW * (this.view.width / zoomW);
            top -= scaleH * (this.view.offsetY / zoomH);
            bottom = top - scaleH * (this.view.height / zoomH);
        }
        this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
        this.projectionMatrixInverse.getInverse(this.projectionMatrix);
    },
    toJSON: function(meta) {
        var data = Object3D.prototype.toJSON.call(this, meta);
        data.object.zoom = this.zoom;
        data.object.left = this.left;
        data.object.right = this.right;
        data.object.top = this.top;
        data.object.bottom = this.bottom;
        data.object.near = this.near;
        data.object.far = this.far;
        if (this.view !== null) data.object.view = Object.assign({}, this.view);
        return data;
    }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */ function DirectionalLightShadow() {
    LightShadow.call(this, new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
}
DirectionalLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
    constructor: DirectionalLightShadow
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */ function DirectionalLight(color, intensity) {
    Light.call(this, color, intensity);
    this.type = "DirectionalLight";
    this.position.copy(Object3D.DefaultUp);
    this.updateMatrix();
    this.target = new Object3D();
    this.shadow = new DirectionalLightShadow();
}
DirectionalLight.prototype = Object.assign(Object.create(Light.prototype), {
    constructor: DirectionalLight,
    isDirectionalLight: true,
    copy: function(source) {
        Light.prototype.copy.call(this, source);
        this.target = source.target.clone();
        this.shadow = source.shadow.clone();
        return this;
    }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */ function AmbientLight(color, intensity) {
    Light.call(this, color, intensity);
    this.type = "AmbientLight";
    this.castShadow = undefined;
}
AmbientLight.prototype = Object.assign(Object.create(Light.prototype), {
    constructor: AmbientLight,
    isAmbientLight: true
});
/**
 * @author abelnation / http://github.com/abelnation
 */ function RectAreaLight(color, intensity, width, height) {
    Light.call(this, color, intensity);
    this.type = "RectAreaLight";
    this.width = width !== undefined ? width : 10;
    this.height = height !== undefined ? height : 10;
}
RectAreaLight.prototype = Object.assign(Object.create(Light.prototype), {
    constructor: RectAreaLight,
    isRectAreaLight: true,
    copy: function(source) {
        Light.prototype.copy.call(this, source);
        this.width = source.width;
        this.height = source.height;
        return this;
    },
    toJSON: function(meta) {
        var data = Light.prototype.toJSON.call(this, meta);
        data.object.width = this.width;
        data.object.height = this.height;
        return data;
    }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */ function MaterialLoader(manager) {
    this.manager = manager !== undefined ? manager : DefaultLoadingManager;
    this.textures = {};
}
Object.assign(MaterialLoader.prototype, {
    load: function(url, onLoad, onProgress, onError) {
        var scope = this;
        var loader = new FileLoader(scope.manager);
        loader.setPath(scope.path);
        loader.load(url, function(text) {
            onLoad(scope.parse(JSON.parse(text)));
        }, onProgress, onError);
    },
    parse: function(json) {
        var textures = this.textures;
        function getTexture(name) {
            if (textures[name] === undefined) console.warn("THREE.MaterialLoader: Undefined texture", name);
            return textures[name];
        }
        var material = new Materials[json.type]();
        if (json.uuid !== undefined) material.uuid = json.uuid;
        if (json.name !== undefined) material.name = json.name;
        if (json.color !== undefined) material.color.setHex(json.color);
        if (json.roughness !== undefined) material.roughness = json.roughness;
        if (json.metalness !== undefined) material.metalness = json.metalness;
        if (json.emissive !== undefined) material.emissive.setHex(json.emissive);
        if (json.specular !== undefined) material.specular.setHex(json.specular);
        if (json.shininess !== undefined) material.shininess = json.shininess;
        if (json.clearCoat !== undefined) material.clearCoat = json.clearCoat;
        if (json.clearCoatRoughness !== undefined) material.clearCoatRoughness = json.clearCoatRoughness;
        if (json.vertexColors !== undefined) material.vertexColors = json.vertexColors;
        if (json.fog !== undefined) material.fog = json.fog;
        if (json.flatShading !== undefined) material.flatShading = json.flatShading;
        if (json.blending !== undefined) material.blending = json.blending;
        if (json.combine !== undefined) material.combine = json.combine;
        if (json.side !== undefined) material.side = json.side;
        if (json.opacity !== undefined) material.opacity = json.opacity;
        if (json.transparent !== undefined) material.transparent = json.transparent;
        if (json.alphaTest !== undefined) material.alphaTest = json.alphaTest;
        if (json.depthTest !== undefined) material.depthTest = json.depthTest;
        if (json.depthWrite !== undefined) material.depthWrite = json.depthWrite;
        if (json.colorWrite !== undefined) material.colorWrite = json.colorWrite;
        if (json.wireframe !== undefined) material.wireframe = json.wireframe;
        if (json.wireframeLinewidth !== undefined) material.wireframeLinewidth = json.wireframeLinewidth;
        if (json.wireframeLinecap !== undefined) material.wireframeLinecap = json.wireframeLinecap;
        if (json.wireframeLinejoin !== undefined) material.wireframeLinejoin = json.wireframeLinejoin;
        if (json.rotation !== undefined) material.rotation = json.rotation;
        if (json.linewidth !== 1) material.linewidth = json.linewidth;
        if (json.dashSize !== undefined) material.dashSize = json.dashSize;
        if (json.gapSize !== undefined) material.gapSize = json.gapSize;
        if (json.scale !== undefined) material.scale = json.scale;
        if (json.polygonOffset !== undefined) material.polygonOffset = json.polygonOffset;
        if (json.polygonOffsetFactor !== undefined) material.polygonOffsetFactor = json.polygonOffsetFactor;
        if (json.polygonOffsetUnits !== undefined) material.polygonOffsetUnits = json.polygonOffsetUnits;
        if (json.skinning !== undefined) material.skinning = json.skinning;
        if (json.morphTargets !== undefined) material.morphTargets = json.morphTargets;
        if (json.dithering !== undefined) material.dithering = json.dithering;
        if (json.visible !== undefined) material.visible = json.visible;
        if (json.userData !== undefined) material.userData = json.userData;
        // Shader Material
        if (json.uniforms !== undefined) for(var name in json.uniforms){
            var uniform = json.uniforms[name];
            material.uniforms[name] = {};
            switch(uniform.type){
                case "t":
                    material.uniforms[name].value = getTexture(uniform.value);
                    break;
                case "c":
                    material.uniforms[name].value = new Color().setHex(uniform.value);
                    break;
                case "v2":
                    material.uniforms[name].value = new Vector2().fromArray(uniform.value);
                    break;
                case "v3":
                    material.uniforms[name].value = new Vector3().fromArray(uniform.value);
                    break;
                case "v4":
                    material.uniforms[name].value = new Vector4().fromArray(uniform.value);
                    break;
                case "m4":
                    material.uniforms[name].value = new Matrix4().fromArray(uniform.value);
                    break;
                default:
                    material.uniforms[name].value = uniform.value;
            }
        }
        if (json.defines !== undefined) material.defines = json.defines;
        if (json.vertexShader !== undefined) material.vertexShader = json.vertexShader;
        if (json.fragmentShader !== undefined) material.fragmentShader = json.fragmentShader;
        if (json.extensions !== undefined) for(var key in json.extensions)material.extensions[key] = json.extensions[key];
        // Deprecated
        if (json.shading !== undefined) material.flatShading = json.shading === 1; // THREE.FlatShading
        // for PointsMaterial
        if (json.size !== undefined) material.size = json.size;
        if (json.sizeAttenuation !== undefined) material.sizeAttenuation = json.sizeAttenuation;
        // maps
        if (json.map !== undefined) material.map = getTexture(json.map);
        if (json.alphaMap !== undefined) {
            material.alphaMap = getTexture(json.alphaMap);
            material.transparent = true;
        }
        if (json.bumpMap !== undefined) material.bumpMap = getTexture(json.bumpMap);
        if (json.bumpScale !== undefined) material.bumpScale = json.bumpScale;
        if (json.normalMap !== undefined) material.normalMap = getTexture(json.normalMap);
        if (json.normalMapType !== undefined) material.normalMapType = json.normalMapType;
        if (json.normalScale !== undefined) {
            var normalScale = json.normalScale;
            if (Array.isArray(normalScale) === false) // Blender exporter used to export a scalar. See #7459
            normalScale = [
                normalScale,
                normalScale
            ];
            material.normalScale = new Vector2().fromArray(normalScale);
        }
        if (json.displacementMap !== undefined) material.displacementMap = getTexture(json.displacementMap);
        if (json.displacementScale !== undefined) material.displacementScale = json.displacementScale;
        if (json.displacementBias !== undefined) material.displacementBias = json.displacementBias;
        if (json.roughnessMap !== undefined) material.roughnessMap = getTexture(json.roughnessMap);
        if (json.metalnessMap !== undefined) material.metalnessMap = getTexture(json.metalnessMap);
        if (json.emissiveMap !== undefined) material.emissiveMap = getTexture(json.emissiveMap);
        if (json.emissiveIntensity !== undefined) material.emissiveIntensity = json.emissiveIntensity;
        if (json.specularMap !== undefined) material.specularMap = getTexture(json.specularMap);
        if (json.envMap !== undefined) material.envMap = getTexture(json.envMap);
        if (json.envMapIntensity !== undefined) material.envMapIntensity = json.envMapIntensity;
        if (json.reflectivity !== undefined) material.reflectivity = json.reflectivity;
        if (json.lightMap !== undefined) material.lightMap = getTexture(json.lightMap);
        if (json.lightMapIntensity !== undefined) material.lightMapIntensity = json.lightMapIntensity;
        if (json.aoMap !== undefined) material.aoMap = getTexture(json.aoMap);
        if (json.aoMapIntensity !== undefined) material.aoMapIntensity = json.aoMapIntensity;
        if (json.gradientMap !== undefined) material.gradientMap = getTexture(json.gradientMap);
        return material;
    },
    setPath: function(value) {
        this.path = value;
        return this;
    },
    setTextures: function(value) {
        this.textures = value;
        return this;
    }
});
/**
 * @author Don McCurdy / https://www.donmccurdy.com
 */ var LoaderUtils = {
    decodeText: function(array) {
        if (typeof TextDecoder !== "undefined") return new TextDecoder().decode(array);
        // Avoid the String.fromCharCode.apply(null, array) shortcut, which
        // throws a "maximum call stack size exceeded" error for large arrays.
        var s = "";
        for(var i = 0, il = array.length; i < il; i++)// Implicitly assumes little-endian.
        s += String.fromCharCode(array[i]);
        // Merges multi-byte utf-8 characters.
        return decodeURIComponent(escape(s));
    },
    extractUrlBase: function(url) {
        var index = url.lastIndexOf("/");
        if (index === -1) return "./";
        return url.substr(0, index + 1);
    }
};
/**
 * @author mrdoob / http://mrdoob.com/
 */ function BufferGeometryLoader(manager) {
    this.manager = manager !== undefined ? manager : DefaultLoadingManager;
}
Object.assign(BufferGeometryLoader.prototype, {
    load: function(url, onLoad, onProgress, onError) {
        var scope = this;
        var loader = new FileLoader(scope.manager);
        loader.setPath(scope.path);
        loader.load(url, function(text) {
            onLoad(scope.parse(JSON.parse(text)));
        }, onProgress, onError);
    },
    parse: function(json) {
        var geometry = new BufferGeometry();
        var index = json.data.index;
        if (index !== undefined) {
            var typedArray = new TYPED_ARRAYS[index.type](index.array);
            geometry.setIndex(new BufferAttribute(typedArray, 1));
        }
        var attributes = json.data.attributes;
        for(var key in attributes){
            var attribute = attributes[key];
            var typedArray = new TYPED_ARRAYS[attribute.type](attribute.array);
            geometry.addAttribute(key, new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized));
        }
        var groups = json.data.groups || json.data.drawcalls || json.data.offsets;
        if (groups !== undefined) for(var i = 0, n = groups.length; i !== n; ++i){
            var group = groups[i];
            geometry.addGroup(group.start, group.count, group.materialIndex);
        }
        var boundingSphere = json.data.boundingSphere;
        if (boundingSphere !== undefined) {
            var center = new Vector3();
            if (boundingSphere.center !== undefined) center.fromArray(boundingSphere.center);
            geometry.boundingSphere = new Sphere(center, boundingSphere.radius);
        }
        if (json.name) geometry.name = json.name;
        if (json.userData) geometry.userData = json.userData;
        return geometry;
    },
    setPath: function(value) {
        this.path = value;
        return this;
    }
});
var TYPED_ARRAYS = {
    Int8Array: Int8Array,
    Uint8Array: Uint8Array,
    // Workaround for IE11 pre KB2929437. See #11440
    Uint8ClampedArray: typeof Uint8ClampedArray !== "undefined" ? Uint8ClampedArray : Uint8Array,
    Int16Array: Int16Array,
    Uint16Array: Uint16Array,
    Int32Array: Int32Array,
    Uint32Array: Uint32Array,
    Float32Array: Float32Array,
    Float64Array: Float64Array
};
/**
 * @author mrdoob / http://mrdoob.com/
 */ function ObjectLoader(manager) {
    this.manager = manager !== undefined ? manager : DefaultLoadingManager;
    this.resourcePath = "";
}
Object.assign(ObjectLoader.prototype, {
    crossOrigin: "anonymous",
    load: function(url, onLoad, onProgress, onError) {
        var scope = this;
        var path = this.path === undefined ? LoaderUtils.extractUrlBase(url) : this.path;
        this.resourcePath = this.resourcePath || path;
        var loader = new FileLoader(scope.manager);
        loader.setPath(this.path);
        loader.load(url, function(text) {
            var json = null;
            try {
                json = JSON.parse(text);
            } catch (error) {
                if (onError !== undefined) onError(error);
                console.error("THREE:ObjectLoader: Can't parse " + url + ".", error.message);
                return;
            }
            var metadata = json.metadata;
            if (metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === "geometry") {
                console.error("THREE.ObjectLoader: Can't load " + url);
                return;
            }
            scope.parse(json, onLoad);
        }, onProgress, onError);
    },
    setPath: function(value) {
        this.path = value;
        return this;
    },
    setResourcePath: function(value) {
        this.resourcePath = value;
        return this;
    },
    setCrossOrigin: function(value) {
        this.crossOrigin = value;
        return this;
    },
    parse: function(json, onLoad) {
        var shapes = this.parseShape(json.shapes);
        var geometries = this.parseGeometries(json.geometries, shapes);
        var images = this.parseImages(json.images, function() {
            if (onLoad !== undefined) onLoad(object);
        });
        var textures = this.parseTextures(json.textures, images);
        var materials = this.parseMaterials(json.materials, textures);
        var object = this.parseObject(json.object, geometries, materials);
        if (json.animations) object.animations = this.parseAnimations(json.animations);
        if (json.images === undefined || json.images.length === 0) {
            if (onLoad !== undefined) onLoad(object);
        }
        return object;
    },
    parseShape: function(json) {
        var shapes = {};
        if (json !== undefined) for(var i = 0, l = json.length; i < l; i++){
            var shape = new Shape().fromJSON(json[i]);
            shapes[shape.uuid] = shape;
        }
        return shapes;
    },
    parseGeometries: function(json, shapes) {
        var geometries = {};
        if (json !== undefined) {
            var bufferGeometryLoader = new BufferGeometryLoader();
            for(var i = 0, l = json.length; i < l; i++){
                var geometry;
                var data = json[i];
                switch(data.type){
                    case "PlaneGeometry":
                    case "PlaneBufferGeometry":
                        geometry = new Geometries[data.type](data.width, data.height, data.widthSegments, data.heightSegments);
                        break;
                    case "BoxGeometry":
                    case "BoxBufferGeometry":
                    case "CubeGeometry":
                        geometry = new Geometries[data.type](data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
                        break;
                    case "CircleGeometry":
                    case "CircleBufferGeometry":
                        geometry = new Geometries[data.type](data.radius, data.segments, data.thetaStart, data.thetaLength);
                        break;
                    case "CylinderGeometry":
                    case "CylinderBufferGeometry":
                        geometry = new Geometries[data.type](data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
                        break;
                    case "ConeGeometry":
                    case "ConeBufferGeometry":
                        geometry = new Geometries[data.type](data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
                        break;
                    case "SphereGeometry":
                    case "SphereBufferGeometry":
                        geometry = new Geometries[data.type](data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
                        break;
                    case "DodecahedronGeometry":
                    case "DodecahedronBufferGeometry":
                    case "IcosahedronGeometry":
                    case "IcosahedronBufferGeometry":
                    case "OctahedronGeometry":
                    case "OctahedronBufferGeometry":
                    case "TetrahedronGeometry":
                    case "TetrahedronBufferGeometry":
                        geometry = new Geometries[data.type](data.radius, data.detail);
                        break;
                    case "RingGeometry":
                    case "RingBufferGeometry":
                        geometry = new Geometries[data.type](data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
                        break;
                    case "TorusGeometry":
                    case "TorusBufferGeometry":
                        geometry = new Geometries[data.type](data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
                        break;
                    case "TorusKnotGeometry":
                    case "TorusKnotBufferGeometry":
                        geometry = new Geometries[data.type](data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
                        break;
                    case "LatheGeometry":
                    case "LatheBufferGeometry":
                        geometry = new Geometries[data.type](data.points, data.segments, data.phiStart, data.phiLength);
                        break;
                    case "PolyhedronGeometry":
                    case "PolyhedronBufferGeometry":
                        geometry = new Geometries[data.type](data.vertices, data.indices, data.radius, data.details);
                        break;
                    case "ShapeGeometry":
                    case "ShapeBufferGeometry":
                        var geometryShapes = [];
                        for(var j = 0, jl = data.shapes.length; j < jl; j++){
                            var shape = shapes[data.shapes[j]];
                            geometryShapes.push(shape);
                        }
                        geometry = new Geometries[data.type](geometryShapes, data.curveSegments);
                        break;
                    case "ExtrudeGeometry":
                    case "ExtrudeBufferGeometry":
                        var geometryShapes = [];
                        for(var j = 0, jl = data.shapes.length; j < jl; j++){
                            var shape = shapes[data.shapes[j]];
                            geometryShapes.push(shape);
                        }
                        var extrudePath = data.options.extrudePath;
                        if (extrudePath !== undefined) data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);
                        geometry = new Geometries[data.type](geometryShapes, data.options);
                        break;
                    case "BufferGeometry":
                        geometry = bufferGeometryLoader.parse(data);
                        break;
                    case "Geometry":
                        if ("THREE" in window && "LegacyJSONLoader" in THREE) {
                            var geometryLoader = new THREE.LegacyJSONLoader();
                            geometry = geometryLoader.parse(data, this.resourcePath).geometry;
                        } else console.error('THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type "Geometry".');
                        break;
                    default:
                        console.warn('THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"');
                        continue;
                }
                geometry.uuid = data.uuid;
                if (data.name !== undefined) geometry.name = data.name;
                if (geometry.isBufferGeometry === true && data.userData !== undefined) geometry.userData = data.userData;
                geometries[data.uuid] = geometry;
            }
        }
        return geometries;
    },
    parseMaterials: function(json, textures) {
        var cache = {}; // MultiMaterial
        var materials = {};
        if (json !== undefined) {
            var loader = new MaterialLoader();
            loader.setTextures(textures);
            for(var i = 0, l = json.length; i < l; i++){
                var data = json[i];
                if (data.type === "MultiMaterial") {
                    // Deprecated
                    var array = [];
                    for(var j = 0; j < data.materials.length; j++){
                        var material = data.materials[j];
                        if (cache[material.uuid] === undefined) cache[material.uuid] = loader.parse(material);
                        array.push(cache[material.uuid]);
                    }
                    materials[data.uuid] = array;
                } else {
                    materials[data.uuid] = loader.parse(data);
                    cache[data.uuid] = materials[data.uuid];
                }
            }
        }
        return materials;
    },
    parseAnimations: function(json) {
        var animations = [];
        for(var i = 0; i < json.length; i++){
            var data = json[i];
            var clip = AnimationClip.parse(data);
            if (data.uuid !== undefined) clip.uuid = data.uuid;
            animations.push(clip);
        }
        return animations;
    },
    parseImages: function(json, onLoad) {
        var scope = this;
        var images = {};
        function loadImage(url) {
            scope.manager.itemStart(url);
            return loader.load(url, function() {
                scope.manager.itemEnd(url);
            }, undefined, function() {
                scope.manager.itemError(url);
                scope.manager.itemEnd(url);
            });
        }
        if (json !== undefined && json.length > 0) {
            var manager = new LoadingManager(onLoad);
            var loader = new ImageLoader(manager);
            loader.setCrossOrigin(this.crossOrigin);
            for(var i = 0, il = json.length; i < il; i++){
                var image = json[i];
                var url = image.url;
                if (Array.isArray(url)) {
                    // load array of images e.g CubeTexture
                    images[image.uuid] = [];
                    for(var j = 0, jl = url.length; j < jl; j++){
                        var currentUrl = url[j];
                        var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(currentUrl) ? currentUrl : scope.resourcePath + currentUrl;
                        images[image.uuid].push(loadImage(path));
                    }
                } else {
                    // load single image
                    var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(image.url) ? image.url : scope.resourcePath + image.url;
                    images[image.uuid] = loadImage(path);
                }
            }
        }
        return images;
    },
    parseTextures: function(json, images) {
        function parseConstant(value, type) {
            if (typeof value === "number") return value;
            console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", value);
            return type[value];
        }
        var textures = {};
        if (json !== undefined) for(var i = 0, l = json.length; i < l; i++){
            var data = json[i];
            if (data.image === undefined) console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid);
            if (images[data.image] === undefined) console.warn("THREE.ObjectLoader: Undefined image", data.image);
            var texture;
            if (Array.isArray(images[data.image])) texture = new CubeTexture(images[data.image]);
            else texture = new Texture(images[data.image]);
            texture.needsUpdate = true;
            texture.uuid = data.uuid;
            if (data.name !== undefined) texture.name = data.name;
            if (data.mapping !== undefined) texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);
            if (data.offset !== undefined) texture.offset.fromArray(data.offset);
            if (data.repeat !== undefined) texture.repeat.fromArray(data.repeat);
            if (data.center !== undefined) texture.center.fromArray(data.center);
            if (data.rotation !== undefined) texture.rotation = data.rotation;
            if (data.wrap !== undefined) {
                texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING);
                texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING);
            }
            if (data.format !== undefined) texture.format = data.format;
            if (data.type !== undefined) texture.type = data.type;
            if (data.encoding !== undefined) texture.encoding = data.encoding;
            if (data.minFilter !== undefined) texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);
            if (data.magFilter !== undefined) texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);
            if (data.anisotropy !== undefined) texture.anisotropy = data.anisotropy;
            if (data.flipY !== undefined) texture.flipY = data.flipY;
            if (data.premultiplyAlpha !== undefined) texture.premultiplyAlpha = data.premultiplyAlpha;
            if (data.unpackAlignment !== undefined) texture.unpackAlignment = data.unpackAlignment;
            textures[data.uuid] = texture;
        }
        return textures;
    },
    parseObject: function(data, geometries, materials) {
        var object;
        function getGeometry(name) {
            if (geometries[name] === undefined) console.warn("THREE.ObjectLoader: Undefined geometry", name);
            return geometries[name];
        }
        function getMaterial(name) {
            if (name === undefined) return undefined;
            if (Array.isArray(name)) {
                var array = [];
                for(var i = 0, l = name.length; i < l; i++){
                    var uuid = name[i];
                    if (materials[uuid] === undefined) console.warn("THREE.ObjectLoader: Undefined material", uuid);
                    array.push(materials[uuid]);
                }
                return array;
            }
            if (materials[name] === undefined) console.warn("THREE.ObjectLoader: Undefined material", name);
            return materials[name];
        }
        switch(data.type){
            case "Scene":
                object = new Scene();
                if (data.background !== undefined) {
                    if (Number.isInteger(data.background)) object.background = new Color(data.background);
                }
                if (data.fog !== undefined) {
                    if (data.fog.type === "Fog") object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);
                    else if (data.fog.type === "FogExp2") object.fog = new FogExp2(data.fog.color, data.fog.density);
                }
                break;
            case "PerspectiveCamera":
                object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);
                if (data.focus !== undefined) object.focus = data.focus;
                if (data.zoom !== undefined) object.zoom = data.zoom;
                if (data.filmGauge !== undefined) object.filmGauge = data.filmGauge;
                if (data.filmOffset !== undefined) object.filmOffset = data.filmOffset;
                if (data.view !== undefined) object.view = Object.assign({}, data.view);
                break;
            case "OrthographicCamera":
                object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
                if (data.zoom !== undefined) object.zoom = data.zoom;
                if (data.view !== undefined) object.view = Object.assign({}, data.view);
                break;
            case "AmbientLight":
                object = new AmbientLight(data.color, data.intensity);
                break;
            case "DirectionalLight":
                object = new DirectionalLight(data.color, data.intensity);
                break;
            case "PointLight":
                object = new PointLight(data.color, data.intensity, data.distance, data.decay);
                break;
            case "RectAreaLight":
                object = new RectAreaLight(data.color, data.intensity, data.width, data.height);
                break;
            case "SpotLight":
                object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
                break;
            case "HemisphereLight":
                object = new HemisphereLight(data.color, data.groundColor, data.intensity);
                break;
            case "SkinnedMesh":
                console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
            case "Mesh":
                var geometry = getGeometry(data.geometry);
                var material = getMaterial(data.material);
                if (geometry.bones && geometry.bones.length > 0) object = new SkinnedMesh(geometry, material);
                else object = new Mesh(geometry, material);
                break;
            case "LOD":
                object = new LOD();
                break;
            case "Line":
                object = new Line(getGeometry(data.geometry), getMaterial(data.material), data.mode);
                break;
            case "LineLoop":
                object = new LineLoop(getGeometry(data.geometry), getMaterial(data.material));
                break;
            case "LineSegments":
                object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));
                break;
            case "PointCloud":
            case "Points":
                object = new Points(getGeometry(data.geometry), getMaterial(data.material));
                break;
            case "Sprite":
                object = new Sprite(getMaterial(data.material));
                break;
            case "Group":
                object = new Group();
                break;
            default:
                object = new Object3D();
        }
        object.uuid = data.uuid;
        if (data.name !== undefined) object.name = data.name;
        if (data.matrix !== undefined) {
            object.matrix.fromArray(data.matrix);
            if (data.matrixAutoUpdate !== undefined) object.matrixAutoUpdate = data.matrixAutoUpdate;
            if (object.matrixAutoUpdate) object.matrix.decompose(object.position, object.quaternion, object.scale);
        } else {
            if (data.position !== undefined) object.position.fromArray(data.position);
            if (data.rotation !== undefined) object.rotation.fromArray(data.rotation);
            if (data.quaternion !== undefined) object.quaternion.fromArray(data.quaternion);
            if (data.scale !== undefined) object.scale.fromArray(data.scale);
        }
        if (data.castShadow !== undefined) object.castShadow = data.castShadow;
        if (data.receiveShadow !== undefined) object.receiveShadow = data.receiveShadow;
        if (data.shadow) {
            if (data.shadow.bias !== undefined) object.shadow.bias = data.shadow.bias;
            if (data.shadow.radius !== undefined) object.shadow.radius = data.shadow.radius;
            if (data.shadow.mapSize !== undefined) object.shadow.mapSize.fromArray(data.shadow.mapSize);
            if (data.shadow.camera !== undefined) object.shadow.camera = this.parseObject(data.shadow.camera);
        }
        if (data.visible !== undefined) object.visible = data.visible;
        if (data.frustumCulled !== undefined) object.frustumCulled = data.frustumCulled;
        if (data.renderOrder !== undefined) object.renderOrder = data.renderOrder;
        if (data.userData !== undefined) object.userData = data.userData;
        if (data.layers !== undefined) object.layers.mask = data.layers;
        if (data.children !== undefined) {
            var children = data.children;
            for(var i = 0; i < children.length; i++)object.add(this.parseObject(children[i], geometries, materials));
        }
        if (data.type === "LOD") {
            var levels = data.levels;
            for(var l = 0; l < levels.length; l++){
                var level = levels[l];
                var child = object.getObjectByProperty("uuid", level.object);
                if (child !== undefined) object.addLevel(child, level.distance);
            }
        }
        return object;
    }
});
var TEXTURE_MAPPING = {
    UVMapping: UVMapping,
    CubeReflectionMapping: CubeReflectionMapping,
    CubeRefractionMapping: CubeRefractionMapping,
    EquirectangularReflectionMapping: EquirectangularReflectionMapping,
    EquirectangularRefractionMapping: EquirectangularRefractionMapping,
    SphericalReflectionMapping: SphericalReflectionMapping,
    CubeUVReflectionMapping: CubeUVReflectionMapping,
    CubeUVRefractionMapping: CubeUVRefractionMapping
};
var TEXTURE_WRAPPING = {
    RepeatWrapping: RepeatWrapping,
    ClampToEdgeWrapping: ClampToEdgeWrapping,
    MirroredRepeatWrapping: MirroredRepeatWrapping
};
var TEXTURE_FILTER = {
    NearestFilter: NearestFilter,
    NearestMipMapNearestFilter: NearestMipMapNearestFilter,
    NearestMipMapLinearFilter: NearestMipMapLinearFilter,
    LinearFilter: LinearFilter,
    LinearMipMapNearestFilter: LinearMipMapNearestFilter,
    LinearMipMapLinearFilter: LinearMipMapLinearFilter
};
/**
 * @author thespite / http://clicktorelease.com/
 */ function ImageBitmapLoader(manager) {
    if (typeof createImageBitmap === "undefined") console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported.");
    if (typeof fetch === "undefined") console.warn("THREE.ImageBitmapLoader: fetch() not supported.");
    this.manager = manager !== undefined ? manager : DefaultLoadingManager;
    this.options = undefined;
}
ImageBitmapLoader.prototype = {
    constructor: ImageBitmapLoader,
    setOptions: function setOptions(options) {
        this.options = options;
        return this;
    },
    load: function(url, onLoad, onProgress, onError) {
        if (url === undefined) url = "";
        if (this.path !== undefined) url = this.path + url;
        url = this.manager.resolveURL(url);
        var scope = this;
        var cached = Cache.get(url);
        if (cached !== undefined) {
            scope.manager.itemStart(url);
            setTimeout(function() {
                if (onLoad) onLoad(cached);
                scope.manager.itemEnd(url);
            }, 0);
            return cached;
        }
        fetch(url).then(function(res) {
            return res.blob();
        }).then(function(blob) {
            return createImageBitmap(blob, scope.options);
        }).then(function(imageBitmap) {
            Cache.add(url, imageBitmap);
            if (onLoad) onLoad(imageBitmap);
            scope.manager.itemEnd(url);
        }).catch(function(e) {
            if (onError) onError(e);
            scope.manager.itemError(url);
            scope.manager.itemEnd(url);
        });
    },
    setCrossOrigin: function() {
        return this;
    },
    setPath: function(value) {
        this.path = value;
        return this;
    }
};
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * minimal class for proxing functions to Path. Replaces old "extractSubpaths()"
 **/ function ShapePath() {
    this.type = "ShapePath";
    this.color = new Color();
    this.subPaths = [];
    this.currentPath = null;
}
Object.assign(ShapePath.prototype, {
    moveTo: function(x, y) {
        this.currentPath = new Path();
        this.subPaths.push(this.currentPath);
        this.currentPath.moveTo(x, y);
    },
    lineTo: function(x, y) {
        this.currentPath.lineTo(x, y);
    },
    quadraticCurveTo: function(aCPx, aCPy, aX, aY) {
        this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
    },
    bezierCurveTo: function(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
        this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
    },
    splineThru: function(pts) {
        this.currentPath.splineThru(pts);
    },
    toShapes: function(isCCW, noHoles) {
        function toShapesNoHoles(inSubpaths) {
            var shapes = [];
            for(var i = 0, l = inSubpaths.length; i < l; i++){
                var tmpPath = inSubpaths[i];
                var tmpShape = new Shape();
                tmpShape.curves = tmpPath.curves;
                shapes.push(tmpShape);
            }
            return shapes;
        }
        function isPointInsidePolygon(inPt, inPolygon) {
            var polyLen = inPolygon.length;
            // inPt on polygon contour => immediate success    or
            // toggling of inside/outside at every single! intersection point of an edge
            //  with the horizontal line through inPt, left of inPt
            //  not counting lowerY endpoints of edges and whole edges on that line
            var inside = false;
            for(var p = polyLen - 1, q = 0; q < polyLen; p = q++){
                var edgeLowPt = inPolygon[p];
                var edgeHighPt = inPolygon[q];
                var edgeDx = edgeHighPt.x - edgeLowPt.x;
                var edgeDy = edgeHighPt.y - edgeLowPt.y;
                if (Math.abs(edgeDy) > Number.EPSILON) {
                    // not parallel
                    if (edgeDy < 0) {
                        edgeLowPt = inPolygon[q];
                        edgeDx = -edgeDx;
                        edgeHighPt = inPolygon[p];
                        edgeDy = -edgeDy;
                    }
                    if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y) continue;
                    if (inPt.y === edgeLowPt.y) {
                        if (inPt.x === edgeLowPt.x) return true; // inPt is on contour ?
                    // continue;				// no intersection or edgeLowPt => doesn't count !!!
                    } else {
                        var perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
                        if (perpEdge === 0) return true; // inPt is on contour ?
                        if (perpEdge < 0) continue;
                        inside = !inside; // true intersection left of inPt
                    }
                } else {
                    // parallel or collinear
                    if (inPt.y !== edgeLowPt.y) continue; // parallel
                    // edge lies on the same horizontal line as inPt
                    if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x) return true; // inPt: Point on contour !
                // continue;
                }
            }
            return inside;
        }
        var isClockWise = ShapeUtils.isClockWise;
        var subPaths = this.subPaths;
        if (subPaths.length === 0) return [];
        if (noHoles === true) return toShapesNoHoles(subPaths);
        var solid, tmpPath, tmpShape, shapes = [];
        if (subPaths.length === 1) {
            tmpPath = subPaths[0];
            tmpShape = new Shape();
            tmpShape.curves = tmpPath.curves;
            shapes.push(tmpShape);
            return shapes;
        }
        var holesFirst = !isClockWise(subPaths[0].getPoints());
        holesFirst = isCCW ? !holesFirst : holesFirst;
        // console.log("Holes first", holesFirst);
        var betterShapeHoles = [];
        var newShapes = [];
        var newShapeHoles = [];
        var mainIdx = 0;
        var tmpPoints;
        newShapes[mainIdx] = undefined;
        newShapeHoles[mainIdx] = [];
        for(var i = 0, l = subPaths.length; i < l; i++){
            tmpPath = subPaths[i];
            tmpPoints = tmpPath.getPoints();
            solid = isClockWise(tmpPoints);
            solid = isCCW ? !solid : solid;
            if (solid) {
                if (!holesFirst && newShapes[mainIdx]) mainIdx++;
                newShapes[mainIdx] = {
                    s: new Shape(),
                    p: tmpPoints
                };
                newShapes[mainIdx].s.curves = tmpPath.curves;
                if (holesFirst) mainIdx++;
                newShapeHoles[mainIdx] = [];
            //console.log('cw', i);
            } else newShapeHoles[mainIdx].push({
                h: tmpPath,
                p: tmpPoints[0]
            });
        }
        // only Holes? -> probably all Shapes with wrong orientation
        if (!newShapes[0]) return toShapesNoHoles(subPaths);
        if (newShapes.length > 1) {
            var ambiguous = false;
            var toChange = [];
            for(var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++)betterShapeHoles[sIdx] = [];
            for(var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++){
                var sho = newShapeHoles[sIdx];
                for(var hIdx = 0; hIdx < sho.length; hIdx++){
                    var ho = sho[hIdx];
                    var hole_unassigned = true;
                    for(var s2Idx = 0; s2Idx < newShapes.length; s2Idx++)if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
                        if (sIdx !== s2Idx) toChange.push({
                            froms: sIdx,
                            tos: s2Idx,
                            hole: hIdx
                        });
                        if (hole_unassigned) {
                            hole_unassigned = false;
                            betterShapeHoles[s2Idx].push(ho);
                        } else ambiguous = true;
                    }
                    if (hole_unassigned) betterShapeHoles[sIdx].push(ho);
                }
            }
            // console.log("ambiguous: ", ambiguous);
            if (toChange.length > 0) // console.log("to change: ", toChange);
            {
                if (!ambiguous) newShapeHoles = betterShapeHoles;
            }
        }
        var tmpHoles;
        for(var i = 0, il = newShapes.length; i < il; i++){
            tmpShape = newShapes[i].s;
            shapes.push(tmpShape);
            tmpHoles = newShapeHoles[i];
            for(var j = 0, jl = tmpHoles.length; j < jl; j++)tmpShape.holes.push(tmpHoles[j].h);
        }
        //console.log("shape", shapes);
        return shapes;
    }
});
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author mrdoob / http://mrdoob.com/
 */ function Font(data) {
    this.type = "Font";
    this.data = data;
}
Object.assign(Font.prototype, {
    isFont: true,
    generateShapes: function(text, size) {
        if (size === undefined) size = 100;
        var shapes = [];
        var paths = createPaths(text, size, this.data);
        for(var p = 0, pl = paths.length; p < pl; p++)Array.prototype.push.apply(shapes, paths[p].toShapes());
        return shapes;
    }
});
function createPaths(text, size, data) {
    var chars = Array.from ? Array.from(text) : String(text).split(""); // see #13988
    var scale = size / data.resolution;
    var line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;
    var paths = [];
    var offsetX = 0, offsetY = 0;
    for(var i = 0; i < chars.length; i++){
        var char = chars[i];
        if (char === "\n") {
            offsetX = 0;
            offsetY -= line_height;
        } else {
            var ret = createPath(char, scale, offsetX, offsetY, data);
            offsetX += ret.offsetX;
            paths.push(ret.path);
        }
    }
    return paths;
}
function createPath(char, scale, offsetX, offsetY, data) {
    var glyph = data.glyphs[char] || data.glyphs["?"];
    if (!glyph) return;
    var path = new ShapePath();
    var x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;
    if (glyph.o) {
        var outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(" "));
        for(var i = 0, l = outline.length; i < l;){
            var action = outline[i++];
            switch(action){
                case "m":
                    x = outline[i++] * scale + offsetX;
                    y = outline[i++] * scale + offsetY;
                    path.moveTo(x, y);
                    break;
                case "l":
                    x = outline[i++] * scale + offsetX;
                    y = outline[i++] * scale + offsetY;
                    path.lineTo(x, y);
                    break;
                case "q":
                    cpx = outline[i++] * scale + offsetX;
                    cpy = outline[i++] * scale + offsetY;
                    cpx1 = outline[i++] * scale + offsetX;
                    cpy1 = outline[i++] * scale + offsetY;
                    path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
                    break;
                case "b":
                    cpx = outline[i++] * scale + offsetX;
                    cpy = outline[i++] * scale + offsetY;
                    cpx1 = outline[i++] * scale + offsetX;
                    cpy1 = outline[i++] * scale + offsetY;
                    cpx2 = outline[i++] * scale + offsetX;
                    cpy2 = outline[i++] * scale + offsetY;
                    path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
                    break;
            }
        }
    }
    return {
        offsetX: glyph.ha * scale,
        path: path
    };
}
/**
 * @author mrdoob / http://mrdoob.com/
 */ function FontLoader(manager) {
    this.manager = manager !== undefined ? manager : DefaultLoadingManager;
}
Object.assign(FontLoader.prototype, {
    load: function(url, onLoad, onProgress, onError) {
        var scope = this;
        var loader = new FileLoader(this.manager);
        loader.setPath(this.path);
        loader.load(url, function(text) {
            var json;
            try {
                json = JSON.parse(text);
            } catch (e) {
                console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.");
                json = JSON.parse(text.substring(65, text.length - 2));
            }
            var font = scope.parse(json);
            if (onLoad) onLoad(font);
        }, onProgress, onError);
    },
    parse: function(json) {
        return new Font(json);
    },
    setPath: function(value) {
        this.path = value;
        return this;
    }
});
/**
 * @author alteredq / http://alteredqualia.com/
 */ function Loader() {}
Loader.Handlers = {
    handlers: [],
    add: function(regex, loader) {
        this.handlers.push(regex, loader);
    },
    get: function(file) {
        var handlers = this.handlers;
        for(var i = 0, l = handlers.length; i < l; i += 2){
            var regex = handlers[i];
            var loader = handlers[i + 1];
            if (regex.test(file)) return loader;
        }
        return null;
    }
};
Object.assign(Loader.prototype, {
    crossOrigin: "anonymous",
    onLoadStart: function() {},
    onLoadProgress: function() {},
    onLoadComplete: function() {},
    initMaterials: function(materials, texturePath, crossOrigin) {
        var array = [];
        for(var i = 0; i < materials.length; ++i)array[i] = this.createMaterial(materials[i], texturePath, crossOrigin);
        return array;
    },
    createMaterial: function() {
        var BlendingMode = {
            NoBlending: NoBlending,
            NormalBlending: NormalBlending,
            AdditiveBlending: AdditiveBlending,
            SubtractiveBlending: SubtractiveBlending,
            MultiplyBlending: MultiplyBlending,
            CustomBlending: CustomBlending
        };
        var color = new Color();
        var textureLoader = new TextureLoader();
        var materialLoader = new MaterialLoader();
        return function createMaterial(m, texturePath, crossOrigin) {
            // convert from old material format
            var textures = {};
            function loadTexture(path, repeat, offset, wrap, anisotropy) {
                var fullPath = texturePath + path;
                var loader = Loader.Handlers.get(fullPath);
                var texture;
                if (loader !== null) texture = loader.load(fullPath);
                else {
                    textureLoader.setCrossOrigin(crossOrigin);
                    texture = textureLoader.load(fullPath);
                }
                if (repeat !== undefined) {
                    texture.repeat.fromArray(repeat);
                    if (repeat[0] !== 1) texture.wrapS = RepeatWrapping;
                    if (repeat[1] !== 1) texture.wrapT = RepeatWrapping;
                }
                if (offset !== undefined) texture.offset.fromArray(offset);
                if (wrap !== undefined) {
                    if (wrap[0] === "repeat") texture.wrapS = RepeatWrapping;
                    if (wrap[0] === "mirror") texture.wrapS = MirroredRepeatWrapping;
                    if (wrap[1] === "repeat") texture.wrapT = RepeatWrapping;
                    if (wrap[1] === "mirror") texture.wrapT = MirroredRepeatWrapping;
                }
                if (anisotropy !== undefined) texture.anisotropy = anisotropy;
                var uuid = _Math.generateUUID();
                textures[uuid] = texture;
                return uuid;
            }
            //
            var json = {
                uuid: _Math.generateUUID(),
                type: "MeshLambertMaterial"
            };
            for(var name in m){
                var value = m[name];
                switch(name){
                    case "DbgColor":
                    case "DbgIndex":
                    case "opticalDensity":
                    case "illumination":
                        break;
                    case "DbgName":
                        json.name = value;
                        break;
                    case "blending":
                        json.blending = BlendingMode[value];
                        break;
                    case "colorAmbient":
                    case "mapAmbient":
                        console.warn("THREE.Loader.createMaterial:", name, "is no longer supported.");
                        break;
                    case "colorDiffuse":
                        json.color = color.fromArray(value).getHex();
                        break;
                    case "colorSpecular":
                        json.specular = color.fromArray(value).getHex();
                        break;
                    case "colorEmissive":
                        json.emissive = color.fromArray(value).getHex();
                        break;
                    case "specularCoef":
                        json.shininess = value;
                        break;
                    case "shading":
                        if (value.toLowerCase() === "basic") json.type = "MeshBasicMaterial";
                        if (value.toLowerCase() === "phong") json.type = "MeshPhongMaterial";
                        if (value.toLowerCase() === "standard") json.type = "MeshStandardMaterial";
                        break;
                    case "mapDiffuse":
                        json.map = loadTexture(value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy);
                        break;
                    case "mapDiffuseRepeat":
                    case "mapDiffuseOffset":
                    case "mapDiffuseWrap":
                    case "mapDiffuseAnisotropy":
                        break;
                    case "mapEmissive":
                        json.emissiveMap = loadTexture(value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy);
                        break;
                    case "mapEmissiveRepeat":
                    case "mapEmissiveOffset":
                    case "mapEmissiveWrap":
                    case "mapEmissiveAnisotropy":
                        break;
                    case "mapLight":
                        json.lightMap = loadTexture(value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy);
                        break;
                    case "mapLightRepeat":
                    case "mapLightOffset":
                    case "mapLightWrap":
                    case "mapLightAnisotropy":
                        break;
                    case "mapAO":
                        json.aoMap = loadTexture(value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy);
                        break;
                    case "mapAORepeat":
                    case "mapAOOffset":
                    case "mapAOWrap":
                    case "mapAOAnisotropy":
                        break;
                    case "mapBump":
                        json.bumpMap = loadTexture(value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy);
                        break;
                    case "mapBumpScale":
                        json.bumpScale = value;
                        break;
                    case "mapBumpRepeat":
                    case "mapBumpOffset":
                    case "mapBumpWrap":
                    case "mapBumpAnisotropy":
                        break;
                    case "mapNormal":
                        json.normalMap = loadTexture(value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy);
                        break;
                    case "mapNormalFactor":
                        json.normalScale = value;
                        break;
                    case "mapNormalRepeat":
                    case "mapNormalOffset":
                    case "mapNormalWrap":
                    case "mapNormalAnisotropy":
                        break;
                    case "mapSpecular":
                        json.specularMap = loadTexture(value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy);
                        break;
                    case "mapSpecularRepeat":
                    case "mapSpecularOffset":
                    case "mapSpecularWrap":
                    case "mapSpecularAnisotropy":
                        break;
                    case "mapMetalness":
                        json.metalnessMap = loadTexture(value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy);
                        break;
                    case "mapMetalnessRepeat":
                    case "mapMetalnessOffset":
                    case "mapMetalnessWrap":
                    case "mapMetalnessAnisotropy":
                        break;
                    case "mapRoughness":
                        json.roughnessMap = loadTexture(value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy);
                        break;
                    case "mapRoughnessRepeat":
                    case "mapRoughnessOffset":
                    case "mapRoughnessWrap":
                    case "mapRoughnessAnisotropy":
                        break;
                    case "mapAlpha":
                        json.alphaMap = loadTexture(value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy);
                        break;
                    case "mapAlphaRepeat":
                    case "mapAlphaOffset":
                    case "mapAlphaWrap":
                    case "mapAlphaAnisotropy":
                        break;
                    case "flipSided":
                        json.side = BackSide;
                        break;
                    case "doubleSided":
                        json.side = DoubleSide;
                        break;
                    case "transparency":
                        console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity");
                        json.opacity = value;
                        break;
                    case "depthTest":
                    case "depthWrite":
                    case "colorWrite":
                    case "opacity":
                    case "reflectivity":
                    case "transparent":
                    case "visible":
                    case "wireframe":
                        json[name] = value;
                        break;
                    case "vertexColors":
                        if (value === true) json.vertexColors = VertexColors;
                        if (value === "face") json.vertexColors = FaceColors;
                        break;
                    default:
                        console.error("THREE.Loader.createMaterial: Unsupported", name, value);
                        break;
                }
            }
            if (json.type === "MeshBasicMaterial") delete json.emissive;
            if (json.type !== "MeshPhongMaterial") delete json.specular;
            if (json.opacity < 1) json.transparent = true;
            materialLoader.setTextures(textures);
            return materialLoader.parse(json);
        };
    }()
});
/**
 * @author mrdoob / http://mrdoob.com/
 */ var context;
var AudioContext = {
    getContext: function() {
        if (context === undefined) context = new (window.AudioContext || window.webkitAudioContext)();
        return context;
    },
    setContext: function(value) {
        context = value;
    }
};
/**
 * @author Reece Aaron Lecrivain / http://reecenotes.com/
 */ function AudioLoader(manager) {
    this.manager = manager !== undefined ? manager : DefaultLoadingManager;
}
Object.assign(AudioLoader.prototype, {
    load: function(url, onLoad, onProgress, onError) {
        var loader = new FileLoader(this.manager);
        loader.setResponseType("arraybuffer");
        loader.setPath(this.path);
        loader.load(url, function(buffer) {
            // Create a copy of the buffer. The `decodeAudioData` method
            // detaches the buffer when complete, preventing reuse.
            var bufferCopy = buffer.slice(0);
            var context = AudioContext.getContext();
            context.decodeAudioData(bufferCopy, function(audioBuffer) {
                onLoad(audioBuffer);
            });
        }, onProgress, onError);
    },
    setPath: function(value) {
        this.path = value;
        return this;
    }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */ function StereoCamera() {
    this.type = "StereoCamera";
    this.aspect = 1;
    this.eyeSep = 0.064;
    this.cameraL = new PerspectiveCamera();
    this.cameraL.layers.enable(1);
    this.cameraL.matrixAutoUpdate = false;
    this.cameraR = new PerspectiveCamera();
    this.cameraR.layers.enable(2);
    this.cameraR.matrixAutoUpdate = false;
}
Object.assign(StereoCamera.prototype, {
    update: function() {
        var instance, focus, fov, aspect, near, far, zoom, eyeSep;
        var eyeRight = new Matrix4();
        var eyeLeft = new Matrix4();
        return function update(camera) {
            var needsUpdate = instance !== this || focus !== camera.focus || fov !== camera.fov || aspect !== camera.aspect * this.aspect || near !== camera.near || far !== camera.far || zoom !== camera.zoom || eyeSep !== this.eyeSep;
            if (needsUpdate) {
                instance = this;
                focus = camera.focus;
                fov = camera.fov;
                aspect = camera.aspect * this.aspect;
                near = camera.near;
                far = camera.far;
                zoom = camera.zoom;
                // Off-axis stereoscopic effect based on
                // http://paulbourke.net/stereographics/stereorender/
                var projectionMatrix = camera.projectionMatrix.clone();
                eyeSep = this.eyeSep / 2;
                var eyeSepOnProjection = eyeSep * near / focus;
                var ymax = near * Math.tan(_Math.DEG2RAD * fov * 0.5) / zoom;
                var xmin, xmax;
                // translate xOffset
                eyeLeft.elements[12] = -eyeSep;
                eyeRight.elements[12] = eyeSep;
                // for left eye
                xmin = -ymax * aspect + eyeSepOnProjection;
                xmax = ymax * aspect + eyeSepOnProjection;
                projectionMatrix.elements[0] = 2 * near / (xmax - xmin);
                projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
                this.cameraL.projectionMatrix.copy(projectionMatrix);
                // for right eye
                xmin = -ymax * aspect - eyeSepOnProjection;
                xmax = ymax * aspect - eyeSepOnProjection;
                projectionMatrix.elements[0] = 2 * near / (xmax - xmin);
                projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
                this.cameraR.projectionMatrix.copy(projectionMatrix);
            }
            this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(eyeLeft);
            this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(eyeRight);
        };
    }()
});
/**
 * Camera for rendering cube maps
 *	- renders scene into axis-aligned cube
 *
 * @author alteredq / http://alteredqualia.com/
 */ function CubeCamera(near, far, cubeResolution, options) {
    Object3D.call(this);
    this.type = "CubeCamera";
    var fov = 90, aspect = 1;
    var cameraPX = new PerspectiveCamera(fov, aspect, near, far);
    cameraPX.up.set(0, -1, 0);
    cameraPX.lookAt(new Vector3(1, 0, 0));
    this.add(cameraPX);
    var cameraNX = new PerspectiveCamera(fov, aspect, near, far);
    cameraNX.up.set(0, -1, 0);
    cameraNX.lookAt(new Vector3(-1, 0, 0));
    this.add(cameraNX);
    var cameraPY = new PerspectiveCamera(fov, aspect, near, far);
    cameraPY.up.set(0, 0, 1);
    cameraPY.lookAt(new Vector3(0, 1, 0));
    this.add(cameraPY);
    var cameraNY = new PerspectiveCamera(fov, aspect, near, far);
    cameraNY.up.set(0, 0, -1);
    cameraNY.lookAt(new Vector3(0, -1, 0));
    this.add(cameraNY);
    var cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraPZ.up.set(0, -1, 0);
    cameraPZ.lookAt(new Vector3(0, 0, 1));
    this.add(cameraPZ);
    var cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraNZ.up.set(0, -1, 0);
    cameraNZ.lookAt(new Vector3(0, 0, -1));
    this.add(cameraNZ);
    options = options || {
        format: RGBFormat,
        magFilter: LinearFilter,
        minFilter: LinearFilter
    };
    this.renderTarget = new WebGLRenderTargetCube(cubeResolution, cubeResolution, options);
    this.renderTarget.texture.name = "CubeCamera";
    this.update = function(renderer, scene) {
        if (this.parent === null) this.updateMatrixWorld();
        var renderTarget = this.renderTarget;
        var generateMipmaps = renderTarget.texture.generateMipmaps;
        renderTarget.texture.generateMipmaps = false;
        renderTarget.activeCubeFace = 0;
        renderer.render(scene, cameraPX, renderTarget);
        renderTarget.activeCubeFace = 1;
        renderer.render(scene, cameraNX, renderTarget);
        renderTarget.activeCubeFace = 2;
        renderer.render(scene, cameraPY, renderTarget);
        renderTarget.activeCubeFace = 3;
        renderer.render(scene, cameraNY, renderTarget);
        renderTarget.activeCubeFace = 4;
        renderer.render(scene, cameraPZ, renderTarget);
        renderTarget.texture.generateMipmaps = generateMipmaps;
        renderTarget.activeCubeFace = 5;
        renderer.render(scene, cameraNZ, renderTarget);
        renderer.setRenderTarget(null);
    };
    this.clear = function(renderer, color, depth, stencil) {
        var renderTarget = this.renderTarget;
        for(var i = 0; i < 6; i++){
            renderTarget.activeCubeFace = i;
            renderer.setRenderTarget(renderTarget);
            renderer.clear(color, depth, stencil);
        }
        renderer.setRenderTarget(null);
    };
}
CubeCamera.prototype = Object.create(Object3D.prototype);
CubeCamera.prototype.constructor = CubeCamera;
/**
 * @author alteredq / http://alteredqualia.com/
 */ function Clock(autoStart) {
    this.autoStart = autoStart !== undefined ? autoStart : true;
    this.startTime = 0;
    this.oldTime = 0;
    this.elapsedTime = 0;
    this.running = false;
}
Object.assign(Clock.prototype, {
    start: function() {
        this.startTime = (typeof performance === "undefined" ? Date : performance).now(); // see #10732
        this.oldTime = this.startTime;
        this.elapsedTime = 0;
        this.running = true;
    },
    stop: function() {
        this.getElapsedTime();
        this.running = false;
        this.autoStart = false;
    },
    getElapsedTime: function() {
        this.getDelta();
        return this.elapsedTime;
    },
    getDelta: function() {
        var diff = 0;
        if (this.autoStart && !this.running) {
            this.start();
            return 0;
        }
        if (this.running) {
            var newTime = (typeof performance === "undefined" ? Date : performance).now();
            diff = (newTime - this.oldTime) / 1000;
            this.oldTime = newTime;
            this.elapsedTime += diff;
        }
        return diff;
    }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */ function AudioListener() {
    Object3D.call(this);
    this.type = "AudioListener";
    this.context = AudioContext.getContext();
    this.gain = this.context.createGain();
    this.gain.connect(this.context.destination);
    this.filter = null;
    this.timeDelta = 0;
}
AudioListener.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: AudioListener,
    getInput: function() {
        return this.gain;
    },
    removeFilter: function() {
        if (this.filter !== null) {
            this.gain.disconnect(this.filter);
            this.filter.disconnect(this.context.destination);
            this.gain.connect(this.context.destination);
            this.filter = null;
        }
        return this;
    },
    getFilter: function() {
        return this.filter;
    },
    setFilter: function(value) {
        if (this.filter !== null) {
            this.gain.disconnect(this.filter);
            this.filter.disconnect(this.context.destination);
        } else this.gain.disconnect(this.context.destination);
        this.filter = value;
        this.gain.connect(this.filter);
        this.filter.connect(this.context.destination);
        return this;
    },
    getMasterVolume: function() {
        return this.gain.gain.value;
    },
    setMasterVolume: function(value) {
        this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
        return this;
    },
    updateMatrixWorld: function() {
        var position = new Vector3();
        var quaternion = new Quaternion();
        var scale = new Vector3();
        var orientation = new Vector3();
        var clock = new Clock();
        return function updateMatrixWorld(force) {
            Object3D.prototype.updateMatrixWorld.call(this, force);
            var listener = this.context.listener;
            var up = this.up;
            this.timeDelta = clock.getDelta();
            this.matrixWorld.decompose(position, quaternion, scale);
            orientation.set(0, 0, -1).applyQuaternion(quaternion);
            if (listener.positionX) {
                // code path for Chrome (see #14393)
                var endTime = this.context.currentTime + this.timeDelta;
                listener.positionX.linearRampToValueAtTime(position.x, endTime);
                listener.positionY.linearRampToValueAtTime(position.y, endTime);
                listener.positionZ.linearRampToValueAtTime(position.z, endTime);
                listener.forwardX.linearRampToValueAtTime(orientation.x, endTime);
                listener.forwardY.linearRampToValueAtTime(orientation.y, endTime);
                listener.forwardZ.linearRampToValueAtTime(orientation.z, endTime);
                listener.upX.linearRampToValueAtTime(up.x, endTime);
                listener.upY.linearRampToValueAtTime(up.y, endTime);
                listener.upZ.linearRampToValueAtTime(up.z, endTime);
            } else {
                listener.setPosition(position.x, position.y, position.z);
                listener.setOrientation(orientation.x, orientation.y, orientation.z, up.x, up.y, up.z);
            }
        };
    }()
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author Reece Aaron Lecrivain / http://reecenotes.com/
 */ function Audio(listener) {
    Object3D.call(this);
    this.type = "Audio";
    this.listener = listener;
    this.context = listener.context;
    this.gain = this.context.createGain();
    this.gain.connect(listener.getInput());
    this.autoplay = false;
    this.buffer = null;
    this.detune = 0;
    this.loop = false;
    this.startTime = 0;
    this.offset = 0;
    this.playbackRate = 1;
    this.isPlaying = false;
    this.hasPlaybackControl = true;
    this.sourceType = "empty";
    this.filters = [];
}
Audio.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Audio,
    getOutput: function() {
        return this.gain;
    },
    setNodeSource: function(audioNode) {
        this.hasPlaybackControl = false;
        this.sourceType = "audioNode";
        this.source = audioNode;
        this.connect();
        return this;
    },
    setMediaElementSource: function(mediaElement) {
        this.hasPlaybackControl = false;
        this.sourceType = "mediaNode";
        this.source = this.context.createMediaElementSource(mediaElement);
        this.connect();
        return this;
    },
    setBuffer: function(audioBuffer) {
        this.buffer = audioBuffer;
        this.sourceType = "buffer";
        if (this.autoplay) this.play();
        return this;
    },
    play: function() {
        if (this.isPlaying === true) {
            console.warn("THREE.Audio: Audio is already playing.");
            return;
        }
        if (this.hasPlaybackControl === false) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
        }
        var source = this.context.createBufferSource();
        source.buffer = this.buffer;
        source.detune.value = this.detune;
        source.loop = this.loop;
        source.onended = this.onEnded.bind(this);
        source.playbackRate.setValueAtTime(this.playbackRate, this.startTime);
        this.startTime = this.context.currentTime;
        source.start(this.startTime, this.offset);
        this.isPlaying = true;
        this.source = source;
        return this.connect();
    },
    pause: function() {
        if (this.hasPlaybackControl === false) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
        }
        if (this.isPlaying === true) {
            this.source.stop();
            this.source.onended = null;
            this.offset += (this.context.currentTime - this.startTime) * this.playbackRate;
            this.isPlaying = false;
        }
        return this;
    },
    stop: function() {
        if (this.hasPlaybackControl === false) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
        }
        this.source.stop();
        this.source.onended = null;
        this.offset = 0;
        this.isPlaying = false;
        return this;
    },
    connect: function() {
        if (this.filters.length > 0) {
            this.source.connect(this.filters[0]);
            for(var i = 1, l = this.filters.length; i < l; i++)this.filters[i - 1].connect(this.filters[i]);
            this.filters[this.filters.length - 1].connect(this.getOutput());
        } else this.source.connect(this.getOutput());
        return this;
    },
    disconnect: function() {
        if (this.filters.length > 0) {
            this.source.disconnect(this.filters[0]);
            for(var i = 1, l = this.filters.length; i < l; i++)this.filters[i - 1].disconnect(this.filters[i]);
            this.filters[this.filters.length - 1].disconnect(this.getOutput());
        } else this.source.disconnect(this.getOutput());
        return this;
    },
    getFilters: function() {
        return this.filters;
    },
    setFilters: function(value) {
        if (!value) value = [];
        if (this.isPlaying === true) {
            this.disconnect();
            this.filters = value;
            this.connect();
        } else this.filters = value;
        return this;
    },
    setDetune: function(value) {
        this.detune = value;
        if (this.isPlaying === true) this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);
        return this;
    },
    getDetune: function() {
        return this.detune;
    },
    getFilter: function() {
        return this.getFilters()[0];
    },
    setFilter: function(filter) {
        return this.setFilters(filter ? [
            filter
        ] : []);
    },
    setPlaybackRate: function(value) {
        if (this.hasPlaybackControl === false) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
        }
        this.playbackRate = value;
        if (this.isPlaying === true) this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);
        return this;
    },
    getPlaybackRate: function() {
        return this.playbackRate;
    },
    onEnded: function() {
        this.isPlaying = false;
    },
    getLoop: function() {
        if (this.hasPlaybackControl === false) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return false;
        }
        return this.loop;
    },
    setLoop: function(value) {
        if (this.hasPlaybackControl === false) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
        }
        this.loop = value;
        if (this.isPlaying === true) this.source.loop = this.loop;
        return this;
    },
    getVolume: function() {
        return this.gain.gain.value;
    },
    setVolume: function(value) {
        this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
        return this;
    }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */ function PositionalAudio(listener) {
    Audio.call(this, listener);
    this.panner = this.context.createPanner();
    this.panner.connect(this.gain);
}
PositionalAudio.prototype = Object.assign(Object.create(Audio.prototype), {
    constructor: PositionalAudio,
    getOutput: function() {
        return this.panner;
    },
    getRefDistance: function() {
        return this.panner.refDistance;
    },
    setRefDistance: function(value) {
        this.panner.refDistance = value;
        return this;
    },
    getRolloffFactor: function() {
        return this.panner.rolloffFactor;
    },
    setRolloffFactor: function(value) {
        this.panner.rolloffFactor = value;
        return this;
    },
    getDistanceModel: function() {
        return this.panner.distanceModel;
    },
    setDistanceModel: function(value) {
        this.panner.distanceModel = value;
        return this;
    },
    getMaxDistance: function() {
        return this.panner.maxDistance;
    },
    setMaxDistance: function(value) {
        this.panner.maxDistance = value;
        return this;
    },
    setDirectionalCone: function(coneInnerAngle, coneOuterAngle, coneOuterGain) {
        this.panner.coneInnerAngle = coneInnerAngle;
        this.panner.coneOuterAngle = coneOuterAngle;
        this.panner.coneOuterGain = coneOuterGain;
        return this;
    },
    updateMatrixWorld: function() {
        var position = new Vector3();
        var quaternion = new Quaternion();
        var scale = new Vector3();
        var orientation = new Vector3();
        return function updateMatrixWorld(force) {
            Object3D.prototype.updateMatrixWorld.call(this, force);
            if (this.isPlaying === false) return;
            this.matrixWorld.decompose(position, quaternion, scale);
            orientation.set(0, 0, 1).applyQuaternion(quaternion);
            var panner = this.panner;
            if (panner.positionX) {
                // code path for Chrome and Firefox (see #14393)
                var endTime = this.context.currentTime + this.listener.timeDelta;
                panner.positionX.linearRampToValueAtTime(position.x, endTime);
                panner.positionY.linearRampToValueAtTime(position.y, endTime);
                panner.positionZ.linearRampToValueAtTime(position.z, endTime);
                panner.orientationX.linearRampToValueAtTime(orientation.x, endTime);
                panner.orientationY.linearRampToValueAtTime(orientation.y, endTime);
                panner.orientationZ.linearRampToValueAtTime(orientation.z, endTime);
            } else {
                panner.setPosition(position.x, position.y, position.z);
                panner.setOrientation(orientation.x, orientation.y, orientation.z);
            }
        };
    }()
});
/**
 * @author mrdoob / http://mrdoob.com/
 */ function AudioAnalyser(audio, fftSize) {
    this.analyser = audio.context.createAnalyser();
    this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;
    this.data = new Uint8Array(this.analyser.frequencyBinCount);
    audio.getOutput().connect(this.analyser);
}
Object.assign(AudioAnalyser.prototype, {
    getFrequencyData: function() {
        this.analyser.getByteFrequencyData(this.data);
        return this.data;
    },
    getAverageFrequency: function() {
        var value = 0, data = this.getFrequencyData();
        for(var i = 0; i < data.length; i++)value += data[i];
        return value / data.length;
    }
});
/**
 *
 * Buffered scene graph property that allows weighted accumulation.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */ function PropertyMixer(binding, typeName, valueSize) {
    this.binding = binding;
    this.valueSize = valueSize;
    var bufferType = Float64Array, mixFunction;
    switch(typeName){
        case "quaternion":
            mixFunction = this._slerp;
            break;
        case "string":
        case "bool":
            bufferType = Array;
            mixFunction = this._select;
            break;
        default:
            mixFunction = this._lerp;
    }
    this.buffer = new bufferType(valueSize * 4);
    // layout: [ incoming | accu0 | accu1 | orig ]
    //
    // interpolators can use .buffer as their .result
    // the data then goes to 'incoming'
    //
    // 'accu0' and 'accu1' are used frame-interleaved for
    // the cumulative result and are compared to detect
    // changes
    //
    // 'orig' stores the original state of the property
    this._mixBufferRegion = mixFunction;
    this.cumulativeWeight = 0;
    this.useCount = 0;
    this.referenceCount = 0;
}
Object.assign(PropertyMixer.prototype, {
    // accumulate data in the 'incoming' region into 'accu<i>'
    accumulate: function(accuIndex, weight) {
        // note: happily accumulating nothing when weight = 0, the caller knows
        // the weight and shouldn't have made the call in the first place
        var buffer = this.buffer, stride = this.valueSize, offset = accuIndex * stride + stride, currentWeight = this.cumulativeWeight;
        if (currentWeight === 0) {
            // accuN := incoming * weight
            for(var i = 0; i !== stride; ++i)buffer[offset + i] = buffer[i];
            currentWeight = weight;
        } else {
            // accuN := accuN + incoming * weight
            currentWeight += weight;
            var mix = weight / currentWeight;
            this._mixBufferRegion(buffer, offset, 0, mix, stride);
        }
        this.cumulativeWeight = currentWeight;
    },
    // apply the state of 'accu<i>' to the binding when accus differ
    apply: function(accuIndex) {
        var stride = this.valueSize, buffer = this.buffer, offset = accuIndex * stride + stride, weight = this.cumulativeWeight, binding = this.binding;
        this.cumulativeWeight = 0;
        if (weight < 1) {
            // accuN := accuN + original * ( 1 - cumulativeWeight )
            var originalValueOffset = stride * 3;
            this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);
        }
        for(var i = stride, e = stride + stride; i !== e; ++i)if (buffer[i] !== buffer[i + stride]) {
            // value has changed -> update scene graph
            binding.setValue(buffer, offset);
            break;
        }
    },
    // remember the state of the bound property and copy it to both accus
    saveOriginalState: function() {
        var binding = this.binding;
        var buffer = this.buffer, stride = this.valueSize, originalValueOffset = stride * 3;
        binding.getValue(buffer, originalValueOffset);
        // accu[0..1] := orig -- initially detect changes against the original
        for(var i = stride, e = originalValueOffset; i !== e; ++i)buffer[i] = buffer[originalValueOffset + i % stride];
        this.cumulativeWeight = 0;
    },
    // apply the state previously taken via 'saveOriginalState' to the binding
    restoreOriginalState: function() {
        var originalValueOffset = this.valueSize * 3;
        this.binding.setValue(this.buffer, originalValueOffset);
    },
    // mix functions
    _select: function(buffer, dstOffset, srcOffset, t, stride) {
        if (t >= 0.5) for(var i = 0; i !== stride; ++i)buffer[dstOffset + i] = buffer[srcOffset + i];
    },
    _slerp: function(buffer, dstOffset, srcOffset, t) {
        Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);
    },
    _lerp: function(buffer, dstOffset, srcOffset, t, stride) {
        var s = 1 - t;
        for(var i = 0; i !== stride; ++i){
            var j = dstOffset + i;
            buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t;
        }
    }
});
/**
 *
 * A reference to a real property in the scene graph.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */ // Characters [].:/ are reserved for track binding syntax.
var RESERVED_CHARS_RE = "\\[\\]\\.:\\/";
function Composite(targetGroup, path, optionalParsedPath) {
    var parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
    this._targetGroup = targetGroup;
    this._bindings = targetGroup.subscribe_(path, parsedPath);
}
Object.assign(Composite.prototype, {
    getValue: function(array, offset) {
        this.bind(); // bind all binding
        var firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
        // and only call .getValue on the first
        if (binding !== undefined) binding.getValue(array, offset);
    },
    setValue: function(array, offset) {
        var bindings = this._bindings;
        for(var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i)bindings[i].setValue(array, offset);
    },
    bind: function() {
        var bindings = this._bindings;
        for(var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i)bindings[i].bind();
    },
    unbind: function() {
        var bindings = this._bindings;
        for(var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i)bindings[i].unbind();
    }
});
function PropertyBinding(rootNode, path, parsedPath) {
    this.path = path;
    this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
    this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
    this.rootNode = rootNode;
}
Object.assign(PropertyBinding, {
    Composite: Composite,
    create: function(root, path, parsedPath) {
        if (!(root && root.isAnimationObjectGroup)) return new PropertyBinding(root, path, parsedPath);
        else return new PropertyBinding.Composite(root, path, parsedPath);
    },
    /**
	 * Replaces spaces with underscores and removes unsupported characters from
	 * node names, to ensure compatibility with parseTrackName().
	 *
	 * @param  {string} name Node name to be sanitized.
	 * @return {string}
	 */ sanitizeNodeName: function() {
        var reservedRe = new RegExp("[" + RESERVED_CHARS_RE + "]", "g");
        return function sanitizeNodeName(name) {
            return name.replace(/\s/g, "_").replace(reservedRe, "");
        };
    }(),
    parseTrackName: function() {
        // Attempts to allow node names from any language. ES5's `\w` regexp matches
        // only latin characters, and the unicode \p{L} is not yet supported. So
        // instead, we exclude reserved characters and match everything else.
        var wordChar = "[^" + RESERVED_CHARS_RE + "]";
        var wordCharOrDot = "[^" + RESERVED_CHARS_RE.replace("\\.", "") + "]";
        // Parent directories, delimited by '/' or ':'. Currently unused, but must
        // be matched to parse the rest of the track name.
        var directoryRe = /((?:WC+[\/:])*)/.source.replace("WC", wordChar);
        // Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
        var nodeRe = /(WCOD+)?/.source.replace("WCOD", wordCharOrDot);
        // Object on target node, and accessor. May not contain reserved
        // characters. Accessor may contain any character except closing bracket.
        var objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", wordChar);
        // Property and accessor. May not contain reserved characters. Accessor may
        // contain any non-bracket characters.
        var propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", wordChar);
        var trackRe = new RegExp("^" + directoryRe + nodeRe + objectRe + propertyRe + "$");
        var supportedObjectNames = [
            "material",
            "materials",
            "bones"
        ];
        return function parseTrackName(trackName) {
            var matches = trackRe.exec(trackName);
            if (!matches) throw new Error("PropertyBinding: Cannot parse trackName: " + trackName);
            var results = {
                // directoryName: matches[ 1 ], // (tschw) currently unused
                nodeName: matches[2],
                objectName: matches[3],
                objectIndex: matches[4],
                propertyName: matches[5],
                propertyIndex: matches[6]
            };
            var lastDot = results.nodeName && results.nodeName.lastIndexOf(".");
            if (lastDot !== undefined && lastDot !== -1) {
                var objectName = results.nodeName.substring(lastDot + 1);
                // Object names must be checked against a whitelist. Otherwise, there
                // is no way to parse 'foo.bar.baz': 'baz' must be a property, but
                // 'bar' could be the objectName, or part of a nodeName (which can
                // include '.' characters).
                if (supportedObjectNames.indexOf(objectName) !== -1) {
                    results.nodeName = results.nodeName.substring(0, lastDot);
                    results.objectName = objectName;
                }
            }
            if (results.propertyName === null || results.propertyName.length === 0) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + trackName);
            return results;
        };
    }(),
    findNode: function(root, nodeName) {
        if (!nodeName || nodeName === "" || nodeName === "root" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) return root;
        // search into skeleton bones.
        if (root.skeleton) {
            var bone = root.skeleton.getBoneByName(nodeName);
            if (bone !== undefined) return bone;
        }
        // search into node subtree.
        if (root.children) {
            var searchNodeSubtree = function(children) {
                for(var i = 0; i < children.length; i++){
                    var childNode = children[i];
                    if (childNode.name === nodeName || childNode.uuid === nodeName) return childNode;
                    var result = searchNodeSubtree(childNode.children);
                    if (result) return result;
                }
                return null;
            };
            var subTreeNode = searchNodeSubtree(root.children);
            if (subTreeNode) return subTreeNode;
        }
        return null;
    }
});
Object.assign(PropertyBinding.prototype, {
    // these are used to "bind" a nonexistent property
    _getValue_unavailable: function() {},
    _setValue_unavailable: function() {},
    BindingType: {
        Direct: 0,
        EntireArray: 1,
        ArrayElement: 2,
        HasFromToArray: 3
    },
    Versioning: {
        None: 0,
        NeedsUpdate: 1,
        MatrixWorldNeedsUpdate: 2
    },
    GetterByBindingType: [
        function getValue_direct(buffer, offset) {
            buffer[offset] = this.node[this.propertyName];
        },
        function getValue_array(buffer, offset) {
            var source = this.resolvedProperty;
            for(var i = 0, n = source.length; i !== n; ++i)buffer[offset++] = source[i];
        },
        function getValue_arrayElement(buffer, offset) {
            buffer[offset] = this.resolvedProperty[this.propertyIndex];
        },
        function getValue_toArray(buffer, offset) {
            this.resolvedProperty.toArray(buffer, offset);
        }
    ],
    SetterByBindingTypeAndVersioning: [
        [
            // Direct
            function setValue_direct(buffer, offset) {
                this.targetObject[this.propertyName] = buffer[offset];
            },
            function setValue_direct_setNeedsUpdate(buffer, offset) {
                this.targetObject[this.propertyName] = buffer[offset];
                this.targetObject.needsUpdate = true;
            },
            function setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
                this.targetObject[this.propertyName] = buffer[offset];
                this.targetObject.matrixWorldNeedsUpdate = true;
            }
        ],
        [
            // EntireArray
            function setValue_array(buffer, offset) {
                var dest = this.resolvedProperty;
                for(var i = 0, n = dest.length; i !== n; ++i)dest[i] = buffer[offset++];
            },
            function setValue_array_setNeedsUpdate(buffer, offset) {
                var dest = this.resolvedProperty;
                for(var i = 0, n = dest.length; i !== n; ++i)dest[i] = buffer[offset++];
                this.targetObject.needsUpdate = true;
            },
            function setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
                var dest = this.resolvedProperty;
                for(var i = 0, n = dest.length; i !== n; ++i)dest[i] = buffer[offset++];
                this.targetObject.matrixWorldNeedsUpdate = true;
            }
        ],
        [
            // ArrayElement
            function setValue_arrayElement(buffer, offset) {
                this.resolvedProperty[this.propertyIndex] = buffer[offset];
            },
            function setValue_arrayElement_setNeedsUpdate(buffer, offset) {
                this.resolvedProperty[this.propertyIndex] = buffer[offset];
                this.targetObject.needsUpdate = true;
            },
            function setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
                this.resolvedProperty[this.propertyIndex] = buffer[offset];
                this.targetObject.matrixWorldNeedsUpdate = true;
            }
        ],
        [
            // HasToFromArray
            function setValue_fromArray(buffer, offset) {
                this.resolvedProperty.fromArray(buffer, offset);
            },
            function setValue_fromArray_setNeedsUpdate(buffer, offset) {
                this.resolvedProperty.fromArray(buffer, offset);
                this.targetObject.needsUpdate = true;
            },
            function setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
                this.resolvedProperty.fromArray(buffer, offset);
                this.targetObject.matrixWorldNeedsUpdate = true;
            }
        ]
    ],
    getValue: function getValue_unbound(targetArray, offset) {
        this.bind();
        this.getValue(targetArray, offset);
    // Note: This class uses a State pattern on a per-method basis:
    // 'bind' sets 'this.getValue' / 'setValue' and shadows the
    // prototype version of these methods with one that represents
    // the bound state. When the property is not found, the methods
    // become no-ops.
    },
    setValue: function getValue_unbound(sourceArray, offset) {
        this.bind();
        this.setValue(sourceArray, offset);
    },
    // create getter / setter pair for a property in the scene graph
    bind: function() {
        var targetObject = this.node, parsedPath = this.parsedPath, objectName = parsedPath.objectName, propertyName = parsedPath.propertyName, propertyIndex = parsedPath.propertyIndex;
        if (!targetObject) {
            targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
            this.node = targetObject;
        }
        // set fail state so we can just 'return' on error
        this.getValue = this._getValue_unavailable;
        this.setValue = this._setValue_unavailable;
        // ensure there is a value node
        if (!targetObject) {
            console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
            return;
        }
        if (objectName) {
            var objectIndex = parsedPath.objectIndex;
            // special cases were we need to reach deeper into the hierarchy to get the face materials....
            switch(objectName){
                case "materials":
                    if (!targetObject.material) {
                        console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                        return;
                    }
                    if (!targetObject.material.materials) {
                        console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                        return;
                    }
                    targetObject = targetObject.material.materials;
                    break;
                case "bones":
                    if (!targetObject.skeleton) {
                        console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                        return;
                    }
                    // potential future optimization: skip this if propertyIndex is already an integer
                    // and convert the integer string to a true integer.
                    targetObject = targetObject.skeleton.bones;
                    // support resolving morphTarget names into indices.
                    for(var i = 0; i < targetObject.length; i++)if (targetObject[i].name === objectIndex) {
                        objectIndex = i;
                        break;
                    }
                    break;
                default:
                    if (targetObject[objectName] === undefined) {
                        console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                        return;
                    }
                    targetObject = targetObject[objectName];
            }
            if (objectIndex !== undefined) {
                if (targetObject[objectIndex] === undefined) {
                    console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, targetObject);
                    return;
                }
                targetObject = targetObject[objectIndex];
            }
        }
        // resolve property
        var nodeProperty = targetObject[propertyName];
        if (nodeProperty === undefined) {
            var nodeName = parsedPath.nodeName;
            console.error("THREE.PropertyBinding: Trying to update property for track: " + nodeName + "." + propertyName + " but it wasn't found.", targetObject);
            return;
        }
        // determine versioning scheme
        var versioning = this.Versioning.None;
        this.targetObject = targetObject;
        if (targetObject.needsUpdate !== undefined) versioning = this.Versioning.NeedsUpdate;
        else if (targetObject.matrixWorldNeedsUpdate !== undefined) versioning = this.Versioning.MatrixWorldNeedsUpdate;
        // determine how the property gets bound
        var bindingType = this.BindingType.Direct;
        if (propertyIndex !== undefined) {
            // access a sub element of the property array (only primitives are supported right now)
            if (propertyName === "morphTargetInfluences") {
                // potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.
                // support resolving morphTarget names into indices.
                if (!targetObject.geometry) {
                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                    return;
                }
                if (targetObject.geometry.isBufferGeometry) {
                    if (!targetObject.geometry.morphAttributes) {
                        console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                        return;
                    }
                    for(var i = 0; i < this.node.geometry.morphAttributes.position.length; i++)if (targetObject.geometry.morphAttributes.position[i].name === propertyIndex) {
                        propertyIndex = i;
                        break;
                    }
                } else {
                    if (!targetObject.geometry.morphTargets) {
                        console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this);
                        return;
                    }
                    for(var i = 0; i < this.node.geometry.morphTargets.length; i++)if (targetObject.geometry.morphTargets[i].name === propertyIndex) {
                        propertyIndex = i;
                        break;
                    }
                }
            }
            bindingType = this.BindingType.ArrayElement;
            this.resolvedProperty = nodeProperty;
            this.propertyIndex = propertyIndex;
        } else if (nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined) {
            // must use copy for Object3D.Euler/Quaternion
            bindingType = this.BindingType.HasFromToArray;
            this.resolvedProperty = nodeProperty;
        } else if (Array.isArray(nodeProperty)) {
            bindingType = this.BindingType.EntireArray;
            this.resolvedProperty = nodeProperty;
        } else this.propertyName = propertyName;
        // select getter / setter
        this.getValue = this.GetterByBindingType[bindingType];
        this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
    },
    unbind: function() {
        this.node = null;
        // back to the prototype version of getValue / setValue
        // note: avoiding to mutate the shape of 'this' via 'delete'
        this.getValue = this._getValue_unbound;
        this.setValue = this._setValue_unbound;
    }
});
//!\ DECLARE ALIAS AFTER assign prototype !
Object.assign(PropertyBinding.prototype, {
    // initial state of these methods that calls 'bind'
    _getValue_unbound: PropertyBinding.prototype.getValue,
    _setValue_unbound: PropertyBinding.prototype.setValue
});
/**
 *
 * A group of objects that receives a shared animation state.
 *
 * Usage:
 *
 *  - Add objects you would otherwise pass as 'root' to the
 *    constructor or the .clipAction method of AnimationMixer.
 *
 *  - Instead pass this object as 'root'.
 *
 *  - You can also add and remove objects later when the mixer
 *    is running.
 *
 * Note:
 *
 *    Objects of this class appear as one object to the mixer,
 *    so cache control of the individual objects must be done
 *    on the group.
 *
 * Limitation:
 *
 *  - The animated properties must be compatible among the
 *    all objects in the group.
 *
 *  - A single property can either be controlled through a
 *    target group or directly, but not both.
 *
 * @author tschw
 */ function AnimationObjectGroup() {
    this.uuid = _Math.generateUUID();
    // cached objects followed by the active ones
    this._objects = Array.prototype.slice.call(arguments);
    this.nCachedObjects_ = 0; // threshold
    // note: read by PropertyBinding.Composite
    var indices = {};
    this._indicesByUUID = indices; // for bookkeeping
    for(var i = 0, n = arguments.length; i !== n; ++i)indices[arguments[i].uuid] = i;
    this._paths = []; // inside: string
    this._parsedPaths = []; // inside: { we don't care, here }
    this._bindings = []; // inside: Array< PropertyBinding >
    this._bindingsIndicesByPath = {}; // inside: indices in these arrays
    var scope = this;
    this.stats = {
        objects: {
            get total () {
                return scope._objects.length;
            },
            get inUse () {
                return this.total - scope.nCachedObjects_;
            }
        },
        get bindingsPerObject () {
            return scope._bindings.length;
        }
    };
}
Object.assign(AnimationObjectGroup.prototype, {
    isAnimationObjectGroup: true,
    add: function() {
        var objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, indicesByUUID = this._indicesByUUID, paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, nBindings = bindings.length, knownObject = undefined;
        for(var i = 0, n = arguments.length; i !== n; ++i){
            var object = arguments[i], uuid = object.uuid, index = indicesByUUID[uuid];
            if (index === undefined) {
                // unknown object -> add it to the ACTIVE region
                index = nObjects++;
                indicesByUUID[uuid] = index;
                objects.push(object);
                // accounting is done, now do the same for all bindings
                for(var j = 0, m = nBindings; j !== m; ++j)bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));
            } else if (index < nCachedObjects) {
                knownObject = objects[index];
                // move existing object to the ACTIVE region
                var firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex];
                indicesByUUID[lastCachedObject.uuid] = index;
                objects[index] = lastCachedObject;
                indicesByUUID[uuid] = firstActiveIndex;
                objects[firstActiveIndex] = object;
                // accounting is done, now do the same for all bindings
                for(var j = 0, m = nBindings; j !== m; ++j){
                    var bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex], binding = bindingsForPath[index];
                    bindingsForPath[index] = lastCached;
                    if (binding === undefined) // since we do not bother to create new bindings
                    // for objects that are cached, the binding may
                    // or may not exist
                    binding = new PropertyBinding(object, paths[j], parsedPaths[j]);
                    bindingsForPath[firstActiveIndex] = binding;
                }
            } else if (objects[index] !== knownObject) console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
             // else the object is already where we want it to be
        } // for arguments
        this.nCachedObjects_ = nCachedObjects;
    },
    remove: function() {
        var objects = this._objects, nCachedObjects = this.nCachedObjects_, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
        for(var i = 0, n = arguments.length; i !== n; ++i){
            var object = arguments[i], uuid = object.uuid, index = indicesByUUID[uuid];
            if (index !== undefined && index >= nCachedObjects) {
                // move existing object into the CACHED region
                var lastCachedIndex = nCachedObjects++, firstActiveObject = objects[lastCachedIndex];
                indicesByUUID[firstActiveObject.uuid] = index;
                objects[index] = firstActiveObject;
                indicesByUUID[uuid] = lastCachedIndex;
                objects[lastCachedIndex] = object;
                // accounting is done, now do the same for all bindings
                for(var j = 0, m = nBindings; j !== m; ++j){
                    var bindingsForPath = bindings[j], firstActive = bindingsForPath[lastCachedIndex], binding = bindingsForPath[index];
                    bindingsForPath[index] = firstActive;
                    bindingsForPath[lastCachedIndex] = binding;
                }
            }
        } // for arguments
        this.nCachedObjects_ = nCachedObjects;
    },
    // remove & forget
    uncache: function() {
        var objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
        for(var i = 0, n = arguments.length; i !== n; ++i){
            var object = arguments[i], uuid = object.uuid, index = indicesByUUID[uuid];
            if (index !== undefined) {
                delete indicesByUUID[uuid];
                if (index < nCachedObjects) {
                    // object is cached, shrink the CACHED region
                    var firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex], lastIndex = --nObjects, lastObject = objects[lastIndex];
                    // last cached object takes this object's place
                    indicesByUUID[lastCachedObject.uuid] = index;
                    objects[index] = lastCachedObject;
                    // last object goes to the activated slot and pop
                    indicesByUUID[lastObject.uuid] = firstActiveIndex;
                    objects[firstActiveIndex] = lastObject;
                    objects.pop();
                    // accounting is done, now do the same for all bindings
                    for(var j = 0, m = nBindings; j !== m; ++j){
                        var bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex], last = bindingsForPath[lastIndex];
                        bindingsForPath[index] = lastCached;
                        bindingsForPath[firstActiveIndex] = last;
                        bindingsForPath.pop();
                    }
                } else {
                    // object is active, just swap with the last and pop
                    var lastIndex = --nObjects, lastObject = objects[lastIndex];
                    indicesByUUID[lastObject.uuid] = index;
                    objects[index] = lastObject;
                    objects.pop();
                    // accounting is done, now do the same for all bindings
                    for(var j = 0, m = nBindings; j !== m; ++j){
                        var bindingsForPath = bindings[j];
                        bindingsForPath[index] = bindingsForPath[lastIndex];
                        bindingsForPath.pop();
                    }
                } // cached or active
            } // if object is known
        } // for arguments
        this.nCachedObjects_ = nCachedObjects;
    },
    // Internal interface used by befriended PropertyBinding.Composite:
    subscribe_: function(path, parsedPath) {
        // returns an array of bindings for the given path that is changed
        // according to the contained objects in the group
        var indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[path], bindings = this._bindings;
        if (index !== undefined) return bindings[index];
        var paths = this._paths, parsedPaths = this._parsedPaths, objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, bindingsForPath = new Array(nObjects);
        index = bindings.length;
        indicesByPath[path] = index;
        paths.push(path);
        parsedPaths.push(parsedPath);
        bindings.push(bindingsForPath);
        for(var i = nCachedObjects, n = objects.length; i !== n; ++i){
            var object = objects[i];
            bindingsForPath[i] = new PropertyBinding(object, path, parsedPath);
        }
        return bindingsForPath;
    },
    unsubscribe_: function(path) {
        // tells the group to forget about a property path and no longer
        // update the array previously obtained with 'subscribe_'
        var indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[path];
        if (index !== undefined) {
            var paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, lastBindingsIndex = bindings.length - 1, lastBindings = bindings[lastBindingsIndex], lastBindingsPath = path[lastBindingsIndex];
            indicesByPath[lastBindingsPath] = index;
            bindings[index] = lastBindings;
            bindings.pop();
            parsedPaths[index] = parsedPaths[lastBindingsIndex];
            parsedPaths.pop();
            paths[index] = paths[lastBindingsIndex];
            paths.pop();
        }
    }
});
/**
 *
 * Action provided by AnimationMixer for scheduling clip playback on specific
 * objects.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 *
 */ function AnimationAction(mixer, clip, localRoot) {
    this._mixer = mixer;
    this._clip = clip;
    this._localRoot = localRoot || null;
    var tracks = clip.tracks, nTracks = tracks.length, interpolants = new Array(nTracks);
    var interpolantSettings = {
        endingStart: ZeroCurvatureEnding,
        endingEnd: ZeroCurvatureEnding
    };
    for(var i = 0; i !== nTracks; ++i){
        var interpolant = tracks[i].createInterpolant(null);
        interpolants[i] = interpolant;
        interpolant.settings = interpolantSettings;
    }
    this._interpolantSettings = interpolantSettings;
    this._interpolants = interpolants; // bound by the mixer
    // inside: PropertyMixer (managed by the mixer)
    this._propertyBindings = new Array(nTracks);
    this._cacheIndex = null; // for the memory manager
    this._byClipCacheIndex = null; // for the memory manager
    this._timeScaleInterpolant = null;
    this._weightInterpolant = null;
    this.loop = LoopRepeat;
    this._loopCount = -1;
    // global mixer time when the action is to be started
    // it's set back to 'null' upon start of the action
    this._startTime = null;
    // scaled local time of the action
    // gets clamped or wrapped to 0..clip.duration according to loop
    this.time = 0;
    this.timeScale = 1;
    this._effectiveTimeScale = 1;
    this.weight = 1;
    this._effectiveWeight = 1;
    this.repetitions = Infinity; // no. of repetitions when looping
    this.paused = false; // true -> zero effective time scale
    this.enabled = true; // false -> zero effective weight
    this.clampWhenFinished = false; // keep feeding the last frame?
    this.zeroSlopeAtStart = true; // for smooth interpolation w/o separate
    this.zeroSlopeAtEnd = true; // clips for start, loop and end
}
Object.assign(AnimationAction.prototype, {
    // State & Scheduling
    play: function() {
        this._mixer._activateAction(this);
        return this;
    },
    stop: function() {
        this._mixer._deactivateAction(this);
        return this.reset();
    },
    reset: function() {
        this.paused = false;
        this.enabled = true;
        this.time = 0; // restart clip
        this._loopCount = -1; // forget previous loops
        this._startTime = null; // forget scheduling
        return this.stopFading().stopWarping();
    },
    isRunning: function() {
        return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
    },
    // return true when play has been called
    isScheduled: function() {
        return this._mixer._isActiveAction(this);
    },
    startAt: function(time) {
        this._startTime = time;
        return this;
    },
    setLoop: function(mode, repetitions) {
        this.loop = mode;
        this.repetitions = repetitions;
        return this;
    },
    // Weight
    // set the weight stopping any scheduled fading
    // although .enabled = false yields an effective weight of zero, this
    // method does *not* change .enabled, because it would be confusing
    setEffectiveWeight: function(weight) {
        this.weight = weight;
        // note: same logic as when updated at runtime
        this._effectiveWeight = this.enabled ? weight : 0;
        return this.stopFading();
    },
    // return the weight considering fading and .enabled
    getEffectiveWeight: function() {
        return this._effectiveWeight;
    },
    fadeIn: function(duration) {
        return this._scheduleFading(duration, 0, 1);
    },
    fadeOut: function(duration) {
        return this._scheduleFading(duration, 1, 0);
    },
    crossFadeFrom: function(fadeOutAction, duration, warp) {
        fadeOutAction.fadeOut(duration);
        this.fadeIn(duration);
        if (warp) {
            var fadeInDuration = this._clip.duration, fadeOutDuration = fadeOutAction._clip.duration, startEndRatio = fadeOutDuration / fadeInDuration, endStartRatio = fadeInDuration / fadeOutDuration;
            fadeOutAction.warp(1.0, startEndRatio, duration);
            this.warp(endStartRatio, 1.0, duration);
        }
        return this;
    },
    crossFadeTo: function(fadeInAction, duration, warp) {
        return fadeInAction.crossFadeFrom(this, duration, warp);
    },
    stopFading: function() {
        var weightInterpolant = this._weightInterpolant;
        if (weightInterpolant !== null) {
            this._weightInterpolant = null;
            this._mixer._takeBackControlInterpolant(weightInterpolant);
        }
        return this;
    },
    // Time Scale Control
    // set the time scale stopping any scheduled warping
    // although .paused = true yields an effective time scale of zero, this
    // method does *not* change .paused, because it would be confusing
    setEffectiveTimeScale: function(timeScale) {
        this.timeScale = timeScale;
        this._effectiveTimeScale = this.paused ? 0 : timeScale;
        return this.stopWarping();
    },
    // return the time scale considering warping and .paused
    getEffectiveTimeScale: function() {
        return this._effectiveTimeScale;
    },
    setDuration: function(duration) {
        this.timeScale = this._clip.duration / duration;
        return this.stopWarping();
    },
    syncWith: function(action) {
        this.time = action.time;
        this.timeScale = action.timeScale;
        return this.stopWarping();
    },
    halt: function(duration) {
        return this.warp(this._effectiveTimeScale, 0, duration);
    },
    warp: function(startTimeScale, endTimeScale, duration) {
        var mixer = this._mixer, now = mixer.time, interpolant = this._timeScaleInterpolant, timeScale = this.timeScale;
        if (interpolant === null) {
            interpolant = mixer._lendControlInterpolant();
            this._timeScaleInterpolant = interpolant;
        }
        var times = interpolant.parameterPositions, values = interpolant.sampleValues;
        times[0] = now;
        times[1] = now + duration;
        values[0] = startTimeScale / timeScale;
        values[1] = endTimeScale / timeScale;
        return this;
    },
    stopWarping: function() {
        var timeScaleInterpolant = this._timeScaleInterpolant;
        if (timeScaleInterpolant !== null) {
            this._timeScaleInterpolant = null;
            this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
        }
        return this;
    },
    // Object Accessors
    getMixer: function() {
        return this._mixer;
    },
    getClip: function() {
        return this._clip;
    },
    getRoot: function() {
        return this._localRoot || this._mixer._root;
    },
    // Interna
    _update: function(time, deltaTime, timeDirection, accuIndex) {
        // called by the mixer
        if (!this.enabled) {
            // call ._updateWeight() to update ._effectiveWeight
            this._updateWeight(time);
            return;
        }
        var startTime = this._startTime;
        if (startTime !== null) {
            // check for scheduled start of action
            var timeRunning = (time - startTime) * timeDirection;
            if (timeRunning < 0 || timeDirection === 0) return; // yet to come / don't decide when delta = 0
            // start
            this._startTime = null; // unschedule
            deltaTime = timeDirection * timeRunning;
        }
        // apply time scale and advance time
        deltaTime *= this._updateTimeScale(time);
        var clipTime = this._updateTime(deltaTime);
        // note: _updateTime may disable the action resulting in
        // an effective weight of 0
        var weight = this._updateWeight(time);
        if (weight > 0) {
            var interpolants = this._interpolants;
            var propertyMixers = this._propertyBindings;
            for(var j = 0, m = interpolants.length; j !== m; ++j){
                interpolants[j].evaluate(clipTime);
                propertyMixers[j].accumulate(accuIndex, weight);
            }
        }
    },
    _updateWeight: function(time) {
        var weight = 0;
        if (this.enabled) {
            weight = this.weight;
            var interpolant = this._weightInterpolant;
            if (interpolant !== null) {
                var interpolantValue = interpolant.evaluate(time)[0];
                weight *= interpolantValue;
                if (time > interpolant.parameterPositions[1]) {
                    this.stopFading();
                    if (interpolantValue === 0) // faded out, disable
                    this.enabled = false;
                }
            }
        }
        this._effectiveWeight = weight;
        return weight;
    },
    _updateTimeScale: function(time) {
        var timeScale = 0;
        if (!this.paused) {
            timeScale = this.timeScale;
            var interpolant = this._timeScaleInterpolant;
            if (interpolant !== null) {
                var interpolantValue = interpolant.evaluate(time)[0];
                timeScale *= interpolantValue;
                if (time > interpolant.parameterPositions[1]) {
                    this.stopWarping();
                    if (timeScale === 0) // motion has halted, pause
                    this.paused = true;
                    else // warp done - apply final time scale
                    this.timeScale = timeScale;
                }
            }
        }
        this._effectiveTimeScale = timeScale;
        return timeScale;
    },
    _updateTime: function(deltaTime) {
        var time = this.time + deltaTime;
        var duration = this._clip.duration;
        var loop = this.loop;
        var loopCount = this._loopCount;
        var pingPong = loop === LoopPingPong;
        if (deltaTime === 0) {
            if (loopCount === -1) return time;
            return pingPong && (loopCount & 1) === 1 ? duration - time : time;
        }
        if (loop === LoopOnce) {
            if (loopCount === -1) {
                // just started
                this._loopCount = 0;
                this._setEndings(true, true, false);
            }
            handle_stop: {
                if (time >= duration) time = duration;
                else if (time < 0) time = 0;
                else break handle_stop;
                if (this.clampWhenFinished) this.paused = true;
                else this.enabled = false;
                this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: deltaTime < 0 ? -1 : 1
                });
            }
        } else {
            if (loopCount === -1) {
                // just started
                if (deltaTime >= 0) {
                    loopCount = 0;
                    this._setEndings(true, this.repetitions === 0, pingPong);
                } else // when looping in reverse direction, the initial
                // transition through zero counts as a repetition,
                // so leave loopCount at -1
                this._setEndings(this.repetitions === 0, true, pingPong);
            }
            if (time >= duration || time < 0) {
                // wrap around
                var loopDelta = Math.floor(time / duration); // signed
                time -= duration * loopDelta;
                loopCount += Math.abs(loopDelta);
                var pending = this.repetitions - loopCount;
                if (pending <= 0) {
                    // have to stop (switch state, clamp time, fire event)
                    if (this.clampWhenFinished) this.paused = true;
                    else this.enabled = false;
                    time = deltaTime > 0 ? duration : 0;
                    this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: deltaTime > 0 ? 1 : -1
                    });
                } else {
                    // keep running
                    if (pending === 1) {
                        // entering the last round
                        var atStart = deltaTime < 0;
                        this._setEndings(atStart, !atStart, pingPong);
                    } else this._setEndings(false, false, pingPong);
                    this._loopCount = loopCount;
                    this._mixer.dispatchEvent({
                        type: "loop",
                        action: this,
                        loopDelta: loopDelta
                    });
                }
            }
            if (pingPong && (loopCount & 1) === 1) {
                // invert time for the "pong round"
                this.time = time;
                return duration - time;
            }
        }
        this.time = time;
        return time;
    },
    _setEndings: function(atStart, atEnd, pingPong) {
        var settings = this._interpolantSettings;
        if (pingPong) {
            settings.endingStart = ZeroSlopeEnding;
            settings.endingEnd = ZeroSlopeEnding;
        } else {
            // assuming for LoopOnce atStart == atEnd == true
            if (atStart) settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
            else settings.endingStart = WrapAroundEnding;
            if (atEnd) settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
            else settings.endingEnd = WrapAroundEnding;
        }
    },
    _scheduleFading: function(duration, weightNow, weightThen) {
        var mixer = this._mixer, now = mixer.time, interpolant = this._weightInterpolant;
        if (interpolant === null) {
            interpolant = mixer._lendControlInterpolant();
            this._weightInterpolant = interpolant;
        }
        var times = interpolant.parameterPositions, values = interpolant.sampleValues;
        times[0] = now;
        values[0] = weightNow;
        times[1] = now + duration;
        values[1] = weightThen;
        return this;
    }
});
/**
 *
 * Player for AnimationClips.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */ function AnimationMixer(root) {
    this._root = root;
    this._initMemoryManager();
    this._accuIndex = 0;
    this.time = 0;
    this.timeScale = 1.0;
}
AnimationMixer.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
    constructor: AnimationMixer,
    _bindAction: function(action, prototypeAction) {
        var root = action._localRoot || this._root, tracks = action._clip.tracks, nTracks = tracks.length, bindings = action._propertyBindings, interpolants = action._interpolants, rootUuid = root.uuid, bindingsByRoot = this._bindingsByRootAndName, bindingsByName = bindingsByRoot[rootUuid];
        if (bindingsByName === undefined) {
            bindingsByName = {};
            bindingsByRoot[rootUuid] = bindingsByName;
        }
        for(var i = 0; i !== nTracks; ++i){
            var track = tracks[i], trackName = track.name, binding = bindingsByName[trackName];
            if (binding !== undefined) bindings[i] = binding;
            else {
                binding = bindings[i];
                if (binding !== undefined) {
                    // existing binding, make sure the cache knows
                    if (binding._cacheIndex === null) {
                        ++binding.referenceCount;
                        this._addInactiveBinding(binding, rootUuid, trackName);
                    }
                    continue;
                }
                var path = prototypeAction && prototypeAction._propertyBindings[i].binding.parsedPath;
                binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());
                ++binding.referenceCount;
                this._addInactiveBinding(binding, rootUuid, trackName);
                bindings[i] = binding;
            }
            interpolants[i].resultBuffer = binding.buffer;
        }
    },
    _activateAction: function(action) {
        if (!this._isActiveAction(action)) {
            if (action._cacheIndex === null) {
                // this action has been forgotten by the cache, but the user
                // appears to be still using it -> rebind
                var rootUuid = (action._localRoot || this._root).uuid, clipUuid = action._clip.uuid, actionsForClip = this._actionsByClip[clipUuid];
                this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);
                this._addInactiveAction(action, clipUuid, rootUuid);
            }
            var bindings = action._propertyBindings;
            // increment reference counts / sort out state
            for(var i = 0, n = bindings.length; i !== n; ++i){
                var binding = bindings[i];
                if (binding.useCount++ === 0) {
                    this._lendBinding(binding);
                    binding.saveOriginalState();
                }
            }
            this._lendAction(action);
        }
    },
    _deactivateAction: function(action) {
        if (this._isActiveAction(action)) {
            var bindings = action._propertyBindings;
            // decrement reference counts / sort out state
            for(var i = 0, n = bindings.length; i !== n; ++i){
                var binding = bindings[i];
                if (--binding.useCount === 0) {
                    binding.restoreOriginalState();
                    this._takeBackBinding(binding);
                }
            }
            this._takeBackAction(action);
        }
    },
    // Memory manager
    _initMemoryManager: function() {
        this._actions = []; // 'nActiveActions' followed by inactive ones
        this._nActiveActions = 0;
        this._actionsByClip = {};
        // inside:
        // {
        // 	knownActions: Array< AnimationAction > - used as prototypes
        // 	actionByRoot: AnimationAction - lookup
        // }
        this._bindings = []; // 'nActiveBindings' followed by inactive ones
        this._nActiveBindings = 0;
        this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >
        this._controlInterpolants = []; // same game as above
        this._nActiveControlInterpolants = 0;
        var scope = this;
        this.stats = {
            actions: {
                get total () {
                    return scope._actions.length;
                },
                get inUse () {
                    return scope._nActiveActions;
                }
            },
            bindings: {
                get total () {
                    return scope._bindings.length;
                },
                get inUse () {
                    return scope._nActiveBindings;
                }
            },
            controlInterpolants: {
                get total () {
                    return scope._controlInterpolants.length;
                },
                get inUse () {
                    return scope._nActiveControlInterpolants;
                }
            }
        };
    },
    // Memory management for AnimationAction objects
    _isActiveAction: function(action) {
        var index = action._cacheIndex;
        return index !== null && index < this._nActiveActions;
    },
    _addInactiveAction: function(action, clipUuid, rootUuid) {
        var actions = this._actions, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
        if (actionsForClip === undefined) {
            actionsForClip = {
                knownActions: [
                    action
                ],
                actionByRoot: {}
            };
            action._byClipCacheIndex = 0;
            actionsByClip[clipUuid] = actionsForClip;
        } else {
            var knownActions = actionsForClip.knownActions;
            action._byClipCacheIndex = knownActions.length;
            knownActions.push(action);
        }
        action._cacheIndex = actions.length;
        actions.push(action);
        actionsForClip.actionByRoot[rootUuid] = action;
    },
    _removeInactiveAction: function(action) {
        var actions = this._actions, lastInactiveAction = actions[actions.length - 1], cacheIndex = action._cacheIndex;
        lastInactiveAction._cacheIndex = cacheIndex;
        actions[cacheIndex] = lastInactiveAction;
        actions.pop();
        action._cacheIndex = null;
        var clipUuid = action._clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid], knownActionsForClip = actionsForClip.knownActions, lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1], byClipCacheIndex = action._byClipCacheIndex;
        lastKnownAction._byClipCacheIndex = byClipCacheIndex;
        knownActionsForClip[byClipCacheIndex] = lastKnownAction;
        knownActionsForClip.pop();
        action._byClipCacheIndex = null;
        var actionByRoot = actionsForClip.actionByRoot, rootUuid = (action._localRoot || this._root).uuid;
        delete actionByRoot[rootUuid];
        if (knownActionsForClip.length === 0) delete actionsByClip[clipUuid];
        this._removeInactiveBindingsForAction(action);
    },
    _removeInactiveBindingsForAction: function(action) {
        var bindings = action._propertyBindings;
        for(var i = 0, n = bindings.length; i !== n; ++i){
            var binding = bindings[i];
            if (--binding.referenceCount === 0) this._removeInactiveBinding(binding);
        }
    },
    _lendAction: function(action) {
        // [ active actions |  inactive actions  ]
        // [  active actions >| inactive actions ]
        //                 s        a
        //                  <-swap->
        //                 a        s
        var actions = this._actions, prevIndex = action._cacheIndex, lastActiveIndex = this._nActiveActions++, firstInactiveAction = actions[lastActiveIndex];
        action._cacheIndex = lastActiveIndex;
        actions[lastActiveIndex] = action;
        firstInactiveAction._cacheIndex = prevIndex;
        actions[prevIndex] = firstInactiveAction;
    },
    _takeBackAction: function(action) {
        // [  active actions  | inactive actions ]
        // [ active actions |< inactive actions  ]
        //        a        s
        //         <-swap->
        //        s        a
        var actions = this._actions, prevIndex = action._cacheIndex, firstInactiveIndex = --this._nActiveActions, lastActiveAction = actions[firstInactiveIndex];
        action._cacheIndex = firstInactiveIndex;
        actions[firstInactiveIndex] = action;
        lastActiveAction._cacheIndex = prevIndex;
        actions[prevIndex] = lastActiveAction;
    },
    // Memory management for PropertyMixer objects
    _addInactiveBinding: function(binding, rootUuid, trackName) {
        var bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], bindings = this._bindings;
        if (bindingByName === undefined) {
            bindingByName = {};
            bindingsByRoot[rootUuid] = bindingByName;
        }
        bindingByName[trackName] = binding;
        binding._cacheIndex = bindings.length;
        bindings.push(binding);
    },
    _removeInactiveBinding: function(binding) {
        var bindings = this._bindings, propBinding = binding.binding, rootUuid = propBinding.rootNode.uuid, trackName = propBinding.path, bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], lastInactiveBinding = bindings[bindings.length - 1], cacheIndex = binding._cacheIndex;
        lastInactiveBinding._cacheIndex = cacheIndex;
        bindings[cacheIndex] = lastInactiveBinding;
        bindings.pop();
        delete bindingByName[trackName];
        remove_empty_map: {
            for(var _ in bindingByName)break remove_empty_map; // eslint-disable-line no-unused-vars
            delete bindingsByRoot[rootUuid];
        }
    },
    _lendBinding: function(binding) {
        var bindings = this._bindings, prevIndex = binding._cacheIndex, lastActiveIndex = this._nActiveBindings++, firstInactiveBinding = bindings[lastActiveIndex];
        binding._cacheIndex = lastActiveIndex;
        bindings[lastActiveIndex] = binding;
        firstInactiveBinding._cacheIndex = prevIndex;
        bindings[prevIndex] = firstInactiveBinding;
    },
    _takeBackBinding: function(binding) {
        var bindings = this._bindings, prevIndex = binding._cacheIndex, firstInactiveIndex = --this._nActiveBindings, lastActiveBinding = bindings[firstInactiveIndex];
        binding._cacheIndex = firstInactiveIndex;
        bindings[firstInactiveIndex] = binding;
        lastActiveBinding._cacheIndex = prevIndex;
        bindings[prevIndex] = lastActiveBinding;
    },
    // Memory management of Interpolants for weight and time scale
    _lendControlInterpolant: function() {
        var interpolants = this._controlInterpolants, lastActiveIndex = this._nActiveControlInterpolants++, interpolant = interpolants[lastActiveIndex];
        if (interpolant === undefined) {
            interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);
            interpolant.__cacheIndex = lastActiveIndex;
            interpolants[lastActiveIndex] = interpolant;
        }
        return interpolant;
    },
    _takeBackControlInterpolant: function(interpolant) {
        var interpolants = this._controlInterpolants, prevIndex = interpolant.__cacheIndex, firstInactiveIndex = --this._nActiveControlInterpolants, lastActiveInterpolant = interpolants[firstInactiveIndex];
        interpolant.__cacheIndex = firstInactiveIndex;
        interpolants[firstInactiveIndex] = interpolant;
        lastActiveInterpolant.__cacheIndex = prevIndex;
        interpolants[prevIndex] = lastActiveInterpolant;
    },
    _controlInterpolantsResultBuffer: new Float32Array(1),
    // return an action for a clip optionally using a custom root target
    // object (this method allocates a lot of dynamic memory in case a
    // previously unknown clip/root combination is specified)
    clipAction: function(clip, optionalRoot) {
        var root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject !== null ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid], prototypeAction = null;
        if (actionsForClip !== undefined) {
            var existingAction = actionsForClip.actionByRoot[rootUuid];
            if (existingAction !== undefined) return existingAction;
            // we know the clip, so we don't have to parse all
            // the bindings again but can just copy
            prototypeAction = actionsForClip.knownActions[0];
            // also, take the clip from the prototype action
            if (clipObject === null) clipObject = prototypeAction._clip;
        }
        // clip must be known when specified via string
        if (clipObject === null) return null;
        // allocate all resources required to run it
        var newAction = new AnimationAction(this, clipObject, optionalRoot);
        this._bindAction(newAction, prototypeAction);
        // and make the action known to the memory manager
        this._addInactiveAction(newAction, clipUuid, rootUuid);
        return newAction;
    },
    // get an existing action
    existingAction: function(clip, optionalRoot) {
        var root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid];
        if (actionsForClip !== undefined) return actionsForClip.actionByRoot[rootUuid] || null;
        return null;
    },
    // deactivates all previously scheduled actions
    stopAllAction: function() {
        var actions = this._actions, nActions = this._nActiveActions, bindings = this._bindings, nBindings = this._nActiveBindings;
        this._nActiveActions = 0;
        this._nActiveBindings = 0;
        for(var i = 0; i !== nActions; ++i)actions[i].reset();
        for(var i = 0; i !== nBindings; ++i)bindings[i].useCount = 0;
        return this;
    },
    // advance the time and update apply the animation
    update: function(deltaTime) {
        deltaTime *= this.timeScale;
        var actions = this._actions, nActions = this._nActiveActions, time = this.time += deltaTime, timeDirection = Math.sign(deltaTime), accuIndex = this._accuIndex ^= 1;
        // run active actions
        for(var i = 0; i !== nActions; ++i){
            var action = actions[i];
            action._update(time, deltaTime, timeDirection, accuIndex);
        }
        // update scene graph
        var bindings = this._bindings, nBindings = this._nActiveBindings;
        for(var i = 0; i !== nBindings; ++i)bindings[i].apply(accuIndex);
        return this;
    },
    // return this mixer's root target object
    getRoot: function() {
        return this._root;
    },
    // free all resources specific to a particular clip
    uncacheClip: function(clip) {
        var actions = this._actions, clipUuid = clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
        if (actionsForClip !== undefined) {
            // note: just calling _removeInactiveAction would mess up the
            // iteration state and also require updating the state we can
            // just throw away
            var actionsToRemove = actionsForClip.knownActions;
            for(var i = 0, n = actionsToRemove.length; i !== n; ++i){
                var action = actionsToRemove[i];
                this._deactivateAction(action);
                var cacheIndex = action._cacheIndex, lastInactiveAction = actions[actions.length - 1];
                action._cacheIndex = null;
                action._byClipCacheIndex = null;
                lastInactiveAction._cacheIndex = cacheIndex;
                actions[cacheIndex] = lastInactiveAction;
                actions.pop();
                this._removeInactiveBindingsForAction(action);
            }
            delete actionsByClip[clipUuid];
        }
    },
    // free all resources specific to a particular root target object
    uncacheRoot: function(root) {
        var rootUuid = root.uuid, actionsByClip = this._actionsByClip;
        for(var clipUuid in actionsByClip){
            var actionByRoot = actionsByClip[clipUuid].actionByRoot, action = actionByRoot[rootUuid];
            if (action !== undefined) {
                this._deactivateAction(action);
                this._removeInactiveAction(action);
            }
        }
        var bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid];
        if (bindingByName !== undefined) for(var trackName in bindingByName){
            var binding = bindingByName[trackName];
            binding.restoreOriginalState();
            this._removeInactiveBinding(binding);
        }
    },
    // remove a targeted clip from the cache
    uncacheAction: function(clip, optionalRoot) {
        var action = this.existingAction(clip, optionalRoot);
        if (action !== null) {
            this._deactivateAction(action);
            this._removeInactiveAction(action);
        }
    }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */ function Uniform(value) {
    if (typeof value === "string") {
        console.warn("THREE.Uniform: Type parameter is no longer needed.");
        value = arguments[1];
    }
    this.value = value;
}
Uniform.prototype.clone = function() {
    return new Uniform(this.value.clone === undefined ? this.value : this.value.clone());
};
/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */ function InstancedBufferGeometry() {
    BufferGeometry.call(this);
    this.type = "InstancedBufferGeometry";
    this.maxInstancedCount = undefined;
}
InstancedBufferGeometry.prototype = Object.assign(Object.create(BufferGeometry.prototype), {
    constructor: InstancedBufferGeometry,
    isInstancedBufferGeometry: true,
    copy: function(source) {
        BufferGeometry.prototype.copy.call(this, source);
        this.maxInstancedCount = source.maxInstancedCount;
        return this;
    },
    clone: function() {
        return new this.constructor().copy(this);
    }
});
/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */ function InstancedInterleavedBuffer(array, stride, meshPerAttribute) {
    InterleavedBuffer.call(this, array, stride);
    this.meshPerAttribute = meshPerAttribute || 1;
}
InstancedInterleavedBuffer.prototype = Object.assign(Object.create(InterleavedBuffer.prototype), {
    constructor: InstancedInterleavedBuffer,
    isInstancedInterleavedBuffer: true,
    copy: function(source) {
        InterleavedBuffer.prototype.copy.call(this, source);
        this.meshPerAttribute = source.meshPerAttribute;
        return this;
    }
});
/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */ function InstancedBufferAttribute(array, itemSize, normalized, meshPerAttribute) {
    if (typeof normalized === "number") {
        meshPerAttribute = normalized;
        normalized = false;
        console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.");
    }
    BufferAttribute.call(this, array, itemSize, normalized);
    this.meshPerAttribute = meshPerAttribute || 1;
}
InstancedBufferAttribute.prototype = Object.assign(Object.create(BufferAttribute.prototype), {
    constructor: InstancedBufferAttribute,
    isInstancedBufferAttribute: true,
    copy: function(source) {
        BufferAttribute.prototype.copy.call(this, source);
        this.meshPerAttribute = source.meshPerAttribute;
        return this;
    }
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author bhouston / http://clara.io/
 * @author stephomi / http://stephaneginier.com/
 */ function Raycaster(origin, direction, near, far) {
    this.ray = new Ray(origin, direction);
    // direction is assumed to be normalized (for accurate distance calculations)
    this.near = near || 0;
    this.far = far || Infinity;
    this.params = {
        Mesh: {},
        Line: {},
        LOD: {},
        Points: {
            threshold: 1
        },
        Sprite: {}
    };
    Object.defineProperties(this.params, {
        PointCloud: {
            get: function() {
                console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points.");
                return this.Points;
            }
        }
    });
}
function ascSort(a, b) {
    return a.distance - b.distance;
}
function intersectObject(object, raycaster, intersects, recursive) {
    if (object.visible === false) return;
    object.raycast(raycaster, intersects);
    if (recursive === true) {
        var children = object.children;
        for(var i = 0, l = children.length; i < l; i++)intersectObject(children[i], raycaster, intersects, true);
    }
}
Object.assign(Raycaster.prototype, {
    linePrecision: 1,
    set: function(origin, direction) {
        // direction is assumed to be normalized (for accurate distance calculations)
        this.ray.set(origin, direction);
    },
    setFromCamera: function(coords, camera) {
        if (camera && camera.isPerspectiveCamera) {
            this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
            this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
        } else if (camera && camera.isOrthographicCamera) {
            this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera); // set origin in plane of camera
            this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
        } else console.error("THREE.Raycaster: Unsupported camera type.");
    },
    intersectObject: function(object, recursive, optionalTarget) {
        var intersects = optionalTarget || [];
        intersectObject(object, this, intersects, recursive);
        intersects.sort(ascSort);
        return intersects;
    },
    intersectObjects: function(objects, recursive, optionalTarget) {
        var intersects = optionalTarget || [];
        if (Array.isArray(objects) === false) {
            console.warn("THREE.Raycaster.intersectObjects: objects is not an Array.");
            return intersects;
        }
        for(var i = 0, l = objects.length; i < l; i++)intersectObject(objects[i], this, intersects, recursive);
        intersects.sort(ascSort);
        return intersects;
    }
});
/**
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 *
 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
 *
 * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.
 * The azimuthal angle (theta) is measured from the positive z-axiz.
 */ function Spherical(radius, phi, theta) {
    this.radius = radius !== undefined ? radius : 1.0;
    this.phi = phi !== undefined ? phi : 0; // polar angle
    this.theta = theta !== undefined ? theta : 0; // azimuthal angle
    return this;
}
Object.assign(Spherical.prototype, {
    set: function(radius, phi, theta) {
        this.radius = radius;
        this.phi = phi;
        this.theta = theta;
        return this;
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(other) {
        this.radius = other.radius;
        this.phi = other.phi;
        this.theta = other.theta;
        return this;
    },
    // restrict phi to be betwee EPS and PI-EPS
    makeSafe: function() {
        var EPS = 0.000001;
        this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
        return this;
    },
    setFromVector3: function(v) {
        return this.setFromCartesianCoords(v.x, v.y, v.z);
    },
    setFromCartesianCoords: function(x, y, z) {
        this.radius = Math.sqrt(x * x + y * y + z * z);
        if (this.radius === 0) {
            this.theta = 0;
            this.phi = 0;
        } else {
            this.theta = Math.atan2(x, z);
            this.phi = Math.acos(_Math.clamp(y / this.radius, -1, 1));
        }
        return this;
    }
});
/**
 * @author Mugen87 / https://github.com/Mugen87
 *
 * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
 *
 */ function Cylindrical(radius, theta, y) {
    this.radius = radius !== undefined ? radius : 1.0; // distance from the origin to a point in the x-z plane
    this.theta = theta !== undefined ? theta : 0; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis
    this.y = y !== undefined ? y : 0; // height above the x-z plane
    return this;
}
Object.assign(Cylindrical.prototype, {
    set: function(radius, theta, y) {
        this.radius = radius;
        this.theta = theta;
        this.y = y;
        return this;
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(other) {
        this.radius = other.radius;
        this.theta = other.theta;
        this.y = other.y;
        return this;
    },
    setFromVector3: function(v) {
        return this.setFromCartesianCoords(v.x, v.y, v.z);
    },
    setFromCartesianCoords: function(x, y, z) {
        this.radius = Math.sqrt(x * x + z * z);
        this.theta = Math.atan2(x, z);
        this.y = y;
        return this;
    }
});
/**
 * @author bhouston / http://clara.io
 */ function Box2(min, max) {
    this.min = min !== undefined ? min : new Vector2(Infinity, Infinity);
    this.max = max !== undefined ? max : new Vector2(-Infinity, -Infinity);
}
Object.assign(Box2.prototype, {
    set: function(min, max) {
        this.min.copy(min);
        this.max.copy(max);
        return this;
    },
    setFromPoints: function(points) {
        this.makeEmpty();
        for(var i = 0, il = points.length; i < il; i++)this.expandByPoint(points[i]);
        return this;
    },
    setFromCenterAndSize: function() {
        var v1 = new Vector2();
        return function setFromCenterAndSize(center, size) {
            var halfSize = v1.copy(size).multiplyScalar(0.5);
            this.min.copy(center).sub(halfSize);
            this.max.copy(center).add(halfSize);
            return this;
        };
    }(),
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(box) {
        this.min.copy(box.min);
        this.max.copy(box.max);
        return this;
    },
    makeEmpty: function() {
        this.min.x = this.min.y = Infinity;
        this.max.x = this.max.y = -Infinity;
        return this;
    },
    isEmpty: function() {
        // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
        return this.max.x < this.min.x || this.max.y < this.min.y;
    },
    getCenter: function(target) {
        if (target === undefined) {
            console.warn("THREE.Box2: .getCenter() target is now required");
            target = new Vector2();
        }
        return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
    },
    getSize: function(target) {
        if (target === undefined) {
            console.warn("THREE.Box2: .getSize() target is now required");
            target = new Vector2();
        }
        return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);
    },
    expandByPoint: function(point) {
        this.min.min(point);
        this.max.max(point);
        return this;
    },
    expandByVector: function(vector) {
        this.min.sub(vector);
        this.max.add(vector);
        return this;
    },
    expandByScalar: function(scalar) {
        this.min.addScalar(-scalar);
        this.max.addScalar(scalar);
        return this;
    },
    containsPoint: function(point) {
        return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y ? false : true;
    },
    containsBox: function(box) {
        return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
    },
    getParameter: function(point, target) {
        // This can potentially have a divide by zero if the box
        // has a size dimension of 0.
        if (target === undefined) {
            console.warn("THREE.Box2: .getParameter() target is now required");
            target = new Vector2();
        }
        return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
    },
    intersectsBox: function(box) {
        // using 4 splitting planes to rule out intersections
        return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
    },
    clampPoint: function(point, target) {
        if (target === undefined) {
            console.warn("THREE.Box2: .clampPoint() target is now required");
            target = new Vector2();
        }
        return target.copy(point).clamp(this.min, this.max);
    },
    distanceToPoint: function() {
        var v1 = new Vector2();
        return function distanceToPoint(point) {
            var clampedPoint = v1.copy(point).clamp(this.min, this.max);
            return clampedPoint.sub(point).length();
        };
    }(),
    intersect: function(box) {
        this.min.max(box.min);
        this.max.min(box.max);
        return this;
    },
    union: function(box) {
        this.min.min(box.min);
        this.max.max(box.max);
        return this;
    },
    translate: function(offset) {
        this.min.add(offset);
        this.max.add(offset);
        return this;
    },
    equals: function(box) {
        return box.min.equals(this.min) && box.max.equals(this.max);
    }
});
/**
 * @author bhouston / http://clara.io
 */ function Line3(start, end) {
    this.start = start !== undefined ? start : new Vector3();
    this.end = end !== undefined ? end : new Vector3();
}
Object.assign(Line3.prototype, {
    set: function(start, end) {
        this.start.copy(start);
        this.end.copy(end);
        return this;
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(line) {
        this.start.copy(line.start);
        this.end.copy(line.end);
        return this;
    },
    getCenter: function(target) {
        if (target === undefined) {
            console.warn("THREE.Line3: .getCenter() target is now required");
            target = new Vector3();
        }
        return target.addVectors(this.start, this.end).multiplyScalar(0.5);
    },
    delta: function(target) {
        if (target === undefined) {
            console.warn("THREE.Line3: .delta() target is now required");
            target = new Vector3();
        }
        return target.subVectors(this.end, this.start);
    },
    distanceSq: function() {
        return this.start.distanceToSquared(this.end);
    },
    distance: function() {
        return this.start.distanceTo(this.end);
    },
    at: function(t, target) {
        if (target === undefined) {
            console.warn("THREE.Line3: .at() target is now required");
            target = new Vector3();
        }
        return this.delta(target).multiplyScalar(t).add(this.start);
    },
    closestPointToPointParameter: function() {
        var startP = new Vector3();
        var startEnd = new Vector3();
        return function closestPointToPointParameter(point, clampToLine) {
            startP.subVectors(point, this.start);
            startEnd.subVectors(this.end, this.start);
            var startEnd2 = startEnd.dot(startEnd);
            var startEnd_startP = startEnd.dot(startP);
            var t = startEnd_startP / startEnd2;
            if (clampToLine) t = _Math.clamp(t, 0, 1);
            return t;
        };
    }(),
    closestPointToPoint: function(point, clampToLine, target) {
        var t = this.closestPointToPointParameter(point, clampToLine);
        if (target === undefined) {
            console.warn("THREE.Line3: .closestPointToPoint() target is now required");
            target = new Vector3();
        }
        return this.delta(target).multiplyScalar(t).add(this.start);
    },
    applyMatrix4: function(matrix) {
        this.start.applyMatrix4(matrix);
        this.end.applyMatrix4(matrix);
        return this;
    },
    equals: function(line) {
        return line.start.equals(this.start) && line.end.equals(this.end);
    }
});
/**
 * @author alteredq / http://alteredqualia.com/
 */ function ImmediateRenderObject(material) {
    Object3D.call(this);
    this.material = material;
    this.render = function() {};
}
ImmediateRenderObject.prototype = Object.create(Object3D.prototype);
ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;
ImmediateRenderObject.prototype.isImmediateRenderObject = true;
/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */ function VertexNormalsHelper(object, size, hex, linewidth) {
    this.object = object;
    this.size = size !== undefined ? size : 1;
    var color = hex !== undefined ? hex : 0xff0000;
    var width = linewidth !== undefined ? linewidth : 1;
    //
    var nNormals = 0;
    var objGeometry = this.object.geometry;
    if (objGeometry && objGeometry.isGeometry) nNormals = objGeometry.faces.length * 3;
    else if (objGeometry && objGeometry.isBufferGeometry) nNormals = objGeometry.attributes.normal.count;
    //
    var geometry = new BufferGeometry();
    var positions = new Float32BufferAttribute(nNormals * 6, 3);
    geometry.addAttribute("position", positions);
    LineSegments.call(this, geometry, new LineBasicMaterial({
        color: color,
        linewidth: width
    }));
    //
    this.matrixAutoUpdate = false;
    this.update();
}
VertexNormalsHelper.prototype = Object.create(LineSegments.prototype);
VertexNormalsHelper.prototype.constructor = VertexNormalsHelper;
VertexNormalsHelper.prototype.update = function() {
    var v1 = new Vector3();
    var v2 = new Vector3();
    var normalMatrix = new Matrix3();
    return function update() {
        var keys = [
            "a",
            "b",
            "c"
        ];
        this.object.updateMatrixWorld(true);
        normalMatrix.getNormalMatrix(this.object.matrixWorld);
        var matrixWorld = this.object.matrixWorld;
        var position = this.geometry.attributes.position;
        //
        var objGeometry = this.object.geometry;
        if (objGeometry && objGeometry.isGeometry) {
            var vertices = objGeometry.vertices;
            var faces = objGeometry.faces;
            var idx = 0;
            for(var i = 0, l = faces.length; i < l; i++){
                var face = faces[i];
                for(var j = 0, jl = face.vertexNormals.length; j < jl; j++){
                    var vertex = vertices[face[keys[j]]];
                    var normal = face.vertexNormals[j];
                    v1.copy(vertex).applyMatrix4(matrixWorld);
                    v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);
                    position.setXYZ(idx, v1.x, v1.y, v1.z);
                    idx = idx + 1;
                    position.setXYZ(idx, v2.x, v2.y, v2.z);
                    idx = idx + 1;
                }
            }
        } else if (objGeometry && objGeometry.isBufferGeometry) {
            var objPos = objGeometry.attributes.position;
            var objNorm = objGeometry.attributes.normal;
            var idx = 0;
            // for simplicity, ignore index and drawcalls, and render every normal
            for(var j = 0, jl = objPos.count; j < jl; j++){
                v1.set(objPos.getX(j), objPos.getY(j), objPos.getZ(j)).applyMatrix4(matrixWorld);
                v2.set(objNorm.getX(j), objNorm.getY(j), objNorm.getZ(j));
                v2.applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);
                position.setXYZ(idx, v1.x, v1.y, v1.z);
                idx = idx + 1;
                position.setXYZ(idx, v2.x, v2.y, v2.z);
                idx = idx + 1;
            }
        }
        position.needsUpdate = true;
    };
}();
/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */ function SpotLightHelper(light, color) {
    Object3D.call(this);
    this.light = light;
    this.light.updateMatrixWorld();
    this.matrix = light.matrixWorld;
    this.matrixAutoUpdate = false;
    this.color = color;
    var geometry = new BufferGeometry();
    var positions = [
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        1,
        0,
        0,
        0,
        -1,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        1,
        0,
        0,
        0,
        0,
        -1,
        1
    ];
    for(var i = 0, j = 1, l = 32; i < l; i++, j++){
        var p1 = i / l * Math.PI * 2;
        var p2 = j / l * Math.PI * 2;
        positions.push(Math.cos(p1), Math.sin(p1), 1, Math.cos(p2), Math.sin(p2), 1);
    }
    geometry.addAttribute("position", new Float32BufferAttribute(positions, 3));
    var material = new LineBasicMaterial({
        fog: false
    });
    this.cone = new LineSegments(geometry, material);
    this.add(this.cone);
    this.update();
}
SpotLightHelper.prototype = Object.create(Object3D.prototype);
SpotLightHelper.prototype.constructor = SpotLightHelper;
SpotLightHelper.prototype.dispose = function() {
    this.cone.geometry.dispose();
    this.cone.material.dispose();
};
SpotLightHelper.prototype.update = function() {
    var vector = new Vector3();
    return function update() {
        this.light.updateMatrixWorld();
        var coneLength = this.light.distance ? this.light.distance : 1000;
        var coneWidth = coneLength * Math.tan(this.light.angle);
        this.cone.scale.set(coneWidth, coneWidth, coneLength);
        vector.setFromMatrixPosition(this.light.target.matrixWorld);
        this.cone.lookAt(vector);
        if (this.color !== undefined) this.cone.material.color.set(this.color);
        else this.cone.material.color.copy(this.light.color);
    };
}();
/**
 * @author Sean Griffin / http://twitter.com/sgrif
 * @author Michael Guerrero / http://realitymeltdown.com
 * @author mrdoob / http://mrdoob.com/
 * @author ikerr / http://verold.com
 * @author Mugen87 / https://github.com/Mugen87
 */ function getBoneList(object) {
    var boneList = [];
    if (object && object.isBone) boneList.push(object);
    for(var i = 0; i < object.children.length; i++)boneList.push.apply(boneList, getBoneList(object.children[i]));
    return boneList;
}
function SkeletonHelper(object) {
    var bones = getBoneList(object);
    var geometry = new BufferGeometry();
    var vertices = [];
    var colors = [];
    var color1 = new Color(0, 0, 1);
    var color2 = new Color(0, 1, 0);
    for(var i = 0; i < bones.length; i++){
        var bone = bones[i];
        if (bone.parent && bone.parent.isBone) {
            vertices.push(0, 0, 0);
            vertices.push(0, 0, 0);
            colors.push(color1.r, color1.g, color1.b);
            colors.push(color2.r, color2.g, color2.b);
        }
    }
    geometry.addAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry.addAttribute("color", new Float32BufferAttribute(colors, 3));
    var material = new LineBasicMaterial({
        vertexColors: VertexColors,
        depthTest: false,
        depthWrite: false,
        transparent: true
    });
    LineSegments.call(this, geometry, material);
    this.root = object;
    this.bones = bones;
    this.matrix = object.matrixWorld;
    this.matrixAutoUpdate = false;
}
SkeletonHelper.prototype = Object.create(LineSegments.prototype);
SkeletonHelper.prototype.constructor = SkeletonHelper;
SkeletonHelper.prototype.updateMatrixWorld = function() {
    var vector = new Vector3();
    var boneMatrix = new Matrix4();
    var matrixWorldInv = new Matrix4();
    return function updateMatrixWorld(force) {
        var bones = this.bones;
        var geometry = this.geometry;
        var position = geometry.getAttribute("position");
        matrixWorldInv.getInverse(this.root.matrixWorld);
        for(var i = 0, j = 0; i < bones.length; i++){
            var bone = bones[i];
            if (bone.parent && bone.parent.isBone) {
                boneMatrix.multiplyMatrices(matrixWorldInv, bone.matrixWorld);
                vector.setFromMatrixPosition(boneMatrix);
                position.setXYZ(j, vector.x, vector.y, vector.z);
                boneMatrix.multiplyMatrices(matrixWorldInv, bone.parent.matrixWorld);
                vector.setFromMatrixPosition(boneMatrix);
                position.setXYZ(j + 1, vector.x, vector.y, vector.z);
                j += 2;
            }
        }
        geometry.getAttribute("position").needsUpdate = true;
        Object3D.prototype.updateMatrixWorld.call(this, force);
    };
}();
/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */ function PointLightHelper(light, sphereSize, color) {
    this.light = light;
    this.light.updateMatrixWorld();
    this.color = color;
    var geometry = new SphereBufferGeometry(sphereSize, 4, 2);
    var material = new MeshBasicMaterial({
        wireframe: true,
        fog: false
    });
    Mesh.call(this, geometry, material);
    this.matrix = this.light.matrixWorld;
    this.matrixAutoUpdate = false;
    this.update();
/*
	var distanceGeometry = new THREE.IcosahedronBufferGeometry( 1, 2 );
	var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

	this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
	this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

	var d = light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.scale.set( d, d, d );

	}

	this.add( this.lightDistance );
	*/ }
PointLightHelper.prototype = Object.create(Mesh.prototype);
PointLightHelper.prototype.constructor = PointLightHelper;
PointLightHelper.prototype.dispose = function() {
    this.geometry.dispose();
    this.material.dispose();
};
PointLightHelper.prototype.update = function() {
    if (this.color !== undefined) this.material.color.set(this.color);
    else this.material.color.copy(this.light.color);
/*
	var d = this.light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.visible = true;
		this.lightDistance.scale.set( d, d, d );

	}
	*/ };
/**
 * @author abelnation / http://github.com/abelnation
 * @author Mugen87 / http://github.com/Mugen87
 * @author WestLangley / http://github.com/WestLangley
 *
 *  This helper must be added as a child of the light
 */ function RectAreaLightHelper(light, color) {
    this.type = "RectAreaLightHelper";
    this.light = light;
    this.color = color; // optional hardwired color for the helper
    var positions = [
        1,
        1,
        0,
        -1,
        1,
        0,
        -1,
        -1,
        0,
        1,
        -1,
        0,
        1,
        1,
        0
    ];
    var geometry = new BufferGeometry();
    geometry.addAttribute("position", new Float32BufferAttribute(positions, 3));
    geometry.computeBoundingSphere();
    var material = new LineBasicMaterial({
        fog: false
    });
    Line.call(this, geometry, material);
    //
    var positions2 = [
        1,
        1,
        0,
        -1,
        1,
        0,
        -1,
        -1,
        0,
        1,
        1,
        0,
        -1,
        -1,
        0,
        1,
        -1,
        0
    ];
    var geometry2 = new BufferGeometry();
    geometry2.addAttribute("position", new Float32BufferAttribute(positions2, 3));
    geometry2.computeBoundingSphere();
    this.add(new Mesh(geometry2, new MeshBasicMaterial({
        side: THREE.BackSide,
        fog: false
    })));
    this.update();
}
RectAreaLightHelper.prototype = Object.create(Line.prototype);
RectAreaLightHelper.prototype.constructor = RectAreaLightHelper;
RectAreaLightHelper.prototype.update = function() {
    this.scale.set(0.5 * this.light.width, 0.5 * this.light.height, 1);
    if (this.color !== undefined) {
        this.material.color.set(this.color);
        this.children[0].material.color.set(this.color);
    } else {
        this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
        // prevent hue shift
        var c = this.material.color;
        var max = Math.max(c.r, c.g, c.b);
        if (max > 1) c.multiplyScalar(1 / max);
        this.children[0].material.color.copy(this.material.color);
    }
};
RectAreaLightHelper.prototype.dispose = function() {
    this.geometry.dispose();
    this.material.dispose();
    this.children[0].geometry.dispose();
    this.children[0].material.dispose();
};
/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */ function HemisphereLightHelper(light, size, color) {
    Object3D.call(this);
    this.light = light;
    this.light.updateMatrixWorld();
    this.matrix = light.matrixWorld;
    this.matrixAutoUpdate = false;
    this.color = color;
    var geometry = new OctahedronBufferGeometry(size);
    geometry.rotateY(Math.PI * 0.5);
    this.material = new MeshBasicMaterial({
        wireframe: true,
        fog: false
    });
    if (this.color === undefined) this.material.vertexColors = VertexColors;
    var position = geometry.getAttribute("position");
    var colors = new Float32Array(position.count * 3);
    geometry.addAttribute("color", new BufferAttribute(colors, 3));
    this.add(new Mesh(geometry, this.material));
    this.update();
}
HemisphereLightHelper.prototype = Object.create(Object3D.prototype);
HemisphereLightHelper.prototype.constructor = HemisphereLightHelper;
HemisphereLightHelper.prototype.dispose = function() {
    this.children[0].geometry.dispose();
    this.children[0].material.dispose();
};
HemisphereLightHelper.prototype.update = function() {
    var vector = new Vector3();
    var color1 = new Color();
    var color2 = new Color();
    return function update() {
        var mesh = this.children[0];
        if (this.color !== undefined) this.material.color.set(this.color);
        else {
            var colors = mesh.geometry.getAttribute("color");
            color1.copy(this.light.color);
            color2.copy(this.light.groundColor);
            for(var i = 0, l = colors.count; i < l; i++){
                var color = i < l / 2 ? color1 : color2;
                colors.setXYZ(i, color.r, color.g, color.b);
            }
            colors.needsUpdate = true;
        }
        mesh.lookAt(vector.setFromMatrixPosition(this.light.matrixWorld).negate());
    };
}();
/**
 * @author mrdoob / http://mrdoob.com/
 */ function GridHelper(size, divisions, color1, color2) {
    size = size || 10;
    divisions = divisions || 10;
    color1 = new Color(color1 !== undefined ? color1 : 0x444444);
    color2 = new Color(color2 !== undefined ? color2 : 0x888888);
    var center = divisions / 2;
    var step = size / divisions;
    var halfSize = size / 2;
    var vertices = [], colors = [];
    for(var i = 0, j = 0, k = -halfSize; i <= divisions; i++, k += step){
        vertices.push(-halfSize, 0, k, halfSize, 0, k);
        vertices.push(k, 0, -halfSize, k, 0, halfSize);
        var color = i === center ? color1 : color2;
        color.toArray(colors, j);
        j += 3;
        color.toArray(colors, j);
        j += 3;
        color.toArray(colors, j);
        j += 3;
        color.toArray(colors, j);
        j += 3;
    }
    var geometry = new BufferGeometry();
    geometry.addAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry.addAttribute("color", new Float32BufferAttribute(colors, 3));
    var material = new LineBasicMaterial({
        vertexColors: VertexColors
    });
    LineSegments.call(this, geometry, material);
}
GridHelper.prototype = Object.create(LineSegments.prototype);
GridHelper.prototype.constructor = GridHelper;
/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / http://github.com/Mugen87
 * @author Hectate / http://www.github.com/Hectate
 */ function PolarGridHelper(radius, radials, circles, divisions, color1, color2) {
    radius = radius || 10;
    radials = radials || 16;
    circles = circles || 8;
    divisions = divisions || 64;
    color1 = new Color(color1 !== undefined ? color1 : 0x444444);
    color2 = new Color(color2 !== undefined ? color2 : 0x888888);
    var vertices = [];
    var colors = [];
    var x, z;
    var v, i, j, r, color;
    // create the radials
    for(i = 0; i <= radials; i++){
        v = i / radials * (Math.PI * 2);
        x = Math.sin(v) * radius;
        z = Math.cos(v) * radius;
        vertices.push(0, 0, 0);
        vertices.push(x, 0, z);
        color = i & 1 ? color1 : color2;
        colors.push(color.r, color.g, color.b);
        colors.push(color.r, color.g, color.b);
    }
    // create the circles
    for(i = 0; i <= circles; i++){
        color = i & 1 ? color1 : color2;
        r = radius - radius / circles * i;
        for(j = 0; j < divisions; j++){
            // first vertex
            v = j / divisions * (Math.PI * 2);
            x = Math.sin(v) * r;
            z = Math.cos(v) * r;
            vertices.push(x, 0, z);
            colors.push(color.r, color.g, color.b);
            // second vertex
            v = (j + 1) / divisions * (Math.PI * 2);
            x = Math.sin(v) * r;
            z = Math.cos(v) * r;
            vertices.push(x, 0, z);
            colors.push(color.r, color.g, color.b);
        }
    }
    var geometry = new BufferGeometry();
    geometry.addAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry.addAttribute("color", new Float32BufferAttribute(colors, 3));
    var material = new LineBasicMaterial({
        vertexColors: VertexColors
    });
    LineSegments.call(this, geometry, material);
}
PolarGridHelper.prototype = Object.create(LineSegments.prototype);
PolarGridHelper.prototype.constructor = PolarGridHelper;
/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */ function FaceNormalsHelper(object, size, hex, linewidth) {
    // FaceNormalsHelper only supports THREE.Geometry
    this.object = object;
    this.size = size !== undefined ? size : 1;
    var color = hex !== undefined ? hex : 0xffff00;
    var width = linewidth !== undefined ? linewidth : 1;
    //
    var nNormals = 0;
    var objGeometry = this.object.geometry;
    if (objGeometry && objGeometry.isGeometry) nNormals = objGeometry.faces.length;
    else console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.");
    //
    var geometry = new BufferGeometry();
    var positions = new Float32BufferAttribute(nNormals * 6, 3);
    geometry.addAttribute("position", positions);
    LineSegments.call(this, geometry, new LineBasicMaterial({
        color: color,
        linewidth: width
    }));
    //
    this.matrixAutoUpdate = false;
    this.update();
}
FaceNormalsHelper.prototype = Object.create(LineSegments.prototype);
FaceNormalsHelper.prototype.constructor = FaceNormalsHelper;
FaceNormalsHelper.prototype.update = function() {
    var v1 = new Vector3();
    var v2 = new Vector3();
    var normalMatrix = new Matrix3();
    return function update() {
        this.object.updateMatrixWorld(true);
        normalMatrix.getNormalMatrix(this.object.matrixWorld);
        var matrixWorld = this.object.matrixWorld;
        var position = this.geometry.attributes.position;
        //
        var objGeometry = this.object.geometry;
        var vertices = objGeometry.vertices;
        var faces = objGeometry.faces;
        var idx = 0;
        for(var i = 0, l = faces.length; i < l; i++){
            var face = faces[i];
            var normal = face.normal;
            v1.copy(vertices[face.a]).add(vertices[face.b]).add(vertices[face.c]).divideScalar(3).applyMatrix4(matrixWorld);
            v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);
            position.setXYZ(idx, v1.x, v1.y, v1.z);
            idx = idx + 1;
            position.setXYZ(idx, v2.x, v2.y, v2.z);
            idx = idx + 1;
        }
        position.needsUpdate = true;
    };
}();
/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */ function DirectionalLightHelper(light, size, color) {
    Object3D.call(this);
    this.light = light;
    this.light.updateMatrixWorld();
    this.matrix = light.matrixWorld;
    this.matrixAutoUpdate = false;
    this.color = color;
    if (size === undefined) size = 1;
    var geometry = new BufferGeometry();
    geometry.addAttribute("position", new Float32BufferAttribute([
        -size,
        size,
        0,
        size,
        size,
        0,
        size,
        -size,
        0,
        -size,
        -size,
        0,
        -size,
        size,
        0
    ], 3));
    var material = new LineBasicMaterial({
        fog: false
    });
    this.lightPlane = new Line(geometry, material);
    this.add(this.lightPlane);
    geometry = new BufferGeometry();
    geometry.addAttribute("position", new Float32BufferAttribute([
        0,
        0,
        0,
        0,
        0,
        1
    ], 3));
    this.targetLine = new Line(geometry, material);
    this.add(this.targetLine);
    this.update();
}
DirectionalLightHelper.prototype = Object.create(Object3D.prototype);
DirectionalLightHelper.prototype.constructor = DirectionalLightHelper;
DirectionalLightHelper.prototype.dispose = function() {
    this.lightPlane.geometry.dispose();
    this.lightPlane.material.dispose();
    this.targetLine.geometry.dispose();
    this.targetLine.material.dispose();
};
DirectionalLightHelper.prototype.update = function() {
    var v1 = new Vector3();
    var v2 = new Vector3();
    var v3 = new Vector3();
    return function update() {
        v1.setFromMatrixPosition(this.light.matrixWorld);
        v2.setFromMatrixPosition(this.light.target.matrixWorld);
        v3.subVectors(v2, v1);
        this.lightPlane.lookAt(v2);
        if (this.color !== undefined) {
            this.lightPlane.material.color.set(this.color);
            this.targetLine.material.color.set(this.color);
        } else {
            this.lightPlane.material.color.copy(this.light.color);
            this.targetLine.material.color.copy(this.light.color);
        }
        this.targetLine.lookAt(v2);
        this.targetLine.scale.z = v3.length();
    };
}();
/**
 * @author alteredq / http://alteredqualia.com/
 * @author Mugen87 / https://github.com/Mugen87
 *
 *	- shows frustum, line of sight and up of the camera
 *	- suitable for fast updates
 * 	- based on frustum visualization in lightgl.js shadowmap example
 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
 */ function CameraHelper(camera) {
    var geometry = new BufferGeometry();
    var material = new LineBasicMaterial({
        color: 0xffffff,
        vertexColors: FaceColors
    });
    var vertices = [];
    var colors = [];
    var pointMap = {};
    // colors
    var colorFrustum = new Color(0xffaa00);
    var colorCone = new Color(0xff0000);
    var colorUp = new Color(0x00aaff);
    var colorTarget = new Color(0xffffff);
    var colorCross = new Color(0x333333);
    // near
    addLine("n1", "n2", colorFrustum);
    addLine("n2", "n4", colorFrustum);
    addLine("n4", "n3", colorFrustum);
    addLine("n3", "n1", colorFrustum);
    // far
    addLine("f1", "f2", colorFrustum);
    addLine("f2", "f4", colorFrustum);
    addLine("f4", "f3", colorFrustum);
    addLine("f3", "f1", colorFrustum);
    // sides
    addLine("n1", "f1", colorFrustum);
    addLine("n2", "f2", colorFrustum);
    addLine("n3", "f3", colorFrustum);
    addLine("n4", "f4", colorFrustum);
    // cone
    addLine("p", "n1", colorCone);
    addLine("p", "n2", colorCone);
    addLine("p", "n3", colorCone);
    addLine("p", "n4", colorCone);
    // up
    addLine("u1", "u2", colorUp);
    addLine("u2", "u3", colorUp);
    addLine("u3", "u1", colorUp);
    // target
    addLine("c", "t", colorTarget);
    addLine("p", "c", colorCross);
    // cross
    addLine("cn1", "cn2", colorCross);
    addLine("cn3", "cn4", colorCross);
    addLine("cf1", "cf2", colorCross);
    addLine("cf3", "cf4", colorCross);
    function addLine(a, b, color) {
        addPoint(a, color);
        addPoint(b, color);
    }
    function addPoint(id, color) {
        vertices.push(0, 0, 0);
        colors.push(color.r, color.g, color.b);
        if (pointMap[id] === undefined) pointMap[id] = [];
        pointMap[id].push(vertices.length / 3 - 1);
    }
    geometry.addAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry.addAttribute("color", new Float32BufferAttribute(colors, 3));
    LineSegments.call(this, geometry, material);
    this.camera = camera;
    if (this.camera.updateProjectionMatrix) this.camera.updateProjectionMatrix();
    this.matrix = camera.matrixWorld;
    this.matrixAutoUpdate = false;
    this.pointMap = pointMap;
    this.update();
}
CameraHelper.prototype = Object.create(LineSegments.prototype);
CameraHelper.prototype.constructor = CameraHelper;
CameraHelper.prototype.update = function() {
    var geometry, pointMap;
    var vector = new Vector3();
    var camera = new Camera();
    function setPoint(point, x, y, z) {
        vector.set(x, y, z).unproject(camera);
        var points = pointMap[point];
        if (points !== undefined) {
            var position = geometry.getAttribute("position");
            for(var i = 0, l = points.length; i < l; i++)position.setXYZ(points[i], vector.x, vector.y, vector.z);
        }
    }
    return function update() {
        geometry = this.geometry;
        pointMap = this.pointMap;
        var w = 1, h = 1;
        // we need just camera projection matrix
        // world matrix must be identity
        camera.projectionMatrix.copy(this.camera.projectionMatrix);
        // center / target
        setPoint("c", 0, 0, -1);
        setPoint("t", 0, 0, 1);
        // near
        setPoint("n1", -w, -h, -1);
        setPoint("n2", w, -h, -1);
        setPoint("n3", -w, h, -1);
        setPoint("n4", w, h, -1);
        // far
        setPoint("f1", -w, -h, 1);
        setPoint("f2", w, -h, 1);
        setPoint("f3", -w, h, 1);
        setPoint("f4", w, h, 1);
        // up
        setPoint("u1", w * 0.7, h * 1.1, -1);
        setPoint("u2", -w * 0.7, h * 1.1, -1);
        setPoint("u3", 0, h * 2, -1);
        // cross
        setPoint("cf1", -w, 0, 1);
        setPoint("cf2", w, 0, 1);
        setPoint("cf3", 0, -h, 1);
        setPoint("cf4", 0, h, 1);
        setPoint("cn1", -w, 0, -1);
        setPoint("cn2", w, 0, -1);
        setPoint("cn3", 0, -h, -1);
        setPoint("cn4", 0, h, -1);
        geometry.getAttribute("position").needsUpdate = true;
    };
}();
/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / http://github.com/Mugen87
 */ function BoxHelper(object, color) {
    this.object = object;
    if (color === undefined) color = 0xffff00;
    var indices = new Uint16Array([
        0,
        1,
        1,
        2,
        2,
        3,
        3,
        0,
        4,
        5,
        5,
        6,
        6,
        7,
        7,
        4,
        0,
        4,
        1,
        5,
        2,
        6,
        3,
        7
    ]);
    var positions = new Float32Array(24);
    var geometry = new BufferGeometry();
    geometry.setIndex(new BufferAttribute(indices, 1));
    geometry.addAttribute("position", new BufferAttribute(positions, 3));
    LineSegments.call(this, geometry, new LineBasicMaterial({
        color: color
    }));
    this.matrixAutoUpdate = false;
    this.update();
}
BoxHelper.prototype = Object.create(LineSegments.prototype);
BoxHelper.prototype.constructor = BoxHelper;
BoxHelper.prototype.update = function() {
    var box = new Box3();
    return function update(object) {
        if (object !== undefined) console.warn("THREE.BoxHelper: .update() has no longer arguments.");
        if (this.object !== undefined) box.setFromObject(this.object);
        if (box.isEmpty()) return;
        var min = box.min;
        var max = box.max;
        /*
		  5____4
		1/___0/|
		| 6__|_7
		2/___3/

		0: max.x, max.y, max.z
		1: min.x, max.y, max.z
		2: min.x, min.y, max.z
		3: max.x, min.y, max.z
		4: max.x, max.y, min.z
		5: min.x, max.y, min.z
		6: min.x, min.y, min.z
		7: max.x, min.y, min.z
		*/ var position = this.geometry.attributes.position;
        var array = position.array;
        array[0] = max.x;
        array[1] = max.y;
        array[2] = max.z;
        array[3] = min.x;
        array[4] = max.y;
        array[5] = max.z;
        array[6] = min.x;
        array[7] = min.y;
        array[8] = max.z;
        array[9] = max.x;
        array[10] = min.y;
        array[11] = max.z;
        array[12] = max.x;
        array[13] = max.y;
        array[14] = min.z;
        array[15] = min.x;
        array[16] = max.y;
        array[17] = min.z;
        array[18] = min.x;
        array[19] = min.y;
        array[20] = min.z;
        array[21] = max.x;
        array[22] = min.y;
        array[23] = min.z;
        position.needsUpdate = true;
        this.geometry.computeBoundingSphere();
    };
}();
BoxHelper.prototype.setFromObject = function(object) {
    this.object = object;
    this.update();
    return this;
};
BoxHelper.prototype.copy = function(source) {
    LineSegments.prototype.copy.call(this, source);
    this.object = source.object;
    return this;
};
BoxHelper.prototype.clone = function() {
    return new this.constructor().copy(this);
};
/**
 * @author WestLangley / http://github.com/WestLangley
 */ function Box3Helper(box, hex) {
    this.type = "Box3Helper";
    this.box = box;
    var color = hex !== undefined ? hex : 0xffff00;
    var indices = new Uint16Array([
        0,
        1,
        1,
        2,
        2,
        3,
        3,
        0,
        4,
        5,
        5,
        6,
        6,
        7,
        7,
        4,
        0,
        4,
        1,
        5,
        2,
        6,
        3,
        7
    ]);
    var positions = [
        1,
        1,
        1,
        -1,
        1,
        1,
        -1,
        -1,
        1,
        1,
        -1,
        1,
        1,
        1,
        -1,
        -1,
        1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        -1
    ];
    var geometry = new BufferGeometry();
    geometry.setIndex(new BufferAttribute(indices, 1));
    geometry.addAttribute("position", new Float32BufferAttribute(positions, 3));
    LineSegments.call(this, geometry, new LineBasicMaterial({
        color: color
    }));
    this.geometry.computeBoundingSphere();
}
Box3Helper.prototype = Object.create(LineSegments.prototype);
Box3Helper.prototype.constructor = Box3Helper;
Box3Helper.prototype.updateMatrixWorld = function(force) {
    var box = this.box;
    if (box.isEmpty()) return;
    box.getCenter(this.position);
    box.getSize(this.scale);
    this.scale.multiplyScalar(0.5);
    Object3D.prototype.updateMatrixWorld.call(this, force);
};
/**
 * @author WestLangley / http://github.com/WestLangley
 */ function PlaneHelper(plane, size, hex) {
    this.type = "PlaneHelper";
    this.plane = plane;
    this.size = size === undefined ? 1 : size;
    var color = hex !== undefined ? hex : 0xffff00;
    var positions = [
        1,
        -1,
        1,
        -1,
        1,
        1,
        -1,
        -1,
        1,
        1,
        1,
        1,
        -1,
        1,
        1,
        -1,
        -1,
        1,
        1,
        -1,
        1,
        1,
        1,
        1,
        0,
        0,
        1,
        0,
        0,
        0
    ];
    var geometry = new BufferGeometry();
    geometry.addAttribute("position", new Float32BufferAttribute(positions, 3));
    geometry.computeBoundingSphere();
    Line.call(this, geometry, new LineBasicMaterial({
        color: color
    }));
    //
    var positions2 = [
        1,
        1,
        1,
        -1,
        1,
        1,
        -1,
        -1,
        1,
        1,
        1,
        1,
        -1,
        -1,
        1,
        1,
        -1,
        1
    ];
    var geometry2 = new BufferGeometry();
    geometry2.addAttribute("position", new Float32BufferAttribute(positions2, 3));
    geometry2.computeBoundingSphere();
    this.add(new Mesh(geometry2, new MeshBasicMaterial({
        color: color,
        opacity: 0.2,
        transparent: true,
        depthWrite: false
    })));
}
PlaneHelper.prototype = Object.create(Line.prototype);
PlaneHelper.prototype.constructor = PlaneHelper;
PlaneHelper.prototype.updateMatrixWorld = function(force) {
    var scale = -this.plane.constant;
    if (Math.abs(scale) < 1e-8) scale = 1e-8; // sign does not matter
    this.scale.set(0.5 * this.size, 0.5 * this.size, scale);
    this.children[0].material.side = scale < 0 ? BackSide : FrontSide; // renderer flips side when determinant < 0; flipping not wanted here
    this.lookAt(this.plane.normal);
    Object3D.prototype.updateMatrixWorld.call(this, force);
};
/**
 * @author WestLangley / http://github.com/WestLangley
 * @author zz85 / http://github.com/zz85
 * @author bhouston / http://clara.io
 *
 * Creates an arrow for visualizing directions
 *
 * Parameters:
 *  dir - Vector3
 *  origin - Vector3
 *  length - Number
 *  color - color in hex value
 *  headLength - Number
 *  headWidth - Number
 */ var lineGeometry, coneGeometry;
function ArrowHelper(dir, origin, length, color, headLength, headWidth) {
    // dir is assumed to be normalized
    Object3D.call(this);
    if (dir === undefined) dir = new THREE.Vector3(0, 0, 1);
    if (origin === undefined) origin = new THREE.Vector3(0, 0, 0);
    if (length === undefined) length = 1;
    if (color === undefined) color = 0xffff00;
    if (headLength === undefined) headLength = 0.2 * length;
    if (headWidth === undefined) headWidth = 0.2 * headLength;
    if (lineGeometry === undefined) {
        lineGeometry = new BufferGeometry();
        lineGeometry.addAttribute("position", new Float32BufferAttribute([
            0,
            0,
            0,
            0,
            1,
            0
        ], 3));
        coneGeometry = new CylinderBufferGeometry(0, 0.5, 1, 5, 1);
        coneGeometry.translate(0, -0.5, 0);
    }
    this.position.copy(origin);
    this.line = new Line(lineGeometry, new LineBasicMaterial({
        color: color
    }));
    this.line.matrixAutoUpdate = false;
    this.add(this.line);
    this.cone = new Mesh(coneGeometry, new MeshBasicMaterial({
        color: color
    }));
    this.cone.matrixAutoUpdate = false;
    this.add(this.cone);
    this.setDirection(dir);
    this.setLength(length, headLength, headWidth);
}
ArrowHelper.prototype = Object.create(Object3D.prototype);
ArrowHelper.prototype.constructor = ArrowHelper;
ArrowHelper.prototype.setDirection = function() {
    var axis = new Vector3();
    var radians;
    return function setDirection(dir) {
        // dir is assumed to be normalized
        if (dir.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
        else if (dir.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
        else {
            axis.set(dir.z, 0, -dir.x).normalize();
            radians = Math.acos(dir.y);
            this.quaternion.setFromAxisAngle(axis, radians);
        }
    };
}();
ArrowHelper.prototype.setLength = function(length, headLength, headWidth) {
    if (headLength === undefined) headLength = 0.2 * length;
    if (headWidth === undefined) headWidth = 0.2 * headLength;
    this.line.scale.set(1, Math.max(0, length - headLength), 1);
    this.line.updateMatrix();
    this.cone.scale.set(headWidth, headLength, headWidth);
    this.cone.position.y = length;
    this.cone.updateMatrix();
};
ArrowHelper.prototype.setColor = function(color) {
    this.line.material.color.copy(color);
    this.cone.material.color.copy(color);
};
ArrowHelper.prototype.copy = function(source) {
    Object3D.prototype.copy.call(this, source, false);
    this.line.copy(source.line);
    this.cone.copy(source.cone);
    return this;
};
ArrowHelper.prototype.clone = function() {
    return new this.constructor().copy(this);
};
/**
 * @author sroucheray / http://sroucheray.org/
 * @author mrdoob / http://mrdoob.com/
 */ function AxesHelper(size) {
    size = size || 1;
    var vertices = [
        0,
        0,
        0,
        size,
        0,
        0,
        0,
        0,
        0,
        0,
        size,
        0,
        0,
        0,
        0,
        0,
        0,
        size
    ];
    var colors = [
        1,
        0,
        0,
        1,
        0.6,
        0,
        0,
        1,
        0,
        0.6,
        1,
        0,
        0,
        0,
        1,
        0,
        0.6,
        1
    ];
    var geometry = new BufferGeometry();
    geometry.addAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry.addAttribute("color", new Float32BufferAttribute(colors, 3));
    var material = new LineBasicMaterial({
        vertexColors: VertexColors
    });
    LineSegments.call(this, geometry, material);
}
AxesHelper.prototype = Object.create(LineSegments.prototype);
AxesHelper.prototype.constructor = AxesHelper;
/**
 * @author mrdoob / http://mrdoob.com/
 */ function Face4(a, b, c, d, normal, color, materialIndex) {
    console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead.");
    return new Face3(a, b, c, normal, color, materialIndex);
}
var LineStrip = 0;
var LinePieces = 1;
function MeshFaceMaterial(materials) {
    console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead.");
    return materials;
}
function MultiMaterial(materials) {
    if (materials === undefined) materials = [];
    console.warn("THREE.MultiMaterial has been removed. Use an Array instead.");
    materials.isMultiMaterial = true;
    materials.materials = materials;
    materials.clone = function() {
        return materials.slice();
    };
    return materials;
}
function PointCloud(geometry, material) {
    console.warn("THREE.PointCloud has been renamed to THREE.Points.");
    return new Points(geometry, material);
}
function Particle(material) {
    console.warn("THREE.Particle has been renamed to THREE.Sprite.");
    return new Sprite(material);
}
function ParticleSystem(geometry, material) {
    console.warn("THREE.ParticleSystem has been renamed to THREE.Points.");
    return new Points(geometry, material);
}
function PointCloudMaterial(parameters) {
    console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.");
    return new PointsMaterial(parameters);
}
function ParticleBasicMaterial(parameters) {
    console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.");
    return new PointsMaterial(parameters);
}
function ParticleSystemMaterial(parameters) {
    console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.");
    return new PointsMaterial(parameters);
}
function Vertex(x, y, z) {
    console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead.");
    return new Vector3(x, y, z);
}
//
function DynamicBufferAttribute(array, itemSize) {
    console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.");
    return new BufferAttribute(array, itemSize).setDynamic(true);
}
function Int8Attribute(array, itemSize) {
    console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.");
    return new Int8BufferAttribute(array, itemSize);
}
function Uint8Attribute(array, itemSize) {
    console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.");
    return new Uint8BufferAttribute(array, itemSize);
}
function Uint8ClampedAttribute(array, itemSize) {
    console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.");
    return new Uint8ClampedBufferAttribute(array, itemSize);
}
function Int16Attribute(array, itemSize) {
    console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.");
    return new Int16BufferAttribute(array, itemSize);
}
function Uint16Attribute(array, itemSize) {
    console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.");
    return new Uint16BufferAttribute(array, itemSize);
}
function Int32Attribute(array, itemSize) {
    console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.");
    return new Int32BufferAttribute(array, itemSize);
}
function Uint32Attribute(array, itemSize) {
    console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.");
    return new Uint32BufferAttribute(array, itemSize);
}
function Float32Attribute(array, itemSize) {
    console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.");
    return new Float32BufferAttribute(array, itemSize);
}
function Float64Attribute(array, itemSize) {
    console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.");
    return new Float64BufferAttribute(array, itemSize);
}
//
Curve.create = function(construct, getPoint) {
    console.log("THREE.Curve.create() has been deprecated");
    construct.prototype = Object.create(Curve.prototype);
    construct.prototype.constructor = construct;
    construct.prototype.getPoint = getPoint;
    return construct;
};
//
Object.assign(CurvePath.prototype, {
    createPointsGeometry: function(divisions) {
        console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
        // generate geometry from path points (for Line or Points objects)
        var pts = this.getPoints(divisions);
        return this.createGeometry(pts);
    },
    createSpacedPointsGeometry: function(divisions) {
        console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
        // generate geometry from equidistant sampling along the path
        var pts = this.getSpacedPoints(divisions);
        return this.createGeometry(pts);
    },
    createGeometry: function(points) {
        console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
        var geometry = new Geometry();
        for(var i = 0, l = points.length; i < l; i++){
            var point = points[i];
            geometry.vertices.push(new Vector3(point.x, point.y, point.z || 0));
        }
        return geometry;
    }
});
//
Object.assign(Path.prototype, {
    fromPoints: function(points) {
        console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints().");
        this.setFromPoints(points);
    }
});
//
function ClosedSplineCurve3(points) {
    console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.");
    CatmullRomCurve3.call(this, points);
    this.type = "catmullrom";
    this.closed = true;
}
ClosedSplineCurve3.prototype = Object.create(CatmullRomCurve3.prototype);
//
function SplineCurve3(points) {
    console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.");
    CatmullRomCurve3.call(this, points);
    this.type = "catmullrom";
}
SplineCurve3.prototype = Object.create(CatmullRomCurve3.prototype);
//
function Spline(points) {
    console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.");
    CatmullRomCurve3.call(this, points);
    this.type = "catmullrom";
}
Spline.prototype = Object.create(CatmullRomCurve3.prototype);
Object.assign(Spline.prototype, {
    initFromArray: function() {
        console.error("THREE.Spline: .initFromArray() has been removed.");
    },
    getControlPointsArray: function() {
        console.error("THREE.Spline: .getControlPointsArray() has been removed.");
    },
    reparametrizeByArcLength: function() {
        console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.");
    }
});
//
function AxisHelper(size) {
    console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper.");
    return new AxesHelper(size);
}
function BoundingBoxHelper(object, color) {
    console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.");
    return new BoxHelper(object, color);
}
function EdgesHelper(object, hex) {
    console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.");
    return new LineSegments(new EdgesGeometry(object.geometry), new LineBasicMaterial({
        color: hex !== undefined ? hex : 0xffffff
    }));
}
GridHelper.prototype.setColors = function() {
    console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
};
SkeletonHelper.prototype.update = function() {
    console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
};
function WireframeHelper(object, hex) {
    console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.");
    return new LineSegments(new WireframeGeometry(object.geometry), new LineBasicMaterial({
        color: hex !== undefined ? hex : 0xffffff
    }));
}
//
Object.assign(Loader.prototype, {
    extractUrlBase: function(url) {
        console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.");
        return LoaderUtils.extractUrlBase(url);
    }
});
function XHRLoader(manager) {
    console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader.");
    return new FileLoader(manager);
}
function BinaryTextureLoader(manager) {
    console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.");
    return new DataTextureLoader(manager);
}
Object.assign(ObjectLoader.prototype, {
    setTexturePath: function(value) {
        console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().");
        return this.setResourcePath(value);
    }
});
//
Object.assign(Box2.prototype, {
    center: function(optionalTarget) {
        console.warn("THREE.Box2: .center() has been renamed to .getCenter().");
        return this.getCenter(optionalTarget);
    },
    empty: function() {
        console.warn("THREE.Box2: .empty() has been renamed to .isEmpty().");
        return this.isEmpty();
    },
    isIntersectionBox: function(box) {
        console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().");
        return this.intersectsBox(box);
    },
    size: function(optionalTarget) {
        console.warn("THREE.Box2: .size() has been renamed to .getSize().");
        return this.getSize(optionalTarget);
    }
});
Object.assign(Box3.prototype, {
    center: function(optionalTarget) {
        console.warn("THREE.Box3: .center() has been renamed to .getCenter().");
        return this.getCenter(optionalTarget);
    },
    empty: function() {
        console.warn("THREE.Box3: .empty() has been renamed to .isEmpty().");
        return this.isEmpty();
    },
    isIntersectionBox: function(box) {
        console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().");
        return this.intersectsBox(box);
    },
    isIntersectionSphere: function(sphere) {
        console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().");
        return this.intersectsSphere(sphere);
    },
    size: function(optionalTarget) {
        console.warn("THREE.Box3: .size() has been renamed to .getSize().");
        return this.getSize(optionalTarget);
    }
});
Line3.prototype.center = function(optionalTarget) {
    console.warn("THREE.Line3: .center() has been renamed to .getCenter().");
    return this.getCenter(optionalTarget);
};
Object.assign(_Math, {
    random16: function() {
        console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead.");
        return Math.random();
    },
    nearestPowerOfTwo: function(value) {
        console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().");
        return _Math.floorPowerOfTwo(value);
    },
    nextPowerOfTwo: function(value) {
        console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().");
        return _Math.ceilPowerOfTwo(value);
    }
});
Object.assign(Matrix3.prototype, {
    flattenToArrayOffset: function(array, offset) {
        console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
        return this.toArray(array, offset);
    },
    multiplyVector3: function(vector) {
        console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.");
        return vector.applyMatrix3(this);
    },
    multiplyVector3Array: function() {
        console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
    },
    applyToBuffer: function(buffer /*, offset, length */ ) {
        console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.");
        return this.applyToBufferAttribute(buffer);
    },
    applyToVector3Array: function() {
        console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
    }
});
Object.assign(Matrix4.prototype, {
    extractPosition: function(m) {
        console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().");
        return this.copyPosition(m);
    },
    flattenToArrayOffset: function(array, offset) {
        console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
        return this.toArray(array, offset);
    },
    getPosition: function() {
        var v1;
        return function getPosition() {
            if (v1 === undefined) v1 = new Vector3();
            console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");
            return v1.setFromMatrixColumn(this, 3);
        };
    }(),
    setRotationFromQuaternion: function(q) {
        console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().");
        return this.makeRotationFromQuaternion(q);
    },
    multiplyToArray: function() {
        console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
    },
    multiplyVector3: function(vector) {
        console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.");
        return vector.applyMatrix4(this);
    },
    multiplyVector4: function(vector) {
        console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.");
        return vector.applyMatrix4(this);
    },
    multiplyVector3Array: function() {
        console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
    },
    rotateAxis: function(v) {
        console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.");
        v.transformDirection(this);
    },
    crossVector: function(vector) {
        console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.");
        return vector.applyMatrix4(this);
    },
    translate: function() {
        console.error("THREE.Matrix4: .translate() has been removed.");
    },
    rotateX: function() {
        console.error("THREE.Matrix4: .rotateX() has been removed.");
    },
    rotateY: function() {
        console.error("THREE.Matrix4: .rotateY() has been removed.");
    },
    rotateZ: function() {
        console.error("THREE.Matrix4: .rotateZ() has been removed.");
    },
    rotateByAxis: function() {
        console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
    },
    applyToBuffer: function(buffer /*, offset, length */ ) {
        console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.");
        return this.applyToBufferAttribute(buffer);
    },
    applyToVector3Array: function() {
        console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
    },
    makeFrustum: function(left, right, bottom, top, near, far) {
        console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.");
        return this.makePerspective(left, right, top, bottom, near, far);
    }
});
Plane.prototype.isIntersectionLine = function(line) {
    console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().");
    return this.intersectsLine(line);
};
Quaternion.prototype.multiplyVector3 = function(vector) {
    console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.");
    return vector.applyQuaternion(this);
};
Object.assign(Ray.prototype, {
    isIntersectionBox: function(box) {
        console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().");
        return this.intersectsBox(box);
    },
    isIntersectionPlane: function(plane) {
        console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().");
        return this.intersectsPlane(plane);
    },
    isIntersectionSphere: function(sphere) {
        console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().");
        return this.intersectsSphere(sphere);
    }
});
Object.assign(Triangle.prototype, {
    area: function() {
        console.warn("THREE.Triangle: .area() has been renamed to .getArea().");
        return this.getArea();
    },
    barycoordFromPoint: function(point, target) {
        console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
        return this.getBarycoord(point, target);
    },
    midpoint: function(target) {
        console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint().");
        return this.getMidpoint(target);
    },
    normal: function(target) {
        console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
        return this.getNormal(target);
    },
    plane: function(target) {
        console.warn("THREE.Triangle: .plane() has been renamed to .getPlane().");
        return this.getPlane(target);
    }
});
Object.assign(Triangle, {
    barycoordFromPoint: function(point, a, b, c, target) {
        console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
        return Triangle.getBarycoord(point, a, b, c, target);
    },
    normal: function(a, b, c, target) {
        console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
        return Triangle.getNormal(a, b, c, target);
    }
});
Object.assign(Shape.prototype, {
    extractAllPoints: function(divisions) {
        console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.");
        return this.extractPoints(divisions);
    },
    extrude: function(options) {
        console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.");
        return new ExtrudeGeometry(this, options);
    },
    makeGeometry: function(options) {
        console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.");
        return new ShapeGeometry(this, options);
    }
});
Object.assign(Vector2.prototype, {
    fromAttribute: function(attribute, index, offset) {
        console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().");
        return this.fromBufferAttribute(attribute, index, offset);
    },
    distanceToManhattan: function(v) {
        console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
        return this.manhattanDistanceTo(v);
    },
    lengthManhattan: function() {
        console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().");
        return this.manhattanLength();
    }
});
Object.assign(Vector3.prototype, {
    setEulerFromRotationMatrix: function() {
        console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
    },
    setEulerFromQuaternion: function() {
        console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
    },
    getPositionFromMatrix: function(m) {
        console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().");
        return this.setFromMatrixPosition(m);
    },
    getScaleFromMatrix: function(m) {
        console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().");
        return this.setFromMatrixScale(m);
    },
    getColumnFromMatrix: function(index, matrix) {
        console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().");
        return this.setFromMatrixColumn(matrix, index);
    },
    applyProjection: function(m) {
        console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.");
        return this.applyMatrix4(m);
    },
    fromAttribute: function(attribute, index, offset) {
        console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().");
        return this.fromBufferAttribute(attribute, index, offset);
    },
    distanceToManhattan: function(v) {
        console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
        return this.manhattanDistanceTo(v);
    },
    lengthManhattan: function() {
        console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().");
        return this.manhattanLength();
    }
});
Object.assign(Vector4.prototype, {
    fromAttribute: function(attribute, index, offset) {
        console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().");
        return this.fromBufferAttribute(attribute, index, offset);
    },
    lengthManhattan: function() {
        console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().");
        return this.manhattanLength();
    }
});
//
Object.assign(Geometry.prototype, {
    computeTangents: function() {
        console.error("THREE.Geometry: .computeTangents() has been removed.");
    },
    computeLineDistances: function() {
        console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.");
    }
});
Object.assign(Object3D.prototype, {
    getChildByName: function(name) {
        console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().");
        return this.getObjectByName(name);
    },
    renderDepth: function() {
        console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
    },
    translate: function(distance, axis) {
        console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.");
        return this.translateOnAxis(axis, distance);
    },
    getWorldRotation: function() {
        console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.");
    }
});
Object.defineProperties(Object3D.prototype, {
    eulerOrder: {
        get: function() {
            console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
            return this.rotation.order;
        },
        set: function(value) {
            console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
            this.rotation.order = value;
        }
    },
    useQuaternion: {
        get: function() {
            console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
        },
        set: function() {
            console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
        }
    }
});
Object.defineProperties(LOD.prototype, {
    objects: {
        get: function() {
            console.warn("THREE.LOD: .objects has been renamed to .levels.");
            return this.levels;
        }
    }
});
Object.defineProperty(Skeleton.prototype, "useVertexTexture", {
    get: function() {
        console.warn("THREE.Skeleton: useVertexTexture has been removed.");
    },
    set: function() {
        console.warn("THREE.Skeleton: useVertexTexture has been removed.");
    }
});
SkinnedMesh.prototype.initBones = function() {
    console.error("THREE.SkinnedMesh: initBones() has been removed.");
};
Object.defineProperty(Curve.prototype, "__arcLengthDivisions", {
    get: function() {
        console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.");
        return this.arcLengthDivisions;
    },
    set: function(value) {
        console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.");
        this.arcLengthDivisions = value;
    }
});
//
PerspectiveCamera.prototype.setLens = function(focalLength, filmGauge) {
    console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.");
    if (filmGauge !== undefined) this.filmGauge = filmGauge;
    this.setFocalLength(focalLength);
};
//
Object.defineProperties(Light.prototype, {
    onlyShadow: {
        set: function() {
            console.warn("THREE.Light: .onlyShadow has been removed.");
        }
    },
    shadowCameraFov: {
        set: function(value) {
            console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov.");
            this.shadow.camera.fov = value;
        }
    },
    shadowCameraLeft: {
        set: function(value) {
            console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left.");
            this.shadow.camera.left = value;
        }
    },
    shadowCameraRight: {
        set: function(value) {
            console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right.");
            this.shadow.camera.right = value;
        }
    },
    shadowCameraTop: {
        set: function(value) {
            console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top.");
            this.shadow.camera.top = value;
        }
    },
    shadowCameraBottom: {
        set: function(value) {
            console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.");
            this.shadow.camera.bottom = value;
        }
    },
    shadowCameraNear: {
        set: function(value) {
            console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near.");
            this.shadow.camera.near = value;
        }
    },
    shadowCameraFar: {
        set: function(value) {
            console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far.");
            this.shadow.camera.far = value;
        }
    },
    shadowCameraVisible: {
        set: function() {
            console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
        }
    },
    shadowBias: {
        set: function(value) {
            console.warn("THREE.Light: .shadowBias is now .shadow.bias.");
            this.shadow.bias = value;
        }
    },
    shadowDarkness: {
        set: function() {
            console.warn("THREE.Light: .shadowDarkness has been removed.");
        }
    },
    shadowMapWidth: {
        set: function(value) {
            console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.");
            this.shadow.mapSize.width = value;
        }
    },
    shadowMapHeight: {
        set: function(value) {
            console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.");
            this.shadow.mapSize.height = value;
        }
    }
});
//
Object.defineProperties(BufferAttribute.prototype, {
    length: {
        get: function() {
            console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead.");
            return this.array.length;
        }
    },
    copyIndicesArray: function() {
        console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.");
    }
});
Object.assign(BufferGeometry.prototype, {
    addIndex: function(index) {
        console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().");
        this.setIndex(index);
    },
    addDrawCall: function(start, count, indexOffset) {
        if (indexOffset !== undefined) console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.");
        console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup().");
        this.addGroup(start, count);
    },
    clearDrawCalls: function() {
        console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().");
        this.clearGroups();
    },
    computeTangents: function() {
        console.warn("THREE.BufferGeometry: .computeTangents() has been removed.");
    },
    computeOffsets: function() {
        console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
    }
});
Object.defineProperties(BufferGeometry.prototype, {
    drawcalls: {
        get: function() {
            console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups.");
            return this.groups;
        }
    },
    offsets: {
        get: function() {
            console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups.");
            return this.groups;
        }
    }
});
//
Object.assign(ExtrudeBufferGeometry.prototype, {
    getArrays: function() {
        console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.");
    },
    addShapeList: function() {
        console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.");
    },
    addShape: function() {
        console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.");
    }
});
//
Object.defineProperties(Uniform.prototype, {
    dynamic: {
        set: function() {
            console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.");
        }
    },
    onUpdate: {
        value: function() {
            console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.");
            return this;
        }
    }
});
//
Object.defineProperties(Material.prototype, {
    wrapAround: {
        get: function() {
            console.warn("THREE.Material: .wrapAround has been removed.");
        },
        set: function() {
            console.warn("THREE.Material: .wrapAround has been removed.");
        }
    },
    overdraw: {
        get: function() {
            console.warn("THREE.Material: .overdraw has been removed.");
        },
        set: function() {
            console.warn("THREE.Material: .overdraw has been removed.");
        }
    },
    wrapRGB: {
        get: function() {
            console.warn("THREE.Material: .wrapRGB has been removed.");
            return new Color();
        }
    },
    shading: {
        get: function() {
            console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
        },
        set: function(value) {
            console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
            this.flatShading = value === FlatShading;
        }
    }
});
Object.defineProperties(MeshPhongMaterial.prototype, {
    metal: {
        get: function() {
            console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.");
            return false;
        },
        set: function() {
            console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead");
        }
    }
});
Object.defineProperties(ShaderMaterial.prototype, {
    derivatives: {
        get: function() {
            console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
            return this.extensions.derivatives;
        },
        set: function(value) {
            console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
            this.extensions.derivatives = value;
        }
    }
});
//
Object.assign(WebGLRenderer.prototype, {
    clearTarget: function(renderTarget, color, depth, stencil) {
        console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.");
        this.setRenderTarget(renderTarget);
        this.clear(color, depth, stencil);
    },
    animate: function(callback) {
        console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop().");
        this.setAnimationLoop(callback);
    },
    getCurrentRenderTarget: function() {
        console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().");
        return this.getRenderTarget();
    },
    getMaxAnisotropy: function() {
        console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().");
        return this.capabilities.getMaxAnisotropy();
    },
    getPrecision: function() {
        console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.");
        return this.capabilities.precision;
    },
    resetGLState: function() {
        console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset().");
        return this.state.reset();
    },
    supportsFloatTextures: function() {
        console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' ).");
        return this.extensions.get("OES_texture_float");
    },
    supportsHalfFloatTextures: function() {
        console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' ).");
        return this.extensions.get("OES_texture_half_float");
    },
    supportsStandardDerivatives: function() {
        console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' ).");
        return this.extensions.get("OES_standard_derivatives");
    },
    supportsCompressedTextureS3TC: function() {
        console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' ).");
        return this.extensions.get("WEBGL_compressed_texture_s3tc");
    },
    supportsCompressedTexturePVRTC: function() {
        console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' ).");
        return this.extensions.get("WEBGL_compressed_texture_pvrtc");
    },
    supportsBlendMinMax: function() {
        console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' ).");
        return this.extensions.get("EXT_blend_minmax");
    },
    supportsVertexTextures: function() {
        console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.");
        return this.capabilities.vertexTextures;
    },
    supportsInstancedArrays: function() {
        console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' ).");
        return this.extensions.get("ANGLE_instanced_arrays");
    },
    enableScissorTest: function(boolean) {
        console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().");
        this.setScissorTest(boolean);
    },
    initMaterial: function() {
        console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
    },
    addPrePlugin: function() {
        console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
    },
    addPostPlugin: function() {
        console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
    },
    updateShadowMap: function() {
        console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
    },
    setFaceCulling: function() {
        console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
    }
});
Object.defineProperties(WebGLRenderer.prototype, {
    shadowMapEnabled: {
        get: function() {
            return this.shadowMap.enabled;
        },
        set: function(value) {
            console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.");
            this.shadowMap.enabled = value;
        }
    },
    shadowMapType: {
        get: function() {
            return this.shadowMap.type;
        },
        set: function(value) {
            console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.");
            this.shadowMap.type = value;
        }
    },
    shadowMapCullFace: {
        get: function() {
            console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
            return undefined;
        },
        set: function() {
            console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
        }
    }
});
Object.defineProperties(WebGLShadowMap.prototype, {
    cullFace: {
        get: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
            return undefined;
        },
        set: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
        }
    },
    renderReverseSided: {
        get: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
            return undefined;
        },
        set: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
        }
    },
    renderSingleSided: {
        get: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
            return undefined;
        },
        set: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
        }
    }
});
//
Object.defineProperties(WebGLRenderTarget.prototype, {
    wrapS: {
        get: function() {
            console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
            return this.texture.wrapS;
        },
        set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
            this.texture.wrapS = value;
        }
    },
    wrapT: {
        get: function() {
            console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
            return this.texture.wrapT;
        },
        set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
            this.texture.wrapT = value;
        }
    },
    magFilter: {
        get: function() {
            console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
            return this.texture.magFilter;
        },
        set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
            this.texture.magFilter = value;
        }
    },
    minFilter: {
        get: function() {
            console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
            return this.texture.minFilter;
        },
        set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
            this.texture.minFilter = value;
        }
    },
    anisotropy: {
        get: function() {
            console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
            return this.texture.anisotropy;
        },
        set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
            this.texture.anisotropy = value;
        }
    },
    offset: {
        get: function() {
            console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
            return this.texture.offset;
        },
        set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
            this.texture.offset = value;
        }
    },
    repeat: {
        get: function() {
            console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
            return this.texture.repeat;
        },
        set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
            this.texture.repeat = value;
        }
    },
    format: {
        get: function() {
            console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
            return this.texture.format;
        },
        set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
            this.texture.format = value;
        }
    },
    type: {
        get: function() {
            console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
            return this.texture.type;
        },
        set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
            this.texture.type = value;
        }
    },
    generateMipmaps: {
        get: function() {
            console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
            return this.texture.generateMipmaps;
        },
        set: function(value) {
            console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
            this.texture.generateMipmaps = value;
        }
    }
});
//
Object.defineProperties(WebVRManager.prototype, {
    standing: {
        set: function() {
            console.warn("THREE.WebVRManager: .standing has been removed.");
        }
    },
    userHeight: {
        set: function() {
            console.warn("THREE.WebVRManager: .userHeight has been removed.");
        }
    }
});
//
Audio.prototype.load = function(file) {
    console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
    var scope = this;
    var audioLoader = new AudioLoader();
    audioLoader.load(file, function(buffer) {
        scope.setBuffer(buffer);
    });
    return this;
};
AudioAnalyser.prototype.getData = function() {
    console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData().");
    return this.getFrequencyData();
};
//
CubeCamera.prototype.updateCubeMap = function(renderer, scene) {
    console.warn("THREE.CubeCamera: .updateCubeMap() is now .update().");
    return this.update(renderer, scene);
};
//
var GeometryUtils = {
    merge: function(geometry1, geometry2, materialIndexOffset) {
        console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.");
        var matrix;
        if (geometry2.isMesh) {
            geometry2.matrixAutoUpdate && geometry2.updateMatrix();
            matrix = geometry2.matrix;
            geometry2 = geometry2.geometry;
        }
        geometry1.merge(geometry2, matrix, materialIndexOffset);
    },
    center: function(geometry) {
        console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.");
        return geometry.center();
    }
};
ImageUtils.crossOrigin = undefined;
ImageUtils.loadTexture = function(url, mapping, onLoad, onError) {
    console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
    var loader = new TextureLoader();
    loader.setCrossOrigin(this.crossOrigin);
    var texture = loader.load(url, onLoad, undefined, onError);
    if (mapping) texture.mapping = mapping;
    return texture;
};
ImageUtils.loadTextureCube = function(urls, mapping, onLoad, onError) {
    console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
    var loader = new CubeTextureLoader();
    loader.setCrossOrigin(this.crossOrigin);
    var texture = loader.load(urls, onLoad, undefined, onError);
    if (mapping) texture.mapping = mapping;
    return texture;
};
ImageUtils.loadCompressedTexture = function() {
    console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
};
ImageUtils.loadCompressedTextureCube = function() {
    console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
};
//
function Projector() {
    console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js.");
    this.projectVector = function(vector, camera) {
        console.warn("THREE.Projector: .projectVector() is now vector.project().");
        vector.project(camera);
    };
    this.unprojectVector = function(vector, camera) {
        console.warn("THREE.Projector: .unprojectVector() is now vector.unproject().");
        vector.unproject(camera);
    };
    this.pickingRay = function() {
        console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().");
    };
}
//
function CanvasRenderer() {
    console.error("THREE.CanvasRenderer has been removed");
}
//
function JSONLoader() {
    console.error("THREE.JSONLoader has been removed.");
}
//
var SceneUtils = {
    createMultiMaterialObject: function() {
        console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js");
    },
    detach: function() {
        console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js");
    },
    attach: function() {
        console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js");
    }
};
//
function LensFlare() {
    console.error("THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js");
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"bnxJ5"}],"7g2Az":[function(require,module,exports) {
/**
 * @author takahirox / http://github.com/takahirox/
 *
 * Reference: https://en.wikipedia.org/wiki/Cel_shading
 *
 * // How to set default outline parameters
 * new THREE.OutlineEffect( renderer, {
 * 	defaultThickness: 0.01,
 * 	defaultColor: [ 0, 0, 0 ],
 * 	defaultAlpha: 0.8,
 * 	defaultKeepAlive: true // keeps outline material in cache even if material is removed from scene
 * } );
 *
 * // How to set outline parameters for each material
 * material.userData.outlineParameters = {
 * 	thickness: 0.01,
 * 	color: [ 0, 0, 0 ]
 * 	alpha: 0.8,
 * 	visible: true,
 * 	keepAlive: true
 * };
 *
 * TODO
 *  - support shader material without objectNormal in its vertexShader
 */ THREE.OutlineEffect = function(renderer, parameters) {
    parameters = parameters || {};
    this.enabled = true;
    var defaultThickness = parameters.defaultThickness !== undefined ? parameters.defaultThickness : 0.003;
    var defaultColor = parameters.defaultColor || new THREE.Color().fromArray(parameters.defaultColor !== undefined ? parameters.defaultColor : [
        0,
        0,
        0
    ]);
    var defaultAlpha = parameters.defaultAlpha !== undefined ? parameters.defaultAlpha : 1.0;
    var defaultKeepAlive = parameters.defaultKeepAlive !== undefined ? parameters.defaultKeepAlive : false;
    // object.material.uuid -> outlineMaterial or
    // object.material[ n ].uuid -> outlineMaterial
    // save at the outline material creation and release
    // if it's unused removeThresholdCount frames
    // unless keepAlive is true.
    var cache = {};
    var removeThresholdCount = 60;
    // outlineMaterial.uuid -> object.material or
    // outlineMaterial.uuid -> object.material[ n ]
    // save before render and release after render.
    var originalMaterials = {};
    // object.uuid -> originalOnBeforeRender
    // save before render and release after render.
    var originalOnBeforeRenders = {};
    //this.cache = cache;  // for debug
    // copied from WebGLPrograms and removed some materials
    var shaderIDs = {
        MeshBasicMaterial: "basic",
        MeshLambertMaterial: "lambert",
        MeshPhongMaterial: "phong",
        MeshToonMaterial: "phong",
        MeshStandardMaterial: "physical",
        MeshPhysicalMaterial: "physical"
    };
    var uniformsChunk = {
        outlineThickness: {
            type: "f",
            value: defaultThickness
        },
        outlineColor: {
            type: "c",
            value: defaultColor
        },
        outlineAlpha: {
            type: "f",
            value: defaultAlpha
        }
    };
    var vertexShaderChunk = [
        // "#include <fog_pars_vertex>",
        "uniform float outlineThickness;",
        "vec4 calculateOutline( vec4 pos, vec3 objectNormal, vec4 skinned ) {",
        "	float thickness = outlineThickness;",
        "	const float ratio = 1.0;",
        "	vec4 pos2 = projectionMatrix * modelViewMatrix * vec4( skinned.xyz + objectNormal, 1.0 );",
        // NOTE: subtract pos2 from pos because BackSide objectNormal is negative
        "	vec4 norm = normalize( pos - pos2 );",
        "	return pos + norm * thickness * pos.w * ratio;",
        "}"
    ].join("\n");
    var vertexShaderChunk2 = [
        "#if ! defined( LAMBERT ) && ! defined( PHONG ) && ! defined( TOON ) && ! defined( PHYSICAL )",
        "	#ifndef USE_ENVMAP",
        "		vec3 objectNormal = normalize( normal );",
        "	#endif",
        "#endif",
        "#ifdef FLIP_SIDED",
        "	objectNormal = -objectNormal;",
        "#endif",
        "#ifdef DECLARE_TRANSFORMED",
        "	vec3 transformed = vec3( position );",
        "#endif",
        "gl_Position = calculateOutline( gl_Position, objectNormal, vec4( transformed, 1.0 ) );",
        "#include <fog_vertex>"
    ].join("\n");
    var fragmentShader = [
        "#include <common>",
        "#include <fog_pars_fragment>",
        "uniform vec3 outlineColor;",
        "uniform float outlineAlpha;",
        "void main() {",
        "	gl_FragColor = vec4( outlineColor, outlineAlpha );",
        "	#include <fog_fragment>",
        "}"
    ].join("\n");
    function createInvisibleMaterial() {
        return new THREE.ShaderMaterial({
            name: "invisible",
            visible: false
        });
    }
    function createMaterial(originalMaterial) {
        var shaderID = shaderIDs[originalMaterial.type];
        var originalUniforms, originalVertexShader;
        var outlineParameters = originalMaterial.userData.outlineParameters;
        if (shaderID !== undefined) {
            var shader = THREE.ShaderLib[shaderID];
            originalUniforms = shader.uniforms;
            originalVertexShader = shader.vertexShader;
        } else if (originalMaterial.isRawShaderMaterial === true) {
            originalUniforms = originalMaterial.uniforms;
            originalVertexShader = originalMaterial.vertexShader;
            if (!/attribute\s+vec3\s+position\s*;/.test(originalVertexShader) || !/attribute\s+vec3\s+normal\s*;/.test(originalVertexShader)) {
                console.warn("THREE.OutlineEffect requires both vec3 position and normal attributes in vertex shader, does not draw outline for " + originalMaterial.name + "(uuid:" + originalMaterial.uuid + ") material.");
                return createInvisibleMaterial();
            }
        } else if (originalMaterial.isShaderMaterial === true) {
            originalUniforms = originalMaterial.uniforms;
            originalVertexShader = originalMaterial.vertexShader;
        } else return createInvisibleMaterial();
        var uniforms = Object.assign({}, originalUniforms, uniformsChunk);
        var vertexShader = originalVertexShader// put vertexShaderChunk right before "void main() {...}"
        .replace(/void\s+main\s*\(\s*\)/, vertexShaderChunk + "\nvoid main()")// put vertexShaderChunk2 the end of "void main() {...}"
        // Note: here assums originalVertexShader ends with "}" of "void main() {...}"
        .replace(/\}\s*$/, vertexShaderChunk2 + "\n}")// remove any light related lines
        // Note: here is very sensitive to originalVertexShader
        // TODO: consider safer way
        .replace(/#include\s+<[\w_]*light[\w_]*>/g, "");
        var defines = {};
        if (!/vec3\s+transformed\s*=/.test(originalVertexShader) && !/#include\s+<begin_vertex>/.test(originalVertexShader)) defines.DECLARE_TRANSFORMED = true;
        return new THREE.ShaderMaterial({
            defines: defines,
            uniforms: uniforms,
            vertexShader: vertexShader,
            fragmentShader: fragmentShader,
            side: THREE.BackSide,
            //wireframe: true,
            skinning: false,
            morphTargets: false,
            morphNormals: false,
            fog: false
        });
    }
    function getOutlineMaterialFromCache(originalMaterial) {
        var data = cache[originalMaterial.uuid];
        if (data === undefined) {
            data = {
                material: createMaterial(originalMaterial),
                used: true,
                keepAlive: defaultKeepAlive,
                count: 0
            };
            cache[originalMaterial.uuid] = data;
        }
        data.used = true;
        return data.material;
    }
    function getOutlineMaterial(originalMaterial) {
        var outlineMaterial = getOutlineMaterialFromCache(originalMaterial);
        originalMaterials[outlineMaterial.uuid] = originalMaterial;
        updateOutlineMaterial(outlineMaterial, originalMaterial);
        return outlineMaterial;
    }
    function setOutlineMaterial(object) {
        if (object.material === undefined) return;
        if (Array.isArray(object.material)) for(var i = 0, il = object.material.length; i < il; i++)object.material[i] = getOutlineMaterial(object.material[i]);
        else object.material = getOutlineMaterial(object.material);
        originalOnBeforeRenders[object.uuid] = object.onBeforeRender;
        object.onBeforeRender = onBeforeRender;
    }
    function restoreOriginalMaterial(object) {
        if (object.material === undefined) return;
        if (Array.isArray(object.material)) for(var i = 0, il = object.material.length; i < il; i++)object.material[i] = originalMaterials[object.material[i].uuid];
        else object.material = originalMaterials[object.material.uuid];
        object.onBeforeRender = originalOnBeforeRenders[object.uuid];
    }
    function onBeforeRender(renderer, scene, camera, geometry, material, group) {
        var originalMaterial = originalMaterials[material.uuid];
        // just in case
        if (originalMaterial === undefined) return;
        updateUniforms(material, originalMaterial);
    }
    function updateUniforms(material, originalMaterial) {
        var outlineParameters = originalMaterial.userData.outlineParameters;
        material.uniforms.outlineAlpha.value = originalMaterial.opacity;
        if (outlineParameters !== undefined) {
            if (outlineParameters.thickness !== undefined) material.uniforms.outlineThickness.value = outlineParameters.thickness;
            if (outlineParameters.color !== undefined) material.uniforms.outlineColor.value.fromArray(outlineParameters.color);
            if (outlineParameters.alpha !== undefined) material.uniforms.outlineAlpha.value = outlineParameters.alpha;
        }
    }
    function updateOutlineMaterial(material, originalMaterial) {
        if (material.name === "invisible") return;
        var outlineParameters = originalMaterial.userData.outlineParameters;
        material.skinning = originalMaterial.skinning;
        material.morphTargets = originalMaterial.morphTargets;
        material.morphNormals = originalMaterial.morphNormals;
        material.fog = originalMaterial.fog;
        if (outlineParameters !== undefined) {
            if (originalMaterial.visible === false) material.visible = false;
            else material.visible = outlineParameters.visible !== undefined ? outlineParameters.visible : true;
            material.transparent = outlineParameters.alpha !== undefined && outlineParameters.alpha < 1.0 ? true : originalMaterial.transparent;
            if (outlineParameters.keepAlive !== undefined) cache[originalMaterial.uuid].keepAlive = outlineParameters.keepAlive;
        } else {
            material.transparent = originalMaterial.transparent;
            material.visible = originalMaterial.visible;
        }
        if (originalMaterial.wireframe === true || originalMaterial.depthTest === false) material.visible = false;
    }
    function cleanupCache() {
        var keys;
        // clear originialMaterials
        keys = Object.keys(originalMaterials);
        for(var i = 0, il = keys.length; i < il; i++)originalMaterials[keys[i]] = undefined;
        // clear originalOnBeforeRenders
        keys = Object.keys(originalOnBeforeRenders);
        for(var i = 0, il = keys.length; i < il; i++)originalOnBeforeRenders[keys[i]] = undefined;
        // remove unused outlineMaterial from cache
        keys = Object.keys(cache);
        for(var i = 0, il = keys.length; i < il; i++){
            var key = keys[i];
            if (cache[key].used === false) {
                cache[key].count++;
                if (cache[key].keepAlive === false && cache[key].count > removeThresholdCount) delete cache[key];
            } else {
                cache[key].used = false;
                cache[key].count = 0;
            }
        }
    }
    this.render = function(scene, camera, renderTarget, forceClear) {
        if (this.enabled === false) {
            renderer.render(scene, camera, renderTarget, forceClear);
            return;
        }
        var currentAutoClear = renderer.autoClear;
        renderer.autoClear = this.autoClear;
        // 1. render normally
        renderer.render(scene, camera, renderTarget, forceClear);
        // 2. render outline
        var currentSceneAutoUpdate = scene.autoUpdate;
        var currentSceneBackground = scene.background;
        var currentShadowMapEnabled = renderer.shadowMap.enabled;
        scene.autoUpdate = false;
        scene.background = null;
        renderer.autoClear = false;
        renderer.shadowMap.enabled = false;
        scene.traverse(setOutlineMaterial);
        renderer.render(scene, camera, renderTarget);
        scene.traverse(restoreOriginalMaterial);
        cleanupCache();
        scene.autoUpdate = currentSceneAutoUpdate;
        scene.background = currentSceneBackground;
        renderer.autoClear = currentAutoClear;
        renderer.shadowMap.enabled = currentShadowMapEnabled;
    };
    /*
	 * See #9918
	 *
	 * The following property copies and wrapper methods enable
	 * THREE.OutlineEffect to be called from other *Effect, like
	 *
	 * effect = new THREE.StereoEffect( new THREE.OutlineEffect( renderer ) );
	 *
	 * function render () {
	 *
 	 * 	effect.render( scene, camera );
	 *
	 * }
	 */ this.autoClear = renderer.autoClear;
    this.domElement = renderer.domElement;
    this.shadowMap = renderer.shadowMap;
    this.clear = function(color, depth, stencil) {
        renderer.clear(color, depth, stencil);
    };
    this.getPixelRatio = function() {
        return renderer.getPixelRatio();
    };
    this.setPixelRatio = function(value) {
        renderer.setPixelRatio(value);
    };
    this.getSize = function() {
        return renderer.getSize();
    };
    this.setSize = function(width, height, updateStyle) {
        renderer.setSize(width, height, updateStyle);
    };
    this.setViewport = function(x, y, width, height) {
        renderer.setViewport(x, y, width, height);
    };
    this.setScissor = function(x, y, width, height) {
        renderer.setScissor(x, y, width, height);
    };
    this.setScissorTest = function(boolean) {
        renderer.setScissorTest(boolean);
    };
    this.setRenderTarget = function(renderTarget) {
        renderer.setRenderTarget(renderTarget);
    };
};

},{}],"jdCb6":[function(require,module,exports) {
"use strict";
// lib
const { Observable } = require("54be499136595a8");
// threejs
const THREE = require("d003712c273bbfe2");
window.THREE = window.THREE || THREE;
require("83922f89d1aacd6a");
const load = (url)=>new Observable((observer)=>new THREE.ColladaLoader(new THREE.LoadingManager()).load(url, function(collada) {
            observer.next(collada);
            observer.complete();
        }));
module.exports = {
    load
};

},{"54be499136595a8":"hWUVi","d003712c273bbfe2":"5IrVb","83922f89d1aacd6a":"lxi0u"}],"lxi0u":[function(require,module,exports) {
/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */ THREE.ColladaLoader = function(manager) {
    this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
};
THREE.ColladaLoader.prototype = {
    constructor: THREE.ColladaLoader,
    crossOrigin: "anonymous",
    load: function(url, onLoad, onProgress, onError) {
        var scope = this;
        var path = scope.path === undefined ? THREE.LoaderUtils.extractUrlBase(url) : scope.path;
        var loader = new THREE.FileLoader(scope.manager);
        loader.setPath(scope.path);
        loader.load(url, function(text) {
            onLoad(scope.parse(text, path));
        }, onProgress, onError);
    },
    setPath: function(value1) {
        this.path = value1;
        return this;
    },
    setResourcePath: function(value1) {
        this.resourcePath = value1;
        return this;
    },
    options: {
        set convertUpAxis (value){
            console.warn("THREE.ColladaLoader: options.convertUpAxis() has been removed. Up axis is converted automatically.");
        }
    },
    setCrossOrigin: function(value1) {
        this.crossOrigin = value1;
        return this;
    },
    parse: function(text, path) {
        function getElementsByTagName(xml, name) {
            // Non recursive xml.getElementsByTagName() ...
            var array = [];
            var childNodes = xml.childNodes;
            for(var i = 0, l = childNodes.length; i < l; i++){
                var child = childNodes[i];
                if (child.nodeName === name) array.push(child);
            }
            return array;
        }
        function parseStrings(text) {
            if (text.length === 0) return [];
            var parts = text.trim().split(/\s+/);
            var array = new Array(parts.length);
            for(var i = 0, l = parts.length; i < l; i++)array[i] = parts[i];
            return array;
        }
        function parseFloats(text) {
            if (text.length === 0) return [];
            var parts = text.trim().split(/\s+/);
            var array = new Array(parts.length);
            for(var i = 0, l = parts.length; i < l; i++)array[i] = parseFloat(parts[i]);
            return array;
        }
        function parseInts(text) {
            if (text.length === 0) return [];
            var parts = text.trim().split(/\s+/);
            var array = new Array(parts.length);
            for(var i = 0, l = parts.length; i < l; i++)array[i] = parseInt(parts[i]);
            return array;
        }
        function parseId(text) {
            return text.substring(1);
        }
        function generateId() {
            return "three_default_" + count++;
        }
        function isEmpty(object) {
            return Object.keys(object).length === 0;
        }
        // asset
        function parseAsset(xml) {
            return {
                unit: parseAssetUnit(getElementsByTagName(xml, "unit")[0]),
                upAxis: parseAssetUpAxis(getElementsByTagName(xml, "up_axis")[0])
            };
        }
        function parseAssetUnit(xml) {
            if (xml !== undefined && xml.hasAttribute("meter") === true) return parseFloat(xml.getAttribute("meter"));
            else return 1; // default 1 meter
        }
        function parseAssetUpAxis(xml) {
            return xml !== undefined ? xml.textContent : "Y_UP";
        }
        // library
        function parseLibrary(xml, libraryName, nodeName, parser) {
            var library = getElementsByTagName(xml, libraryName)[0];
            if (library !== undefined) {
                var elements = getElementsByTagName(library, nodeName);
                for(var i = 0; i < elements.length; i++)parser(elements[i]);
            }
        }
        function buildLibrary(data, builder) {
            for(var name in data){
                var object = data[name];
                object.build = builder(data[name]);
            }
        }
        // get
        function getBuild(data, builder) {
            if (data.build !== undefined) return data.build;
            data.build = builder(data);
            return data.build;
        }
        // animation
        function parseAnimation(xml) {
            var data = {
                sources: {},
                samplers: {},
                channels: {}
            };
            for(var i = 0, l = xml.childNodes.length; i < l; i++){
                var child = xml.childNodes[i];
                if (child.nodeType !== 1) continue;
                var id;
                switch(child.nodeName){
                    case "source":
                        id = child.getAttribute("id");
                        data.sources[id] = parseSource(child);
                        break;
                    case "sampler":
                        id = child.getAttribute("id");
                        data.samplers[id] = parseAnimationSampler(child);
                        break;
                    case "channel":
                        id = child.getAttribute("target");
                        data.channels[id] = parseAnimationChannel(child);
                        break;
                    default:
                        console.log(child);
                }
            }
            library.animations[xml.getAttribute("id")] = data;
        }
        function parseAnimationSampler(xml) {
            var data = {
                inputs: {}
            };
            for(var i = 0, l = xml.childNodes.length; i < l; i++){
                var child = xml.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "input":
                        var id = parseId(child.getAttribute("source"));
                        var semantic = child.getAttribute("semantic");
                        data.inputs[semantic] = id;
                        break;
                }
            }
            return data;
        }
        function parseAnimationChannel(xml) {
            var data = {};
            var target = xml.getAttribute("target");
            // parsing SID Addressing Syntax
            var parts = target.split("/");
            var id = parts.shift();
            var sid = parts.shift();
            // check selection syntax
            var arraySyntax = sid.indexOf("(") !== -1;
            var memberSyntax = sid.indexOf(".") !== -1;
            if (memberSyntax) {
                //  member selection access
                parts = sid.split(".");
                sid = parts.shift();
                data.member = parts.shift();
            } else if (arraySyntax) {
                // array-access syntax. can be used to express fields in one-dimensional vectors or two-dimensional matrices.
                var indices = sid.split("(");
                sid = indices.shift();
                for(var i = 0; i < indices.length; i++)indices[i] = parseInt(indices[i].replace(/\)/, ""));
                data.indices = indices;
            }
            data.id = id;
            data.sid = sid;
            data.arraySyntax = arraySyntax;
            data.memberSyntax = memberSyntax;
            data.sampler = parseId(xml.getAttribute("source"));
            return data;
        }
        function buildAnimation(data) {
            var tracks = [];
            var channels = data.channels;
            var samplers = data.samplers;
            var sources = data.sources;
            for(var target in channels)if (channels.hasOwnProperty(target)) {
                var channel = channels[target];
                var sampler = samplers[channel.sampler];
                var inputId = sampler.inputs.INPUT;
                var outputId = sampler.inputs.OUTPUT;
                var inputSource = sources[inputId];
                var outputSource = sources[outputId];
                var animation = buildAnimationChannel(channel, inputSource, outputSource);
                createKeyframeTracks(animation, tracks);
            }
            return tracks;
        }
        function getAnimation(id) {
            return getBuild(library.animations[id], buildAnimation);
        }
        function buildAnimationChannel(channel, inputSource, outputSource) {
            var node = library.nodes[channel.id];
            var object3D = getNode(node.id);
            var transform = node.transforms[channel.sid];
            var defaultMatrix = node.matrix.clone().transpose();
            var time, stride;
            var i, il, j, jl;
            var data = {};
            // the collada spec allows the animation of data in various ways.
            // depending on the transform type (matrix, translate, rotate, scale), we execute different logic
            switch(transform){
                case "matrix":
                    for(i = 0, il = inputSource.array.length; i < il; i++){
                        time = inputSource.array[i];
                        stride = i * outputSource.stride;
                        if (data[time] === undefined) data[time] = {};
                        if (channel.arraySyntax === true) {
                            var value1 = outputSource.array[stride];
                            var index = channel.indices[0] + 4 * channel.indices[1];
                            data[time][index] = value1;
                        } else for(j = 0, jl = outputSource.stride; j < jl; j++)data[time][j] = outputSource.array[stride + j];
                    }
                    break;
                case "translate":
                    console.warn('THREE.ColladaLoader: Animation transform type "%s" not yet implemented.', transform);
                    break;
                case "rotate":
                    console.warn('THREE.ColladaLoader: Animation transform type "%s" not yet implemented.', transform);
                    break;
                case "scale":
                    console.warn('THREE.ColladaLoader: Animation transform type "%s" not yet implemented.', transform);
                    break;
            }
            var keyframes = prepareAnimationData(data, defaultMatrix);
            var animation = {
                name: object3D.uuid,
                keyframes: keyframes
            };
            return animation;
        }
        function prepareAnimationData(data, defaultMatrix) {
            var keyframes = [];
            // transfer data into a sortable array
            for(var time in data)keyframes.push({
                time: parseFloat(time),
                value: data[time]
            });
            // ensure keyframes are sorted by time
            keyframes.sort(ascending);
            // now we clean up all animation data, so we can use them for keyframe tracks
            for(var i = 0; i < 16; i++)transformAnimationData(keyframes, i, defaultMatrix.elements[i]);
            return keyframes;
            // array sort function
            function ascending(a, b) {
                return a.time - b.time;
            }
        }
        var position = new THREE.Vector3();
        var scale = new THREE.Vector3();
        var quaternion = new THREE.Quaternion();
        function createKeyframeTracks(animation, tracks) {
            var keyframes = animation.keyframes;
            var name = animation.name;
            var times = [];
            var positionData = [];
            var quaternionData = [];
            var scaleData = [];
            for(var i = 0, l = keyframes.length; i < l; i++){
                var keyframe = keyframes[i];
                var time = keyframe.time;
                var value1 = keyframe.value;
                matrix.fromArray(value1).transpose();
                matrix.decompose(position, quaternion, scale);
                times.push(time);
                positionData.push(position.x, position.y, position.z);
                quaternionData.push(quaternion.x, quaternion.y, quaternion.z, quaternion.w);
                scaleData.push(scale.x, scale.y, scale.z);
            }
            if (positionData.length > 0) tracks.push(new THREE.VectorKeyframeTrack(name + ".position", times, positionData));
            if (quaternionData.length > 0) tracks.push(new THREE.QuaternionKeyframeTrack(name + ".quaternion", times, quaternionData));
            if (scaleData.length > 0) tracks.push(new THREE.VectorKeyframeTrack(name + ".scale", times, scaleData));
            return tracks;
        }
        function transformAnimationData(keyframes, property, defaultValue) {
            var keyframe;
            var empty = true;
            var i, l;
            // check, if values of a property are missing in our keyframes
            for(i = 0, l = keyframes.length; i < l; i++){
                keyframe = keyframes[i];
                if (keyframe.value[property] === undefined) keyframe.value[property] = null; // mark as missing
                else empty = false;
            }
            if (empty === true) // no values at all, so we set a default value
            for(i = 0, l = keyframes.length; i < l; i++){
                keyframe = keyframes[i];
                keyframe.value[property] = defaultValue;
            }
            else // filling gaps
            createMissingKeyframes(keyframes, property);
        }
        function createMissingKeyframes(keyframes, property) {
            var prev, next;
            for(var i = 0, l = keyframes.length; i < l; i++){
                var keyframe = keyframes[i];
                if (keyframe.value[property] === null) {
                    prev = getPrev(keyframes, i, property);
                    next = getNext(keyframes, i, property);
                    if (prev === null) {
                        keyframe.value[property] = next.value[property];
                        continue;
                    }
                    if (next === null) {
                        keyframe.value[property] = prev.value[property];
                        continue;
                    }
                    interpolate(keyframe, prev, next, property);
                }
            }
        }
        function getPrev(keyframes, i, property) {
            while(i >= 0){
                var keyframe = keyframes[i];
                if (keyframe.value[property] !== null) return keyframe;
                i--;
            }
            return null;
        }
        function getNext(keyframes, i, property) {
            while(i < keyframes.length){
                var keyframe = keyframes[i];
                if (keyframe.value[property] !== null) return keyframe;
                i++;
            }
            return null;
        }
        function interpolate(key, prev, next, property) {
            if (next.time - prev.time === 0) {
                key.value[property] = prev.value[property];
                return;
            }
            key.value[property] = (key.time - prev.time) * (next.value[property] - prev.value[property]) / (next.time - prev.time) + prev.value[property];
        }
        // animation clips
        function parseAnimationClip(xml) {
            var data = {
                name: xml.getAttribute("id") || "default",
                start: parseFloat(xml.getAttribute("start") || 0),
                end: parseFloat(xml.getAttribute("end") || 0),
                animations: []
            };
            for(var i = 0, l = xml.childNodes.length; i < l; i++){
                var child = xml.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "instance_animation":
                        data.animations.push(parseId(child.getAttribute("url")));
                        break;
                }
            }
            library.clips[xml.getAttribute("id")] = data;
        }
        function buildAnimationClip(data) {
            var tracks = [];
            var name = data.name;
            var duration = data.end - data.start || -1;
            var animations = data.animations;
            for(var i = 0, il = animations.length; i < il; i++){
                var animationTracks = getAnimation(animations[i]);
                for(var j = 0, jl = animationTracks.length; j < jl; j++)tracks.push(animationTracks[j]);
            }
            return new THREE.AnimationClip(name, duration, tracks);
        }
        function getAnimationClip(id) {
            return getBuild(library.clips[id], buildAnimationClip);
        }
        // controller
        function parseController(xml) {
            var data = {};
            for(var i = 0, l = xml.childNodes.length; i < l; i++){
                var child = xml.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "skin":
                        // there is exactly one skin per controller
                        data.id = parseId(child.getAttribute("source"));
                        data.skin = parseSkin(child);
                        break;
                    case "morph":
                        data.id = parseId(child.getAttribute("source"));
                        console.warn("THREE.ColladaLoader: Morph target animation not supported yet.");
                        break;
                }
            }
            library.controllers[xml.getAttribute("id")] = data;
        }
        function parseSkin(xml) {
            var data = {
                sources: {}
            };
            for(var i = 0, l = xml.childNodes.length; i < l; i++){
                var child = xml.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "bind_shape_matrix":
                        data.bindShapeMatrix = parseFloats(child.textContent);
                        break;
                    case "source":
                        var id = child.getAttribute("id");
                        data.sources[id] = parseSource(child);
                        break;
                    case "joints":
                        data.joints = parseJoints(child);
                        break;
                    case "vertex_weights":
                        data.vertexWeights = parseVertexWeights(child);
                        break;
                }
            }
            return data;
        }
        function parseJoints(xml) {
            var data = {
                inputs: {}
            };
            for(var i = 0, l = xml.childNodes.length; i < l; i++){
                var child = xml.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "input":
                        var semantic = child.getAttribute("semantic");
                        var id = parseId(child.getAttribute("source"));
                        data.inputs[semantic] = id;
                        break;
                }
            }
            return data;
        }
        function parseVertexWeights(xml) {
            var data = {
                inputs: {}
            };
            for(var i = 0, l = xml.childNodes.length; i < l; i++){
                var child = xml.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "input":
                        var semantic = child.getAttribute("semantic");
                        var id = parseId(child.getAttribute("source"));
                        var offset = parseInt(child.getAttribute("offset"));
                        data.inputs[semantic] = {
                            id: id,
                            offset: offset
                        };
                        break;
                    case "vcount":
                        data.vcount = parseInts(child.textContent);
                        break;
                    case "v":
                        data.v = parseInts(child.textContent);
                        break;
                }
            }
            return data;
        }
        function buildController(data) {
            var build = {
                id: data.id
            };
            var geometry = library.geometries[build.id];
            if (data.skin !== undefined) {
                build.skin = buildSkin(data.skin);
                // we enhance the 'sources' property of the corresponding geometry with our skin data
                geometry.sources.skinIndices = build.skin.indices;
                geometry.sources.skinWeights = build.skin.weights;
            }
            return build;
        }
        function buildSkin(data) {
            var BONE_LIMIT = 4;
            var build = {
                joints: [],
                indices: {
                    array: [],
                    stride: BONE_LIMIT
                },
                weights: {
                    array: [],
                    stride: BONE_LIMIT
                }
            };
            var sources = data.sources;
            var vertexWeights = data.vertexWeights;
            var vcount = vertexWeights.vcount;
            var v = vertexWeights.v;
            var jointOffset = vertexWeights.inputs.JOINT.offset;
            var weightOffset = vertexWeights.inputs.WEIGHT.offset;
            var jointSource = data.sources[data.joints.inputs.JOINT];
            var inverseSource = data.sources[data.joints.inputs.INV_BIND_MATRIX];
            var weights = sources[vertexWeights.inputs.WEIGHT.id].array;
            var stride = 0;
            var i, j, l;
            // procces skin data for each vertex
            for(i = 0, l = vcount.length; i < l; i++){
                var jointCount = vcount[i]; // this is the amount of joints that affect a single vertex
                var vertexSkinData = [];
                for(j = 0; j < jointCount; j++){
                    var skinIndex = v[stride + jointOffset];
                    var weightId = v[stride + weightOffset];
                    var skinWeight = weights[weightId];
                    vertexSkinData.push({
                        index: skinIndex,
                        weight: skinWeight
                    });
                    stride += 2;
                }
                // we sort the joints in descending order based on the weights.
                // this ensures, we only procced the most important joints of the vertex
                vertexSkinData.sort(descending);
                // now we provide for each vertex a set of four index and weight values.
                // the order of the skin data matches the order of vertices
                for(j = 0; j < BONE_LIMIT; j++){
                    var d = vertexSkinData[j];
                    if (d !== undefined) {
                        build.indices.array.push(d.index);
                        build.weights.array.push(d.weight);
                    } else {
                        build.indices.array.push(0);
                        build.weights.array.push(0);
                    }
                }
            }
            // setup bind matrix
            if (data.bindShapeMatrix) build.bindMatrix = new THREE.Matrix4().fromArray(data.bindShapeMatrix).transpose();
            else build.bindMatrix = new THREE.Matrix4().identity();
            // process bones and inverse bind matrix data
            for(i = 0, l = jointSource.array.length; i < l; i++){
                var name = jointSource.array[i];
                var boneInverse = new THREE.Matrix4().fromArray(inverseSource.array, i * inverseSource.stride).transpose();
                build.joints.push({
                    name: name,
                    boneInverse: boneInverse
                });
            }
            return build;
            // array sort function
            function descending(a, b) {
                return b.weight - a.weight;
            }
        }
        function getController(id) {
            return getBuild(library.controllers[id], buildController);
        }
        // image
        function parseImage(xml) {
            var data = {
                init_from: getElementsByTagName(xml, "init_from")[0].textContent
            };
            library.images[xml.getAttribute("id")] = data;
        }
        function buildImage(data) {
            if (data.build !== undefined) return data.build;
            return data.init_from;
        }
        function getImage(id) {
            var data = library.images[id];
            if (data !== undefined) return getBuild(data, buildImage);
            console.warn("THREE.ColladaLoader: Couldn't find image with ID:", id);
            return null;
        }
        // effect
        function parseEffect(xml) {
            var data = {};
            for(var i = 0, l = xml.childNodes.length; i < l; i++){
                var child = xml.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "profile_COMMON":
                        data.profile = parseEffectProfileCOMMON(child);
                        break;
                }
            }
            library.effects[xml.getAttribute("id")] = data;
        }
        function parseEffectProfileCOMMON(xml) {
            var data = {
                surfaces: {},
                samplers: {}
            };
            for(var i = 0, l = xml.childNodes.length; i < l; i++){
                var child = xml.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "newparam":
                        parseEffectNewparam(child, data);
                        break;
                    case "technique":
                        data.technique = parseEffectTechnique(child);
                        break;
                    case "extra":
                        data.extra = parseEffectExtra(child);
                        break;
                }
            }
            return data;
        }
        function parseEffectNewparam(xml, data) {
            var sid = xml.getAttribute("sid");
            for(var i = 0, l = xml.childNodes.length; i < l; i++){
                var child = xml.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "surface":
                        data.surfaces[sid] = parseEffectSurface(child);
                        break;
                    case "sampler2D":
                        data.samplers[sid] = parseEffectSampler(child);
                        break;
                }
            }
        }
        function parseEffectSurface(xml) {
            var data = {};
            for(var i = 0, l = xml.childNodes.length; i < l; i++){
                var child = xml.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "init_from":
                        data.init_from = child.textContent;
                        break;
                }
            }
            return data;
        }
        function parseEffectSampler(xml) {
            var data = {};
            for(var i = 0, l = xml.childNodes.length; i < l; i++){
                var child = xml.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "source":
                        data.source = child.textContent;
                        break;
                }
            }
            return data;
        }
        function parseEffectTechnique(xml) {
            var data = {};
            for(var i = 0, l = xml.childNodes.length; i < l; i++){
                var child = xml.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "constant":
                    case "lambert":
                    case "blinn":
                    case "phong":
                        data.type = child.nodeName;
                        data.parameters = parseEffectParameters(child);
                        break;
                }
            }
            return data;
        }
        function parseEffectParameters(xml) {
            var data = {};
            for(var i = 0, l = xml.childNodes.length; i < l; i++){
                var child = xml.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "emission":
                    case "diffuse":
                    case "specular":
                    case "bump":
                    case "ambient":
                    case "shininess":
                    case "transparency":
                        data[child.nodeName] = parseEffectParameter(child);
                        break;
                    case "transparent":
                        data[child.nodeName] = {
                            opaque: child.getAttribute("opaque"),
                            data: parseEffectParameter(child)
                        };
                        break;
                }
            }
            return data;
        }
        function parseEffectParameter(xml) {
            var data = {};
            for(var i = 0, l = xml.childNodes.length; i < l; i++){
                var child = xml.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "color":
                        data[child.nodeName] = parseFloats(child.textContent);
                        break;
                    case "float":
                        data[child.nodeName] = parseFloat(child.textContent);
                        break;
                    case "texture":
                        data[child.nodeName] = {
                            id: child.getAttribute("texture"),
                            extra: parseEffectParameterTexture(child)
                        };
                        break;
                }
            }
            return data;
        }
        function parseEffectParameterTexture(xml) {
            var data = {
                technique: {}
            };
            for(var i = 0, l = xml.childNodes.length; i < l; i++){
                var child = xml.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "extra":
                        parseEffectParameterTextureExtra(child, data);
                        break;
                }
            }
            return data;
        }
        function parseEffectParameterTextureExtra(xml, data) {
            for(var i = 0, l = xml.childNodes.length; i < l; i++){
                var child = xml.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "technique":
                        parseEffectParameterTextureExtraTechnique(child, data);
                        break;
                }
            }
        }
        function parseEffectParameterTextureExtraTechnique(xml, data) {
            for(var i = 0, l = xml.childNodes.length; i < l; i++){
                var child = xml.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "repeatU":
                    case "repeatV":
                    case "offsetU":
                    case "offsetV":
                        data.technique[child.nodeName] = parseFloat(child.textContent);
                        break;
                    case "wrapU":
                    case "wrapV":
                        // some files have values for wrapU/wrapV which become NaN via parseInt
                        if (child.textContent.toUpperCase() === "TRUE") data.technique[child.nodeName] = 1;
                        else if (child.textContent.toUpperCase() === "FALSE") data.technique[child.nodeName] = 0;
                        else data.technique[child.nodeName] = parseInt(child.textContent);
                        break;
                }
            }
        }
        function parseEffectExtra(xml) {
            var data = {};
            for(var i = 0, l = xml.childNodes.length; i < l; i++){
                var child = xml.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "technique":
                        data.technique = parseEffectExtraTechnique(child);
                        break;
                }
            }
            return data;
        }
        function parseEffectExtraTechnique(xml) {
            var data = {};
            for(var i = 0, l = xml.childNodes.length; i < l; i++){
                var child = xml.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "double_sided":
                        data[child.nodeName] = parseInt(child.textContent);
                        break;
                }
            }
            return data;
        }
        function buildEffect(data) {
            return data;
        }
        function getEffect(id) {
            return getBuild(library.effects[id], buildEffect);
        }
        // material
        function parseMaterial(xml) {
            var data = {
                name: xml.getAttribute("name")
            };
            for(var i = 0, l = xml.childNodes.length; i < l; i++){
                var child = xml.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "instance_effect":
                        data.url = parseId(child.getAttribute("url"));
                        break;
                }
            }
            library.materials[xml.getAttribute("id")] = data;
        }
        function getTextureLoader(image) {
            var loader;
            var extension = image.slice((image.lastIndexOf(".") - 1 >>> 0) + 2); // http://www.jstips.co/en/javascript/get-file-extension/
            extension = extension.toLowerCase();
            switch(extension){
                case "tga":
                    loader = tgaLoader;
                    break;
                default:
                    loader = textureLoader;
            }
            return loader;
        }
        function buildMaterial(data) {
            var effect = getEffect(data.url);
            var technique = effect.profile.technique;
            var extra = effect.profile.extra;
            var material;
            switch(technique.type){
                case "phong":
                case "blinn":
                    material = new THREE.MeshPhongMaterial();
                    break;
                case "lambert":
                    material = new THREE.MeshLambertMaterial();
                    break;
                default:
                    material = new THREE.MeshBasicMaterial();
                    break;
            }
            material.name = data.name;
            function getTexture(textureObject) {
                var sampler = effect.profile.samplers[textureObject.id];
                var image = null;
                // get image
                if (sampler !== undefined) {
                    var surface = effect.profile.surfaces[sampler.source];
                    image = getImage(surface.init_from);
                } else {
                    console.warn("THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530).");
                    image = getImage(textureObject.id);
                }
                // create texture if image is avaiable
                if (image !== null) {
                    var loader = getTextureLoader(image);
                    if (loader !== undefined) {
                        var texture = loader.load(image);
                        var extra = textureObject.extra;
                        if (extra !== undefined && extra.technique !== undefined && isEmpty(extra.technique) === false) {
                            var technique = extra.technique;
                            texture.wrapS = technique.wrapU ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;
                            texture.wrapT = technique.wrapV ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;
                            texture.offset.set(technique.offsetU || 0, technique.offsetV || 0);
                            texture.repeat.set(technique.repeatU || 1, technique.repeatV || 1);
                        } else {
                            texture.wrapS = THREE.RepeatWrapping;
                            texture.wrapT = THREE.RepeatWrapping;
                        }
                        return texture;
                    } else {
                        console.warn("THREE.ColladaLoader: Loader for texture %s not found.", image);
                        return null;
                    }
                } else {
                    console.warn("THREE.ColladaLoader: Couldn't create texture with ID:", textureObject.id);
                    return null;
                }
            }
            var parameters = technique.parameters;
            for(var key in parameters){
                var parameter = parameters[key];
                switch(key){
                    case "diffuse":
                        if (parameter.color) material.color.fromArray(parameter.color);
                        if (parameter.texture) material.map = getTexture(parameter.texture);
                        break;
                    case "specular":
                        if (parameter.color && material.specular) material.specular.fromArray(parameter.color);
                        if (parameter.texture) material.specularMap = getTexture(parameter.texture);
                        break;
                    case "bump":
                        if (parameter.texture) material.normalMap = getTexture(parameter.texture);
                        break;
                    case "ambient":
                        if (parameter.texture) material.lightMap = getTexture(parameter.texture);
                        break;
                    case "shininess":
                        if (parameter.float && material.shininess) material.shininess = parameter.float;
                        break;
                    case "emission":
                        if (parameter.color && material.emissive) material.emissive.fromArray(parameter.color);
                        if (parameter.texture) material.emissiveMap = getTexture(parameter.texture);
                        break;
                }
            }
            //
            var transparent = parameters["transparent"];
            var transparency = parameters["transparency"];
            // <transparency> does not exist but <transparent>
            if (transparency === undefined && transparent) transparency = {
                float: 1
            };
            // <transparent> does not exist but <transparency>
            if (transparent === undefined && transparency) transparent = {
                opaque: "A_ONE",
                data: {
                    color: [
                        1,
                        1,
                        1,
                        1
                    ]
                }
            };
            if (transparent && transparency) {
                // handle case if a texture exists but no color
                if (transparent.data.texture) // we do not set an alpha map (see #13792)
                material.transparent = true;
                else {
                    var color = transparent.data.color;
                    switch(transparent.opaque){
                        case "A_ONE":
                            material.opacity = color[3] * transparency.float;
                            break;
                        case "RGB_ZERO":
                            material.opacity = 1 - color[0] * transparency.float;
                            break;
                        case "A_ZERO":
                            material.opacity = 1 - color[3] * transparency.float;
                            break;
                        case "RGB_ONE":
                            material.opacity = color[0] * transparency.float;
                            break;
                        default:
                            console.warn('THREE.ColladaLoader: Invalid opaque type "%s" of transparent tag.', transparent.opaque);
                    }
                    if (material.opacity < 1) material.transparent = true;
                }
            }
            //
            if (extra !== undefined && extra.technique !== undefined && extra.technique.double_sided === 1) material.side = THREE.DoubleSide;
            return material;
        }
        function getMaterial(id) {
            return getBuild(library.materials[id], buildMaterial);
        }
        // camera
        function parseCamera(xml) {
            var data = {
                name: xml.getAttribute("name")
            };
            for(var i = 0, l = xml.childNodes.length; i < l; i++){
                var child = xml.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "optics":
                        data.optics = parseCameraOptics(child);
                        break;
                }
            }
            library.cameras[xml.getAttribute("id")] = data;
        }
        function parseCameraOptics(xml) {
            for(var i = 0; i < xml.childNodes.length; i++){
                var child = xml.childNodes[i];
                switch(child.nodeName){
                    case "technique_common":
                        return parseCameraTechnique(child);
                }
            }
            return {};
        }
        function parseCameraTechnique(xml) {
            var data = {};
            for(var i = 0; i < xml.childNodes.length; i++){
                var child = xml.childNodes[i];
                switch(child.nodeName){
                    case "perspective":
                    case "orthographic":
                        data.technique = child.nodeName;
                        data.parameters = parseCameraParameters(child);
                        break;
                }
            }
            return data;
        }
        function parseCameraParameters(xml) {
            var data = {};
            for(var i = 0; i < xml.childNodes.length; i++){
                var child = xml.childNodes[i];
                switch(child.nodeName){
                    case "xfov":
                    case "yfov":
                    case "xmag":
                    case "ymag":
                    case "znear":
                    case "zfar":
                    case "aspect_ratio":
                        data[child.nodeName] = parseFloat(child.textContent);
                        break;
                }
            }
            return data;
        }
        function buildCamera(data) {
            var camera;
            switch(data.optics.technique){
                case "perspective":
                    camera = new THREE.PerspectiveCamera(data.optics.parameters.yfov, data.optics.parameters.aspect_ratio, data.optics.parameters.znear, data.optics.parameters.zfar);
                    break;
                case "orthographic":
                    var ymag = data.optics.parameters.ymag;
                    var xmag = data.optics.parameters.xmag;
                    var aspectRatio = data.optics.parameters.aspect_ratio;
                    xmag = xmag === undefined ? ymag * aspectRatio : xmag;
                    ymag = ymag === undefined ? xmag / aspectRatio : ymag;
                    xmag *= 0.5;
                    ymag *= 0.5;
                    camera = new THREE.OrthographicCamera(-xmag, xmag, ymag, -ymag, data.optics.parameters.znear, data.optics.parameters.zfar);
                    break;
                default:
                    camera = new THREE.PerspectiveCamera();
                    break;
            }
            camera.name = data.name;
            return camera;
        }
        function getCamera(id) {
            var data = library.cameras[id];
            if (data !== undefined) return getBuild(data, buildCamera);
            console.warn("THREE.ColladaLoader: Couldn't find camera with ID:", id);
            return null;
        }
        // light
        function parseLight(xml) {
            var data = {};
            for(var i = 0, l = xml.childNodes.length; i < l; i++){
                var child = xml.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "technique_common":
                        data = parseLightTechnique(child);
                        break;
                }
            }
            library.lights[xml.getAttribute("id")] = data;
        }
        function parseLightTechnique(xml) {
            var data = {};
            for(var i = 0, l = xml.childNodes.length; i < l; i++){
                var child = xml.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "directional":
                    case "point":
                    case "spot":
                    case "ambient":
                        data.technique = child.nodeName;
                        data.parameters = parseLightParameters(child);
                }
            }
            return data;
        }
        function parseLightParameters(xml) {
            var data = {};
            for(var i = 0, l = xml.childNodes.length; i < l; i++){
                var child = xml.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "color":
                        var array = parseFloats(child.textContent);
                        data.color = new THREE.Color().fromArray(array);
                        break;
                    case "falloff_angle":
                        data.falloffAngle = parseFloat(child.textContent);
                        break;
                    case "quadratic_attenuation":
                        var f = parseFloat(child.textContent);
                        data.distance = f ? Math.sqrt(1 / f) : 0;
                        break;
                }
            }
            return data;
        }
        function buildLight(data) {
            var light;
            switch(data.technique){
                case "directional":
                    light = new THREE.DirectionalLight();
                    break;
                case "point":
                    light = new THREE.PointLight();
                    break;
                case "spot":
                    light = new THREE.SpotLight();
                    break;
                case "ambient":
                    light = new THREE.AmbientLight();
                    break;
            }
            if (data.parameters.color) light.color.copy(data.parameters.color);
            if (data.parameters.distance) light.distance = data.parameters.distance;
            return light;
        }
        function getLight(id) {
            var data = library.lights[id];
            if (data !== undefined) return getBuild(data, buildLight);
            console.warn("THREE.ColladaLoader: Couldn't find light with ID:", id);
            return null;
        }
        // geometry
        function parseGeometry(xml) {
            var data = {
                name: xml.getAttribute("name"),
                sources: {},
                vertices: {},
                primitives: []
            };
            var mesh = getElementsByTagName(xml, "mesh")[0];
            // the following tags inside geometry are not supported yet (see https://github.com/mrdoob/three.js/pull/12606): convex_mesh, spline, brep
            if (mesh === undefined) return;
            for(var i = 0; i < mesh.childNodes.length; i++){
                var child = mesh.childNodes[i];
                if (child.nodeType !== 1) continue;
                var id = child.getAttribute("id");
                switch(child.nodeName){
                    case "source":
                        data.sources[id] = parseSource(child);
                        break;
                    case "vertices":
                        // data.sources[ id ] = data.sources[ parseId( getElementsByTagName( child, 'input' )[ 0 ].getAttribute( 'source' ) ) ];
                        data.vertices = parseGeometryVertices(child);
                        break;
                    case "polygons":
                        console.warn("THREE.ColladaLoader: Unsupported primitive type: ", child.nodeName);
                        break;
                    case "lines":
                    case "linestrips":
                    case "polylist":
                    case "triangles":
                        data.primitives.push(parseGeometryPrimitive(child));
                        break;
                    default:
                        console.log(child);
                }
            }
            library.geometries[xml.getAttribute("id")] = data;
        }
        function parseSource(xml) {
            var data = {
                array: [],
                stride: 3
            };
            for(var i = 0; i < xml.childNodes.length; i++){
                var child = xml.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "float_array":
                        data.array = parseFloats(child.textContent);
                        break;
                    case "Name_array":
                        data.array = parseStrings(child.textContent);
                        break;
                    case "technique_common":
                        var accessor = getElementsByTagName(child, "accessor")[0];
                        if (accessor !== undefined) data.stride = parseInt(accessor.getAttribute("stride"));
                        break;
                }
            }
            return data;
        }
        function parseGeometryVertices(xml) {
            var data = {};
            for(var i = 0; i < xml.childNodes.length; i++){
                var child = xml.childNodes[i];
                if (child.nodeType !== 1) continue;
                data[child.getAttribute("semantic")] = parseId(child.getAttribute("source"));
            }
            return data;
        }
        function parseGeometryPrimitive(xml) {
            var primitive = {
                type: xml.nodeName,
                material: xml.getAttribute("material"),
                count: parseInt(xml.getAttribute("count")),
                inputs: {},
                stride: 0,
                hasUV: false
            };
            for(var i = 0, l = xml.childNodes.length; i < l; i++){
                var child = xml.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "input":
                        var id = parseId(child.getAttribute("source"));
                        var semantic = child.getAttribute("semantic");
                        var offset = parseInt(child.getAttribute("offset"));
                        var set = parseInt(child.getAttribute("set"));
                        var inputname = set > 0 ? semantic + set : semantic;
                        primitive.inputs[inputname] = {
                            id: id,
                            offset: offset
                        };
                        primitive.stride = Math.max(primitive.stride, offset + 1);
                        if (semantic === "TEXCOORD") primitive.hasUV = true;
                        break;
                    case "vcount":
                        primitive.vcount = parseInts(child.textContent);
                        break;
                    case "p":
                        primitive.p = parseInts(child.textContent);
                        break;
                }
            }
            return primitive;
        }
        function groupPrimitives(primitives) {
            var build = {};
            for(var i = 0; i < primitives.length; i++){
                var primitive = primitives[i];
                if (build[primitive.type] === undefined) build[primitive.type] = [];
                build[primitive.type].push(primitive);
            }
            return build;
        }
        function checkUVCoordinates(primitives) {
            var count = 0;
            for(var i = 0, l = primitives.length; i < l; i++){
                var primitive = primitives[i];
                if (primitive.hasUV === true) count++;
            }
            if (count > 0 && count < primitives.length) primitives.uvsNeedsFix = true;
        }
        function buildGeometry(data) {
            var build = {};
            var sources = data.sources;
            var vertices = data.vertices;
            var primitives = data.primitives;
            if (primitives.length === 0) return {};
            // our goal is to create one buffer geometry for a single type of primitives
            // first, we group all primitives by their type
            var groupedPrimitives = groupPrimitives(primitives);
            for(var type in groupedPrimitives){
                var primitiveType = groupedPrimitives[type];
                // second, ensure consistent uv coordinates for each type of primitives (polylist,triangles or lines)
                checkUVCoordinates(primitiveType);
                // third, create a buffer geometry for each type of primitives
                build[type] = buildGeometryType(primitiveType, sources, vertices);
            }
            return build;
        }
        function buildGeometryType(primitives, sources, vertices) {
            var build = {};
            var position = {
                array: [],
                stride: 0
            };
            var normal = {
                array: [],
                stride: 0
            };
            var uv = {
                array: [],
                stride: 0
            };
            var uv2 = {
                array: [],
                stride: 0
            };
            var color = {
                array: [],
                stride: 0
            };
            var skinIndex = {
                array: [],
                stride: 4
            };
            var skinWeight = {
                array: [],
                stride: 4
            };
            var geometry = new THREE.BufferGeometry();
            var materialKeys = [];
            var start = 0;
            for(var p = 0; p < primitives.length; p++){
                var primitive = primitives[p];
                var inputs = primitive.inputs;
                // groups
                var count = 0;
                switch(primitive.type){
                    case "lines":
                    case "linestrips":
                        count = primitive.count * 2;
                        break;
                    case "triangles":
                        count = primitive.count * 3;
                        break;
                    case "polylist":
                        for(var g = 0; g < primitive.count; g++){
                            var vc = primitive.vcount[g];
                            switch(vc){
                                case 3:
                                    count += 3; // single triangle
                                    break;
                                case 4:
                                    count += 6; // quad, subdivided into two triangles
                                    break;
                                default:
                                    count += (vc - 2) * 3; // polylist with more than four vertices
                                    break;
                            }
                        }
                        break;
                    default:
                        console.warn("THREE.ColladaLoader: Unknow primitive type:", primitive.type);
                }
                geometry.addGroup(start, count, p);
                start += count;
                // material
                if (primitive.material) materialKeys.push(primitive.material);
                // geometry data
                for(var name in inputs){
                    var input = inputs[name];
                    switch(name){
                        case "VERTEX":
                            for(var key in vertices){
                                var id = vertices[key];
                                switch(key){
                                    case "POSITION":
                                        var prevLength = position.array.length;
                                        buildGeometryData(primitive, sources[id], input.offset, position.array);
                                        position.stride = sources[id].stride;
                                        if (sources.skinWeights && sources.skinIndices) {
                                            buildGeometryData(primitive, sources.skinIndices, input.offset, skinIndex.array);
                                            buildGeometryData(primitive, sources.skinWeights, input.offset, skinWeight.array);
                                        }
                                        // see #3803
                                        if (primitive.hasUV === false && primitives.uvsNeedsFix === true) {
                                            var count = (position.array.length - prevLength) / position.stride;
                                            for(var i = 0; i < count; i++)// fill missing uv coordinates
                                            uv.array.push(0, 0);
                                        }
                                        break;
                                    case "NORMAL":
                                        buildGeometryData(primitive, sources[id], input.offset, normal.array);
                                        normal.stride = sources[id].stride;
                                        break;
                                    case "COLOR":
                                        buildGeometryData(primitive, sources[id], input.offset, color.array);
                                        color.stride = sources[id].stride;
                                        break;
                                    case "TEXCOORD":
                                        buildGeometryData(primitive, sources[id], input.offset, uv.array);
                                        uv.stride = sources[id].stride;
                                        break;
                                    case "TEXCOORD1":
                                        buildGeometryData(primitive, sources[id], input.offset, uv2.array);
                                        uv.stride = sources[id].stride;
                                        break;
                                    default:
                                        console.warn('THREE.ColladaLoader: Semantic "%s" not handled in geometry build process.', key);
                                }
                            }
                            break;
                        case "NORMAL":
                            buildGeometryData(primitive, sources[input.id], input.offset, normal.array);
                            normal.stride = sources[input.id].stride;
                            break;
                        case "COLOR":
                            buildGeometryData(primitive, sources[input.id], input.offset, color.array);
                            color.stride = sources[input.id].stride;
                            break;
                        case "TEXCOORD":
                            buildGeometryData(primitive, sources[input.id], input.offset, uv.array);
                            uv.stride = sources[input.id].stride;
                            break;
                        case "TEXCOORD1":
                            buildGeometryData(primitive, sources[input.id], input.offset, uv2.array);
                            uv2.stride = sources[input.id].stride;
                            break;
                    }
                }
            }
            // build geometry
            if (position.array.length > 0) geometry.addAttribute("position", new THREE.Float32BufferAttribute(position.array, position.stride));
            if (normal.array.length > 0) geometry.addAttribute("normal", new THREE.Float32BufferAttribute(normal.array, normal.stride));
            if (color.array.length > 0) geometry.addAttribute("color", new THREE.Float32BufferAttribute(color.array, color.stride));
            if (uv.array.length > 0) geometry.addAttribute("uv", new THREE.Float32BufferAttribute(uv.array, uv.stride));
            if (uv2.array.length > 0) geometry.addAttribute("uv2", new THREE.Float32BufferAttribute(uv2.array, uv2.stride));
            if (skinIndex.array.length > 0) geometry.addAttribute("skinIndex", new THREE.Float32BufferAttribute(skinIndex.array, skinIndex.stride));
            if (skinWeight.array.length > 0) geometry.addAttribute("skinWeight", new THREE.Float32BufferAttribute(skinWeight.array, skinWeight.stride));
            build.data = geometry;
            build.type = primitives[0].type;
            build.materialKeys = materialKeys;
            return build;
        }
        function buildGeometryData(primitive, source, offset, array) {
            var indices = primitive.p;
            var stride = primitive.stride;
            var vcount = primitive.vcount;
            function pushVector(i) {
                var index = indices[i + offset] * sourceStride;
                var length = index + sourceStride;
                for(; index < length; index++)array.push(sourceArray[index]);
            }
            var sourceArray = source.array;
            var sourceStride = source.stride;
            if (primitive.vcount !== undefined) {
                var index = 0;
                for(var i = 0, l = vcount.length; i < l; i++){
                    var count = vcount[i];
                    if (count === 4) {
                        var a = index + stride * 0;
                        var b = index + stride * 1;
                        var c = index + stride * 2;
                        var d = index + stride * 3;
                        pushVector(a);
                        pushVector(b);
                        pushVector(d);
                        pushVector(b);
                        pushVector(c);
                        pushVector(d);
                    } else if (count === 3) {
                        var a = index + stride * 0;
                        var b = index + stride * 1;
                        var c = index + stride * 2;
                        pushVector(a);
                        pushVector(b);
                        pushVector(c);
                    } else if (count > 4) for(var k = 1, kl = count - 2; k <= kl; k++){
                        var a = index + stride * 0;
                        var b = index + stride * k;
                        var c = index + stride * (k + 1);
                        pushVector(a);
                        pushVector(b);
                        pushVector(c);
                    }
                    index += stride * count;
                }
            } else for(var i = 0, l = indices.length; i < l; i += stride)pushVector(i);
        }
        function getGeometry(id) {
            return getBuild(library.geometries[id], buildGeometry);
        }
        // kinematics
        function parseKinematicsModel(xml) {
            var data = {
                name: xml.getAttribute("name") || "",
                joints: {},
                links: []
            };
            for(var i = 0; i < xml.childNodes.length; i++){
                var child = xml.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "technique_common":
                        parseKinematicsTechniqueCommon(child, data);
                        break;
                }
            }
            library.kinematicsModels[xml.getAttribute("id")] = data;
        }
        function buildKinematicsModel(data) {
            if (data.build !== undefined) return data.build;
            return data;
        }
        function getKinematicsModel(id) {
            return getBuild(library.kinematicsModels[id], buildKinematicsModel);
        }
        function parseKinematicsTechniqueCommon(xml, data) {
            for(var i = 0; i < xml.childNodes.length; i++){
                var child = xml.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "joint":
                        data.joints[child.getAttribute("sid")] = parseKinematicsJoint(child);
                        break;
                    case "link":
                        data.links.push(parseKinematicsLink(child));
                        break;
                }
            }
        }
        function parseKinematicsJoint(xml) {
            var data;
            for(var i = 0; i < xml.childNodes.length; i++){
                var child = xml.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "prismatic":
                    case "revolute":
                        data = parseKinematicsJointParameter(child);
                        break;
                }
            }
            return data;
        }
        function parseKinematicsJointParameter(xml, data) {
            var data = {
                sid: xml.getAttribute("sid"),
                name: xml.getAttribute("name") || "",
                axis: new THREE.Vector3(),
                limits: {
                    min: 0,
                    max: 0
                },
                type: xml.nodeName,
                static: false,
                zeroPosition: 0,
                middlePosition: 0
            };
            for(var i = 0; i < xml.childNodes.length; i++){
                var child = xml.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "axis":
                        var array = parseFloats(child.textContent);
                        data.axis.fromArray(array);
                        break;
                    case "limits":
                        var max = child.getElementsByTagName("max")[0];
                        var min = child.getElementsByTagName("min")[0];
                        data.limits.max = parseFloat(max.textContent);
                        data.limits.min = parseFloat(min.textContent);
                        break;
                }
            }
            // if min is equal to or greater than max, consider the joint static
            if (data.limits.min >= data.limits.max) data.static = true;
            // calculate middle position
            data.middlePosition = (data.limits.min + data.limits.max) / 2.0;
            return data;
        }
        function parseKinematicsLink(xml) {
            var data = {
                sid: xml.getAttribute("sid"),
                name: xml.getAttribute("name") || "",
                attachments: [],
                transforms: []
            };
            for(var i = 0; i < xml.childNodes.length; i++){
                var child = xml.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "attachment_full":
                        data.attachments.push(parseKinematicsAttachment(child));
                        break;
                    case "matrix":
                    case "translate":
                    case "rotate":
                        data.transforms.push(parseKinematicsTransform(child));
                        break;
                }
            }
            return data;
        }
        function parseKinematicsAttachment(xml) {
            var data = {
                joint: xml.getAttribute("joint").split("/").pop(),
                transforms: [],
                links: []
            };
            for(var i = 0; i < xml.childNodes.length; i++){
                var child = xml.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "link":
                        data.links.push(parseKinematicsLink(child));
                        break;
                    case "matrix":
                    case "translate":
                    case "rotate":
                        data.transforms.push(parseKinematicsTransform(child));
                        break;
                }
            }
            return data;
        }
        function parseKinematicsTransform(xml) {
            var data = {
                type: xml.nodeName
            };
            var array = parseFloats(xml.textContent);
            switch(data.type){
                case "matrix":
                    data.obj = new THREE.Matrix4();
                    data.obj.fromArray(array).transpose();
                    break;
                case "translate":
                    data.obj = new THREE.Vector3();
                    data.obj.fromArray(array);
                    break;
                case "rotate":
                    data.obj = new THREE.Vector3();
                    data.obj.fromArray(array);
                    data.angle = THREE.Math.degToRad(array[3]);
                    break;
            }
            return data;
        }
        // physics
        function parsePhysicsModel(xml) {
            var data = {
                name: xml.getAttribute("name") || "",
                rigidBodies: {}
            };
            for(var i = 0; i < xml.childNodes.length; i++){
                var child = xml.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "rigid_body":
                        data.rigidBodies[child.getAttribute("name")] = {};
                        parsePhysicsRigidBody(child, data.rigidBodies[child.getAttribute("name")]);
                        break;
                }
            }
            library.physicsModels[xml.getAttribute("id")] = data;
        }
        function parsePhysicsRigidBody(xml, data) {
            for(var i = 0; i < xml.childNodes.length; i++){
                var child = xml.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "technique_common":
                        parsePhysicsTechniqueCommon(child, data);
                        break;
                }
            }
        }
        function parsePhysicsTechniqueCommon(xml, data) {
            for(var i = 0; i < xml.childNodes.length; i++){
                var child = xml.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "inertia":
                        data.inertia = parseFloats(child.textContent);
                        break;
                    case "mass":
                        data.mass = parseFloats(child.textContent)[0];
                        break;
                }
            }
        }
        // scene
        function parseKinematicsScene(xml) {
            var data = {
                bindJointAxis: []
            };
            for(var i = 0; i < xml.childNodes.length; i++){
                var child = xml.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "bind_joint_axis":
                        data.bindJointAxis.push(parseKinematicsBindJointAxis(child));
                        break;
                }
            }
            library.kinematicsScenes[parseId(xml.getAttribute("url"))] = data;
        }
        function parseKinematicsBindJointAxis(xml) {
            var data = {
                target: xml.getAttribute("target").split("/").pop()
            };
            for(var i = 0; i < xml.childNodes.length; i++){
                var child = xml.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "axis":
                        var param = child.getElementsByTagName("param")[0];
                        data.axis = param.textContent;
                        var tmpJointIndex = data.axis.split("inst_").pop().split("axis")[0];
                        data.jointIndex = tmpJointIndex.substr(0, tmpJointIndex.length - 1);
                        break;
                }
            }
            return data;
        }
        function buildKinematicsScene(data) {
            if (data.build !== undefined) return data.build;
            return data;
        }
        function getKinematicsScene(id) {
            return getBuild(library.kinematicsScenes[id], buildKinematicsScene);
        }
        function setupKinematics() {
            var kinematicsModelId = Object.keys(library.kinematicsModels)[0];
            var kinematicsSceneId = Object.keys(library.kinematicsScenes)[0];
            var visualSceneId = Object.keys(library.visualScenes)[0];
            if (kinematicsModelId === undefined || kinematicsSceneId === undefined) return;
            var kinematicsModel = getKinematicsModel(kinematicsModelId);
            var kinematicsScene = getKinematicsScene(kinematicsSceneId);
            var visualScene = getVisualScene(visualSceneId);
            var bindJointAxis = kinematicsScene.bindJointAxis;
            var jointMap = {};
            for(var i = 0, l = bindJointAxis.length; i < l; i++){
                var axis = bindJointAxis[i];
                // the result of the following query is an element of type 'translate', 'rotate','scale' or 'matrix'
                var targetElement = collada.querySelector('[sid="' + axis.target + '"]');
                if (targetElement) {
                    // get the parent of the transfrom element
                    var parentVisualElement = targetElement.parentElement;
                    // connect the joint of the kinematics model with the element in the visual scene
                    connect(axis.jointIndex, parentVisualElement);
                }
            }
            function connect(jointIndex, visualElement) {
                var visualElementName = visualElement.getAttribute("name");
                var joint = kinematicsModel.joints[jointIndex];
                visualScene.traverse(function(object) {
                    if (object.name === visualElementName) jointMap[jointIndex] = {
                        object: object,
                        transforms: buildTransformList(visualElement),
                        joint: joint,
                        position: joint.zeroPosition
                    };
                });
            }
            var m0 = new THREE.Matrix4();
            kinematics = {
                joints: kinematicsModel && kinematicsModel.joints,
                getJointValue: function(jointIndex) {
                    var jointData = jointMap[jointIndex];
                    if (jointData) return jointData.position;
                    else console.warn("THREE.ColladaLoader: Joint " + jointIndex + " doesn't exist.");
                },
                setJointValue: function(jointIndex, value1) {
                    var jointData = jointMap[jointIndex];
                    if (jointData) {
                        var joint = jointData.joint;
                        if (value1 > joint.limits.max || value1 < joint.limits.min) console.warn("THREE.ColladaLoader: Joint " + jointIndex + " value " + value1 + " outside of limits (min: " + joint.limits.min + ", max: " + joint.limits.max + ").");
                        else if (joint.static) console.warn("THREE.ColladaLoader: Joint " + jointIndex + " is static.");
                        else {
                            var object = jointData.object;
                            var axis = joint.axis;
                            var transforms = jointData.transforms;
                            matrix.identity();
                            // each update, we have to apply all transforms in the correct order
                            for(var i = 0; i < transforms.length; i++){
                                var transform = transforms[i];
                                // if there is a connection of the transform node with a joint, apply the joint value
                                if (transform.sid && transform.sid.indexOf(jointIndex) !== -1) switch(joint.type){
                                    case "revolute":
                                        matrix.multiply(m0.makeRotationAxis(axis, THREE.Math.degToRad(value1)));
                                        break;
                                    case "prismatic":
                                        matrix.multiply(m0.makeTranslation(axis.x * value1, axis.y * value1, axis.z * value1));
                                        break;
                                    default:
                                        console.warn("THREE.ColladaLoader: Unknown joint type: " + joint.type);
                                        break;
                                }
                                else switch(transform.type){
                                    case "matrix":
                                        matrix.multiply(transform.obj);
                                        break;
                                    case "translate":
                                        matrix.multiply(m0.makeTranslation(transform.obj.x, transform.obj.y, transform.obj.z));
                                        break;
                                    case "scale":
                                        matrix.scale(transform.obj);
                                        break;
                                    case "rotate":
                                        matrix.multiply(m0.makeRotationAxis(transform.obj, transform.angle));
                                        break;
                                }
                            }
                            object.matrix.copy(matrix);
                            object.matrix.decompose(object.position, object.quaternion, object.scale);
                            jointMap[jointIndex].position = value1;
                        }
                    } else console.log("THREE.ColladaLoader: " + jointIndex + " does not exist.");
                }
            };
        }
        function buildTransformList(node) {
            var transforms = [];
            var xml = collada.querySelector('[id="' + node.id + '"]');
            for(var i = 0; i < xml.childNodes.length; i++){
                var child = xml.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "matrix":
                        var array = parseFloats(child.textContent);
                        var matrix = new THREE.Matrix4().fromArray(array).transpose();
                        transforms.push({
                            sid: child.getAttribute("sid"),
                            type: child.nodeName,
                            obj: matrix
                        });
                        break;
                    case "translate":
                    case "scale":
                        var array = parseFloats(child.textContent);
                        var vector = new THREE.Vector3().fromArray(array);
                        transforms.push({
                            sid: child.getAttribute("sid"),
                            type: child.nodeName,
                            obj: vector
                        });
                        break;
                    case "rotate":
                        var array = parseFloats(child.textContent);
                        var vector = new THREE.Vector3().fromArray(array);
                        var angle = THREE.Math.degToRad(array[3]);
                        transforms.push({
                            sid: child.getAttribute("sid"),
                            type: child.nodeName,
                            obj: vector,
                            angle: angle
                        });
                        break;
                }
            }
            return transforms;
        }
        // nodes
        function prepareNodes(xml) {
            var elements = xml.getElementsByTagName("node");
            // ensure all node elements have id attributes
            for(var i = 0; i < elements.length; i++){
                var element = elements[i];
                if (element.hasAttribute("id") === false) element.setAttribute("id", generateId());
            }
        }
        var matrix = new THREE.Matrix4();
        var vector = new THREE.Vector3();
        function parseNode(xml) {
            var data = {
                name: xml.getAttribute("name") || "",
                type: xml.getAttribute("type"),
                id: xml.getAttribute("id"),
                sid: xml.getAttribute("sid"),
                matrix: new THREE.Matrix4(),
                nodes: [],
                instanceCameras: [],
                instanceControllers: [],
                instanceLights: [],
                instanceGeometries: [],
                instanceNodes: [],
                transforms: {}
            };
            for(var i = 0; i < xml.childNodes.length; i++){
                var child = xml.childNodes[i];
                if (child.nodeType !== 1) continue;
                switch(child.nodeName){
                    case "node":
                        data.nodes.push(child.getAttribute("id"));
                        parseNode(child);
                        break;
                    case "instance_camera":
                        data.instanceCameras.push(parseId(child.getAttribute("url")));
                        break;
                    case "instance_controller":
                        data.instanceControllers.push(parseNodeInstance(child));
                        break;
                    case "instance_light":
                        data.instanceLights.push(parseId(child.getAttribute("url")));
                        break;
                    case "instance_geometry":
                        data.instanceGeometries.push(parseNodeInstance(child));
                        break;
                    case "instance_node":
                        data.instanceNodes.push(parseId(child.getAttribute("url")));
                        break;
                    case "matrix":
                        var array = parseFloats(child.textContent);
                        data.matrix.multiply(matrix.fromArray(array).transpose());
                        data.transforms[child.getAttribute("sid")] = child.nodeName;
                        break;
                    case "translate":
                        var array = parseFloats(child.textContent);
                        vector.fromArray(array);
                        data.matrix.multiply(matrix.makeTranslation(vector.x, vector.y, vector.z));
                        data.transforms[child.getAttribute("sid")] = child.nodeName;
                        break;
                    case "rotate":
                        var array = parseFloats(child.textContent);
                        var angle = THREE.Math.degToRad(array[3]);
                        data.matrix.multiply(matrix.makeRotationAxis(vector.fromArray(array), angle));
                        data.transforms[child.getAttribute("sid")] = child.nodeName;
                        break;
                    case "scale":
                        var array = parseFloats(child.textContent);
                        data.matrix.scale(vector.fromArray(array));
                        data.transforms[child.getAttribute("sid")] = child.nodeName;
                        break;
                    case "extra":
                        break;
                    default:
                        console.log(child);
                }
            }
            if (hasNode(data.id)) console.warn("THREE.ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.", data.id);
            else library.nodes[data.id] = data;
            return data;
        }
        function parseNodeInstance(xml) {
            var data = {
                id: parseId(xml.getAttribute("url")),
                materials: {},
                skeletons: []
            };
            for(var i = 0; i < xml.childNodes.length; i++){
                var child = xml.childNodes[i];
                switch(child.nodeName){
                    case "bind_material":
                        var instances = child.getElementsByTagName("instance_material");
                        for(var j = 0; j < instances.length; j++){
                            var instance = instances[j];
                            var symbol = instance.getAttribute("symbol");
                            var target = instance.getAttribute("target");
                            data.materials[symbol] = parseId(target);
                        }
                        break;
                    case "skeleton":
                        data.skeletons.push(parseId(child.textContent));
                        break;
                    default:
                        break;
                }
            }
            return data;
        }
        function buildSkeleton(skeletons, joints) {
            var boneData = [];
            var sortedBoneData = [];
            var i, j, data;
            // a skeleton can have multiple root bones. collada expresses this
            // situtation with multiple "skeleton" tags per controller instance
            for(i = 0; i < skeletons.length; i++){
                var skeleton = skeletons[i];
                var root;
                if (hasNode(skeleton)) {
                    root = getNode(skeleton);
                    buildBoneHierarchy(root, joints, boneData);
                } else if (hasVisualScene(skeleton)) {
                    // handle case where the skeleton refers to the visual scene (#13335)
                    var visualScene = library.visualScenes[skeleton];
                    var children = visualScene.children;
                    for(var j = 0; j < children.length; j++){
                        var child = children[j];
                        if (child.type === "JOINT") {
                            var root = getNode(child.id);
                            buildBoneHierarchy(root, joints, boneData);
                        }
                    }
                } else console.error("THREE.ColladaLoader: Unable to find root bone of skeleton with ID:", skeleton);
            }
            // sort bone data (the order is defined in the corresponding controller)
            for(i = 0; i < joints.length; i++)for(j = 0; j < boneData.length; j++){
                data = boneData[j];
                if (data.bone.name === joints[i].name) {
                    sortedBoneData[i] = data;
                    data.processed = true;
                    break;
                }
            }
            // add unprocessed bone data at the end of the list
            for(i = 0; i < boneData.length; i++){
                data = boneData[i];
                if (data.processed === false) {
                    sortedBoneData.push(data);
                    data.processed = true;
                }
            }
            // setup arrays for skeleton creation
            var bones = [];
            var boneInverses = [];
            for(i = 0; i < sortedBoneData.length; i++){
                data = sortedBoneData[i];
                bones.push(data.bone);
                boneInverses.push(data.boneInverse);
            }
            return new THREE.Skeleton(bones, boneInverses);
        }
        function buildBoneHierarchy(root, joints, boneData) {
            // setup bone data from visual scene
            root.traverse(function(object) {
                if (object.isBone === true) {
                    var boneInverse;
                    // retrieve the boneInverse from the controller data
                    for(var i = 0; i < joints.length; i++){
                        var joint = joints[i];
                        if (joint.name === object.name) {
                            boneInverse = joint.boneInverse;
                            break;
                        }
                    }
                    if (boneInverse === undefined) // Unfortunately, there can be joints in the visual scene that are not part of the
                    // corresponding controller. In this case, we have to create a dummy boneInverse matrix
                    // for the respective bone. This bone won't affect any vertices, because there are no skin indices
                    // and weights defined for it. But we still have to add the bone to the sorted bone list in order to
                    // ensure a correct animation of the model.
                    boneInverse = new THREE.Matrix4();
                    boneData.push({
                        bone: object,
                        boneInverse: boneInverse,
                        processed: false
                    });
                }
            });
        }
        function buildNode(data) {
            var objects = [];
            var matrix = data.matrix;
            var nodes = data.nodes;
            var type = data.type;
            var instanceCameras = data.instanceCameras;
            var instanceControllers = data.instanceControllers;
            var instanceLights = data.instanceLights;
            var instanceGeometries = data.instanceGeometries;
            var instanceNodes = data.instanceNodes;
            // nodes
            for(var i = 0, l = nodes.length; i < l; i++)objects.push(getNode(nodes[i]));
            // instance cameras
            for(var i = 0, l = instanceCameras.length; i < l; i++){
                var instanceCamera = getCamera(instanceCameras[i]);
                if (instanceCamera !== null) objects.push(instanceCamera.clone());
            }
            // instance controllers
            for(var i = 0, l = instanceControllers.length; i < l; i++){
                var instance = instanceControllers[i];
                var controller = getController(instance.id);
                var geometries = getGeometry(controller.id);
                var newObjects = buildObjects(geometries, instance.materials);
                var skeletons = instance.skeletons;
                var joints = controller.skin.joints;
                var skeleton = buildSkeleton(skeletons, joints);
                for(var j = 0, jl = newObjects.length; j < jl; j++){
                    var object = newObjects[j];
                    if (object.isSkinnedMesh) {
                        object.bind(skeleton, controller.skin.bindMatrix);
                        object.normalizeSkinWeights();
                    }
                    objects.push(object);
                }
            }
            // instance lights
            for(var i = 0, l = instanceLights.length; i < l; i++){
                var instanceLight = getLight(instanceLights[i]);
                if (instanceLight !== null) objects.push(instanceLight.clone());
            }
            // instance geometries
            for(var i = 0, l = instanceGeometries.length; i < l; i++){
                var instance = instanceGeometries[i];
                // a single geometry instance in collada can lead to multiple object3Ds.
                // this is the case when primitives are combined like triangles and lines
                var geometries = getGeometry(instance.id);
                var newObjects = buildObjects(geometries, instance.materials);
                for(var j = 0, jl = newObjects.length; j < jl; j++)objects.push(newObjects[j]);
            }
            // instance nodes
            for(var i = 0, l = instanceNodes.length; i < l; i++)objects.push(getNode(instanceNodes[i]).clone());
            var object;
            if (nodes.length === 0 && objects.length === 1) object = objects[0];
            else {
                object = type === "JOINT" ? new THREE.Bone() : new THREE.Group();
                for(var i = 0; i < objects.length; i++)object.add(objects[i]);
            }
            if (object.name === "") object.name = type === "JOINT" ? data.sid : data.name;
            object.matrix.copy(matrix);
            object.matrix.decompose(object.position, object.quaternion, object.scale);
            return object;
        }
        var fallbackMaterial = new THREE.MeshBasicMaterial({
            color: 0xff00ff
        });
        function resolveMaterialBinding(keys, instanceMaterials) {
            var materials = [];
            for(var i = 0, l = keys.length; i < l; i++){
                var id = instanceMaterials[keys[i]];
                if (id === undefined) {
                    console.warn("THREE.ColladaLoader: Material with key %s not found. Apply fallback material.", keys[i]);
                    materials.push(fallbackMaterial);
                } else materials.push(getMaterial(id));
            }
            return materials;
        }
        function buildObjects(geometries, instanceMaterials) {
            var objects = [];
            for(var type in geometries){
                var geometry = geometries[type];
                var materials = resolveMaterialBinding(geometry.materialKeys, instanceMaterials);
                // handle case if no materials are defined
                if (materials.length === 0) {
                    if (type === "lines" || type === "linestrips") materials.push(new THREE.LineBasicMaterial());
                    else materials.push(new THREE.MeshPhongMaterial());
                }
                // regard skinning
                var skinning = geometry.data.attributes.skinIndex !== undefined;
                if (skinning) for(var i = 0, l = materials.length; i < l; i++)materials[i].skinning = true;
                // choose between a single or multi materials (material array)
                var material = materials.length === 1 ? materials[0] : materials;
                // now create a specific 3D object
                var object;
                switch(type){
                    case "lines":
                        object = new THREE.LineSegments(geometry.data, material);
                        break;
                    case "linestrips":
                        object = new THREE.Line(geometry.data, material);
                        break;
                    case "triangles":
                    case "polylist":
                        if (skinning) object = new THREE.SkinnedMesh(geometry.data, material);
                        else object = new THREE.Mesh(geometry.data, material);
                        break;
                }
                objects.push(object);
            }
            return objects;
        }
        function hasNode(id) {
            return library.nodes[id] !== undefined;
        }
        function getNode(id) {
            return getBuild(library.nodes[id], buildNode);
        }
        // visual scenes
        function parseVisualScene(xml) {
            var data = {
                name: xml.getAttribute("name"),
                children: []
            };
            prepareNodes(xml);
            var elements = getElementsByTagName(xml, "node");
            for(var i = 0; i < elements.length; i++)data.children.push(parseNode(elements[i]));
            library.visualScenes[xml.getAttribute("id")] = data;
        }
        function buildVisualScene(data) {
            var group = new THREE.Group();
            group.name = data.name;
            var children = data.children;
            for(var i = 0; i < children.length; i++){
                var child = children[i];
                group.add(getNode(child.id));
            }
            return group;
        }
        function hasVisualScene(id) {
            return library.visualScenes[id] !== undefined;
        }
        function getVisualScene(id) {
            return getBuild(library.visualScenes[id], buildVisualScene);
        }
        // scenes
        function parseScene(xml) {
            var instance = getElementsByTagName(xml, "instance_visual_scene")[0];
            return getVisualScene(parseId(instance.getAttribute("url")));
        }
        function setupAnimations() {
            var clips = library.clips;
            if (isEmpty(clips) === true) {
                if (isEmpty(library.animations) === false) {
                    // if there are animations but no clips, we create a default clip for playback
                    var tracks = [];
                    for(var id in library.animations){
                        var animationTracks = getAnimation(id);
                        for(var i = 0, l = animationTracks.length; i < l; i++)tracks.push(animationTracks[i]);
                    }
                    animations.push(new THREE.AnimationClip("default", -1, tracks));
                }
            } else for(var id in clips)animations.push(getAnimationClip(id));
        }
        if (text.length === 0) return {
            scene: new THREE.Scene()
        };
        var xml = new DOMParser().parseFromString(text, "application/xml");
        var collada = getElementsByTagName(xml, "COLLADA")[0];
        // metadata
        var version = collada.getAttribute("version");
        console.log("THREE.ColladaLoader: File version", version);
        var asset = parseAsset(getElementsByTagName(collada, "asset")[0]);
        var textureLoader = new THREE.TextureLoader(this.manager);
        textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);
        var tgaLoader;
        if (THREE.TGALoader) {
            tgaLoader = new THREE.TGALoader(this.manager);
            tgaLoader.setPath(this.resourcePath || path);
        }
        //
        var animations = [];
        var kinematics = {};
        var count = 0;
        //
        var library = {
            animations: {},
            clips: {},
            controllers: {},
            images: {},
            effects: {},
            materials: {},
            cameras: {},
            lights: {},
            geometries: {},
            nodes: {},
            visualScenes: {},
            kinematicsModels: {},
            physicsModels: {},
            kinematicsScenes: {}
        };
        parseLibrary(collada, "library_animations", "animation", parseAnimation);
        parseLibrary(collada, "library_animation_clips", "animation_clip", parseAnimationClip);
        parseLibrary(collada, "library_controllers", "controller", parseController);
        parseLibrary(collada, "library_images", "image", parseImage);
        parseLibrary(collada, "library_effects", "effect", parseEffect);
        parseLibrary(collada, "library_materials", "material", parseMaterial);
        parseLibrary(collada, "library_cameras", "camera", parseCamera);
        parseLibrary(collada, "library_lights", "light", parseLight);
        parseLibrary(collada, "library_geometries", "geometry", parseGeometry);
        parseLibrary(collada, "library_nodes", "node", parseNode);
        parseLibrary(collada, "library_visual_scenes", "visual_scene", parseVisualScene);
        parseLibrary(collada, "library_kinematics_models", "kinematics_model", parseKinematicsModel);
        parseLibrary(collada, "library_physics_models", "physics_model", parsePhysicsModel);
        parseLibrary(collada, "scene", "instance_kinematics_scene", parseKinematicsScene);
        buildLibrary(library.animations, buildAnimation);
        buildLibrary(library.clips, buildAnimationClip);
        buildLibrary(library.controllers, buildController);
        buildLibrary(library.images, buildImage);
        buildLibrary(library.effects, buildEffect);
        buildLibrary(library.materials, buildMaterial);
        buildLibrary(library.cameras, buildCamera);
        buildLibrary(library.lights, buildLight);
        buildLibrary(library.geometries, buildGeometry);
        buildLibrary(library.visualScenes, buildVisualScene);
        setupAnimations();
        setupKinematics();
        var scene = parseScene(getElementsByTagName(collada, "scene")[0]);
        if (asset.upAxis === "Z_UP") scene.quaternion.setFromEuler(new THREE.Euler(-Math.PI / 2, 0, 0));
        scene.scale.multiplyScalar(asset.unit);
        return {
            animations: animations,
            kinematics: kinematics,
            library: library,
            scene: scene
        };
    }
};

},{}],"1fT3w":[function(require,module,exports) {
"use strict";
// lib
const { Observable } = require("ceca75749931aa98");
const { filter, share, withLatestFrom } = require("b951f29c417a8e4f");
const raf = require("2e9a2e45ceca19d2");
const tick = (cb)=>raf(function(dt) {
        cb(dt);
        tick(cb);
    });
const frame = ()=>new Observable((obs)=>tick((dt)=>obs.next(dt))).pipe(filter((dt)=>dt !== 0), share());
const loop = (state$, node)=>frame(node).pipe(withLatestFrom(state$, (dt, state)=>({
            dt,
            state
        })));
module.exports = {
    frame,
    loop
};

},{"ceca75749931aa98":"hWUVi","b951f29c417a8e4f":"1cs2r","2e9a2e45ceca19d2":"7Jun9"}],"7Jun9":[function(require,module,exports) {
var global = arguments[3];
var now = require("8ac08eb46c52bf57"), root = typeof window === "undefined" ? global : window, vendors = [
    "moz",
    "webkit"
], suffix = "AnimationFrame", raf = root["request" + suffix], caf = root["cancel" + suffix] || root["cancelRequest" + suffix];
for(var i = 0; !raf && i < vendors.length; i++){
    raf = root[vendors[i] + "Request" + suffix];
    caf = root[vendors[i] + "Cancel" + suffix] || root[vendors[i] + "CancelRequest" + suffix];
}
// Some versions of FF have rAF but not cAF
if (!raf || !caf) {
    var last = 0, id = 0, queue = [], frameDuration = 1000 / 60;
    raf = function(callback) {
        if (queue.length === 0) {
            var _now = now(), next = Math.max(0, frameDuration - (_now - last));
            last = next + _now;
            setTimeout(function() {
                var cp = queue.slice(0);
                // Clear queue here to prevent
                // callbacks from appending listeners
                // to the current frame's queue
                queue.length = 0;
                for(var i = 0; i < cp.length; i++){
                    if (!cp[i].cancelled) try {
                        cp[i].callback(last);
                    } catch (e) {
                        setTimeout(function() {
                            throw e;
                        }, 0);
                    }
                }
            }, Math.round(next));
        }
        queue.push({
            handle: ++id,
            callback: callback,
            cancelled: false
        });
        return id;
    };
    caf = function(handle) {
        for(var i = 0; i < queue.length; i++)if (queue[i].handle === handle) queue[i].cancelled = true;
    };
}
module.exports = function(fn) {
    // Wrap in a new function to prevent
    // `cancel` potentially being assigned
    // to the native rAF function
    return raf.call(root, fn);
};
module.exports.cancel = function() {
    caf.apply(root, arguments);
};
module.exports.polyfill = function(object) {
    if (!object) object = root;
    object.requestAnimationFrame = raf;
    object.cancelAnimationFrame = caf;
};

},{"8ac08eb46c52bf57":"lOoWL"}],"lOoWL":[function(require,module,exports) {
var process = require("8e102ffac3078272");
// Generated by CoffeeScript 1.12.2
(function() {
    var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;
    if (typeof performance !== "undefined" && performance !== null && performance.now) module.exports = function() {
        return performance.now();
    };
    else if (typeof process !== "undefined" && process !== null && process.hrtime) {
        module.exports = function() {
            return (getNanoSeconds() - nodeLoadTime) / 1e6;
        };
        hrtime = process.hrtime;
        getNanoSeconds = function() {
            var hr;
            hr = hrtime();
            return hr[0] * 1e9 + hr[1];
        };
        moduleLoadTime = getNanoSeconds();
        upTime = process.uptime() * 1e9;
        nodeLoadTime = moduleLoadTime - upTime;
    } else if (Date.now) {
        module.exports = function() {
            return Date.now() - loadTime;
        };
        loadTime = Date.now();
    } else {
        module.exports = function() {
            return new Date().getTime() - loadTime;
        };
        loadTime = new Date().getTime();
    }
}).call(this);

},{"8e102ffac3078272":"8MGn2"}],"8MGn2":[function(require,module,exports) {
// shim for using process in browser
var process = module.exports = {};
// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.
var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
    throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
    throw new Error("clearTimeout has not been defined");
}
(function() {
    try {
        if (typeof setTimeout === "function") cachedSetTimeout = setTimeout;
        else cachedSetTimeout = defaultSetTimout;
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === "function") cachedClearTimeout = clearTimeout;
        else cachedClearTimeout = defaultClearTimeout;
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) //normal enviroments in sane situations
    return setTimeout(fun, 0);
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) //normal enviroments in sane situations
    return clearTimeout(marker);
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
    if (!draining || !currentQueue) return;
    draining = false;
    if (currentQueue.length) queue = currentQueue.concat(queue);
    else queueIndex = -1;
    if (queue.length) drainQueue();
}
function drainQueue() {
    if (draining) return;
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while(len){
        currentQueue = queue;
        queue = [];
        while(++queueIndex < len)if (currentQueue) currentQueue[queueIndex].run();
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}
process.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) for(var i = 1; i < arguments.length; i++)args[i - 1] = arguments[i];
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) runTimeout(drainQueue);
};
// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function() {
    this.fun.apply(null, this.array);
};
process.title = "browser";
process.browser = true;
process.env = {};
process.argv = [];
process.version = ""; // empty string to avoid regexp issues
process.versions = {};
function noop() {}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function(name) {
    return [];
};
process.binding = function(name) {
    throw new Error("process.binding is not supported");
};
process.cwd = function() {
    return "/";
};
process.chdir = function(dir) {
    throw new Error("process.chdir is not supported");
};
process.umask = function() {
    return 0;
};

},{}],"2GmuD":[function(require,module,exports) {
"use strict";
// lib
const { from } = require("7ade0276160a4ba8");
const { concatMap, reduce } = require("f4ec76256794d0c0");
// threejs
const THREE = require("58e82a6766df4681");
window.THREE = window.THREE || THREE;
const { obj, fn } = require("66f146b08a6da29d");
const colladaLoader = require("515377cc478ad48");
const gltfLoader = require("4ee46282c7f6d7a0");
const objLoader = require("ef1b47d3f672867e");
const loadTexture = (file)=>new THREE.TextureLoader().load(file);
const genSkyboxMaterial = (pack, opacity = 0.3)=>new THREE.MeshFaceMaterial([
        "front",
        "back",
        "up",
        "down",
        "right",
        "left"
    ].map((direction)=>new THREE.MeshBasicMaterial({
            map: loadTexture(`assets/skybox/${pack}/${direction}.png`),
            side: THREE.DoubleSide,
            fog: false,
            transparent: true,
            opacity
        })));
const init = ({ scene, state })=>{
    const materials = [
        "ground.jpg",
        "tiles.png"
    ].map((f)=>new THREE.TextureLoader().load(`assets/textures/${f}`)).map((text)=>(text.wrapS = THREE.RepeatWrapping, text.wrapT = THREE.RepeatWrapping, text)).map((map)=>new THREE.MeshPhongMaterial({
            map
        }));
    const skyboxGeo = new THREE.CubeGeometry(1000, 1000, 1000);
    const skybox = new THREE.Mesh(skyboxGeo, genSkyboxMaterial("neccity", 0.1));
    skybox.name = "skybox";
    // skybox.rotation.y += Math.PI / 2;
    skybox.position.set(0, 0, 0);
    scene.add(skybox);
    scene.fog = new THREE.FogExp2(`#17112a`, 0.015);
    scene.background = new THREE.Color(`#17112a`);
    const geometry = new THREE.BoxGeometry(5, 0.2, 5);
    state.level.map.forEach((row, z)=>row.forEach((tile, x)=>fn.pipe(()=>new THREE.Mesh(geometry, materials[tile]), (mesh)=>(mesh.castShadow = true, mesh.receiveShadow = true, mesh), (mesh)=>(mesh.position.set((x - row.length / 2 + 1) * 5, tile * 0.1, (z - state.level.map.length / 2 + 1) * 5), mesh), (mesh)=>scene.add(mesh))()));
    const modelScale = [
        0.5,
        2.5,
        3,
        3,
        1
    ];
    from([
        "lamp.dae",
        "bench.dae",
        "tree1.dae",
        "tree2.dae",
        "tree3.dae"
    ]).pipe(concatMap((f)=>f.match(".dae") ? colladaLoader.load(`assets/models/${f}`) : f.match(".obj") ? objLoader.load(`assets/models/${f}`) : gltfLoader.load(`assets/models/${f}`)), reduce((a, m)=>[].concat(a, m), [])).subscribe((colladaArray)=>{
        let meshes = colladaArray.map((c)=>c.scene).map((c, i)=>(c.castShadow = true, c.receiveShadow = true, c.scale.set(modelScale[i], modelScale[i], modelScale[i]), c));
        state.level.assets.forEach((row, z)=>row.forEach((tile, x)=>tile !== 0 && fn.pipe(()=>meshes[tile - 1].clone(), (mesh)=>(mesh.position.set((x - row.length / 2 + 1) * 5, 0, (z - state.level.map.length / 2 + 1) * 5), mesh), (mesh)=>scene.add(mesh))()));
    });
    // gltfLoader.load(`assets/models/old_fabric/scene.gltf`)
    // 	.subscribe(gltf => {
    // 		let fabric = gltf.scene;
    // 		scene.add(fabric);
    // 		fabric.scale.set(1.72, 1.72, 1.72);
    // 		fabric.position.set(
    // 			(levelMap[0].length / 2 + 3) * 5,
    // 			0.25,
    // 			-2.3
    // 		);
    // 	});
    return scene;
};
module.exports = {
    init
};

},{"7ade0276160a4ba8":"hWUVi","f4ec76256794d0c0":"1cs2r","58e82a6766df4681":"5IrVb","66f146b08a6da29d":"2lXuw","515377cc478ad48":"jdCb6","4ee46282c7f6d7a0":"jAd3E","ef1b47d3f672867e":"2RGT8"}],"jAd3E":[function(require,module,exports) {
"use strict";
// lib
const { Observable } = require("e1598efe5b3512bc");
// threejs
const THREE = require("454acd7844d4f13e");
window.THREE = window.THREE || THREE;
require("bd657e38981e86aa");
const load = (url)=>new Observable((observer)=>new THREE.GLTFLoader().load(url, function(gltf) {
            observer.next(gltf);
            observer.complete();
        }));
const clone = (gltf)=>{
    const clone = {
        animations: gltf.animations,
        scene: gltf.scene.clone(true)
    };
    const skinnedMeshes = {};
    gltf.scene.traverse((node)=>{
        if (node.isSkinnedMesh) skinnedMeshes[node.name] = node;
    });
    const cloneBones = {};
    const cloneSkinnedMeshes = {};
    clone.scene.traverse((node)=>{
        if (node.isBone) cloneBones[node.name] = node;
        if (node.isSkinnedMesh) cloneSkinnedMeshes[node.name] = node;
    });
    for(let name in skinnedMeshes){
        const skinnedMesh = skinnedMeshes[name];
        const skeleton = skinnedMesh.skeleton;
        const cloneSkinnedMesh = cloneSkinnedMeshes[name];
        const orderedCloneBones = [];
        for(let i = 0; i < skeleton.bones.length; ++i){
            const cloneBone = cloneBones[skeleton.bones[i].name];
            orderedCloneBones.push(cloneBone);
        }
        cloneSkinnedMesh.bind(new THREE.Skeleton(orderedCloneBones, skeleton.boneInverses), cloneSkinnedMesh.matrixWorld);
    }
    return clone;
};
module.exports = {
    load,
    clone
};

},{"e1598efe5b3512bc":"hWUVi","454acd7844d4f13e":"5IrVb","bd657e38981e86aa":"lIEUT"}],"lIEUT":[function(require,module,exports) {
/**
 * @author Rich Tibbett / https://github.com/richtr
 * @author mrdoob / http://mrdoob.com/
 * @author Tony Parisi / http://www.tonyparisi.com/
 * @author Takahiro / https://github.com/takahirox
 * @author Don McCurdy / https://www.donmccurdy.com
 */ THREE.GLTFLoader = function() {
    function GLTFLoader(manager) {
        this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
        this.dracoLoader = null;
    }
    GLTFLoader.prototype = {
        constructor: GLTFLoader,
        crossOrigin: "anonymous",
        load: function(url, onLoad, onProgress, onError) {
            var scope = this;
            var resourcePath;
            if (this.resourcePath !== undefined) resourcePath = this.resourcePath;
            else if (this.path !== undefined) resourcePath = this.path;
            else resourcePath = THREE.LoaderUtils.extractUrlBase(url);
            // Tells the LoadingManager to track an extra item, which resolves after
            // the model is fully loaded. This means the count of items loaded will
            // be incorrect, but ensures manager.onLoad() does not fire early.
            scope.manager.itemStart(url);
            var _onError = function(e) {
                if (onError) onError(e);
                else console.error(e);
                scope.manager.itemError(url);
                scope.manager.itemEnd(url);
            };
            var loader = new THREE.FileLoader(scope.manager);
            loader.setPath(this.path);
            loader.setResponseType("arraybuffer");
            loader.load(url, function(data) {
                try {
                    scope.parse(data, resourcePath, function(gltf) {
                        onLoad(gltf);
                        scope.manager.itemEnd(url);
                    }, _onError);
                } catch (e) {
                    _onError(e);
                }
            }, onProgress, _onError);
        },
        setCrossOrigin: function(value) {
            this.crossOrigin = value;
            return this;
        },
        setPath: function(value) {
            this.path = value;
            return this;
        },
        setResourcePath: function(value) {
            this.resourcePath = value;
            return this;
        },
        setDRACOLoader: function(dracoLoader) {
            this.dracoLoader = dracoLoader;
            return this;
        },
        parse: function(data, path, onLoad, onError) {
            var content;
            var extensions = {};
            if (typeof data === "string") content = data;
            else {
                var magic = THREE.LoaderUtils.decodeText(new Uint8Array(data, 0, 4));
                if (magic === BINARY_EXTENSION_HEADER_MAGIC) {
                    try {
                        extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);
                    } catch (error) {
                        if (onError) onError(error);
                        return;
                    }
                    content = extensions[EXTENSIONS.KHR_BINARY_GLTF].content;
                } else content = THREE.LoaderUtils.decodeText(new Uint8Array(data));
            }
            var json = JSON.parse(content);
            if (json.asset === undefined || json.asset.version[0] < 2) {
                if (onError) onError(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported. Use LegacyGLTFLoader instead."));
                return;
            }
            if (json.extensionsUsed) for(var i = 0; i < json.extensionsUsed.length; ++i){
                var extensionName = json.extensionsUsed[i];
                var extensionsRequired = json.extensionsRequired || [];
                switch(extensionName){
                    case EXTENSIONS.KHR_LIGHTS_PUNCTUAL:
                        extensions[extensionName] = new GLTFLightsExtension(json);
                        break;
                    case EXTENSIONS.KHR_MATERIALS_UNLIT:
                        extensions[extensionName] = new GLTFMaterialsUnlitExtension(json);
                        break;
                    case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                        extensions[extensionName] = new GLTFMaterialsPbrSpecularGlossinessExtension(json);
                        break;
                    case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
                        extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);
                        break;
                    case EXTENSIONS.MSFT_TEXTURE_DDS:
                        extensions[EXTENSIONS.MSFT_TEXTURE_DDS] = new GLTFTextureDDSExtension(json);
                        break;
                    case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
                        extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] = new GLTFTextureTransformExtension(json);
                        break;
                    default:
                        if (extensionsRequired.indexOf(extensionName) >= 0) console.warn('THREE.GLTFLoader: Unknown extension "' + extensionName + '".');
                }
            }
            var parser = new GLTFParser(json, extensions, {
                path: path || this.resourcePath || "",
                crossOrigin: this.crossOrigin,
                manager: this.manager
            });
            parser.parse(function(scene, scenes, cameras, animations, json) {
                var glTF = {
                    scene: scene,
                    scenes: scenes,
                    cameras: cameras,
                    animations: animations,
                    asset: json.asset,
                    parser: parser,
                    userData: {}
                };
                addUnknownExtensionsToUserData(extensions, glTF, json);
                onLoad(glTF);
            }, onError);
        }
    };
    /* GLTFREGISTRY */ function GLTFRegistry() {
        var objects = {};
        return {
            get: function(key) {
                return objects[key];
            },
            add: function(key, object) {
                objects[key] = object;
            },
            remove: function(key) {
                delete objects[key];
            },
            removeAll: function() {
                objects = {};
            }
        };
    }
    /*********************************/ /********** EXTENSIONS ***********/ /*********************************/ var EXTENSIONS = {
        KHR_BINARY_GLTF: "KHR_binary_glTF",
        KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
        KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
        KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness",
        KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
        KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
        MSFT_TEXTURE_DDS: "MSFT_texture_dds"
    };
    /**
	 * DDS Texture Extension
	 *
	 * Specification:
	 * https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/MSFT_texture_dds
	 *
	 */ function GLTFTextureDDSExtension() {
        if (!THREE.DDSLoader) throw new Error("THREE.GLTFLoader: Attempting to load .dds texture without importing THREE.DDSLoader");
        this.name = EXTENSIONS.MSFT_TEXTURE_DDS;
        this.ddsLoader = new THREE.DDSLoader();
    }
    /**
	 * Lights Extension
	 *
	 * Specification: PENDING
	 */ function GLTFLightsExtension(json) {
        this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;
        var extension = json.extensions && json.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL] || {};
        this.lightDefs = extension.lights || [];
    }
    GLTFLightsExtension.prototype.loadLight = function(lightIndex) {
        var lightDef = this.lightDefs[lightIndex];
        var lightNode;
        var color = new THREE.Color(0xffffff);
        if (lightDef.color !== undefined) color.fromArray(lightDef.color);
        var range = lightDef.range !== undefined ? lightDef.range : 0;
        switch(lightDef.type){
            case "directional":
                lightNode = new THREE.DirectionalLight(color);
                lightNode.target.position.set(0, 0, -1);
                lightNode.add(lightNode.target);
                break;
            case "point":
                lightNode = new THREE.PointLight(color);
                lightNode.distance = range;
                break;
            case "spot":
                lightNode = new THREE.SpotLight(color);
                lightNode.distance = range;
                // Handle spotlight properties.
                lightDef.spot = lightDef.spot || {};
                lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;
                lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;
                lightNode.angle = lightDef.spot.outerConeAngle;
                lightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;
                lightNode.target.position.set(0, 0, -1);
                lightNode.add(lightNode.target);
                break;
            default:
                throw new Error('THREE.GLTFLoader: Unexpected light type, "' + lightDef.type + '".');
        }
        lightNode.decay = 2;
        if (lightDef.intensity !== undefined) lightNode.intensity = lightDef.intensity;
        lightNode.name = lightDef.name || "light_" + lightIndex;
        return Promise.resolve(lightNode);
    };
    /**
	 * Unlit Materials Extension (pending)
	 *
	 * PR: https://github.com/KhronosGroup/glTF/pull/1163
	 */ function GLTFMaterialsUnlitExtension(json) {
        this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;
    }
    GLTFMaterialsUnlitExtension.prototype.getMaterialType = function(material) {
        return THREE.MeshBasicMaterial;
    };
    GLTFMaterialsUnlitExtension.prototype.extendParams = function(materialParams, material, parser) {
        var pending = [];
        materialParams.color = new THREE.Color(1.0, 1.0, 1.0);
        materialParams.opacity = 1.0;
        var metallicRoughness = material.pbrMetallicRoughness;
        if (metallicRoughness) {
            if (Array.isArray(metallicRoughness.baseColorFactor)) {
                var array = metallicRoughness.baseColorFactor;
                materialParams.color.fromArray(array);
                materialParams.opacity = array[3];
            }
            if (metallicRoughness.baseColorTexture !== undefined) pending.push(parser.assignTexture(materialParams, "map", metallicRoughness.baseColorTexture));
        }
        return Promise.all(pending);
    };
    /* BINARY EXTENSION */ var BINARY_EXTENSION_BUFFER_NAME = "binary_glTF";
    var BINARY_EXTENSION_HEADER_MAGIC = "glTF";
    var BINARY_EXTENSION_HEADER_LENGTH = 12;
    var BINARY_EXTENSION_CHUNK_TYPES = {
        JSON: 0x4E4F534A,
        BIN: 0x004E4942
    };
    function GLTFBinaryExtension(data) {
        this.name = EXTENSIONS.KHR_BINARY_GLTF;
        this.content = null;
        this.body = null;
        var headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);
        this.header = {
            magic: THREE.LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4))),
            version: headerView.getUint32(4, true),
            length: headerView.getUint32(8, true)
        };
        if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
        else if (this.header.version < 2.0) throw new Error("THREE.GLTFLoader: Legacy binary file detected. Use LegacyGLTFLoader instead.");
        var chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);
        var chunkIndex = 0;
        while(chunkIndex < chunkView.byteLength){
            var chunkLength = chunkView.getUint32(chunkIndex, true);
            chunkIndex += 4;
            var chunkType = chunkView.getUint32(chunkIndex, true);
            chunkIndex += 4;
            if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {
                var contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);
                this.content = THREE.LoaderUtils.decodeText(contentArray);
            } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {
                var byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
                this.body = data.slice(byteOffset, byteOffset + chunkLength);
            }
            // Clients must ignore chunks with unknown types.
            chunkIndex += chunkLength;
        }
        if (this.content === null) throw new Error("THREE.GLTFLoader: JSON content not found.");
    }
    /**
	 * DRACO Mesh Compression Extension
	 *
	 * Specification: https://github.com/KhronosGroup/glTF/pull/874
	 */ function GLTFDracoMeshCompressionExtension(json, dracoLoader) {
        if (!dracoLoader) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
        this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;
        this.json = json;
        this.dracoLoader = dracoLoader;
        THREE.DRACOLoader.getDecoderModule();
    }
    GLTFDracoMeshCompressionExtension.prototype.decodePrimitive = function(primitive, parser) {
        var json = this.json;
        var dracoLoader = this.dracoLoader;
        var bufferViewIndex = primitive.extensions[this.name].bufferView;
        var gltfAttributeMap = primitive.extensions[this.name].attributes;
        var threeAttributeMap = {};
        var attributeNormalizedMap = {};
        var attributeTypeMap = {};
        for(var attributeName in gltfAttributeMap){
            if (!(attributeName in ATTRIBUTES)) continue;
            threeAttributeMap[ATTRIBUTES[attributeName]] = gltfAttributeMap[attributeName];
        }
        for(attributeName in primitive.attributes)if (ATTRIBUTES[attributeName] !== undefined && gltfAttributeMap[attributeName] !== undefined) {
            var accessorDef = json.accessors[primitive.attributes[attributeName]];
            var componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
            attributeTypeMap[ATTRIBUTES[attributeName]] = componentType;
            attributeNormalizedMap[ATTRIBUTES[attributeName]] = accessorDef.normalized === true;
        }
        return parser.getDependency("bufferView", bufferViewIndex).then(function(bufferView) {
            return new Promise(function(resolve) {
                dracoLoader.decodeDracoFile(bufferView, function(geometry) {
                    for(var attributeName in geometry.attributes){
                        var attribute = geometry.attributes[attributeName];
                        var normalized = attributeNormalizedMap[attributeName];
                        if (normalized !== undefined) attribute.normalized = normalized;
                    }
                    resolve(geometry);
                }, threeAttributeMap, attributeTypeMap);
            });
        });
    };
    /**
	 * Texture Transform Extension
	 *
	 * Specification:
	 */ function GLTFTextureTransformExtension(json) {
        this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;
    }
    GLTFTextureTransformExtension.prototype.extendTexture = function(texture, transform) {
        texture = texture.clone();
        if (transform.offset !== undefined) texture.offset.fromArray(transform.offset);
        if (transform.rotation !== undefined) texture.rotation = transform.rotation;
        if (transform.scale !== undefined) texture.repeat.fromArray(transform.scale);
        if (transform.texCoord !== undefined) console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.');
        texture.needsUpdate = true;
        return texture;
    };
    /**
	 * Specular-Glossiness Extension
	 *
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness
	 */ function GLTFMaterialsPbrSpecularGlossinessExtension() {
        return {
            name: EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,
            specularGlossinessParams: [
                "color",
                "map",
                "lightMap",
                "lightMapIntensity",
                "aoMap",
                "aoMapIntensity",
                "emissive",
                "emissiveIntensity",
                "emissiveMap",
                "bumpMap",
                "bumpScale",
                "normalMap",
                "displacementMap",
                "displacementScale",
                "displacementBias",
                "specularMap",
                "specular",
                "glossinessMap",
                "glossiness",
                "alphaMap",
                "envMap",
                "envMapIntensity",
                "refractionRatio"
            ],
            getMaterialType: function() {
                return THREE.ShaderMaterial;
            },
            extendParams: function(params, material, parser) {
                var pbrSpecularGlossiness = material.extensions[this.name];
                var shader = THREE.ShaderLib["standard"];
                var uniforms = THREE.UniformsUtils.clone(shader.uniforms);
                var specularMapParsFragmentChunk = [
                    "#ifdef USE_SPECULARMAP",
                    "	uniform sampler2D specularMap;",
                    "#endif"
                ].join("\n");
                var glossinessMapParsFragmentChunk = [
                    "#ifdef USE_GLOSSINESSMAP",
                    "	uniform sampler2D glossinessMap;",
                    "#endif"
                ].join("\n");
                var specularMapFragmentChunk = [
                    "vec3 specularFactor = specular;",
                    "#ifdef USE_SPECULARMAP",
                    "	vec4 texelSpecular = texture2D( specularMap, vUv );",
                    "	texelSpecular = sRGBToLinear( texelSpecular );",
                    "	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture",
                    "	specularFactor *= texelSpecular.rgb;",
                    "#endif"
                ].join("\n");
                var glossinessMapFragmentChunk = [
                    "float glossinessFactor = glossiness;",
                    "#ifdef USE_GLOSSINESSMAP",
                    "	vec4 texelGlossiness = texture2D( glossinessMap, vUv );",
                    "	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture",
                    "	glossinessFactor *= texelGlossiness.a;",
                    "#endif"
                ].join("\n");
                var lightPhysicalFragmentChunk = [
                    "PhysicalMaterial material;",
                    "material.diffuseColor = diffuseColor.rgb;",
                    "material.specularRoughness = clamp( 1.0 - glossinessFactor, 0.04, 1.0 );",
                    "material.specularColor = specularFactor.rgb;"
                ].join("\n");
                var fragmentShader = shader.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", specularMapParsFragmentChunk).replace("#include <metalnessmap_pars_fragment>", glossinessMapParsFragmentChunk).replace("#include <roughnessmap_fragment>", specularMapFragmentChunk).replace("#include <metalnessmap_fragment>", glossinessMapFragmentChunk).replace("#include <lights_physical_fragment>", lightPhysicalFragmentChunk);
                delete uniforms.roughness;
                delete uniforms.metalness;
                delete uniforms.roughnessMap;
                delete uniforms.metalnessMap;
                uniforms.specular = {
                    value: new THREE.Color().setHex(0x111111)
                };
                uniforms.glossiness = {
                    value: 0.5
                };
                uniforms.specularMap = {
                    value: null
                };
                uniforms.glossinessMap = {
                    value: null
                };
                params.vertexShader = shader.vertexShader;
                params.fragmentShader = fragmentShader;
                params.uniforms = uniforms;
                params.defines = {
                    "STANDARD": ""
                };
                params.color = new THREE.Color(1.0, 1.0, 1.0);
                params.opacity = 1.0;
                var pending = [];
                if (Array.isArray(pbrSpecularGlossiness.diffuseFactor)) {
                    var array = pbrSpecularGlossiness.diffuseFactor;
                    params.color.fromArray(array);
                    params.opacity = array[3];
                }
                if (pbrSpecularGlossiness.diffuseTexture !== undefined) pending.push(parser.assignTexture(params, "map", pbrSpecularGlossiness.diffuseTexture));
                params.emissive = new THREE.Color(0.0, 0.0, 0.0);
                params.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;
                params.specular = new THREE.Color(1.0, 1.0, 1.0);
                if (Array.isArray(pbrSpecularGlossiness.specularFactor)) params.specular.fromArray(pbrSpecularGlossiness.specularFactor);
                if (pbrSpecularGlossiness.specularGlossinessTexture !== undefined) {
                    var specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;
                    pending.push(parser.assignTexture(params, "glossinessMap", specGlossMapDef));
                    pending.push(parser.assignTexture(params, "specularMap", specGlossMapDef));
                }
                return Promise.all(pending);
            },
            createMaterial: function(params) {
                // setup material properties based on MeshStandardMaterial for Specular-Glossiness
                var material = new THREE.ShaderMaterial({
                    defines: params.defines,
                    vertexShader: params.vertexShader,
                    fragmentShader: params.fragmentShader,
                    uniforms: params.uniforms,
                    fog: true,
                    lights: true,
                    opacity: params.opacity,
                    transparent: params.transparent
                });
                material.isGLTFSpecularGlossinessMaterial = true;
                material.color = params.color;
                material.map = params.map === undefined ? null : params.map;
                material.lightMap = null;
                material.lightMapIntensity = 1.0;
                material.aoMap = params.aoMap === undefined ? null : params.aoMap;
                material.aoMapIntensity = 1.0;
                material.emissive = params.emissive;
                material.emissiveIntensity = 1.0;
                material.emissiveMap = params.emissiveMap === undefined ? null : params.emissiveMap;
                material.bumpMap = params.bumpMap === undefined ? null : params.bumpMap;
                material.bumpScale = 1;
                material.normalMap = params.normalMap === undefined ? null : params.normalMap;
                if (params.normalScale) material.normalScale = params.normalScale;
                material.displacementMap = null;
                material.displacementScale = 1;
                material.displacementBias = 0;
                material.specularMap = params.specularMap === undefined ? null : params.specularMap;
                material.specular = params.specular;
                material.glossinessMap = params.glossinessMap === undefined ? null : params.glossinessMap;
                material.glossiness = params.glossiness;
                material.alphaMap = null;
                material.envMap = params.envMap === undefined ? null : params.envMap;
                material.envMapIntensity = 1.0;
                material.refractionRatio = 0.98;
                material.extensions.derivatives = true;
                return material;
            },
            /**
			 * Clones a GLTFSpecularGlossinessMaterial instance. The ShaderMaterial.copy() method can
			 * copy only properties it knows about or inherits, and misses many properties that would
			 * normally be defined by MeshStandardMaterial.
			 *
			 * This method allows GLTFSpecularGlossinessMaterials to be cloned in the process of
			 * loading a glTF model, but cloning later (e.g. by the user) would require these changes
			 * AND also updating `.onBeforeRender` on the parent mesh.
			 *
			 * @param  {THREE.ShaderMaterial} source
			 * @return {THREE.ShaderMaterial}
			 */ cloneMaterial: function(source) {
                var target = source.clone();
                target.isGLTFSpecularGlossinessMaterial = true;
                var params = this.specularGlossinessParams;
                for(var i = 0, il = params.length; i < il; i++)target[params[i]] = source[params[i]];
                return target;
            },
            // Here's based on refreshUniformsCommon() and refreshUniformsStandard() in WebGLRenderer.
            refreshUniforms: function(renderer, scene, camera, geometry, material, group) {
                if (material.isGLTFSpecularGlossinessMaterial !== true) return;
                var uniforms = material.uniforms;
                var defines = material.defines;
                uniforms.opacity.value = material.opacity;
                uniforms.diffuse.value.copy(material.color);
                uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
                uniforms.map.value = material.map;
                uniforms.specularMap.value = material.specularMap;
                uniforms.alphaMap.value = material.alphaMap;
                uniforms.lightMap.value = material.lightMap;
                uniforms.lightMapIntensity.value = material.lightMapIntensity;
                uniforms.aoMap.value = material.aoMap;
                uniforms.aoMapIntensity.value = material.aoMapIntensity;
                // uv repeat and offset setting priorities
                // 1. color map
                // 2. specular map
                // 3. normal map
                // 4. bump map
                // 5. alpha map
                // 6. emissive map
                var uvScaleMap;
                if (material.map) uvScaleMap = material.map;
                else if (material.specularMap) uvScaleMap = material.specularMap;
                else if (material.displacementMap) uvScaleMap = material.displacementMap;
                else if (material.normalMap) uvScaleMap = material.normalMap;
                else if (material.bumpMap) uvScaleMap = material.bumpMap;
                else if (material.glossinessMap) uvScaleMap = material.glossinessMap;
                else if (material.alphaMap) uvScaleMap = material.alphaMap;
                else if (material.emissiveMap) uvScaleMap = material.emissiveMap;
                if (uvScaleMap !== undefined) {
                    // backwards compatibility
                    if (uvScaleMap.isWebGLRenderTarget) uvScaleMap = uvScaleMap.texture;
                    if (uvScaleMap.matrixAutoUpdate === true) uvScaleMap.updateMatrix();
                    uniforms.uvTransform.value.copy(uvScaleMap.matrix);
                }
                if (material.envMap) {
                    uniforms.envMap.value = material.envMap;
                    uniforms.envMapIntensity.value = material.envMapIntensity;
                    // don't flip CubeTexture envMaps, flip everything else:
                    //  WebGLRenderTargetCube will be flipped for backwards compatibility
                    //  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture
                    // this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future
                    uniforms.flipEnvMap.value = material.envMap.isCubeTexture ? -1 : 1;
                    uniforms.reflectivity.value = material.reflectivity;
                    uniforms.refractionRatio.value = material.refractionRatio;
                    uniforms.maxMipLevel.value = renderer.properties.get(material.envMap).__maxMipLevel;
                }
                uniforms.specular.value.copy(material.specular);
                uniforms.glossiness.value = material.glossiness;
                uniforms.glossinessMap.value = material.glossinessMap;
                uniforms.emissiveMap.value = material.emissiveMap;
                uniforms.bumpMap.value = material.bumpMap;
                uniforms.normalMap.value = material.normalMap;
                uniforms.displacementMap.value = material.displacementMap;
                uniforms.displacementScale.value = material.displacementScale;
                uniforms.displacementBias.value = material.displacementBias;
                if (uniforms.glossinessMap.value !== null && defines.USE_GLOSSINESSMAP === undefined) {
                    defines.USE_GLOSSINESSMAP = "";
                    // set USE_ROUGHNESSMAP to enable vUv
                    defines.USE_ROUGHNESSMAP = "";
                }
                if (uniforms.glossinessMap.value === null && defines.USE_GLOSSINESSMAP !== undefined) {
                    delete defines.USE_GLOSSINESSMAP;
                    delete defines.USE_ROUGHNESSMAP;
                }
            }
        };
    }
    /*********************************/ /********** INTERPOLATION ********/ /*********************************/ // Spline Interpolation
    // Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation
    function GLTFCubicSplineInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
        THREE.Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
    }
    GLTFCubicSplineInterpolant.prototype = Object.create(THREE.Interpolant.prototype);
    GLTFCubicSplineInterpolant.prototype.constructor = GLTFCubicSplineInterpolant;
    GLTFCubicSplineInterpolant.prototype.copySampleValue_ = function(index) {
        // Copies a sample value to the result buffer. See description of glTF
        // CUBICSPLINE values layout in interpolate_() function below.
        var result = this.resultBuffer, values = this.sampleValues, valueSize = this.valueSize, offset = index * valueSize * 3 + valueSize;
        for(var i = 0; i !== valueSize; i++)result[i] = values[offset + i];
        return result;
    };
    GLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;
    GLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;
    GLTFCubicSplineInterpolant.prototype.interpolate_ = function(i1, t0, t, t1) {
        var result = this.resultBuffer;
        var values = this.sampleValues;
        var stride = this.valueSize;
        var stride2 = stride * 2;
        var stride3 = stride * 3;
        var td = t1 - t0;
        var p = (t - t0) / td;
        var pp = p * p;
        var ppp = pp * p;
        var offset1 = i1 * stride3;
        var offset0 = offset1 - stride3;
        var s2 = -2 * ppp + 3 * pp;
        var s3 = ppp - pp;
        var s0 = 1 - s2;
        var s1 = s3 - pp + p;
        // Layout of keyframe output values for CUBICSPLINE animations:
        //   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]
        for(var i = 0; i !== stride; i++){
            var p0 = values[offset0 + i + stride]; // splineVertex_k
            var m0 = values[offset0 + i + stride2] * td; // outTangent_k * (t_k+1 - t_k)
            var p1 = values[offset1 + i + stride]; // splineVertex_k+1
            var m1 = values[offset1 + i] * td; // inTangent_k+1 * (t_k+1 - t_k)
            result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;
        }
        return result;
    };
    /*********************************/ /********** INTERNALS ************/ /*********************************/ /* CONSTANTS */ var WEBGL_CONSTANTS = {
        FLOAT: 5126,
        //FLOAT_MAT2: 35674,
        FLOAT_MAT3: 35675,
        FLOAT_MAT4: 35676,
        FLOAT_VEC2: 35664,
        FLOAT_VEC3: 35665,
        FLOAT_VEC4: 35666,
        LINEAR: 9729,
        REPEAT: 10497,
        SAMPLER_2D: 35678,
        POINTS: 0,
        LINES: 1,
        LINE_LOOP: 2,
        LINE_STRIP: 3,
        TRIANGLES: 4,
        TRIANGLE_STRIP: 5,
        TRIANGLE_FAN: 6,
        UNSIGNED_BYTE: 5121,
        UNSIGNED_SHORT: 5123
    };
    var WEBGL_TYPE = {
        5126: Number,
        //35674: THREE.Matrix2,
        35675: THREE.Matrix3,
        35676: THREE.Matrix4,
        35664: THREE.Vector2,
        35665: THREE.Vector3,
        35666: THREE.Vector4,
        35678: THREE.Texture
    };
    var WEBGL_COMPONENT_TYPES = {
        5120: Int8Array,
        5121: Uint8Array,
        5122: Int16Array,
        5123: Uint16Array,
        5125: Uint32Array,
        5126: Float32Array
    };
    var WEBGL_FILTERS = {
        9728: THREE.NearestFilter,
        9729: THREE.LinearFilter,
        9984: THREE.NearestMipMapNearestFilter,
        9985: THREE.LinearMipMapNearestFilter,
        9986: THREE.NearestMipMapLinearFilter,
        9987: THREE.LinearMipMapLinearFilter
    };
    var WEBGL_WRAPPINGS = {
        33071: THREE.ClampToEdgeWrapping,
        33648: THREE.MirroredRepeatWrapping,
        10497: THREE.RepeatWrapping
    };
    var WEBGL_SIDES = {
        1028: THREE.BackSide,
        1029: THREE.FrontSide // Culling back
    };
    var WEBGL_DEPTH_FUNCS = {
        512: THREE.NeverDepth,
        513: THREE.LessDepth,
        514: THREE.EqualDepth,
        515: THREE.LessEqualDepth,
        516: THREE.GreaterEqualDepth,
        517: THREE.NotEqualDepth,
        518: THREE.GreaterEqualDepth,
        519: THREE.AlwaysDepth
    };
    var WEBGL_BLEND_EQUATIONS = {
        32774: THREE.AddEquation,
        32778: THREE.SubtractEquation,
        32779: THREE.ReverseSubtractEquation
    };
    var WEBGL_BLEND_FUNCS = {
        0: THREE.ZeroFactor,
        1: THREE.OneFactor,
        768: THREE.SrcColorFactor,
        769: THREE.OneMinusSrcColorFactor,
        770: THREE.SrcAlphaFactor,
        771: THREE.OneMinusSrcAlphaFactor,
        772: THREE.DstAlphaFactor,
        773: THREE.OneMinusDstAlphaFactor,
        774: THREE.DstColorFactor,
        775: THREE.OneMinusDstColorFactor,
        776: THREE.SrcAlphaSaturateFactor
    };
    var WEBGL_TYPE_SIZES = {
        "SCALAR": 1,
        "VEC2": 2,
        "VEC3": 3,
        "VEC4": 4,
        "MAT2": 4,
        "MAT3": 9,
        "MAT4": 16
    };
    var ATTRIBUTES = {
        POSITION: "position",
        NORMAL: "normal",
        TEXCOORD_0: "uv",
        TEXCOORD_1: "uv2",
        COLOR_0: "color",
        WEIGHTS_0: "skinWeight",
        JOINTS_0: "skinIndex"
    };
    var PATH_PROPERTIES = {
        scale: "scale",
        translation: "position",
        rotation: "quaternion",
        weights: "morphTargetInfluences"
    };
    var INTERPOLATION = {
        CUBICSPLINE: THREE.InterpolateSmooth,
        // KeyframeTrack.optimize() can't handle glTF Cubic Spline output values layout,
        // using THREE.InterpolateSmooth for KeyframeTrack instantiation to prevent optimization.
        // See KeyframeTrack.optimize() for the detail.
        LINEAR: THREE.InterpolateLinear,
        STEP: THREE.InterpolateDiscrete
    };
    var STATES_ENABLES = {
        2884: "CULL_FACE",
        2929: "DEPTH_TEST",
        3042: "BLEND",
        3089: "SCISSOR_TEST",
        32823: "POLYGON_OFFSET_FILL",
        32926: "SAMPLE_ALPHA_TO_COVERAGE"
    };
    var ALPHA_MODES = {
        OPAQUE: "OPAQUE",
        MASK: "MASK",
        BLEND: "BLEND"
    };
    var MIME_TYPE_FORMATS = {
        "image/png": THREE.RGBAFormat,
        "image/jpeg": THREE.RGBFormat
    };
    /* UTILITY FUNCTIONS */ function resolveURL(url, path) {
        // Invalid URL
        if (typeof url !== "string" || url === "") return "";
        // Absolute URL http://,https://,//
        if (/^(https?:)?\/\//i.test(url)) return url;
        // Data URI
        if (/^data:.*,.*$/i.test(url)) return url;
        // Blob URL
        if (/^blob:.*$/i.test(url)) return url;
        // Relative URL
        return path + url;
    }
    /**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material
	 */ function createDefaultMaterial() {
        return new THREE.MeshStandardMaterial({
            color: 0xFFFFFF,
            emissive: 0x000000,
            metalness: 1,
            roughness: 1,
            transparent: false,
            depthTest: true,
            side: THREE.FrontSide
        });
    }
    function addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {
        // Add unknown glTF extensions to an object's userData.
        for(var name in objectDef.extensions)if (knownExtensions[name] === undefined) {
            object.userData.gltfExtensions = object.userData.gltfExtensions || {};
            object.userData.gltfExtensions[name] = objectDef.extensions[name];
        }
    }
    /**
	 * @param {THREE.Object3D|THREE.Material|THREE.BufferGeometry} object
	 * @param {GLTF.definition} gltfDef
	 */ function assignExtrasToUserData(object, gltfDef) {
        if (gltfDef.extras !== undefined) {
            if (typeof gltfDef.extras === "object") object.userData = gltfDef.extras;
            else console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + gltfDef.extras);
        }
    }
    /**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets
	 *
	 * @param {THREE.BufferGeometry} geometry
	 * @param {Array<GLTF.Target>} targets
	 * @param {GLTFParser} parser
	 * @return {Promise<THREE.BufferGeometry>}
	 */ function addMorphTargets(geometry, targets, parser) {
        var hasMorphPosition = false;
        var hasMorphNormal = false;
        for(var i = 0, il = targets.length; i < il; i++){
            var target = targets[i];
            if (target.POSITION !== undefined) hasMorphPosition = true;
            if (target.NORMAL !== undefined) hasMorphNormal = true;
            if (hasMorphPosition && hasMorphNormal) break;
        }
        if (!hasMorphPosition && !hasMorphNormal) return Promise.resolve(geometry);
        var pendingPositionAccessors = [];
        var pendingNormalAccessors = [];
        for(var i = 0, il = targets.length; i < il; i++){
            var target = targets[i];
            if (hasMorphPosition) {
                // TODO: Error-prone use of a callback inside a loop.
                var accessor = target.POSITION !== undefined ? parser.getDependency("accessor", target.POSITION).then(function(accessor) {
                    // Cloning not to pollute original accessor below
                    return cloneBufferAttribute(accessor);
                }) : geometry.attributes.position;
                pendingPositionAccessors.push(accessor);
            }
            if (hasMorphNormal) {
                // TODO: Error-prone use of a callback inside a loop.
                var accessor = target.NORMAL !== undefined ? parser.getDependency("accessor", target.NORMAL).then(function(accessor) {
                    return cloneBufferAttribute(accessor);
                }) : geometry.attributes.normal;
                pendingNormalAccessors.push(accessor);
            }
        }
        return Promise.all([
            Promise.all(pendingPositionAccessors),
            Promise.all(pendingNormalAccessors)
        ]).then(function(accessors) {
            var morphPositions = accessors[0];
            var morphNormals = accessors[1];
            for(var i = 0, il = targets.length; i < il; i++){
                var target = targets[i];
                var attributeName = "morphTarget" + i;
                if (hasMorphPosition) // Three.js morph position is absolute value. The formula is
                //   basePosition
                //     + weight0 * ( morphPosition0 - basePosition )
                //     + weight1 * ( morphPosition1 - basePosition )
                //     ...
                // while the glTF one is relative
                //   basePosition
                //     + weight0 * glTFmorphPosition0
                //     + weight1 * glTFmorphPosition1
                //     ...
                // then we need to convert from relative to absolute here.
                {
                    if (target.POSITION !== undefined) {
                        var positionAttribute = morphPositions[i];
                        positionAttribute.name = attributeName;
                        var position = geometry.attributes.position;
                        for(var j = 0, jl = positionAttribute.count; j < jl; j++)positionAttribute.setXYZ(j, positionAttribute.getX(j) + position.getX(j), positionAttribute.getY(j) + position.getY(j), positionAttribute.getZ(j) + position.getZ(j));
                    }
                }
                if (hasMorphNormal) // see target.POSITION's comment
                {
                    if (target.NORMAL !== undefined) {
                        var normalAttribute = morphNormals[i];
                        normalAttribute.name = attributeName;
                        var normal = geometry.attributes.normal;
                        for(var j = 0, jl = normalAttribute.count; j < jl; j++)normalAttribute.setXYZ(j, normalAttribute.getX(j) + normal.getX(j), normalAttribute.getY(j) + normal.getY(j), normalAttribute.getZ(j) + normal.getZ(j));
                    }
                }
            }
            if (hasMorphPosition) geometry.morphAttributes.position = morphPositions;
            if (hasMorphNormal) geometry.morphAttributes.normal = morphNormals;
            return geometry;
        });
    }
    /**
	 * @param {THREE.Mesh} mesh
	 * @param {GLTF.Mesh} meshDef
	 */ function updateMorphTargets(mesh, meshDef) {
        mesh.updateMorphTargets();
        if (meshDef.weights !== undefined) for(var i = 0, il = meshDef.weights.length; i < il; i++)mesh.morphTargetInfluences[i] = meshDef.weights[i];
        // .extras has user-defined data, so check that .extras.targetNames is an array.
        if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {
            var targetNames = meshDef.extras.targetNames;
            if (mesh.morphTargetInfluences.length === targetNames.length) {
                mesh.morphTargetDictionary = {};
                for(var i = 0, il = targetNames.length; i < il; i++)mesh.morphTargetDictionary[targetNames[i]] = i;
            } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
        }
    }
    function isPrimitiveEqual(a, b) {
        var dracoExtA = a.extensions ? a.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION] : undefined;
        var dracoExtB = b.extensions ? b.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION] : undefined;
        if (dracoExtA && dracoExtB) {
            if (dracoExtA.bufferView !== dracoExtB.bufferView) return false;
            return isObjectEqual(dracoExtA.attributes, dracoExtB.attributes);
        }
        if (a.indices !== b.indices) return false;
        return isObjectEqual(a.attributes, b.attributes);
    }
    function isObjectEqual(a, b) {
        if (Object.keys(a).length !== Object.keys(b).length) return false;
        for(var key in a){
            if (a[key] !== b[key]) return false;
        }
        return true;
    }
    function isArrayEqual(a, b) {
        if (a.length !== b.length) return false;
        for(var i = 0, il = a.length; i < il; i++){
            if (a[i] !== b[i]) return false;
        }
        return true;
    }
    function getCachedGeometry(cache, newPrimitive) {
        for(var i = 0, il = cache.length; i < il; i++){
            var cached = cache[i];
            if (isPrimitiveEqual(cached.primitive, newPrimitive)) return cached.promise;
        }
        return null;
    }
    function getCachedCombinedGeometry(cache, geometries) {
        for(var i = 0, il = cache.length; i < il; i++){
            var cached = cache[i];
            if (isArrayEqual(geometries, cached.baseGeometries)) return cached.geometry;
        }
        return null;
    }
    function getCachedMultiPassGeometry(cache, geometry, primitives) {
        for(var i = 0, il = cache.length; i < il; i++){
            var cached = cache[i];
            if (geometry === cached.baseGeometry && isArrayEqual(primitives, cached.primitives)) return cached.geometry;
        }
        return null;
    }
    function cloneBufferAttribute(attribute) {
        if (attribute.isInterleavedBufferAttribute) {
            var count = attribute.count;
            var itemSize = attribute.itemSize;
            var array = attribute.array.slice(0, count * itemSize);
            for(var i = 0, j = 0; i < count; ++i){
                array[j++] = attribute.getX(i);
                if (itemSize >= 2) array[j++] = attribute.getY(i);
                if (itemSize >= 3) array[j++] = attribute.getZ(i);
                if (itemSize >= 4) array[j++] = attribute.getW(i);
            }
            return new THREE.BufferAttribute(array, itemSize, attribute.normalized);
        }
        return attribute.clone();
    }
    /**
	 * Checks if we can build a single Mesh with MultiMaterial from multiple primitives.
	 * Returns true if all primitives use the same attributes/morphAttributes/mode
	 * and also have index. Otherwise returns false.
	 *
	 * @param {Array<GLTF.Primitive>} primitives
	 * @return {Boolean}
	 */ function isMultiPassGeometry(primitives) {
        if (primitives.length < 2) return false;
        var primitive0 = primitives[0];
        var targets0 = primitive0.targets || [];
        if (primitive0.indices === undefined) return false;
        for(var i = 1, il = primitives.length; i < il; i++){
            var primitive = primitives[i];
            if (primitive0.mode !== primitive.mode) return false;
            if (primitive.indices === undefined) return false;
            if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) return false;
            if (!isObjectEqual(primitive0.attributes, primitive.attributes)) return false;
            var targets = primitive.targets || [];
            if (targets0.length !== targets.length) return false;
            for(var j = 0, jl = targets0.length; j < jl; j++){
                if (!isObjectEqual(targets0[j], targets[j])) return false;
            }
        }
        return true;
    }
    /* GLTF PARSER */ function GLTFParser(json, extensions, options) {
        this.json = json || {};
        this.extensions = extensions || {};
        this.options = options || {};
        // loader object cache
        this.cache = new GLTFRegistry();
        // BufferGeometry caching
        this.primitiveCache = [];
        this.multiplePrimitivesCache = [];
        this.multiPassGeometryCache = [];
        this.textureLoader = new THREE.TextureLoader(this.options.manager);
        this.textureLoader.setCrossOrigin(this.options.crossOrigin);
        this.fileLoader = new THREE.FileLoader(this.options.manager);
        this.fileLoader.setResponseType("arraybuffer");
    }
    GLTFParser.prototype.parse = function(onLoad, onError) {
        var json = this.json;
        // Clear the loader cache
        this.cache.removeAll();
        // Mark the special nodes/meshes in json for efficient parse
        this.markDefs();
        // Fire the callback on complete
        this.getMultiDependencies([
            "scene",
            "animation",
            "camera"
        ]).then(function(dependencies) {
            var scenes = dependencies.scenes || [];
            var scene = scenes[json.scene || 0];
            var animations = dependencies.animations || [];
            var cameras = dependencies.cameras || [];
            onLoad(scene, scenes, cameras, animations, json);
        }).catch(onError);
    };
    /**
	 * Marks the special nodes/meshes in json for efficient parse.
	 */ GLTFParser.prototype.markDefs = function() {
        var nodeDefs = this.json.nodes || [];
        var skinDefs = this.json.skins || [];
        var meshDefs = this.json.meshes || [];
        var meshReferences = {};
        var meshUses = {};
        // Nothing in the node definition indicates whether it is a Bone or an
        // Object3D. Use the skins' joint references to mark bones.
        for(var skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++){
            var joints = skinDefs[skinIndex].joints;
            for(var i = 0, il = joints.length; i < il; i++)nodeDefs[joints[i]].isBone = true;
        }
        // Meshes can (and should) be reused by multiple nodes in a glTF asset. To
        // avoid having more than one THREE.Mesh with the same name, count
        // references and rename instances below.
        //
        // Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
        for(var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++){
            var nodeDef = nodeDefs[nodeIndex];
            if (nodeDef.mesh !== undefined) {
                if (meshReferences[nodeDef.mesh] === undefined) meshReferences[nodeDef.mesh] = meshUses[nodeDef.mesh] = 0;
                meshReferences[nodeDef.mesh]++;
                // Nothing in the mesh definition indicates whether it is
                // a SkinnedMesh or Mesh. Use the node's mesh reference
                // to mark SkinnedMesh if node has skin.
                if (nodeDef.skin !== undefined) meshDefs[nodeDef.mesh].isSkinnedMesh = true;
            }
        }
        this.json.meshReferences = meshReferences;
        this.json.meshUses = meshUses;
    };
    /**
	 * Requests the specified dependency asynchronously, with caching.
	 * @param {string} type
	 * @param {number} index
	 * @return {Promise<THREE.Object3D|THREE.Material|THREE.Texture|THREE.AnimationClip|ArrayBuffer|Object>}
	 */ GLTFParser.prototype.getDependency = function(type, index) {
        var cacheKey = type + ":" + index;
        var dependency = this.cache.get(cacheKey);
        if (!dependency) {
            switch(type){
                case "scene":
                    dependency = this.loadScene(index);
                    break;
                case "node":
                    dependency = this.loadNode(index);
                    break;
                case "mesh":
                    dependency = this.loadMesh(index);
                    break;
                case "accessor":
                    dependency = this.loadAccessor(index);
                    break;
                case "bufferView":
                    dependency = this.loadBufferView(index);
                    break;
                case "buffer":
                    dependency = this.loadBuffer(index);
                    break;
                case "material":
                    dependency = this.loadMaterial(index);
                    break;
                case "texture":
                    dependency = this.loadTexture(index);
                    break;
                case "skin":
                    dependency = this.loadSkin(index);
                    break;
                case "animation":
                    dependency = this.loadAnimation(index);
                    break;
                case "camera":
                    dependency = this.loadCamera(index);
                    break;
                case "light":
                    dependency = this.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL].loadLight(index);
                    break;
                default:
                    throw new Error("Unknown type: " + type);
            }
            this.cache.add(cacheKey, dependency);
        }
        return dependency;
    };
    /**
	 * Requests all dependencies of the specified type asynchronously, with caching.
	 * @param {string} type
	 * @return {Promise<Array<Object>>}
	 */ GLTFParser.prototype.getDependencies = function(type) {
        var dependencies = this.cache.get(type);
        if (!dependencies) {
            var parser = this;
            var defs = this.json[type + (type === "mesh" ? "es" : "s")] || [];
            dependencies = Promise.all(defs.map(function(def, index) {
                return parser.getDependency(type, index);
            }));
            this.cache.add(type, dependencies);
        }
        return dependencies;
    };
    /**
	 * Requests all multiple dependencies of the specified types asynchronously, with caching.
	 * @param {Array<string>} types
	 * @return {Promise<Object<Array<Object>>>}
	 */ GLTFParser.prototype.getMultiDependencies = function(types) {
        var results = {};
        var pending = [];
        for(var i = 0, il = types.length; i < il; i++){
            var type = types[i];
            var value = this.getDependencies(type);
            // TODO: Error-prone use of a callback inside a loop.
            value = value.then((function(key, value) {
                results[key] = value;
            }).bind(this, type + (type === "mesh" ? "es" : "s")));
            pending.push(value);
        }
        return Promise.all(pending).then(function() {
            return results;
        });
    };
    /**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
	 * @param {number} bufferIndex
	 * @return {Promise<ArrayBuffer>}
	 */ GLTFParser.prototype.loadBuffer = function(bufferIndex) {
        var bufferDef = this.json.buffers[bufferIndex];
        var loader = this.fileLoader;
        if (bufferDef.type && bufferDef.type !== "arraybuffer") throw new Error("THREE.GLTFLoader: " + bufferDef.type + " buffer type is not supported.");
        // If present, GLB container is required to be the first buffer.
        if (bufferDef.uri === undefined && bufferIndex === 0) return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);
        var options = this.options;
        return new Promise(function(resolve, reject) {
            loader.load(resolveURL(bufferDef.uri, options.path), resolve, undefined, function() {
                reject(new Error('THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".'));
            });
        });
    };
    /**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
	 * @param {number} bufferViewIndex
	 * @return {Promise<ArrayBuffer>}
	 */ GLTFParser.prototype.loadBufferView = function(bufferViewIndex) {
        var bufferViewDef = this.json.bufferViews[bufferViewIndex];
        return this.getDependency("buffer", bufferViewDef.buffer).then(function(buffer) {
            var byteLength = bufferViewDef.byteLength || 0;
            var byteOffset = bufferViewDef.byteOffset || 0;
            return buffer.slice(byteOffset, byteOffset + byteLength);
        });
    };
    /**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
	 * @param {number} accessorIndex
	 * @return {Promise<THREE.BufferAttribute|THREE.InterleavedBufferAttribute>}
	 */ GLTFParser.prototype.loadAccessor = function(accessorIndex) {
        var parser = this;
        var json = this.json;
        var accessorDef = this.json.accessors[accessorIndex];
        if (accessorDef.bufferView === undefined && accessorDef.sparse === undefined) // Ignore empty accessors, which may be used to declare runtime
        // information about attributes coming from another source (e.g. Draco
        // compression extension).
        return Promise.resolve(null);
        var pendingBufferViews = [];
        if (accessorDef.bufferView !== undefined) pendingBufferViews.push(this.getDependency("bufferView", accessorDef.bufferView));
        else pendingBufferViews.push(null);
        if (accessorDef.sparse !== undefined) {
            pendingBufferViews.push(this.getDependency("bufferView", accessorDef.sparse.indices.bufferView));
            pendingBufferViews.push(this.getDependency("bufferView", accessorDef.sparse.values.bufferView));
        }
        return Promise.all(pendingBufferViews).then(function(bufferViews) {
            var bufferView = bufferViews[0];
            var itemSize = WEBGL_TYPE_SIZES[accessorDef.type];
            var TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
            // For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.
            var elementBytes = TypedArray.BYTES_PER_ELEMENT;
            var itemBytes = elementBytes * itemSize;
            var byteOffset = accessorDef.byteOffset || 0;
            var byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[accessorDef.bufferView].byteStride : undefined;
            var normalized = accessorDef.normalized === true;
            var array, bufferAttribute;
            // The buffer is not interleaved if the stride is the item size in bytes.
            if (byteStride && byteStride !== itemBytes) {
                var ibCacheKey = "InterleavedBuffer:" + accessorDef.bufferView + ":" + accessorDef.componentType;
                var ib = parser.cache.get(ibCacheKey);
                if (!ib) {
                    // Use the full buffer if it's interleaved.
                    array = new TypedArray(bufferView);
                    // Integer parameters to IB/IBA are in array elements, not bytes.
                    ib = new THREE.InterleavedBuffer(array, byteStride / elementBytes);
                    parser.cache.add(ibCacheKey, ib);
                }
                bufferAttribute = new THREE.InterleavedBufferAttribute(ib, itemSize, byteOffset / elementBytes, normalized);
            } else {
                if (bufferView === null) array = new TypedArray(accessorDef.count * itemSize);
                else array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);
                bufferAttribute = new THREE.BufferAttribute(array, itemSize, normalized);
            }
            // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors
            if (accessorDef.sparse !== undefined) {
                var itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;
                var TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];
                var byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
                var byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;
                var sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);
                var sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);
                if (bufferView !== null) // Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.
                bufferAttribute.setArray(bufferAttribute.array.slice());
                for(var i = 0, il = sparseIndices.length; i < il; i++){
                    var index = sparseIndices[i];
                    bufferAttribute.setX(index, sparseValues[i * itemSize]);
                    if (itemSize >= 2) bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);
                    if (itemSize >= 3) bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);
                    if (itemSize >= 4) bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);
                    if (itemSize >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
                }
            }
            return bufferAttribute;
        });
    };
    /**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
	 * @param {number} textureIndex
	 * @return {Promise<THREE.Texture>}
	 */ GLTFParser.prototype.loadTexture = function(textureIndex) {
        var parser = this;
        var json = this.json;
        var options = this.options;
        var textureLoader = this.textureLoader;
        var URL = window.URL || window.webkitURL;
        var textureDef = json.textures[textureIndex];
        var textureExtensions = textureDef.extensions || {};
        var source;
        if (textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS]) source = json.images[textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS].source];
        else source = json.images[textureDef.source];
        var sourceURI = source.uri;
        var isObjectURL = false;
        if (source.bufferView !== undefined) // Load binary image data from bufferView, if provided.
        sourceURI = parser.getDependency("bufferView", source.bufferView).then(function(bufferView) {
            isObjectURL = true;
            var blob = new Blob([
                bufferView
            ], {
                type: source.mimeType
            });
            sourceURI = URL.createObjectURL(blob);
            return sourceURI;
        });
        return Promise.resolve(sourceURI).then(function(sourceURI) {
            // Load Texture resource.
            var loader = THREE.Loader.Handlers.get(sourceURI);
            if (!loader) loader = textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS] ? parser.extensions[EXTENSIONS.MSFT_TEXTURE_DDS].ddsLoader : textureLoader;
            return new Promise(function(resolve, reject) {
                loader.load(resolveURL(sourceURI, options.path), resolve, undefined, reject);
            });
        }).then(function(texture) {
            // Clean up resources and configure Texture.
            if (isObjectURL === true) URL.revokeObjectURL(sourceURI);
            texture.flipY = false;
            if (textureDef.name !== undefined) texture.name = textureDef.name;
            // Ignore unknown mime types, like DDS files.
            if (source.mimeType in MIME_TYPE_FORMATS) texture.format = MIME_TYPE_FORMATS[source.mimeType];
            var samplers = json.samplers || {};
            var sampler = samplers[textureDef.sampler] || {};
            texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || THREE.LinearFilter;
            texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || THREE.LinearMipMapLinearFilter;
            texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || THREE.RepeatWrapping;
            texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || THREE.RepeatWrapping;
            return texture;
        });
    };
    /**
	 * Asynchronously assigns a texture to the given material parameters.
	 * @param {Object} materialParams
	 * @param {string} mapName
	 * @param {Object} mapDef
	 * @return {Promise}
	 */ GLTFParser.prototype.assignTexture = function(materialParams, mapName, mapDef) {
        var parser = this;
        return this.getDependency("texture", mapDef.index).then(function(texture) {
            if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {
                var transform = mapDef.extensions !== undefined ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : undefined;
                if (transform) texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);
            }
            materialParams[mapName] = texture;
        });
    };
    /**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
	 * @param {number} materialIndex
	 * @return {Promise<THREE.Material>}
	 */ GLTFParser.prototype.loadMaterial = function(materialIndex) {
        var parser = this;
        var json = this.json;
        var extensions = this.extensions;
        var materialDef = json.materials[materialIndex];
        var materialType;
        var materialParams = {};
        var materialExtensions = materialDef.extensions || {};
        var pending = [];
        if (materialExtensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
            var sgExtension = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
            materialType = sgExtension.getMaterialType(materialDef);
            pending.push(sgExtension.extendParams(materialParams, materialDef, parser));
        } else if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {
            var kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];
            materialType = kmuExtension.getMaterialType(materialDef);
            pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));
        } else {
            // Specification:
            // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material
            materialType = THREE.MeshStandardMaterial;
            var metallicRoughness = materialDef.pbrMetallicRoughness || {};
            materialParams.color = new THREE.Color(1.0, 1.0, 1.0);
            materialParams.opacity = 1.0;
            if (Array.isArray(metallicRoughness.baseColorFactor)) {
                var array = metallicRoughness.baseColorFactor;
                materialParams.color.fromArray(array);
                materialParams.opacity = array[3];
            }
            if (metallicRoughness.baseColorTexture !== undefined) pending.push(parser.assignTexture(materialParams, "map", metallicRoughness.baseColorTexture));
            materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;
            materialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;
            if (metallicRoughness.metallicRoughnessTexture !== undefined) {
                pending.push(parser.assignTexture(materialParams, "metalnessMap", metallicRoughness.metallicRoughnessTexture));
                pending.push(parser.assignTexture(materialParams, "roughnessMap", metallicRoughness.metallicRoughnessTexture));
            }
        }
        if (materialDef.doubleSided === true) materialParams.side = THREE.DoubleSide;
        var alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;
        if (alphaMode === ALPHA_MODES.BLEND) materialParams.transparent = true;
        else {
            materialParams.transparent = false;
            if (alphaMode === ALPHA_MODES.MASK) materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;
        }
        if (materialDef.normalTexture !== undefined && materialType !== THREE.MeshBasicMaterial) {
            pending.push(parser.assignTexture(materialParams, "normalMap", materialDef.normalTexture));
            materialParams.normalScale = new THREE.Vector2(1, 1);
            if (materialDef.normalTexture.scale !== undefined) materialParams.normalScale.set(materialDef.normalTexture.scale, materialDef.normalTexture.scale);
        }
        if (materialDef.occlusionTexture !== undefined && materialType !== THREE.MeshBasicMaterial) {
            pending.push(parser.assignTexture(materialParams, "aoMap", materialDef.occlusionTexture));
            if (materialDef.occlusionTexture.strength !== undefined) materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;
        }
        if (materialDef.emissiveFactor !== undefined && materialType !== THREE.MeshBasicMaterial) materialParams.emissive = new THREE.Color().fromArray(materialDef.emissiveFactor);
        if (materialDef.emissiveTexture !== undefined && materialType !== THREE.MeshBasicMaterial) pending.push(parser.assignTexture(materialParams, "emissiveMap", materialDef.emissiveTexture));
        return Promise.all(pending).then(function() {
            var material;
            if (materialType === THREE.ShaderMaterial) material = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(materialParams);
            else material = new materialType(materialParams);
            if (materialDef.name !== undefined) material.name = materialDef.name;
            // Normal map textures use OpenGL conventions:
            // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#materialnormaltexture
            if (material.normalScale) material.normalScale.y = -material.normalScale.y;
            // baseColorTexture, emissiveTexture, and specularGlossinessTexture use sRGB encoding.
            if (material.map) material.map.encoding = THREE.sRGBEncoding;
            if (material.emissiveMap) material.emissiveMap.encoding = THREE.sRGBEncoding;
            if (material.specularMap) material.specularMap.encoding = THREE.sRGBEncoding;
            assignExtrasToUserData(material, materialDef);
            if (materialDef.extensions) addUnknownExtensionsToUserData(extensions, material, materialDef);
            return material;
        });
    };
    /**
	 * @param {THREE.BufferGeometry} geometry
	 * @param {GLTF.Primitive} primitiveDef
	 * @param {GLTFParser} parser
	 * @return {Promise<THREE.BufferGeometry>}
	 */ function addPrimitiveAttributes(geometry, primitiveDef, parser) {
        var attributes = primitiveDef.attributes;
        var pending = [];
        function assignAttributeAccessor(accessorIndex, attributeName) {
            return parser.getDependency("accessor", accessorIndex).then(function(accessor) {
                geometry.addAttribute(attributeName, accessor);
            });
        }
        for(var gltfAttributeName in attributes){
            var threeAttributeName = ATTRIBUTES[gltfAttributeName];
            if (!threeAttributeName) continue;
            // Skip attributes already provided by e.g. Draco extension.
            if (threeAttributeName in geometry.attributes) continue;
            pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));
        }
        if (primitiveDef.indices !== undefined && !geometry.index) {
            var accessor = parser.getDependency("accessor", primitiveDef.indices).then(function(accessor) {
                geometry.setIndex(accessor);
            });
            pending.push(accessor);
        }
        assignExtrasToUserData(geometry, primitiveDef);
        return Promise.all(pending).then(function() {
            return primitiveDef.targets !== undefined ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;
        });
    }
    /**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
	 *
	 * Creates BufferGeometries from primitives.
	 * If we can build a single BufferGeometry with .groups from multiple primitives, returns one BufferGeometry.
	 * Otherwise, returns BufferGeometries without .groups as many as primitives.
	 *
	 * @param {Array<GLTF.Primitive>} primitives
	 * @return {Promise<Array<THREE.BufferGeometry>>}
	 */ GLTFParser.prototype.loadGeometries = function(primitives) {
        var parser = this;
        var extensions = this.extensions;
        var cache = this.primitiveCache;
        var isMultiPass = isMultiPassGeometry(primitives);
        var originalPrimitives;
        if (isMultiPass) {
            originalPrimitives = primitives; // save original primitives and use later
            // We build a single BufferGeometry with .groups from multiple primitives
            // because all primitives share the same attributes/morph/mode and have indices.
            primitives = [
                primitives[0]
            ];
        // Sets .groups and combined indices to a geometry later in this method.
        }
        function createDracoPrimitive(primitive) {
            return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function(geometry) {
                return addPrimitiveAttributes(geometry, primitive, parser);
            });
        }
        var pending = [];
        for(var i = 0, il = primitives.length; i < il; i++){
            var primitive = primitives[i];
            // See if we've already created this geometry
            var cached = getCachedGeometry(cache, primitive);
            if (cached) // Use the cached geometry if it exists
            pending.push(cached);
            else {
                var geometryPromise;
                if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) // Use DRACO geometry if available
                geometryPromise = createDracoPrimitive(primitive);
                else // Otherwise create a new geometry
                geometryPromise = addPrimitiveAttributes(new THREE.BufferGeometry(), primitive, parser);
                // Cache this geometry
                cache.push({
                    primitive: primitive,
                    promise: geometryPromise
                });
                pending.push(geometryPromise);
            }
        }
        return Promise.all(pending).then(function(geometries) {
            if (isMultiPass) {
                var baseGeometry = geometries[0];
                // See if we've already created this combined geometry
                var cache = parser.multiPassGeometryCache;
                var cached = getCachedMultiPassGeometry(cache, baseGeometry, originalPrimitives);
                if (cached !== null) return [
                    cached.geometry
                ];
                // Cloning geometry because of index override.
                // Attributes can be reused so cloning by myself here.
                var geometry = new THREE.BufferGeometry();
                geometry.name = baseGeometry.name;
                geometry.userData = baseGeometry.userData;
                for(var key in baseGeometry.attributes)geometry.addAttribute(key, baseGeometry.attributes[key]);
                for(var key in baseGeometry.morphAttributes)geometry.morphAttributes[key] = baseGeometry.morphAttributes[key];
                var pendingIndices = [];
                for(var i = 0, il = originalPrimitives.length; i < il; i++)pendingIndices.push(parser.getDependency("accessor", originalPrimitives[i].indices));
                return Promise.all(pendingIndices).then(function(accessors) {
                    var indices = [];
                    var offset = 0;
                    for(var i = 0, il = originalPrimitives.length; i < il; i++){
                        var accessor = accessors[i];
                        for(var j = 0, jl = accessor.count; j < jl; j++)indices.push(accessor.array[j]);
                        geometry.addGroup(offset, accessor.count, i);
                        offset += accessor.count;
                    }
                    geometry.setIndex(indices);
                    cache.push({
                        geometry: geometry,
                        baseGeometry: baseGeometry,
                        primitives: originalPrimitives
                    });
                    return [
                        geometry
                    ];
                });
            } else if (geometries.length > 1 && THREE.BufferGeometryUtils !== undefined) {
                // Tries to merge geometries with BufferGeometryUtils if possible
                for(var i = 1, il = primitives.length; i < il; i++){
                    // can't merge if draw mode is different
                    if (primitives[0].mode !== primitives[i].mode) return geometries;
                }
                // See if we've already created this combined geometry
                var cache = parser.multiplePrimitivesCache;
                var cached = getCachedCombinedGeometry(cache, geometries);
                if (cached) {
                    if (cached.geometry !== null) return [
                        cached.geometry
                    ];
                } else {
                    var geometry = THREE.BufferGeometryUtils.mergeBufferGeometries(geometries, true);
                    cache.push({
                        geometry: geometry,
                        baseGeometries: geometries
                    });
                    if (geometry !== null) return [
                        geometry
                    ];
                }
            }
            return geometries;
        });
    };
    /**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
	 * @param {number} meshIndex
	 * @return {Promise<THREE.Group|THREE.Mesh|THREE.SkinnedMesh>}
	 */ GLTFParser.prototype.loadMesh = function(meshIndex) {
        var parser = this;
        var json = this.json;
        var extensions = this.extensions;
        var meshDef = json.meshes[meshIndex];
        var primitives = meshDef.primitives;
        var pending = [];
        for(var i = 0, il = primitives.length; i < il; i++){
            var material = primitives[i].material === undefined ? createDefaultMaterial() : this.getDependency("material", primitives[i].material);
            pending.push(material);
        }
        return Promise.all(pending).then(function(originalMaterials) {
            return parser.loadGeometries(primitives).then(function(geometries) {
                var isMultiMaterial = geometries.length === 1 && geometries[0].groups.length > 0;
                var meshes = [];
                for(var i = 0, il = geometries.length; i < il; i++){
                    var geometry = geometries[i];
                    var primitive = primitives[i];
                    // 1. create Mesh
                    var mesh;
                    var material = isMultiMaterial ? originalMaterials : originalMaterials[i];
                    if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === undefined) {
                        // .isSkinnedMesh isn't in glTF spec. See .markDefs()
                        mesh = meshDef.isSkinnedMesh === true ? new THREE.SkinnedMesh(geometry, material) : new THREE.Mesh(geometry, material);
                        if (mesh.isSkinnedMesh === true) mesh.normalizeSkinWeights(); // #15319
                        if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) mesh.drawMode = THREE.TriangleStripDrawMode;
                        else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) mesh.drawMode = THREE.TriangleFanDrawMode;
                    } else if (primitive.mode === WEBGL_CONSTANTS.LINES) mesh = new THREE.LineSegments(geometry, material);
                    else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) mesh = new THREE.Line(geometry, material);
                    else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) mesh = new THREE.LineLoop(geometry, material);
                    else if (primitive.mode === WEBGL_CONSTANTS.POINTS) mesh = new THREE.Points(geometry, material);
                    else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + primitive.mode);
                    if (Object.keys(mesh.geometry.morphAttributes).length > 0) updateMorphTargets(mesh, meshDef);
                    mesh.name = meshDef.name || "mesh_" + meshIndex;
                    if (geometries.length > 1) mesh.name += "_" + i;
                    assignExtrasToUserData(mesh, meshDef);
                    meshes.push(mesh);
                    // 2. update Material depending on Mesh and BufferGeometry
                    var materials = isMultiMaterial ? mesh.material : [
                        mesh.material
                    ];
                    var useVertexColors = geometry.attributes.color !== undefined;
                    var useFlatShading = geometry.attributes.normal === undefined;
                    var useSkinning = mesh.isSkinnedMesh === true;
                    var useMorphTargets = Object.keys(geometry.morphAttributes).length > 0;
                    var useMorphNormals = useMorphTargets && geometry.morphAttributes.normal !== undefined;
                    for(var j = 0, jl = materials.length; j < jl; j++){
                        var material = materials[j];
                        if (mesh.isPoints) {
                            var cacheKey = "PointsMaterial:" + material.uuid;
                            var pointsMaterial = parser.cache.get(cacheKey);
                            if (!pointsMaterial) {
                                pointsMaterial = new THREE.PointsMaterial();
                                THREE.Material.prototype.copy.call(pointsMaterial, material);
                                pointsMaterial.color.copy(material.color);
                                pointsMaterial.map = material.map;
                                pointsMaterial.lights = false; // PointsMaterial doesn't support lights yet
                                parser.cache.add(cacheKey, pointsMaterial);
                            }
                            material = pointsMaterial;
                        } else if (mesh.isLine) {
                            var cacheKey = "LineBasicMaterial:" + material.uuid;
                            var lineMaterial = parser.cache.get(cacheKey);
                            if (!lineMaterial) {
                                lineMaterial = new THREE.LineBasicMaterial();
                                THREE.Material.prototype.copy.call(lineMaterial, material);
                                lineMaterial.color.copy(material.color);
                                lineMaterial.lights = false; // LineBasicMaterial doesn't support lights yet
                                parser.cache.add(cacheKey, lineMaterial);
                            }
                            material = lineMaterial;
                        }
                        // Clone the material if it will be modified
                        if (useVertexColors || useFlatShading || useSkinning || useMorphTargets) {
                            var cacheKey = "ClonedMaterial:" + material.uuid + ":";
                            if (material.isGLTFSpecularGlossinessMaterial) cacheKey += "specular-glossiness:";
                            if (useSkinning) cacheKey += "skinning:";
                            if (useVertexColors) cacheKey += "vertex-colors:";
                            if (useFlatShading) cacheKey += "flat-shading:";
                            if (useMorphTargets) cacheKey += "morph-targets:";
                            if (useMorphNormals) cacheKey += "morph-normals:";
                            var cachedMaterial = parser.cache.get(cacheKey);
                            if (!cachedMaterial) {
                                cachedMaterial = material.isGLTFSpecularGlossinessMaterial ? extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].cloneMaterial(material) : material.clone();
                                if (useSkinning) cachedMaterial.skinning = true;
                                if (useVertexColors) cachedMaterial.vertexColors = THREE.VertexColors;
                                if (useFlatShading) cachedMaterial.flatShading = true;
                                if (useMorphTargets) cachedMaterial.morphTargets = true;
                                if (useMorphNormals) cachedMaterial.morphNormals = true;
                                parser.cache.add(cacheKey, cachedMaterial);
                            }
                            material = cachedMaterial;
                        }
                        materials[j] = material;
                        // workarounds for mesh and geometry
                        if (material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined) {
                            console.log("THREE.GLTFLoader: Duplicating UVs to support aoMap.");
                            geometry.addAttribute("uv2", new THREE.BufferAttribute(geometry.attributes.uv.array, 2));
                        }
                        if (material.isGLTFSpecularGlossinessMaterial) // for GLTFSpecularGlossinessMaterial(ShaderMaterial) uniforms runtime update
                        mesh.onBeforeRender = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].refreshUniforms;
                    }
                    mesh.material = isMultiMaterial ? materials : materials[0];
                }
                if (meshes.length === 1) return meshes[0];
                var group = new THREE.Group();
                for(var i = 0, il = meshes.length; i < il; i++)group.add(meshes[i]);
                return group;
            });
        });
    };
    /**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
	 * @param {number} cameraIndex
	 * @return {Promise<THREE.Camera>}
	 */ GLTFParser.prototype.loadCamera = function(cameraIndex) {
        var camera;
        var cameraDef = this.json.cameras[cameraIndex];
        var params = cameraDef[cameraDef.type];
        if (!params) {
            console.warn("THREE.GLTFLoader: Missing camera parameters.");
            return;
        }
        if (cameraDef.type === "perspective") camera = new THREE.PerspectiveCamera(THREE.Math.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);
        else if (cameraDef.type === "orthographic") camera = new THREE.OrthographicCamera(params.xmag / -2, params.xmag / 2, params.ymag / 2, params.ymag / -2, params.znear, params.zfar);
        if (cameraDef.name !== undefined) camera.name = cameraDef.name;
        assignExtrasToUserData(camera, cameraDef);
        return Promise.resolve(camera);
    };
    /**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
	 * @param {number} skinIndex
	 * @return {Promise<Object>}
	 */ GLTFParser.prototype.loadSkin = function(skinIndex) {
        var skinDef = this.json.skins[skinIndex];
        var skinEntry = {
            joints: skinDef.joints
        };
        if (skinDef.inverseBindMatrices === undefined) return Promise.resolve(skinEntry);
        return this.getDependency("accessor", skinDef.inverseBindMatrices).then(function(accessor) {
            skinEntry.inverseBindMatrices = accessor;
            return skinEntry;
        });
    };
    /**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
	 * @param {number} animationIndex
	 * @return {Promise<THREE.AnimationClip>}
	 */ GLTFParser.prototype.loadAnimation = function(animationIndex) {
        var json = this.json;
        var animationDef = json.animations[animationIndex];
        var pendingNodes = [];
        var pendingInputAccessors = [];
        var pendingOutputAccessors = [];
        var pendingSamplers = [];
        var pendingTargets = [];
        for(var i = 0, il = animationDef.channels.length; i < il; i++){
            var channel = animationDef.channels[i];
            var sampler = animationDef.samplers[channel.sampler];
            var target = channel.target;
            var name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated.
            var input = animationDef.parameters !== undefined ? animationDef.parameters[sampler.input] : sampler.input;
            var output = animationDef.parameters !== undefined ? animationDef.parameters[sampler.output] : sampler.output;
            pendingNodes.push(this.getDependency("node", name));
            pendingInputAccessors.push(this.getDependency("accessor", input));
            pendingOutputAccessors.push(this.getDependency("accessor", output));
            pendingSamplers.push(sampler);
            pendingTargets.push(target);
        }
        return Promise.all([
            Promise.all(pendingNodes),
            Promise.all(pendingInputAccessors),
            Promise.all(pendingOutputAccessors),
            Promise.all(pendingSamplers),
            Promise.all(pendingTargets)
        ]).then(function(dependencies) {
            var nodes = dependencies[0];
            var inputAccessors = dependencies[1];
            var outputAccessors = dependencies[2];
            var samplers = dependencies[3];
            var targets = dependencies[4];
            var tracks = [];
            for(var i = 0, il = nodes.length; i < il; i++){
                var node = nodes[i];
                var inputAccessor = inputAccessors[i];
                var outputAccessor = outputAccessors[i];
                var sampler = samplers[i];
                var target = targets[i];
                if (node === undefined) continue;
                node.updateMatrix();
                node.matrixAutoUpdate = true;
                var TypedKeyframeTrack;
                switch(PATH_PROPERTIES[target.path]){
                    case PATH_PROPERTIES.weights:
                        TypedKeyframeTrack = THREE.NumberKeyframeTrack;
                        break;
                    case PATH_PROPERTIES.rotation:
                        TypedKeyframeTrack = THREE.QuaternionKeyframeTrack;
                        break;
                    case PATH_PROPERTIES.position:
                    case PATH_PROPERTIES.scale:
                    default:
                        TypedKeyframeTrack = THREE.VectorKeyframeTrack;
                        break;
                }
                var targetName = node.name ? node.name : node.uuid;
                var interpolation = sampler.interpolation !== undefined ? INTERPOLATION[sampler.interpolation] : THREE.InterpolateLinear;
                var targetNames = [];
                if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) // node can be THREE.Group here but
                // PATH_PROPERTIES.weights(morphTargetInfluences) should be
                // the property of a mesh object under group.
                node.traverse(function(object) {
                    if (object.isMesh === true && object.morphTargetInfluences) targetNames.push(object.name ? object.name : object.uuid);
                });
                else targetNames.push(targetName);
                // KeyframeTrack.optimize() will modify given 'times' and 'values'
                // buffers before creating a truncated copy to keep. Because buffers may
                // be reused by other tracks, make copies here.
                for(var j = 0, jl = targetNames.length; j < jl; j++){
                    var track = new TypedKeyframeTrack(targetNames[j] + "." + PATH_PROPERTIES[target.path], THREE.AnimationUtils.arraySlice(inputAccessor.array, 0), THREE.AnimationUtils.arraySlice(outputAccessor.array, 0), interpolation);
                    // Here is the trick to enable custom interpolation.
                    // Overrides .createInterpolant in a factory method which creates custom interpolation.
                    if (sampler.interpolation === "CUBICSPLINE") {
                        track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {
                            // A CUBICSPLINE keyframe in glTF has three output values for each input value,
                            // representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()
                            // must be divided by three to get the interpolant's sampleSize argument.
                            return new GLTFCubicSplineInterpolant(this.times, this.values, this.getValueSize() / 3, result);
                        };
                        // Workaround, provide an alternate way to know if the interpolant type is cubis spline to track.
                        // track.getInterpolation() doesn't return valid value for custom interpolant.
                        track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;
                    }
                    tracks.push(track);
                }
            }
            var name = animationDef.name !== undefined ? animationDef.name : "animation_" + animationIndex;
            return new THREE.AnimationClip(name, undefined, tracks);
        });
    };
    /**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
	 * @param {number} nodeIndex
	 * @return {Promise<THREE.Object3D>}
	 */ GLTFParser.prototype.loadNode = function(nodeIndex) {
        var json = this.json;
        var extensions = this.extensions;
        var parser = this;
        var meshReferences = json.meshReferences;
        var meshUses = json.meshUses;
        var nodeDef = json.nodes[nodeIndex];
        return (function() {
            // .isBone isn't in glTF spec. See .markDefs
            if (nodeDef.isBone === true) return Promise.resolve(new THREE.Bone());
            else if (nodeDef.mesh !== undefined) return parser.getDependency("mesh", nodeDef.mesh).then(function(mesh) {
                var node;
                if (meshReferences[nodeDef.mesh] > 1) {
                    var instanceNum = meshUses[nodeDef.mesh]++;
                    node = mesh.clone();
                    node.name += "_instance_" + instanceNum;
                    // onBeforeRender copy for Specular-Glossiness
                    node.onBeforeRender = mesh.onBeforeRender;
                    for(var i = 0, il = node.children.length; i < il; i++){
                        node.children[i].name += "_instance_" + instanceNum;
                        node.children[i].onBeforeRender = mesh.children[i].onBeforeRender;
                    }
                } else node = mesh;
                // if weights are provided on the node, override weights on the mesh.
                if (nodeDef.weights !== undefined) node.traverse(function(o) {
                    if (!o.isMesh) return;
                    for(var i = 0, il = nodeDef.weights.length; i < il; i++)o.morphTargetInfluences[i] = nodeDef.weights[i];
                });
                return node;
            });
            else if (nodeDef.camera !== undefined) return parser.getDependency("camera", nodeDef.camera);
            else if (nodeDef.extensions && nodeDef.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL] && nodeDef.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL].light !== undefined) return parser.getDependency("light", nodeDef.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL].light);
            else return Promise.resolve(new THREE.Object3D());
        })().then(function(node) {
            if (nodeDef.name !== undefined) node.name = THREE.PropertyBinding.sanitizeNodeName(nodeDef.name);
            assignExtrasToUserData(node, nodeDef);
            if (nodeDef.extensions) addUnknownExtensionsToUserData(extensions, node, nodeDef);
            if (nodeDef.matrix !== undefined) {
                var matrix = new THREE.Matrix4();
                matrix.fromArray(nodeDef.matrix);
                node.applyMatrix(matrix);
            } else {
                if (nodeDef.translation !== undefined) node.position.fromArray(nodeDef.translation);
                if (nodeDef.rotation !== undefined) node.quaternion.fromArray(nodeDef.rotation);
                if (nodeDef.scale !== undefined) node.scale.fromArray(nodeDef.scale);
            }
            return node;
        });
    };
    /**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
	 * @param {number} sceneIndex
	 * @return {Promise<THREE.Scene>}
	 */ GLTFParser.prototype.loadScene = function() {
        // scene node hierachy builder
        function buildNodeHierachy(nodeId, parentObject, json, parser) {
            var nodeDef = json.nodes[nodeId];
            return parser.getDependency("node", nodeId).then(function(node) {
                if (nodeDef.skin === undefined) return node;
                // build skeleton here as well
                var skinEntry;
                return parser.getDependency("skin", nodeDef.skin).then(function(skin) {
                    skinEntry = skin;
                    var pendingJoints = [];
                    for(var i = 0, il = skinEntry.joints.length; i < il; i++)pendingJoints.push(parser.getDependency("node", skinEntry.joints[i]));
                    return Promise.all(pendingJoints);
                }).then(function(jointNodes) {
                    var meshes = node.isGroup === true ? node.children : [
                        node
                    ];
                    for(var i = 0, il = meshes.length; i < il; i++){
                        var mesh = meshes[i];
                        var bones = [];
                        var boneInverses = [];
                        for(var j = 0, jl = jointNodes.length; j < jl; j++){
                            var jointNode = jointNodes[j];
                            if (jointNode) {
                                bones.push(jointNode);
                                var mat = new THREE.Matrix4();
                                if (skinEntry.inverseBindMatrices !== undefined) mat.fromArray(skinEntry.inverseBindMatrices.array, j * 16);
                                boneInverses.push(mat);
                            } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', skinEntry.joints[j]);
                        }
                        mesh.bind(new THREE.Skeleton(bones, boneInverses), mesh.matrixWorld);
                    }
                    return node;
                });
            }).then(function(node) {
                // build node hierachy
                parentObject.add(node);
                var pending = [];
                if (nodeDef.children) {
                    var children = nodeDef.children;
                    for(var i = 0, il = children.length; i < il; i++){
                        var child = children[i];
                        pending.push(buildNodeHierachy(child, node, json, parser));
                    }
                }
                return Promise.all(pending);
            });
        }
        return function loadScene(sceneIndex) {
            var json = this.json;
            var extensions = this.extensions;
            var sceneDef = this.json.scenes[sceneIndex];
            var parser = this;
            var scene = new THREE.Scene();
            if (sceneDef.name !== undefined) scene.name = sceneDef.name;
            assignExtrasToUserData(scene, sceneDef);
            if (sceneDef.extensions) addUnknownExtensionsToUserData(extensions, scene, sceneDef);
            var nodeIds = sceneDef.nodes || [];
            var pending = [];
            for(var i = 0, il = nodeIds.length; i < il; i++)pending.push(buildNodeHierachy(nodeIds[i], scene, json, parser));
            return Promise.all(pending).then(function() {
                return scene;
            });
        };
    }();
    return GLTFLoader;
}();

},{}],"2RGT8":[function(require,module,exports) {
"use strict";
// lib
const { Observable } = require("47eb0acac4e0baf4");
// threejs
const THREE = require("7a3655fd4b8ecd04");
window.THREE = window.THREE || THREE;
require("8e30909170249de8");
require("e3248440537f254f");
const load = (url)=>new Observable((observer)=>new THREE.MTLLoader().load(url.replace(".obj", ".mtl"), (materials)=>(materials.preload(), new THREE.OBJLoader().setMaterials(materials).load(url, (object)=>(observer.next(object), observer.complete())))));
module.exports = {
    load
};

},{"47eb0acac4e0baf4":"hWUVi","7a3655fd4b8ecd04":"5IrVb","8e30909170249de8":"qb2Iu","e3248440537f254f":"3cK2d"}],"qb2Iu":[function(require,module,exports) {
/**
 * Loads a Wavefront .mtl file specifying materials
 *
 * @author angelxuanchang
 */ THREE.MTLLoader = function(manager) {
    this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
};
THREE.MTLLoader.prototype = {
    constructor: THREE.MTLLoader,
    /**
	 * Loads and parses a MTL asset from a URL.
	 *
	 * @param {String} url - URL to the MTL file.
	 * @param {Function} [onLoad] - Callback invoked with the loaded object.
	 * @param {Function} [onProgress] - Callback for download progress.
	 * @param {Function} [onError] - Callback for download errors.
	 *
	 * @see setPath setResourcePath
	 *
	 * @note In order for relative texture references to resolve correctly
	 * you must call setResourcePath() explicitly prior to load.
	 */ load: function(url, onLoad, onProgress, onError) {
        var scope = this;
        var path = this.path === undefined ? THREE.LoaderUtils.extractUrlBase(url) : this.path;
        var loader = new THREE.FileLoader(this.manager);
        loader.setPath(this.path);
        loader.load(url, function(text) {
            onLoad(scope.parse(text, path));
        }, onProgress, onError);
    },
    /**
	 * Set base path for resolving references.
	 * If set this path will be prepended to each loaded and found reference.
	 *
	 * @see setResourcePath
	 * @param {String} path
	 * @return {THREE.MTLLoader}
	 *
	 * @example
	 *     mtlLoader.setPath( 'assets/obj/' );
	 *     mtlLoader.load( 'my.mtl', ... );
	 */ setPath: function(path) {
        this.path = path;
        return this;
    },
    /**
	 * Set base path for additional resources like textures.
	 *
	 * @see setPath
	 * @param {String} path
	 * @return {THREE.MTLLoader}
	 *
	 * @example
	 *     mtlLoader.setPath( 'assets/obj/' );
	 *     mtlLoader.setResourcePath( 'assets/textures/' );
	 *     mtlLoader.load( 'my.mtl', ... );
	 */ setResourcePath: function(path) {
        this.resourcePath = path;
        return this;
    },
    setTexturePath: function(path) {
        console.warn("THREE.MTLLoader: .setTexturePath() has been renamed to .setResourcePath().");
        return this.setResourcePath(path);
    },
    setCrossOrigin: function(value) {
        this.crossOrigin = value;
        return this;
    },
    setMaterialOptions: function(value) {
        this.materialOptions = value;
        return this;
    },
    /**
	 * Parses a MTL file.
	 *
	 * @param {String} text - Content of MTL file
	 * @return {THREE.MTLLoader.MaterialCreator}
	 *
	 * @see setPath setResourcePath
	 *
	 * @note In order for relative texture references to resolve correctly
	 * you must call setResourcePath() explicitly prior to parse.
	 */ parse: function(text, path) {
        var lines = text.split("\n");
        var info = {};
        var delimiter_pattern = /\s+/;
        var materialsInfo = {};
        for(var i = 0; i < lines.length; i++){
            var line = lines[i];
            line = line.trim();
            if (line.length === 0 || line.charAt(0) === "#") continue;
            var pos = line.indexOf(" ");
            var key = pos >= 0 ? line.substring(0, pos) : line;
            key = key.toLowerCase();
            var value = pos >= 0 ? line.substring(pos + 1) : "";
            value = value.trim();
            if (key === "newmtl") {
                // New material
                info = {
                    name: value
                };
                materialsInfo[value] = info;
            } else if (key === "ka" || key === "kd" || key === "ks" || key === "ke") {
                var ss = value.split(delimiter_pattern, 3);
                info[key] = [
                    parseFloat(ss[0]),
                    parseFloat(ss[1]),
                    parseFloat(ss[2])
                ];
            } else info[key] = value;
        }
        var materialCreator = new THREE.MTLLoader.MaterialCreator(this.resourcePath || path, this.materialOptions);
        materialCreator.setCrossOrigin(this.crossOrigin);
        materialCreator.setManager(this.manager);
        materialCreator.setMaterials(materialsInfo);
        return materialCreator;
    }
};
/**
 * Create a new THREE-MTLLoader.MaterialCreator
 * @param baseUrl - Url relative to which textures are loaded
 * @param options - Set of options on how to construct the materials
 *                  side: Which side to apply the material
 *                        THREE.FrontSide (default), THREE.BackSide, THREE.DoubleSide
 *                  wrap: What type of wrapping to apply for textures
 *                        THREE.RepeatWrapping (default), THREE.ClampToEdgeWrapping, THREE.MirroredRepeatWrapping
 *                  normalizeRGB: RGBs need to be normalized to 0-1 from 0-255
 *                                Default: false, assumed to be already normalized
 *                  ignoreZeroRGBs: Ignore values of RGBs (Ka,Kd,Ks) that are all 0's
 *                                  Default: false
 * @constructor
 */ THREE.MTLLoader.MaterialCreator = function(baseUrl, options) {
    this.baseUrl = baseUrl || "";
    this.options = options;
    this.materialsInfo = {};
    this.materials = {};
    this.materialsArray = [];
    this.nameLookup = {};
    this.side = this.options && this.options.side ? this.options.side : THREE.FrontSide;
    this.wrap = this.options && this.options.wrap ? this.options.wrap : THREE.RepeatWrapping;
};
THREE.MTLLoader.MaterialCreator.prototype = {
    constructor: THREE.MTLLoader.MaterialCreator,
    crossOrigin: "anonymous",
    setCrossOrigin: function(value) {
        this.crossOrigin = value;
        return this;
    },
    setManager: function(value) {
        this.manager = value;
    },
    setMaterials: function(materialsInfo) {
        this.materialsInfo = this.convert(materialsInfo);
        this.materials = {};
        this.materialsArray = [];
        this.nameLookup = {};
    },
    convert: function(materialsInfo) {
        if (!this.options) return materialsInfo;
        var converted = {};
        for(var mn in materialsInfo){
            // Convert materials info into normalized form based on options
            var mat = materialsInfo[mn];
            var covmat = {};
            converted[mn] = covmat;
            for(var prop in mat){
                var save = true;
                var value = mat[prop];
                var lprop = prop.toLowerCase();
                switch(lprop){
                    case "kd":
                    case "ka":
                    case "ks":
                        // Diffuse color (color under white light) using RGB values
                        if (this.options && this.options.normalizeRGB) value = [
                            value[0] / 255,
                            value[1] / 255,
                            value[2] / 255
                        ];
                        if (this.options && this.options.ignoreZeroRGBs) {
                            if (value[0] === 0 && value[1] === 0 && value[2] === 0) // ignore
                            save = false;
                        }
                        break;
                    default:
                        break;
                }
                if (save) covmat[lprop] = value;
            }
        }
        return converted;
    },
    preload: function() {
        for(var mn in this.materialsInfo)this.create(mn);
    },
    getIndex: function(materialName) {
        return this.nameLookup[materialName];
    },
    getAsArray: function() {
        var index = 0;
        for(var mn in this.materialsInfo){
            this.materialsArray[index] = this.create(mn);
            this.nameLookup[mn] = index;
            index++;
        }
        return this.materialsArray;
    },
    create: function(materialName) {
        if (this.materials[materialName] === undefined) this.createMaterial_(materialName);
        return this.materials[materialName];
    },
    createMaterial_: function(materialName) {
        // Create material
        var scope = this;
        var mat = this.materialsInfo[materialName];
        var params = {
            name: materialName,
            side: this.side
        };
        function resolveURL(baseUrl, url) {
            if (typeof url !== "string" || url === "") return "";
            // Absolute URL
            if (/^https?:\/\//i.test(url)) return url;
            return baseUrl + url;
        }
        function setMapForType(mapType, value) {
            if (params[mapType]) return; // Keep the first encountered texture
            var texParams = scope.getTextureParams(value, params);
            var map = scope.loadTexture(resolveURL(scope.baseUrl, texParams.url));
            map.repeat.copy(texParams.scale);
            map.offset.copy(texParams.offset);
            map.wrapS = scope.wrap;
            map.wrapT = scope.wrap;
            params[mapType] = map;
        }
        for(var prop in mat){
            var value = mat[prop];
            var n;
            if (value === "") continue;
            switch(prop.toLowerCase()){
                // Ns is material specular exponent
                case "kd":
                    // Diffuse color (color under white light) using RGB values
                    params.color = new THREE.Color().fromArray(value);
                    break;
                case "ks":
                    // Specular color (color when light is reflected from shiny surface) using RGB values
                    params.specular = new THREE.Color().fromArray(value);
                    break;
                case "ke":
                    // Emissive using RGB values
                    params.emissive = new THREE.Color().fromArray(value);
                    break;
                case "map_kd":
                    // Diffuse texture map
                    setMapForType("map", value);
                    break;
                case "map_ks":
                    // Specular map
                    setMapForType("specularMap", value);
                    break;
                case "map_ke":
                    // Emissive map
                    setMapForType("emissiveMap", value);
                    break;
                case "norm":
                    setMapForType("normalMap", value);
                    break;
                case "map_bump":
                case "bump":
                    // Bump texture map
                    setMapForType("bumpMap", value);
                    break;
                case "map_d":
                    // Alpha map
                    setMapForType("alphaMap", value);
                    params.transparent = true;
                    break;
                case "ns":
                    // The specular exponent (defines the focus of the specular highlight)
                    // A high exponent results in a tight, concentrated highlight. Ns values normally range from 0 to 1000.
                    params.shininess = parseFloat(value);
                    break;
                case "d":
                    n = parseFloat(value);
                    if (n < 1) {
                        params.opacity = n;
                        params.transparent = true;
                    }
                    break;
                case "tr":
                    n = parseFloat(value);
                    if (this.options && this.options.invertTrProperty) n = 1 - n;
                    if (n > 0) {
                        params.opacity = 1 - n;
                        params.transparent = true;
                    }
                    break;
                default:
                    break;
            }
        }
        this.materials[materialName] = new THREE.MeshPhongMaterial(params);
        return this.materials[materialName];
    },
    getTextureParams: function(value, matParams) {
        var texParams = {
            scale: new THREE.Vector2(1, 1),
            offset: new THREE.Vector2(0, 0)
        };
        var items = value.split(/\s+/);
        var pos;
        pos = items.indexOf("-bm");
        if (pos >= 0) {
            matParams.bumpScale = parseFloat(items[pos + 1]);
            items.splice(pos, 2);
        }
        pos = items.indexOf("-s");
        if (pos >= 0) {
            texParams.scale.set(parseFloat(items[pos + 1]), parseFloat(items[pos + 2]));
            items.splice(pos, 4); // we expect 3 parameters here!
        }
        pos = items.indexOf("-o");
        if (pos >= 0) {
            texParams.offset.set(parseFloat(items[pos + 1]), parseFloat(items[pos + 2]));
            items.splice(pos, 4); // we expect 3 parameters here!
        }
        texParams.url = items.join(" ").trim();
        return texParams;
    },
    loadTexture: function(url, mapping, onLoad, onProgress, onError) {
        var texture;
        var loader = THREE.Loader.Handlers.get(url);
        var manager = this.manager !== undefined ? this.manager : THREE.DefaultLoadingManager;
        if (loader === null) loader = new THREE.TextureLoader(manager);
        if (loader.setCrossOrigin) loader.setCrossOrigin(this.crossOrigin);
        texture = loader.load(url, onLoad, onProgress, onError);
        if (mapping !== undefined) texture.mapping = mapping;
        return texture;
    }
};

},{}],"3cK2d":[function(require,module,exports) {
/**
 * @author mrdoob / http://mrdoob.com/
 */ THREE.OBJLoader = function() {
    // o object_name | g group_name
    var object_pattern = /^[og]\s*(.+)?/;
    // mtllib file_reference
    var material_library_pattern = /^mtllib /;
    // usemtl material_name
    var material_use_pattern = /^usemtl /;
    function ParserState() {
        var state = {
            objects: [],
            object: {},
            vertices: [],
            normals: [],
            colors: [],
            uvs: [],
            materialLibraries: [],
            startObject: function(name, fromDeclaration) {
                // If the current object (initial from reset) is not from a g/o declaration in the parsed
                // file. We need to use it for the first parsed g/o to keep things in sync.
                if (this.object && this.object.fromDeclaration === false) {
                    this.object.name = name;
                    this.object.fromDeclaration = fromDeclaration !== false;
                    return;
                }
                var previousMaterial = this.object && typeof this.object.currentMaterial === "function" ? this.object.currentMaterial() : undefined;
                if (this.object && typeof this.object._finalize === "function") this.object._finalize(true);
                this.object = {
                    name: name || "",
                    fromDeclaration: fromDeclaration !== false,
                    geometry: {
                        vertices: [],
                        normals: [],
                        colors: [],
                        uvs: []
                    },
                    materials: [],
                    smooth: true,
                    startMaterial: function(name, libraries) {
                        var previous = this._finalize(false);
                        // New usemtl declaration overwrites an inherited material, except if faces were declared
                        // after the material, then it must be preserved for proper MultiMaterial continuation.
                        if (previous && (previous.inherited || previous.groupCount <= 0)) this.materials.splice(previous.index, 1);
                        var material = {
                            index: this.materials.length,
                            name: name || "",
                            mtllib: Array.isArray(libraries) && libraries.length > 0 ? libraries[libraries.length - 1] : "",
                            smooth: previous !== undefined ? previous.smooth : this.smooth,
                            groupStart: previous !== undefined ? previous.groupEnd : 0,
                            groupEnd: -1,
                            groupCount: -1,
                            inherited: false,
                            clone: function(index) {
                                var cloned = {
                                    index: typeof index === "number" ? index : this.index,
                                    name: this.name,
                                    mtllib: this.mtllib,
                                    smooth: this.smooth,
                                    groupStart: 0,
                                    groupEnd: -1,
                                    groupCount: -1,
                                    inherited: false
                                };
                                cloned.clone = this.clone.bind(cloned);
                                return cloned;
                            }
                        };
                        this.materials.push(material);
                        return material;
                    },
                    currentMaterial: function() {
                        if (this.materials.length > 0) return this.materials[this.materials.length - 1];
                        return undefined;
                    },
                    _finalize: function(end) {
                        var lastMultiMaterial = this.currentMaterial();
                        if (lastMultiMaterial && lastMultiMaterial.groupEnd === -1) {
                            lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;
                            lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;
                            lastMultiMaterial.inherited = false;
                        }
                        // Ignore objects tail materials if no face declarations followed them before a new o/g started.
                        if (end && this.materials.length > 1) {
                            for(var mi = this.materials.length - 1; mi >= 0; mi--)if (this.materials[mi].groupCount <= 0) this.materials.splice(mi, 1);
                        }
                        // Guarantee at least one empty material, this makes the creation later more straight forward.
                        if (end && this.materials.length === 0) this.materials.push({
                            name: "",
                            smooth: this.smooth
                        });
                        return lastMultiMaterial;
                    }
                };
                // Inherit previous objects material.
                // Spec tells us that a declared material must be set to all objects until a new material is declared.
                // If a usemtl declaration is encountered while this new object is being parsed, it will
                // overwrite the inherited material. Exception being that there was already face declarations
                // to the inherited material, then it will be preserved for proper MultiMaterial continuation.
                if (previousMaterial && previousMaterial.name && typeof previousMaterial.clone === "function") {
                    var declared = previousMaterial.clone(0);
                    declared.inherited = true;
                    this.object.materials.push(declared);
                }
                this.objects.push(this.object);
            },
            finalize: function() {
                if (this.object && typeof this.object._finalize === "function") this.object._finalize(true);
            },
            parseVertexIndex: function(value, len) {
                var index = parseInt(value, 10);
                return (index >= 0 ? index - 1 : index + len / 3) * 3;
            },
            parseNormalIndex: function(value, len) {
                var index = parseInt(value, 10);
                return (index >= 0 ? index - 1 : index + len / 3) * 3;
            },
            parseUVIndex: function(value, len) {
                var index = parseInt(value, 10);
                return (index >= 0 ? index - 1 : index + len / 2) * 2;
            },
            addVertex: function(a, b, c) {
                var src = this.vertices;
                var dst = this.object.geometry.vertices;
                dst.push(src[a + 0], src[a + 1], src[a + 2]);
                dst.push(src[b + 0], src[b + 1], src[b + 2]);
                dst.push(src[c + 0], src[c + 1], src[c + 2]);
            },
            addVertexPoint: function(a) {
                var src = this.vertices;
                var dst = this.object.geometry.vertices;
                dst.push(src[a + 0], src[a + 1], src[a + 2]);
            },
            addVertexLine: function(a) {
                var src = this.vertices;
                var dst = this.object.geometry.vertices;
                dst.push(src[a + 0], src[a + 1], src[a + 2]);
            },
            addNormal: function(a, b, c) {
                var src = this.normals;
                var dst = this.object.geometry.normals;
                dst.push(src[a + 0], src[a + 1], src[a + 2]);
                dst.push(src[b + 0], src[b + 1], src[b + 2]);
                dst.push(src[c + 0], src[c + 1], src[c + 2]);
            },
            addColor: function(a, b, c) {
                var src = this.colors;
                var dst = this.object.geometry.colors;
                dst.push(src[a + 0], src[a + 1], src[a + 2]);
                dst.push(src[b + 0], src[b + 1], src[b + 2]);
                dst.push(src[c + 0], src[c + 1], src[c + 2]);
            },
            addUV: function(a, b, c) {
                var src = this.uvs;
                var dst = this.object.geometry.uvs;
                dst.push(src[a + 0], src[a + 1]);
                dst.push(src[b + 0], src[b + 1]);
                dst.push(src[c + 0], src[c + 1]);
            },
            addUVLine: function(a) {
                var src = this.uvs;
                var dst = this.object.geometry.uvs;
                dst.push(src[a + 0], src[a + 1]);
            },
            addFace: function(a, b, c, ua, ub, uc, na, nb, nc) {
                var vLen = this.vertices.length;
                var ia = this.parseVertexIndex(a, vLen);
                var ib = this.parseVertexIndex(b, vLen);
                var ic = this.parseVertexIndex(c, vLen);
                this.addVertex(ia, ib, ic);
                if (ua !== undefined && ua !== "") {
                    var uvLen = this.uvs.length;
                    ia = this.parseUVIndex(ua, uvLen);
                    ib = this.parseUVIndex(ub, uvLen);
                    ic = this.parseUVIndex(uc, uvLen);
                    this.addUV(ia, ib, ic);
                }
                if (na !== undefined && na !== "") {
                    // Normals are many times the same. If so, skip function call and parseInt.
                    var nLen = this.normals.length;
                    ia = this.parseNormalIndex(na, nLen);
                    ib = na === nb ? ia : this.parseNormalIndex(nb, nLen);
                    ic = na === nc ? ia : this.parseNormalIndex(nc, nLen);
                    this.addNormal(ia, ib, ic);
                }
                if (this.colors.length > 0) this.addColor(ia, ib, ic);
            },
            addPointGeometry: function(vertices) {
                this.object.geometry.type = "Points";
                var vLen = this.vertices.length;
                for(var vi = 0, l = vertices.length; vi < l; vi++)this.addVertexPoint(this.parseVertexIndex(vertices[vi], vLen));
            },
            addLineGeometry: function(vertices, uvs) {
                this.object.geometry.type = "Line";
                var vLen = this.vertices.length;
                var uvLen = this.uvs.length;
                for(var vi = 0, l = vertices.length; vi < l; vi++)this.addVertexLine(this.parseVertexIndex(vertices[vi], vLen));
                for(var uvi = 0, l = uvs.length; uvi < l; uvi++)this.addUVLine(this.parseUVIndex(uvs[uvi], uvLen));
            }
        };
        state.startObject("", false);
        return state;
    }
    //
    function OBJLoader(manager) {
        this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
        this.materials = null;
    }
    OBJLoader.prototype = {
        constructor: OBJLoader,
        load: function(url, onLoad, onProgress, onError) {
            var scope = this;
            var loader = new THREE.FileLoader(scope.manager);
            loader.setPath(this.path);
            loader.load(url, function(text) {
                onLoad(scope.parse(text));
            }, onProgress, onError);
        },
        setPath: function(value) {
            this.path = value;
            return this;
        },
        setMaterials: function(materials) {
            this.materials = materials;
            return this;
        },
        parse: function(text) {
            console.time("OBJLoader");
            var state = new ParserState();
            if (text.indexOf("\r\n") !== -1) // This is faster than String.split with regex that splits on both
            text = text.replace(/\r\n/g, "\n");
            if (text.indexOf("\\\n") !== -1) // join lines separated by a line continuation character (\)
            text = text.replace(/\\\n/g, "");
            var lines = text.split("\n");
            var line = "", lineFirstChar = "";
            var lineLength = 0;
            var result = [];
            // Faster to just trim left side of the line. Use if available.
            var trimLeft = typeof "".trimLeft === "function";
            for(var i = 0, l = lines.length; i < l; i++){
                line = lines[i];
                line = trimLeft ? line.trimLeft() : line.trim();
                lineLength = line.length;
                if (lineLength === 0) continue;
                lineFirstChar = line.charAt(0);
                // @todo invoke passed in handler if any
                if (lineFirstChar === "#") continue;
                if (lineFirstChar === "v") {
                    var data = line.split(/\s+/);
                    switch(data[0]){
                        case "v":
                            state.vertices.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));
                            if (data.length === 8) state.colors.push(parseFloat(data[4]), parseFloat(data[5]), parseFloat(data[6]));
                            break;
                        case "vn":
                            state.normals.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));
                            break;
                        case "vt":
                            state.uvs.push(parseFloat(data[1]), parseFloat(data[2]));
                            break;
                    }
                } else if (lineFirstChar === "f") {
                    var lineData = line.substr(1).trim();
                    var vertexData = lineData.split(/\s+/);
                    var faceVertices = [];
                    // Parse the face vertex data into an easy to work with format
                    for(var j = 0, jl = vertexData.length; j < jl; j++){
                        var vertex = vertexData[j];
                        if (vertex.length > 0) {
                            var vertexParts = vertex.split("/");
                            faceVertices.push(vertexParts);
                        }
                    }
                    // Draw an edge between the first vertex and all subsequent vertices to form an n-gon
                    var v1 = faceVertices[0];
                    for(var j = 1, jl = faceVertices.length - 1; j < jl; j++){
                        var v2 = faceVertices[j];
                        var v3 = faceVertices[j + 1];
                        state.addFace(v1[0], v2[0], v3[0], v1[1], v2[1], v3[1], v1[2], v2[2], v3[2]);
                    }
                } else if (lineFirstChar === "l") {
                    var lineParts = line.substring(1).trim().split(" ");
                    var lineVertices = [], lineUVs = [];
                    if (line.indexOf("/") === -1) lineVertices = lineParts;
                    else for(var li = 0, llen = lineParts.length; li < llen; li++){
                        var parts = lineParts[li].split("/");
                        if (parts[0] !== "") lineVertices.push(parts[0]);
                        if (parts[1] !== "") lineUVs.push(parts[1]);
                    }
                    state.addLineGeometry(lineVertices, lineUVs);
                } else if (lineFirstChar === "p") {
                    var lineData = line.substr(1).trim();
                    var pointData = lineData.split(" ");
                    state.addPointGeometry(pointData);
                } else if ((result = object_pattern.exec(line)) !== null) {
                    // o object_name
                    // or
                    // g group_name
                    // WORKAROUND: https://bugs.chromium.org/p/v8/issues/detail?id=2869
                    // var name = result[ 0 ].substr( 1 ).trim();
                    var name = (" " + result[0].substr(1).trim()).substr(1);
                    state.startObject(name);
                } else if (material_use_pattern.test(line)) // material
                state.object.startMaterial(line.substring(7).trim(), state.materialLibraries);
                else if (material_library_pattern.test(line)) // mtl file
                state.materialLibraries.push(line.substring(7).trim());
                else if (lineFirstChar === "s") {
                    result = line.split(" ");
                    // smooth shading
                    // @todo Handle files that have varying smooth values for a set of faces inside one geometry,
                    // but does not define a usemtl for each face set.
                    // This should be detected and a dummy material created (later MultiMaterial and geometry groups).
                    // This requires some care to not create extra material on each smooth value for "normal" obj files.
                    // where explicit usemtl defines geometry groups.
                    // Example asset: examples/models/obj/cerberus/Cerberus.obj
                    /*
					 * http://paulbourke.net/dataformats/obj/
					 * or
					 * http://www.cs.utah.edu/~boulos/cs3505/obj_spec.pdf
					 *
					 * From chapter "Grouping" Syntax explanation "s group_number":
					 * "group_number is the smoothing group number. To turn off smoothing groups, use a value of 0 or off.
					 * Polygonal elements use group numbers to put elements in different smoothing groups. For free-form
					 * surfaces, smoothing groups are either turned on or off; there is no difference between values greater
					 * than 0."
					 */ if (result.length > 1) {
                        var value = result[1].trim().toLowerCase();
                        state.object.smooth = value !== "0" && value !== "off";
                    } else // ZBrush can produce "s" lines #11707
                    state.object.smooth = true;
                    var material = state.object.currentMaterial();
                    if (material) material.smooth = state.object.smooth;
                } else {
                    // Handle null terminated files without exception
                    if (line === "\0") continue;
                    throw new Error('THREE.OBJLoader: Unexpected line: "' + line + '"');
                }
            }
            state.finalize();
            var container = new THREE.Group();
            container.materialLibraries = [].concat(state.materialLibraries);
            for(var i = 0, l = state.objects.length; i < l; i++){
                var object = state.objects[i];
                var geometry = object.geometry;
                var materials = object.materials;
                var isLine = geometry.type === "Line";
                var isPoints = geometry.type === "Points";
                var hasVertexColors = false;
                // Skip o/g line declarations that did not follow with any faces
                if (geometry.vertices.length === 0) continue;
                var buffergeometry = new THREE.BufferGeometry();
                buffergeometry.addAttribute("position", new THREE.Float32BufferAttribute(geometry.vertices, 3));
                if (geometry.normals.length > 0) buffergeometry.addAttribute("normal", new THREE.Float32BufferAttribute(geometry.normals, 3));
                else buffergeometry.computeVertexNormals();
                if (geometry.colors.length > 0) {
                    hasVertexColors = true;
                    buffergeometry.addAttribute("color", new THREE.Float32BufferAttribute(geometry.colors, 3));
                }
                if (geometry.uvs.length > 0) buffergeometry.addAttribute("uv", new THREE.Float32BufferAttribute(geometry.uvs, 2));
                // Create materials
                var createdMaterials = [];
                for(var mi = 0, miLen = materials.length; mi < miLen; mi++){
                    var sourceMaterial = materials[mi];
                    var material = undefined;
                    if (this.materials !== null) {
                        material = this.materials.create(sourceMaterial.name);
                        // mtl etc. loaders probably can't create line materials correctly, copy properties to a line material.
                        if (isLine && material && !(material instanceof THREE.LineBasicMaterial)) {
                            var materialLine = new THREE.LineBasicMaterial();
                            THREE.Material.prototype.copy.call(materialLine, material);
                            materialLine.color.copy(material.color);
                            materialLine.lights = false;
                            material = materialLine;
                        } else if (isPoints && material && !(material instanceof THREE.PointsMaterial)) {
                            var materialPoints = new THREE.PointsMaterial({
                                size: 10,
                                sizeAttenuation: false
                            });
                            THREE.Material.prototype.copy.call(materialPoints, material);
                            materialPoints.color.copy(material.color);
                            materialPoints.map = material.map;
                            materialPoints.lights = false;
                            material = materialPoints;
                        }
                    }
                    if (!material) {
                        if (isLine) material = new THREE.LineBasicMaterial();
                        else if (isPoints) material = new THREE.PointsMaterial({
                            size: 1,
                            sizeAttenuation: false
                        });
                        else material = new THREE.MeshPhongMaterial();
                        material.name = sourceMaterial.name;
                    }
                    material.flatShading = sourceMaterial.smooth ? false : true;
                    material.vertexColors = hasVertexColors ? THREE.VertexColors : THREE.NoColors;
                    createdMaterials.push(material);
                }
                // Create mesh
                var mesh;
                if (createdMaterials.length > 1) {
                    for(var mi = 0, miLen = materials.length; mi < miLen; mi++){
                        var sourceMaterial = materials[mi];
                        buffergeometry.addGroup(sourceMaterial.groupStart, sourceMaterial.groupCount, mi);
                    }
                    if (isLine) mesh = new THREE.LineSegments(buffergeometry, createdMaterials);
                    else if (isPoints) mesh = new THREE.Points(buffergeometry, createdMaterials);
                    else mesh = new THREE.Mesh(buffergeometry, createdMaterials);
                } else {
                    if (isLine) mesh = new THREE.LineSegments(buffergeometry, createdMaterials[0]);
                    else if (isPoints) mesh = new THREE.Points(buffergeometry, createdMaterials[0]);
                    else mesh = new THREE.Mesh(buffergeometry, createdMaterials[0]);
                }
                mesh.name = object.name;
                container.add(mesh);
            }
            console.timeEnd("OBJLoader");
            return container;
        }
    };
    return OBJLoader;
}();

},{}],"izyq4":[function(require,module,exports) {
"use strict";
// threejs
const THREE = require("ade1dc8b7f4c8aa1");
window.THREE = window.THREE || THREE;
const degreeToRadiant = (deg)=>Math.PI / (180 / deg);
const calcucalateAngle = (viewport, range)=>({
        x: viewport.mouse.x / viewport.screen.width * range.h + range.hOffset,
        y: viewport.mouse.y / viewport.screen.height * range.v + range.vOffset
    });
const init = ()=>{};
let cameraAngle = {
    x: 45,
    y: 210
};
let mouse = false;
const refresh = ({ camera, state })=>{
    const centerPos = new THREE.Vector3().fromArray(state.camera.followPlayer ? state.player.position : [
        0,
        0,
        0
    ]);
    if (state.viewport.mouse.down) {
        cameraAngle = {
            x: 360 + (state.player.rotation - 90 - 45) % 360,
            y: (state.camera.range.h + cameraAngle.y - (mouse ? (mouse.y - state.viewport.mouse.y) * 0.3 : 0)) % state.camera.range.h
        };
        // console.log(cameraAngle, mouse);
        cameraAngle.y = Math.max(Math.min(cameraAngle.y, 260), 170);
        mouse = {
            ...state.viewport.mouse
        };
    } else mouse = false;
    const minDistance = 12;
    const distance = Math.min(Math.max(minDistance, state.camera.distance * ((cameraAngle.y - 180) / 90)), state.camera.distance);
    const lookAtPos = centerPos.clone().add({
        x: 0,
        y: 6 - 6 * ((cameraAngle.y - 180) / 90),
        z: 0
    });
    // console.log(cameraAngle.y);
    camera.position.copy(lookAtPos.clone().add({
        // x
        x: Math.cos(degreeToRadiant(cameraAngle.x)) * Math.cos(degreeToRadiant(cameraAngle.y)) * distance,
        y: -Math.sin(degreeToRadiant(cameraAngle.y)) * distance,
        z: -Math.cos(degreeToRadiant(cameraAngle.y)) * Math.sin(degreeToRadiant(cameraAngle.x)) * distance
    }));
    camera.aspect = state.viewport.screen.width / state.viewport.screen.height;
    camera.updateProjectionMatrix();
    camera.lookAt(lookAtPos);
    return camera;
};
module.exports = {
    init,
    refresh
};

},{"ade1dc8b7f4c8aa1":"5IrVb"}],"7WKih":[function(require,module,exports) {
"use strict";
// lib
const { map } = require("f80a1f4672422c1");
// threejs
const THREE = require("2d5281db5c375da0");
window.THREE = window.THREE || THREE;
let clock = new THREE.Clock();
const gltfLoader = require("f5373568060a1ef6");
const degreeToRadiant = (deg)=>Math.PI / (180 / deg);
const init = ()=>gltfLoader.load("assets/models/rogue.glb").pipe(map((gltf)=>{
        let character = gltf.scene;
        // player.rotation.y = -180 * Math.PI / 180;
        character.castShadow = true;
        character.receiveShadow = true;
        character.scale.set(4, 4, 4);
        character.position.set(0, 0.2, 0);
        character.traverse(function(object) {
            if (object.isMesh) {
                // object.castShadow = true;
                // object.receiveShadow = true;
                const reMat = object.material.clone();
                const alpha = 0.3; // cell.side === 0 ? 0 : 1;
                const beta = 0.3;
                const gamma = 0.3;
                let specularColor = new THREE.Color(beta * 0.2, beta * 0.2, beta * 0.2);
                let specularShininess = Math.pow(2, alpha * 10);
                let diffuseColor = new THREE.Color().setHSL(alpha, 0, 1);
                // object.material.color = diffuseColor;
                // object.material.specular = specularColor;
                // object.material.reflectivity = beta;
                // object.material.shininess = specularShininess;
                object.material = new THREE.MeshToonMaterial({
                    color: diffuseColor,
                    specular: specularColor,
                    reflectivity: beta,
                    shininess: specularShininess,
                    skinning: true,
                    map: reMat.map,
                    normalMap: reMat.normalMap
                });
            // .copy(reMat);
            // object.material.specular = new THREE.Color(`#aaa`);
            // object.material.wireframe = true;
            }
        });
        // skeleton
        let skeleton = new THREE.SkeletonHelper(character);
        skeleton.visible = false;
        // scene.add(skeleton);
        // testMesh.scale.set(0.001, 0.001, 0.001);
        let animations = gltf.animations;
        let mixer = new THREE.AnimationMixer(character);
        console.log(character, skeleton);
        let idleAction = mixer.clipAction(animations[0]);
        let idle2Action = mixer.clipAction(animations[1]);
        let walkAction = mixer.clipAction(animations[2]);
        let crouchIdleAction = mixer.clipAction(animations[3]);
        let acts = [
            idleAction,
            idle2Action,
            walkAction,
            crouchIdleAction
        ];
        acts.forEach(function(action) {
            action.setEffectiveWeight(0);
            action.play();
        });
        acts[1].setEffectiveWeight(1);
        return {
            character,
            skeleton,
            mixer,
            acts
        };
    }));
let lookAwayFrom = (me, target)=>{
    let v = new THREE.Vector3();
    v.subVectors(me.position, target.position).add(me.position);
    v.y = me.position.y;
    me.lookAt(v);
};
const refresh = ({ scene, character, mixer, acts, state, camera })=>{
    const newPos = new THREE.Vector3().fromArray(state.player.position);
    let walking = false;
    let running = false;
    let crouching = state.player.crouching;
    if (character && character.position) {
        if (state.camera.followPlayer) character.rotation.set(0, degreeToRadiant(state.player.rotation), 0);
        if (character.position.distanceTo(newPos) > 0) {
            walking = true;
            character.lookAt(newPos);
            if (character.position.distanceTo(newPos) >= 10) running = true;
            // player.rotation.y -= 135;
            console.log(character.position.distanceTo(newPos));
        }
        character.position.copy(newPos);
        scene.getObjectByName("skybox").position.copy(newPos);
    }
    // sunLight.lookAt(newPos);
    // manage animation
    if (acts) {
        if (walking) {
            acts[1].setEffectiveWeight(0);
            acts[2].setEffectiveWeight(1);
        } else {
            acts[1].setEffectiveWeight(1);
            acts[2].setEffectiveWeight(0);
        }
        acts[3].setEffectiveWeight(crouching ? 1 : 0);
    }
    let mixerUpdateDelta = clock.getDelta();
    // console.log(character, mixer, acts);
    if (mixer) mixer.update(mixerUpdateDelta);
};
module.exports = {
    init,
    refresh
};

},{"f80a1f4672422c1":"1cs2r","2d5281db5c375da0":"5IrVb","f5373568060a1ef6":"jAd3E"}],"5tYyC":[function(require,module,exports) {
"use strict";
// lib
const { map } = require("ac5ba03fbc8ab9b");
// threejs
const THREE = require("4d3222cbb77f7f9");
window.THREE = window.THREE || THREE;
let clock = new THREE.Clock();
const routes = [
    [
        [
            -10,
            0.2,
            -20
        ],
        [
            20,
            0.2,
            -20
        ]
    ],
    [
        [
            0,
            0.2,
            0
        ],
        [
            -30,
            0.2,
            0
        ]
    ],
    [
        [
            -20,
            0.2,
            20
        ],
        [
            10,
            0.2,
            20
        ],
        [
            10,
            0.2,
            40
        ]
    ]
];
const gltfLoader = require("263fedc1374edcea");
const init = ()=>gltfLoader.load("assets/models/guard.glb").pipe(map((gltf)=>{
        let animations = gltf.animations;
        // console.log('123', guard, guard.clone());
        // player.rotation.y = -180 * Math.PI / 180;
        const guards = routes.map((route)=>{
            // let model = new THREE.ObjectLoader().parse(guard.toJSON());
            let guard = gltfLoader.clone(gltf);
            let model = guard.scene;
            let animations = guard.animations;
            model.castShadow = true;
            model.receiveShadow = true;
            model.scale.set(4, 4, 4);
            model.position.copy(new THREE.Vector3().fromArray(route[0]));
            // model.lookAt(new THREE.Vector3().fromArray(route[1]));
            model.traverse(function(object) {
                if (object.isMesh) {
                    object.castShadow = true;
                    object.receiveShadow = true;
                }
            });
            // skeleton
            let skeleton = new THREE.SkeletonHelper(model);
            skeleton.visible = false;
            let mixer = new THREE.AnimationMixer(model);
            let idleAction = mixer.clipAction(animations[0]);
            let walkAction = mixer.clipAction(animations[1]);
            let acts = [
                idleAction,
                walkAction
            ];
            acts.forEach(function(action) {
                action.setEffectiveWeight(0);
                action.play();
            });
            model.route = route;
            model.direction = 1;
            model.mode = "idle";
            model.frame = 0;
            return {
                model,
                mixer,
                acts,
                route
            };
        });
        return guards;
    }));
const refresh = ({ scene, guards, state })=>{
    let mixerUpdateDelta = clock.getDelta();
    // console.log(guards);
    guards.forEach((guard)=>{
        // console.log(guard);
        if (guard.model.mode === "walk") {
            if (guard.model.position.distanceTo(new THREE.Vector3().fromArray(guard.model.route[guard.model.direction])) <= 0.12) {
                guard.model.position.copy(new THREE.Vector3().fromArray(guard.model.route[guard.model.direction]));
                if (guard.model.direction < guard.model.route.length - 1) guard.model.direction++;
                else {
                    guard.model.direction = 0;
                    guard.model.route = guard.model.route.reverse();
                    guard.model.mode = "idle";
                }
            // guard.model.lookAt(new THREE.Vector3().fromArray(guard.model.route[guard.model.direction]));
            } else {
                guard.model.lookAt(new THREE.Vector3().fromArray(guard.model.route[guard.model.direction]));
                var direction = new THREE.Vector3();
                guard.model.getWorldDirection(direction);
                guard.model.position.add(direction.multiplyScalar(0.12));
            }
            guard.acts[1].setEffectiveWeight(1);
            guard.acts[0].setEffectiveWeight(0);
        } else {
            if (guard.model.frame <= 128) guard.model.frame++;
            else {
                guard.model.frame = 0;
                guard.model.mode = "walk";
            }
            guard.acts[1].setEffectiveWeight(0);
            guard.acts[0].setEffectiveWeight(1);
        }
        // console.log(character, mixer, acts);
        if (guard.mixer) guard.mixer.update(mixerUpdateDelta);
    });
    return guards;
};
module.exports = {
    init,
    refresh
};

},{"ac5ba03fbc8ab9b":"1cs2r","4d3222cbb77f7f9":"5IrVb","263fedc1374edcea":"jAd3E"}],"jz7zu":[function(require,module,exports) {
"use strict";
// lib
const { fromEvent } = require("cb7e64897cd141b5");
const { withLatestFrom, filter, startWith } = require("ef3b87c02860bebd");
let unhook = ()=>{};
const hook = ({ state$, actions })=>{
    let subs = [];
    // mouse movement
    subs.push(fromEvent(document, "mousemove").pipe(withLatestFrom(state$, (ev, state)=>({
            ev,
            state
        }))).subscribe(({ ev, state })=>actions.set([
            "viewport",
            "mouse"
        ], {
            x: ev.pageX,
            y: ev.pageY,
            changeX: ev.pageX - state.viewport.mouse.x,
            changeY: ev.pageY - state.viewport.mouse.y
        })));
    subs.push(fromEvent(document, "mousedown").pipe(filter((ev)=>ev.target.tagName === "CANVAS")).subscribe((ev)=>actions.set([
            "viewport",
            "mouse"
        ], {
            down: true
        })));
    subs.push(fromEvent(document, "mouseup").subscribe((ev)=>actions.set([
            "viewport",
            "mouse"
        ], {
            down: false
        })));
    subs.push(fromEvent(document, "mousewheel").pipe(filter((ev)=>ev.target.tagName === "CANVAS")).subscribe((ev)=>(ev.preventDefault(), actions.zoom(Math.ceil(Math.abs(ev.deltaY / 30)) * (ev.deltaY > 0 ? 1 : -1)))));
    subs.push(fromEvent(window, "resize").pipe(startWith({})).subscribe((ev)=>actions.set([
            "viewport",
            "screen"
        ], {
            width: window.innerWidth,
            height: window.innerHeight,
            size: window.innerWidth >= 1200 ? "xl" : window.innerWidth >= 992 ? "lg" : window.innerWidth >= 768 ? "md" : window.innerWidth >= 576 ? "sm" : "xs"
        })));
    unhook = ()=>subs.forEach((sub)=>sub.unsubscribe());
};
module.exports = {
    hook,
    unhook: ()=>unhook()
};

},{"cb7e64897cd141b5":"hWUVi","ef3b87c02860bebd":"1cs2r"}],"iNo8a":[function(require,module,exports) {
"use strict";
// lib
const { obj, fn } = require("953a00f8ff519246");
const file = require("8d6570cd26903ec7");
const a = require("97f846dd62ef1d55");
const sampler = require("fb84976182a2a9d6");
const lfo = require("42c340c6100cd338");
const reverb = require("8589f949ab6d138d");
const adsr = require("771db8702ccc245d");
const song = require("33a19d6ef6cf1e7a");
const rack = {
    1: {
        voices: {},
        // adsr1: a.adsr({gain: 0}),
        vcf: a.vcf({
            cutoff: 0.64
        }),
        reverb: a.create("reverb"),
        lfo: a.start(a.lfo({})),
        volume: a.vca({
            gain: 0.3
        }),
        context: a.context
    },
    2: {
        voices: {},
        // adsr1: a.adsr({gain: 0}),
        vcf: a.vcf({
            cutoff: 0.64
        }),
        reverb: a.create("reverb"),
        lfo: a.start(a.lfo({})),
        volume: a.vca({
            gain: 0.3
        }),
        context: a.context
    },
    3: {
        voices: {},
        // adsr1: a.adsr({gain: 0}),
        vcf: a.vcf({
            cutoff: 0.64
        }),
        reverb: a.create("reverb"),
        lfo: a.start(a.lfo({})),
        volume: a.vca({
            gain: 0.3
        }),
        context: a.context
    }
};
let unhook = ()=>{};
const hook = ({ state$, actions })=>{
    let subs = [];
    console.log(song.session.tracks);
    unhook = ()=>subs.forEach((sub)=>sub.unsubscribe());
};
module.exports = {
    hook,
    unhook: ()=>unhook()
};

},{"953a00f8ff519246":"2lXuw","8d6570cd26903ec7":"JPwLI","97f846dd62ef1d55":"hWZ4e","fb84976182a2a9d6":"52guS","42c340c6100cd338":"lVmqa","8589f949ab6d138d":"bS3Ri","771db8702ccc245d":"9iP5U","33a19d6ef6cf1e7a":"kV9Wt"}],"JPwLI":[function(require,module,exports) {
"use strict";
const { Observable, from, of, concat } = require("dd9d3cb8f5503ea7");
const { mergeMap, map } = require("b528e197ec26dafb");
const fileSaver = require("6b4d1a4518a4d451");
const jsZip = require("51c5f6cbbdc78ddb");
const { fn, obj } = require("7e12de702f15e227");
const load = (file, readAs = "text")=>new Observable((stream)=>{
        const fr = new FileReader();
        fr.onload = function(ev) {
            // console.log(readAs, ev.target.result);
            stream.next(readAs === "json" ? JSON.parse(ev.target.result) : ev.target.result);
            stream.complete();
        };
        // console.log(file, readAs);
        (typeof file === "string" ? from(fetch(file)).pipe(mergeMap((res)=>res.blob())) : of(file)).subscribe((f)=>fn.switch(readAs, {
                arrayBuffer: (f)=>fr.readAsArrayBuffer(f),
                default: (f)=>fr.readAsText(f)
            })(f));
    });
const loadZip = (file)=>load(file, "arrayBuffer").pipe(mergeMap((data)=>from(jsZip.loadAsync(data))), mergeMap((zf)=>concat(Object.keys(zf.files).filter((k)=>!zf.files[k].dir)// .map(k => (console.log(k), k))
        .map((k)=>from(zf.files[k].async("arraybuffer")).pipe(map((v)=>({
                    k,
                    v
                }))))).reduce((o, { k, v })=>obj.patch(o, k, v), {})));
const save = (fileName, content)=>fileSaver.saveAs(new Blob([
        JSON.stringify(content)
    ], {
        type: "text/plain;charset=utf-8"
    }), fileName);
module.exports = {
    load,
    loadZip,
    save
};

},{"dd9d3cb8f5503ea7":"hWUVi","b528e197ec26dafb":"1cs2r","6b4d1a4518a4d451":"jszm2","51c5f6cbbdc78ddb":"9fkhX","7e12de702f15e227":"2lXuw"}],"jszm2":[function(require,module,exports) {
var global = arguments[3];
(function(a, b) {
    if ("function" == typeof define && define.amd) define([], b);
    else b();
})(this, function() {
    "use strict";
    function b(a, b) {
        return "undefined" == typeof b ? b = {
            autoBom: !1
        } : "object" != typeof b && (console.warn("Deprecated: Expected third argument to be a object"), b = {
            autoBom: !b
        }), b.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a.type) ? new Blob([
            "\uFEFF",
            a
        ], {
            type: a.type
        }) : a;
    }
    function c(a, b, c) {
        var d = new XMLHttpRequest;
        d.open("GET", a), d.responseType = "blob", d.onload = function() {
            g(d.response, b, c);
        }, d.onerror = function() {
            console.error("could not download file");
        }, d.send();
    }
    function d(a) {
        var b = new XMLHttpRequest;
        b.open("HEAD", a, !1);
        try {
            b.send();
        } catch (a) {}
        return 200 <= b.status && 299 >= b.status;
    }
    function e(a) {
        try {
            a.dispatchEvent(new MouseEvent("click"));
        } catch (c) {
            var b = document.createEvent("MouseEvents");
            b.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), a.dispatchEvent(b);
        }
    }
    var f = "object" == typeof window && window.window === window ? window : "object" == typeof self && self.self === self ? self : "object" == typeof global && global.global === global ? global : void 0, a = f.navigator && /Macintosh/.test(navigator.userAgent) && /AppleWebKit/.test(navigator.userAgent) && !/Safari/.test(navigator.userAgent), g = f.saveAs || ("object" != typeof window || window !== f ? function() {} : "download" in HTMLAnchorElement.prototype && !a ? function(b, g, h) {
        var i = f.URL || f.webkitURL, j = document.createElement("a");
        g = g || b.name || "download", j.download = g, j.rel = "noopener", "string" == typeof b ? (j.href = b, j.origin === location.origin ? e(j) : d(j.href) ? c(b, g, h) : e(j, j.target = "_blank")) : (j.href = i.createObjectURL(b), setTimeout(function() {
            i.revokeObjectURL(j.href);
        }, 4E4), setTimeout(function() {
            e(j);
        }, 0));
    } : "msSaveOrOpenBlob" in navigator ? function(f, g, h) {
        if (g = g || f.name || "download", "string" != typeof f) navigator.msSaveOrOpenBlob(b(f, h), g);
        else if (d(f)) c(f, g, h);
        else {
            var i = document.createElement("a");
            i.href = f, i.target = "_blank", setTimeout(function() {
                e(i);
            });
        }
    } : function(b, d, e, g) {
        if (g = g || open("", "_blank"), g && (g.document.title = g.document.body.innerText = "downloading..."), "string" == typeof b) return c(b, d, e);
        var h = "application/octet-stream" === b.type, i = /constructor/i.test(f.HTMLElement) || f.safari, j = /CriOS\/[\d]+/.test(navigator.userAgent);
        if ((j || h && i || a) && "undefined" != typeof FileReader) {
            var k = new FileReader;
            k.onloadend = function() {
                var a = k.result;
                a = j ? a : a.replace(/^data:[^;]*;/, "data:attachment/file;"), g ? g.location.href = a : location = a, g = null;
            }, k.readAsDataURL(b);
        } else {
            var l = f.URL || f.webkitURL, m = l.createObjectURL(b);
            g ? g.location = m : location.href = m, g = null, setTimeout(function() {
                l.revokeObjectURL(m);
            }, 4E4);
        }
    });
    f.saveAs = g.saveAs = g, module.exports = g;
});

},{}],"9fkhX":[function(require,module,exports) {
/*!

JSZip v3.10.1 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/main/LICENSE
*/ var Buffer = require("4abb3f5ceb14a983").Buffer;
var global = arguments[3];
var process = require("268091f851e8cd54");
!function(e) {
    module.exports = e();
}(function() {
    return (function s(a, o, h) {
        function u(r, e) {
            if (!o[r]) {
                if (!a[r]) {
                    var t = undefined;
                    if (!e && t) return t(r, !0);
                    if (l) return l(r, !0);
                    var n = new Error("Cannot find module '" + r + "'");
                    throw n.code = "MODULE_NOT_FOUND", n;
                }
                var i = o[r] = {
                    exports: {}
                };
                a[r][0].call(i.exports, function(e) {
                    var t = a[r][1][e];
                    return u(t || e);
                }, i, i.exports, s, a, o, h);
            }
            return o[r].exports;
        }
        for(var l = undefined, e = 0; e < h.length; e++)u(h[e]);
        return u;
    })({
        1: [
            function(e, t, r) {
                "use strict";
                var d = e("./utils"), c = e("./support"), p = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
                r.encode = function(e) {
                    for(var t, r, n, i, s, a, o, h = [], u = 0, l = e.length, f = l, c = "string" !== d.getTypeOf(e); u < e.length;)f = l - u, n = c ? (t = e[u++], r = u < l ? e[u++] : 0, u < l ? e[u++] : 0) : (t = e.charCodeAt(u++), r = u < l ? e.charCodeAt(u++) : 0, u < l ? e.charCodeAt(u++) : 0), i = t >> 2, s = (3 & t) << 4 | r >> 4, a = 1 < f ? (15 & r) << 2 | n >> 6 : 64, o = 2 < f ? 63 & n : 64, h.push(p.charAt(i) + p.charAt(s) + p.charAt(a) + p.charAt(o));
                    return h.join("");
                }, r.decode = function(e) {
                    var t, r, n, i, s, a, o = 0, h = 0, u = "data:";
                    if (e.substr(0, u.length) === u) throw new Error("Invalid base64 input, it looks like a data url.");
                    var l, f = 3 * (e = e.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
                    if (e.charAt(e.length - 1) === p.charAt(64) && f--, e.charAt(e.length - 2) === p.charAt(64) && f--, f % 1 != 0) throw new Error("Invalid base64 input, bad content length.");
                    for(l = c.uint8array ? new Uint8Array(0 | f) : new Array(0 | f); o < e.length;)t = p.indexOf(e.charAt(o++)) << 2 | (i = p.indexOf(e.charAt(o++))) >> 4, r = (15 & i) << 4 | (s = p.indexOf(e.charAt(o++))) >> 2, n = (3 & s) << 6 | (a = p.indexOf(e.charAt(o++))), l[h++] = t, 64 !== s && (l[h++] = r), 64 !== a && (l[h++] = n);
                    return l;
                };
            },
            {
                "./support": 30,
                "./utils": 32
            }
        ],
        2: [
            function(e, t, r) {
                "use strict";
                var n = e("./external"), i = e("./stream/DataWorker"), s = e("./stream/Crc32Probe"), a = e("./stream/DataLengthProbe");
                function o(e, t, r, n, i) {
                    this.compressedSize = e, this.uncompressedSize = t, this.crc32 = r, this.compression = n, this.compressedContent = i;
                }
                o.prototype = {
                    getContentWorker: function() {
                        var e = new i(n.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new a("data_length")), t = this;
                        return e.on("end", function() {
                            if (this.streamInfo.data_length !== t.uncompressedSize) throw new Error("Bug : uncompressed data size mismatch");
                        }), e;
                    },
                    getCompressedWorker: function() {
                        return new i(n.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
                    }
                }, o.createWorkerFrom = function(e, t, r) {
                    return e.pipe(new s).pipe(new a("uncompressedSize")).pipe(t.compressWorker(r)).pipe(new a("compressedSize")).withStreamInfo("compression", t);
                }, t.exports = o;
            },
            {
                "./external": 6,
                "./stream/Crc32Probe": 25,
                "./stream/DataLengthProbe": 26,
                "./stream/DataWorker": 27
            }
        ],
        3: [
            function(e, t, r) {
                "use strict";
                var n = e("./stream/GenericWorker");
                r.STORE = {
                    magic: "\0\0",
                    compressWorker: function() {
                        return new n("STORE compression");
                    },
                    uncompressWorker: function() {
                        return new n("STORE decompression");
                    }
                }, r.DEFLATE = e("./flate");
            },
            {
                "./flate": 7,
                "./stream/GenericWorker": 28
            }
        ],
        4: [
            function(e, t, r) {
                "use strict";
                var n = e("./utils");
                var o = function() {
                    for(var e, t = [], r = 0; r < 256; r++){
                        e = r;
                        for(var n = 0; n < 8; n++)e = 1 & e ? 3988292384 ^ e >>> 1 : e >>> 1;
                        t[r] = e;
                    }
                    return t;
                }();
                t.exports = function(e, t) {
                    return void 0 !== e && e.length ? "string" !== n.getTypeOf(e) ? function(e, t, r, n) {
                        var i = o, s = n + r;
                        e ^= -1;
                        for(var a = n; a < s; a++)e = e >>> 8 ^ i[255 & (e ^ t[a])];
                        return -1 ^ e;
                    }(0 | t, e, e.length, 0) : function(e, t, r, n) {
                        var i = o, s = n + r;
                        e ^= -1;
                        for(var a = n; a < s; a++)e = e >>> 8 ^ i[255 & (e ^ t.charCodeAt(a))];
                        return -1 ^ e;
                    }(0 | t, e, e.length, 0) : 0;
                };
            },
            {
                "./utils": 32
            }
        ],
        5: [
            function(e, t, r) {
                "use strict";
                r.base64 = !1, r.binary = !1, r.dir = !1, r.createFolders = !0, r.date = null, r.compression = null, r.compressionOptions = null, r.comment = null, r.unixPermissions = null, r.dosPermissions = null;
            },
            {}
        ],
        6: [
            function(e, t, r) {
                "use strict";
                var n = null;
                n = "undefined" != typeof Promise ? Promise : e("lie"), t.exports = {
                    Promise: n
                };
            },
            {
                lie: 37
            }
        ],
        7: [
            function(e, t, r) {
                "use strict";
                var n = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Uint32Array, i = e("pako"), s = e("./utils"), a = e("./stream/GenericWorker"), o = n ? "uint8array" : "array";
                function h(e, t) {
                    a.call(this, "FlateWorker/" + e), this._pako = null, this._pakoAction = e, this._pakoOptions = t, this.meta = {};
                }
                r.magic = "\b\0", s.inherits(h, a), h.prototype.processChunk = function(e) {
                    this.meta = e.meta, null === this._pako && this._createPako(), this._pako.push(s.transformTo(o, e.data), !1);
                }, h.prototype.flush = function() {
                    a.prototype.flush.call(this), null === this._pako && this._createPako(), this._pako.push([], !0);
                }, h.prototype.cleanUp = function() {
                    a.prototype.cleanUp.call(this), this._pako = null;
                }, h.prototype._createPako = function() {
                    this._pako = new i[this._pakoAction]({
                        raw: !0,
                        level: this._pakoOptions.level || -1
                    });
                    var t = this;
                    this._pako.onData = function(e) {
                        t.push({
                            data: e,
                            meta: t.meta
                        });
                    };
                }, r.compressWorker = function(e) {
                    return new h("Deflate", e);
                }, r.uncompressWorker = function() {
                    return new h("Inflate", {});
                };
            },
            {
                "./stream/GenericWorker": 28,
                "./utils": 32,
                pako: 38
            }
        ],
        8: [
            function(e, t, r) {
                "use strict";
                function A(e, t) {
                    var r, n = "";
                    for(r = 0; r < t; r++)n += String.fromCharCode(255 & e), e >>>= 8;
                    return n;
                }
                function n(e, t, r, n, i, s) {
                    var a, o, h = e.file, u = e.compression, l = s !== O.utf8encode, f = I.transformTo("string", s(h.name)), c = I.transformTo("string", O.utf8encode(h.name)), d = h.comment, p = I.transformTo("string", s(d)), m = I.transformTo("string", O.utf8encode(d)), _ = c.length !== h.name.length, g = m.length !== d.length, b = "", v = "", y = "", w = h.dir, k = h.date, x = {
                        crc32: 0,
                        compressedSize: 0,
                        uncompressedSize: 0
                    };
                    t && !r || (x.crc32 = e.crc32, x.compressedSize = e.compressedSize, x.uncompressedSize = e.uncompressedSize);
                    var S = 0;
                    t && (S |= 8), l || !_ && !g || (S |= 2048);
                    var z = 0, C = 0;
                    w && (z |= 16), "UNIX" === i ? (C = 798, z |= function(e, t) {
                        var r = e;
                        return e || (r = t ? 16893 : 33204), (65535 & r) << 16;
                    }(h.unixPermissions, w)) : (C = 20, z |= function(e) {
                        return 63 & (e || 0);
                    }(h.dosPermissions)), a = k.getUTCHours(), a <<= 6, a |= k.getUTCMinutes(), a <<= 5, a |= k.getUTCSeconds() / 2, o = k.getUTCFullYear() - 1980, o <<= 4, o |= k.getUTCMonth() + 1, o <<= 5, o |= k.getUTCDate(), _ && (v = A(1, 1) + A(B(f), 4) + c, b += "up" + A(v.length, 2) + v), g && (y = A(1, 1) + A(B(p), 4) + m, b += "uc" + A(y.length, 2) + y);
                    var E = "";
                    return E += "\n\0", E += A(S, 2), E += u.magic, E += A(a, 2), E += A(o, 2), E += A(x.crc32, 4), E += A(x.compressedSize, 4), E += A(x.uncompressedSize, 4), E += A(f.length, 2), E += A(b.length, 2), {
                        fileRecord: R.LOCAL_FILE_HEADER + E + f + b,
                        dirRecord: R.CENTRAL_FILE_HEADER + A(C, 2) + E + A(p.length, 2) + "\0\0\0\0" + A(z, 4) + A(n, 4) + f + b + p
                    };
                }
                var I = e("../utils"), i = e("../stream/GenericWorker"), O = e("../utf8"), B = e("../crc32"), R = e("../signature");
                function s(e, t, r, n) {
                    i.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = t, this.zipPlatform = r, this.encodeFileName = n, this.streamFiles = e, this.accumulate = !1, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
                }
                I.inherits(s, i), s.prototype.push = function(e) {
                    var t = e.meta.percent || 0, r = this.entriesCount, n = this._sources.length;
                    this.accumulate ? this.contentBuffer.push(e) : (this.bytesWritten += e.data.length, i.prototype.push.call(this, {
                        data: e.data,
                        meta: {
                            currentFile: this.currentFile,
                            percent: r ? (t + 100 * (r - n - 1)) / r : 100
                        }
                    }));
                }, s.prototype.openedSource = function(e) {
                    this.currentSourceOffset = this.bytesWritten, this.currentFile = e.file.name;
                    var t = this.streamFiles && !e.file.dir;
                    if (t) {
                        var r = n(e, t, !1, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
                        this.push({
                            data: r.fileRecord,
                            meta: {
                                percent: 0
                            }
                        });
                    } else this.accumulate = !0;
                }, s.prototype.closedSource = function(e) {
                    this.accumulate = !1;
                    var t = this.streamFiles && !e.file.dir, r = n(e, t, !0, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
                    if (this.dirRecords.push(r.dirRecord), t) this.push({
                        data: function(e) {
                            return R.DATA_DESCRIPTOR + A(e.crc32, 4) + A(e.compressedSize, 4) + A(e.uncompressedSize, 4);
                        }(e),
                        meta: {
                            percent: 100
                        }
                    });
                    else for(this.push({
                        data: r.fileRecord,
                        meta: {
                            percent: 0
                        }
                    }); this.contentBuffer.length;)this.push(this.contentBuffer.shift());
                    this.currentFile = null;
                }, s.prototype.flush = function() {
                    for(var e = this.bytesWritten, t = 0; t < this.dirRecords.length; t++)this.push({
                        data: this.dirRecords[t],
                        meta: {
                            percent: 100
                        }
                    });
                    var r = this.bytesWritten - e, n = function(e, t, r, n, i) {
                        var s = I.transformTo("string", i(n));
                        return R.CENTRAL_DIRECTORY_END + "\0\0\0\0" + A(e, 2) + A(e, 2) + A(t, 4) + A(r, 4) + A(s.length, 2) + s;
                    }(this.dirRecords.length, r, e, this.zipComment, this.encodeFileName);
                    this.push({
                        data: n,
                        meta: {
                            percent: 100
                        }
                    });
                }, s.prototype.prepareNextSource = function() {
                    this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
                }, s.prototype.registerPrevious = function(e) {
                    this._sources.push(e);
                    var t = this;
                    return e.on("data", function(e) {
                        t.processChunk(e);
                    }), e.on("end", function() {
                        t.closedSource(t.previous.streamInfo), t._sources.length ? t.prepareNextSource() : t.end();
                    }), e.on("error", function(e) {
                        t.error(e);
                    }), this;
                }, s.prototype.resume = function() {
                    return !!i.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), !0) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), !0));
                }, s.prototype.error = function(e) {
                    var t = this._sources;
                    if (!i.prototype.error.call(this, e)) return !1;
                    for(var r = 0; r < t.length; r++)try {
                        t[r].error(e);
                    } catch (e) {}
                    return !0;
                }, s.prototype.lock = function() {
                    i.prototype.lock.call(this);
                    for(var e = this._sources, t = 0; t < e.length; t++)e[t].lock();
                }, t.exports = s;
            },
            {
                "../crc32": 4,
                "../signature": 23,
                "../stream/GenericWorker": 28,
                "../utf8": 31,
                "../utils": 32
            }
        ],
        9: [
            function(e, t, r) {
                "use strict";
                var u = e("../compressions"), n = e("./ZipFileWorker");
                r.generateWorker = function(e, a, t) {
                    var o = new n(a.streamFiles, t, a.platform, a.encodeFileName), h = 0;
                    try {
                        e.forEach(function(e, t) {
                            h++;
                            var r = function(e, t) {
                                var r = e || t, n = u[r];
                                if (!n) throw new Error(r + " is not a valid compression method !");
                                return n;
                            }(t.options.compression, a.compression), n = t.options.compressionOptions || a.compressionOptions || {}, i = t.dir, s = t.date;
                            t._compressWorker(r, n).withStreamInfo("file", {
                                name: e,
                                dir: i,
                                date: s,
                                comment: t.comment || "",
                                unixPermissions: t.unixPermissions,
                                dosPermissions: t.dosPermissions
                            }).pipe(o);
                        }), o.entriesCount = h;
                    } catch (e) {
                        o.error(e);
                    }
                    return o;
                };
            },
            {
                "../compressions": 3,
                "./ZipFileWorker": 8
            }
        ],
        10: [
            function(e, t, r) {
                "use strict";
                function n() {
                    if (!(this instanceof n)) return new n;
                    if (arguments.length) throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
                    this.files = Object.create(null), this.comment = null, this.root = "", this.clone = function() {
                        var e = new n;
                        for(var t in this)"function" != typeof this[t] && (e[t] = this[t]);
                        return e;
                    };
                }
                (n.prototype = e("./object")).loadAsync = e("./load"), n.support = e("./support"), n.defaults = e("./defaults"), n.version = "3.10.1", n.loadAsync = function(e, t) {
                    return (new n).loadAsync(e, t);
                }, n.external = e("./external"), t.exports = n;
            },
            {
                "./defaults": 5,
                "./external": 6,
                "./load": 11,
                "./object": 15,
                "./support": 30
            }
        ],
        11: [
            function(e, t, r) {
                "use strict";
                var u = e("./utils"), i = e("./external"), n = e("./utf8"), s = e("./zipEntries"), a = e("./stream/Crc32Probe"), l = e("./nodejsUtils");
                function f(n) {
                    return new i.Promise(function(e, t) {
                        var r = n.decompressed.getContentWorker().pipe(new a);
                        r.on("error", function(e) {
                            t(e);
                        }).on("end", function() {
                            r.streamInfo.crc32 !== n.decompressed.crc32 ? t(new Error("Corrupted zip : CRC32 mismatch")) : e();
                        }).resume();
                    });
                }
                t.exports = function(e, o) {
                    var h = this;
                    return o = u.extend(o || {}, {
                        base64: !1,
                        checkCRC32: !1,
                        optimizedBinaryString: !1,
                        createFolders: !1,
                        decodeFileName: n.utf8decode
                    }), l.isNode && l.isStream(e) ? i.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : u.prepareContent("the loaded zip file", e, !0, o.optimizedBinaryString, o.base64).then(function(e) {
                        var t = new s(o);
                        return t.load(e), t;
                    }).then(function(e) {
                        var t = [
                            i.Promise.resolve(e)
                        ], r = e.files;
                        if (o.checkCRC32) for(var n = 0; n < r.length; n++)t.push(f(r[n]));
                        return i.Promise.all(t);
                    }).then(function(e) {
                        for(var t = e.shift(), r = t.files, n = 0; n < r.length; n++){
                            var i = r[n], s = i.fileNameStr, a = u.resolve(i.fileNameStr);
                            h.file(a, i.decompressed, {
                                binary: !0,
                                optimizedBinaryString: !0,
                                date: i.date,
                                dir: i.dir,
                                comment: i.fileCommentStr.length ? i.fileCommentStr : null,
                                unixPermissions: i.unixPermissions,
                                dosPermissions: i.dosPermissions,
                                createFolders: o.createFolders
                            }), i.dir || (h.file(a).unsafeOriginalName = s);
                        }
                        return t.zipComment.length && (h.comment = t.zipComment), h;
                    });
                };
            },
            {
                "./external": 6,
                "./nodejsUtils": 14,
                "./stream/Crc32Probe": 25,
                "./utf8": 31,
                "./utils": 32,
                "./zipEntries": 33
            }
        ],
        12: [
            function(e, t, r) {
                "use strict";
                var n = e("../utils"), i = e("../stream/GenericWorker");
                function s(e, t) {
                    i.call(this, "Nodejs stream input adapter for " + e), this._upstreamEnded = !1, this._bindStream(t);
                }
                n.inherits(s, i), s.prototype._bindStream = function(e) {
                    var t = this;
                    (this._stream = e).pause(), e.on("data", function(e) {
                        t.push({
                            data: e,
                            meta: {
                                percent: 0
                            }
                        });
                    }).on("error", function(e) {
                        t.isPaused ? this.generatedError = e : t.error(e);
                    }).on("end", function() {
                        t.isPaused ? t._upstreamEnded = !0 : t.end();
                    });
                }, s.prototype.pause = function() {
                    return !!i.prototype.pause.call(this) && (this._stream.pause(), !0);
                }, s.prototype.resume = function() {
                    return !!i.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), !0);
                }, t.exports = s;
            },
            {
                "../stream/GenericWorker": 28,
                "../utils": 32
            }
        ],
        13: [
            function(e, t, r) {
                "use strict";
                var i = e("readable-stream").Readable;
                function n(e, t, r) {
                    i.call(this, t), this._helper = e;
                    var n = this;
                    e.on("data", function(e, t) {
                        n.push(e) || n._helper.pause(), r && r(t);
                    }).on("error", function(e) {
                        n.emit("error", e);
                    }).on("end", function() {
                        n.push(null);
                    });
                }
                e("../utils").inherits(n, i), n.prototype._read = function() {
                    this._helper.resume();
                }, t.exports = n;
            },
            {
                "../utils": 32,
                "readable-stream": 16
            }
        ],
        14: [
            function(e, t, r) {
                "use strict";
                t.exports = {
                    isNode: "undefined" != typeof Buffer,
                    newBufferFrom: function(e, t) {
                        if (Buffer.from && Buffer.from !== Uint8Array.from) return Buffer.from(e, t);
                        if ("number" == typeof e) throw new Error('The "data" argument must not be a number');
                        return new Buffer(e, t);
                    },
                    allocBuffer: function(e) {
                        if (Buffer.alloc) return Buffer.alloc(e);
                        var t = new Buffer(e);
                        return t.fill(0), t;
                    },
                    isBuffer: function(e) {
                        return Buffer.isBuffer(e);
                    },
                    isStream: function(e) {
                        return e && "function" == typeof e.on && "function" == typeof e.pause && "function" == typeof e.resume;
                    }
                };
            },
            {}
        ],
        15: [
            function(e, t, r) {
                "use strict";
                function s(e, t, r) {
                    var n, i = u.getTypeOf(t), s = u.extend(r || {}, f);
                    s.date = s.date || new Date, null !== s.compression && (s.compression = s.compression.toUpperCase()), "string" == typeof s.unixPermissions && (s.unixPermissions = parseInt(s.unixPermissions, 8)), s.unixPermissions && 16384 & s.unixPermissions && (s.dir = !0), s.dosPermissions && 16 & s.dosPermissions && (s.dir = !0), s.dir && (e = g(e)), s.createFolders && (n = _(e)) && b.call(this, n, !0);
                    var a = "string" === i && !1 === s.binary && !1 === s.base64;
                    r && void 0 !== r.binary || (s.binary = !a), (t instanceof c && 0 === t.uncompressedSize || s.dir || !t || 0 === t.length) && (s.base64 = !1, s.binary = !0, t = "", s.compression = "STORE", i = "string");
                    var o = null;
                    o = t instanceof c || t instanceof l ? t : p.isNode && p.isStream(t) ? new m(e, t) : u.prepareContent(e, t, s.binary, s.optimizedBinaryString, s.base64);
                    var h = new d(e, o, s);
                    this.files[e] = h;
                }
                var i = e("./utf8"), u = e("./utils"), l = e("./stream/GenericWorker"), a = e("./stream/StreamHelper"), f = e("./defaults"), c = e("./compressedObject"), d = e("./zipObject"), o = e("./generate"), p = e("./nodejsUtils"), m = e("./nodejs/NodejsStreamInputAdapter"), _ = function(e) {
                    "/" === e.slice(-1) && (e = e.substring(0, e.length - 1));
                    var t = e.lastIndexOf("/");
                    return 0 < t ? e.substring(0, t) : "";
                }, g = function(e) {
                    return "/" !== e.slice(-1) && (e += "/"), e;
                }, b = function(e, t) {
                    return t = void 0 !== t ? t : f.createFolders, e = g(e), this.files[e] || s.call(this, e, null, {
                        dir: !0,
                        createFolders: t
                    }), this.files[e];
                };
                function h(e) {
                    return "[object RegExp]" === Object.prototype.toString.call(e);
                }
                var n = {
                    load: function() {
                        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
                    },
                    forEach: function(e) {
                        var t, r, n;
                        for(t in this.files)n = this.files[t], (r = t.slice(this.root.length, t.length)) && t.slice(0, this.root.length) === this.root && e(r, n);
                    },
                    filter: function(r) {
                        var n = [];
                        return this.forEach(function(e, t) {
                            r(e, t) && n.push(t);
                        }), n;
                    },
                    file: function(e, t, r) {
                        if (1 !== arguments.length) return e = this.root + e, s.call(this, e, t, r), this;
                        if (h(e)) {
                            var n = e;
                            return this.filter(function(e, t) {
                                return !t.dir && n.test(e);
                            });
                        }
                        var i = this.files[this.root + e];
                        return i && !i.dir ? i : null;
                    },
                    folder: function(r) {
                        if (!r) return this;
                        if (h(r)) return this.filter(function(e, t) {
                            return t.dir && r.test(e);
                        });
                        var e = this.root + r, t = b.call(this, e), n = this.clone();
                        return n.root = t.name, n;
                    },
                    remove: function(r) {
                        r = this.root + r;
                        var e = this.files[r];
                        if (e || ("/" !== r.slice(-1) && (r += "/"), e = this.files[r]), e && !e.dir) delete this.files[r];
                        else for(var t = this.filter(function(e, t) {
                            return t.name.slice(0, r.length) === r;
                        }), n = 0; n < t.length; n++)delete this.files[t[n].name];
                        return this;
                    },
                    generate: function() {
                        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
                    },
                    generateInternalStream: function(e) {
                        var t, r = {};
                        try {
                            if ((r = u.extend(e || {}, {
                                streamFiles: !1,
                                compression: "STORE",
                                compressionOptions: null,
                                type: "",
                                platform: "DOS",
                                comment: null,
                                mimeType: "application/zip",
                                encodeFileName: i.utf8encode
                            })).type = r.type.toLowerCase(), r.compression = r.compression.toUpperCase(), "binarystring" === r.type && (r.type = "string"), !r.type) throw new Error("No output type specified.");
                            u.checkSupport(r.type), "darwin" !== r.platform && "freebsd" !== r.platform && "linux" !== r.platform && "sunos" !== r.platform || (r.platform = "UNIX"), "win32" === r.platform && (r.platform = "DOS");
                            var n = r.comment || this.comment || "";
                            t = o.generateWorker(this, r, n);
                        } catch (e) {
                            (t = new l("error")).error(e);
                        }
                        return new a(t, r.type || "string", r.mimeType);
                    },
                    generateAsync: function(e, t) {
                        return this.generateInternalStream(e).accumulate(t);
                    },
                    generateNodeStream: function(e, t) {
                        return (e = e || {}).type || (e.type = "nodebuffer"), this.generateInternalStream(e).toNodejsStream(t);
                    }
                };
                t.exports = n;
            },
            {
                "./compressedObject": 2,
                "./defaults": 5,
                "./generate": 9,
                "./nodejs/NodejsStreamInputAdapter": 12,
                "./nodejsUtils": 14,
                "./stream/GenericWorker": 28,
                "./stream/StreamHelper": 29,
                "./utf8": 31,
                "./utils": 32,
                "./zipObject": 35
            }
        ],
        16: [
            function(e, t, r) {
                "use strict";
                t.exports = e("stream");
            },
            {
                stream: void 0
            }
        ],
        17: [
            function(e, t, r) {
                "use strict";
                var n = e("./DataReader");
                function i(e) {
                    n.call(this, e);
                    for(var t = 0; t < this.data.length; t++)e[t] = 255 & e[t];
                }
                e("../utils").inherits(i, n), i.prototype.byteAt = function(e) {
                    return this.data[this.zero + e];
                }, i.prototype.lastIndexOfSignature = function(e) {
                    for(var t = e.charCodeAt(0), r = e.charCodeAt(1), n = e.charCodeAt(2), i = e.charCodeAt(3), s = this.length - 4; 0 <= s; --s)if (this.data[s] === t && this.data[s + 1] === r && this.data[s + 2] === n && this.data[s + 3] === i) return s - this.zero;
                    return -1;
                }, i.prototype.readAndCheckSignature = function(e) {
                    var t = e.charCodeAt(0), r = e.charCodeAt(1), n = e.charCodeAt(2), i = e.charCodeAt(3), s = this.readData(4);
                    return t === s[0] && r === s[1] && n === s[2] && i === s[3];
                }, i.prototype.readData = function(e) {
                    if (this.checkOffset(e), 0 === e) return [];
                    var t = this.data.slice(this.zero + this.index, this.zero + this.index + e);
                    return this.index += e, t;
                }, t.exports = i;
            },
            {
                "../utils": 32,
                "./DataReader": 18
            }
        ],
        18: [
            function(e, t, r) {
                "use strict";
                var n = e("../utils");
                function i(e) {
                    this.data = e, this.length = e.length, this.index = 0, this.zero = 0;
                }
                i.prototype = {
                    checkOffset: function(e) {
                        this.checkIndex(this.index + e);
                    },
                    checkIndex: function(e) {
                        if (this.length < this.zero + e || e < 0) throw new Error("End of data reached (data length = " + this.length + ", asked index = " + e + "). Corrupted zip ?");
                    },
                    setIndex: function(e) {
                        this.checkIndex(e), this.index = e;
                    },
                    skip: function(e) {
                        this.setIndex(this.index + e);
                    },
                    byteAt: function() {},
                    readInt: function(e) {
                        var t, r = 0;
                        for(this.checkOffset(e), t = this.index + e - 1; t >= this.index; t--)r = (r << 8) + this.byteAt(t);
                        return this.index += e, r;
                    },
                    readString: function(e) {
                        return n.transformTo("string", this.readData(e));
                    },
                    readData: function() {},
                    lastIndexOfSignature: function() {},
                    readAndCheckSignature: function() {},
                    readDate: function() {
                        var e = this.readInt(4);
                        return new Date(Date.UTC(1980 + (e >> 25 & 127), (e >> 21 & 15) - 1, e >> 16 & 31, e >> 11 & 31, e >> 5 & 63, (31 & e) << 1));
                    }
                }, t.exports = i;
            },
            {
                "../utils": 32
            }
        ],
        19: [
            function(e, t, r) {
                "use strict";
                var n = e("./Uint8ArrayReader");
                function i(e) {
                    n.call(this, e);
                }
                e("../utils").inherits(i, n), i.prototype.readData = function(e) {
                    this.checkOffset(e);
                    var t = this.data.slice(this.zero + this.index, this.zero + this.index + e);
                    return this.index += e, t;
                }, t.exports = i;
            },
            {
                "../utils": 32,
                "./Uint8ArrayReader": 21
            }
        ],
        20: [
            function(e, t, r) {
                "use strict";
                var n = e("./DataReader");
                function i(e) {
                    n.call(this, e);
                }
                e("../utils").inherits(i, n), i.prototype.byteAt = function(e) {
                    return this.data.charCodeAt(this.zero + e);
                }, i.prototype.lastIndexOfSignature = function(e) {
                    return this.data.lastIndexOf(e) - this.zero;
                }, i.prototype.readAndCheckSignature = function(e) {
                    return e === this.readData(4);
                }, i.prototype.readData = function(e) {
                    this.checkOffset(e);
                    var t = this.data.slice(this.zero + this.index, this.zero + this.index + e);
                    return this.index += e, t;
                }, t.exports = i;
            },
            {
                "../utils": 32,
                "./DataReader": 18
            }
        ],
        21: [
            function(e, t, r) {
                "use strict";
                var n = e("./ArrayReader");
                function i(e) {
                    n.call(this, e);
                }
                e("../utils").inherits(i, n), i.prototype.readData = function(e) {
                    if (this.checkOffset(e), 0 === e) return new Uint8Array(0);
                    var t = this.data.subarray(this.zero + this.index, this.zero + this.index + e);
                    return this.index += e, t;
                }, t.exports = i;
            },
            {
                "../utils": 32,
                "./ArrayReader": 17
            }
        ],
        22: [
            function(e, t, r) {
                "use strict";
                var n = e("../utils"), i = e("../support"), s = e("./ArrayReader"), a = e("./StringReader"), o = e("./NodeBufferReader"), h = e("./Uint8ArrayReader");
                t.exports = function(e) {
                    var t = n.getTypeOf(e);
                    return n.checkSupport(t), "string" !== t || i.uint8array ? "nodebuffer" === t ? new o(e) : i.uint8array ? new h(n.transformTo("uint8array", e)) : new s(n.transformTo("array", e)) : new a(e);
                };
            },
            {
                "../support": 30,
                "../utils": 32,
                "./ArrayReader": 17,
                "./NodeBufferReader": 19,
                "./StringReader": 20,
                "./Uint8ArrayReader": 21
            }
        ],
        23: [
            function(e, t, r) {
                "use strict";
                r.LOCAL_FILE_HEADER = "PK\x03\x04", r.CENTRAL_FILE_HEADER = "PK\x01\x02", r.CENTRAL_DIRECTORY_END = "PK\x05\x06", r.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x06\x07", r.ZIP64_CENTRAL_DIRECTORY_END = "PK\x06\x06", r.DATA_DESCRIPTOR = "PK\x07\b";
            },
            {}
        ],
        24: [
            function(e, t, r) {
                "use strict";
                var n = e("./GenericWorker"), i = e("../utils");
                function s(e) {
                    n.call(this, "ConvertWorker to " + e), this.destType = e;
                }
                i.inherits(s, n), s.prototype.processChunk = function(e) {
                    this.push({
                        data: i.transformTo(this.destType, e.data),
                        meta: e.meta
                    });
                }, t.exports = s;
            },
            {
                "../utils": 32,
                "./GenericWorker": 28
            }
        ],
        25: [
            function(e, t, r) {
                "use strict";
                var n = e("./GenericWorker"), i = e("../crc32");
                function s() {
                    n.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
                }
                e("../utils").inherits(s, n), s.prototype.processChunk = function(e) {
                    this.streamInfo.crc32 = i(e.data, this.streamInfo.crc32 || 0), this.push(e);
                }, t.exports = s;
            },
            {
                "../crc32": 4,
                "../utils": 32,
                "./GenericWorker": 28
            }
        ],
        26: [
            function(e, t, r) {
                "use strict";
                var n = e("../utils"), i = e("./GenericWorker");
                function s(e) {
                    i.call(this, "DataLengthProbe for " + e), this.propName = e, this.withStreamInfo(e, 0);
                }
                n.inherits(s, i), s.prototype.processChunk = function(e) {
                    if (e) {
                        var t = this.streamInfo[this.propName] || 0;
                        this.streamInfo[this.propName] = t + e.data.length;
                    }
                    i.prototype.processChunk.call(this, e);
                }, t.exports = s;
            },
            {
                "../utils": 32,
                "./GenericWorker": 28
            }
        ],
        27: [
            function(e, t, r) {
                "use strict";
                var n = e("../utils"), i = e("./GenericWorker");
                function s(e) {
                    i.call(this, "DataWorker");
                    var t = this;
                    this.dataIsReady = !1, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = !1, e.then(function(e) {
                        t.dataIsReady = !0, t.data = e, t.max = e && e.length || 0, t.type = n.getTypeOf(e), t.isPaused || t._tickAndRepeat();
                    }, function(e) {
                        t.error(e);
                    });
                }
                n.inherits(s, i), s.prototype.cleanUp = function() {
                    i.prototype.cleanUp.call(this), this.data = null;
                }, s.prototype.resume = function() {
                    return !!i.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = !0, n.delay(this._tickAndRepeat, [], this)), !0);
                }, s.prototype._tickAndRepeat = function() {
                    this._tickScheduled = !1, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (n.delay(this._tickAndRepeat, [], this), this._tickScheduled = !0));
                }, s.prototype._tick = function() {
                    if (this.isPaused || this.isFinished) return !1;
                    var e = null, t = Math.min(this.max, this.index + 16384);
                    if (this.index >= this.max) return this.end();
                    switch(this.type){
                        case "string":
                            e = this.data.substring(this.index, t);
                            break;
                        case "uint8array":
                            e = this.data.subarray(this.index, t);
                            break;
                        case "array":
                        case "nodebuffer":
                            e = this.data.slice(this.index, t);
                    }
                    return this.index = t, this.push({
                        data: e,
                        meta: {
                            percent: this.max ? this.index / this.max * 100 : 0
                        }
                    });
                }, t.exports = s;
            },
            {
                "../utils": 32,
                "./GenericWorker": 28
            }
        ],
        28: [
            function(e, t, r) {
                "use strict";
                function n(e) {
                    this.name = e || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = !0, this.isFinished = !1, this.isLocked = !1, this._listeners = {
                        data: [],
                        end: [],
                        error: []
                    }, this.previous = null;
                }
                n.prototype = {
                    push: function(e) {
                        this.emit("data", e);
                    },
                    end: function() {
                        if (this.isFinished) return !1;
                        this.flush();
                        try {
                            this.emit("end"), this.cleanUp(), this.isFinished = !0;
                        } catch (e) {
                            this.emit("error", e);
                        }
                        return !0;
                    },
                    error: function(e) {
                        return !this.isFinished && (this.isPaused ? this.generatedError = e : (this.isFinished = !0, this.emit("error", e), this.previous && this.previous.error(e), this.cleanUp()), !0);
                    },
                    on: function(e, t) {
                        return this._listeners[e].push(t), this;
                    },
                    cleanUp: function() {
                        this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
                    },
                    emit: function(e, t) {
                        if (this._listeners[e]) for(var r = 0; r < this._listeners[e].length; r++)this._listeners[e][r].call(this, t);
                    },
                    pipe: function(e) {
                        return e.registerPrevious(this);
                    },
                    registerPrevious: function(e) {
                        if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
                        this.streamInfo = e.streamInfo, this.mergeStreamInfo(), this.previous = e;
                        var t = this;
                        return e.on("data", function(e) {
                            t.processChunk(e);
                        }), e.on("end", function() {
                            t.end();
                        }), e.on("error", function(e) {
                            t.error(e);
                        }), this;
                    },
                    pause: function() {
                        return !this.isPaused && !this.isFinished && (this.isPaused = !0, this.previous && this.previous.pause(), !0);
                    },
                    resume: function() {
                        if (!this.isPaused || this.isFinished) return !1;
                        var e = this.isPaused = !1;
                        return this.generatedError && (this.error(this.generatedError), e = !0), this.previous && this.previous.resume(), !e;
                    },
                    flush: function() {},
                    processChunk: function(e) {
                        this.push(e);
                    },
                    withStreamInfo: function(e, t) {
                        return this.extraStreamInfo[e] = t, this.mergeStreamInfo(), this;
                    },
                    mergeStreamInfo: function() {
                        for(var e in this.extraStreamInfo)Object.prototype.hasOwnProperty.call(this.extraStreamInfo, e) && (this.streamInfo[e] = this.extraStreamInfo[e]);
                    },
                    lock: function() {
                        if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
                        this.isLocked = !0, this.previous && this.previous.lock();
                    },
                    toString: function() {
                        var e = "Worker " + this.name;
                        return this.previous ? this.previous + " -> " + e : e;
                    }
                }, t.exports = n;
            },
            {}
        ],
        29: [
            function(e, t, r) {
                "use strict";
                var h = e("../utils"), i = e("./ConvertWorker"), s = e("./GenericWorker"), u = e("../base64"), n = e("../support"), a = e("../external"), o = null;
                if (n.nodestream) try {
                    o = e("../nodejs/NodejsStreamOutputAdapter");
                } catch (e) {}
                function l(e, o) {
                    return new a.Promise(function(t, r) {
                        var n = [], i = e._internalType, s = e._outputType, a = e._mimeType;
                        e.on("data", function(e, t) {
                            n.push(e), o && o(t);
                        }).on("error", function(e) {
                            n = [], r(e);
                        }).on("end", function() {
                            try {
                                var e = function(e, t, r) {
                                    switch(e){
                                        case "blob":
                                            return h.newBlob(h.transformTo("arraybuffer", t), r);
                                        case "base64":
                                            return u.encode(t);
                                        default:
                                            return h.transformTo(e, t);
                                    }
                                }(s, function(e, t) {
                                    var r, n = 0, i = null, s = 0;
                                    for(r = 0; r < t.length; r++)s += t[r].length;
                                    switch(e){
                                        case "string":
                                            return t.join("");
                                        case "array":
                                            return Array.prototype.concat.apply([], t);
                                        case "uint8array":
                                            for(i = new Uint8Array(s), r = 0; r < t.length; r++)i.set(t[r], n), n += t[r].length;
                                            return i;
                                        case "nodebuffer":
                                            return Buffer.concat(t);
                                        default:
                                            throw new Error("concat : unsupported type '" + e + "'");
                                    }
                                }(i, n), a);
                                t(e);
                            } catch (e) {
                                r(e);
                            }
                            n = [];
                        }).resume();
                    });
                }
                function f(e, t, r) {
                    var n = t;
                    switch(t){
                        case "blob":
                        case "arraybuffer":
                            n = "uint8array";
                            break;
                        case "base64":
                            n = "string";
                    }
                    try {
                        this._internalType = n, this._outputType = t, this._mimeType = r, h.checkSupport(n), this._worker = e.pipe(new i(n)), e.lock();
                    } catch (e) {
                        this._worker = new s("error"), this._worker.error(e);
                    }
                }
                f.prototype = {
                    accumulate: function(e) {
                        return l(this, e);
                    },
                    on: function(e, t) {
                        var r = this;
                        return "data" === e ? this._worker.on(e, function(e) {
                            t.call(r, e.data, e.meta);
                        }) : this._worker.on(e, function() {
                            h.delay(t, arguments, r);
                        }), this;
                    },
                    resume: function() {
                        return h.delay(this._worker.resume, [], this._worker), this;
                    },
                    pause: function() {
                        return this._worker.pause(), this;
                    },
                    toNodejsStream: function(e) {
                        if (h.checkSupport("nodestream"), "nodebuffer" !== this._outputType) throw new Error(this._outputType + " is not supported by this method");
                        return new o(this, {
                            objectMode: "nodebuffer" !== this._outputType
                        }, e);
                    }
                }, t.exports = f;
            },
            {
                "../base64": 1,
                "../external": 6,
                "../nodejs/NodejsStreamOutputAdapter": 13,
                "../support": 30,
                "../utils": 32,
                "./ConvertWorker": 24,
                "./GenericWorker": 28
            }
        ],
        30: [
            function(e, t, r) {
                "use strict";
                if (r.base64 = !0, r.array = !0, r.string = !0, r.arraybuffer = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array, r.nodebuffer = "undefined" != typeof Buffer, r.uint8array = "undefined" != typeof Uint8Array, "undefined" == typeof ArrayBuffer) r.blob = !1;
                else {
                    var n = new ArrayBuffer(0);
                    try {
                        r.blob = 0 === new Blob([
                            n
                        ], {
                            type: "application/zip"
                        }).size;
                    } catch (e) {
                        try {
                            var i = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder);
                            i.append(n), r.blob = 0 === i.getBlob("application/zip").size;
                        } catch (e) {
                            r.blob = !1;
                        }
                    }
                }
                try {
                    r.nodestream = !!e("readable-stream").Readable;
                } catch (e) {
                    r.nodestream = !1;
                }
            },
            {
                "readable-stream": 16
            }
        ],
        31: [
            function(e, t, s) {
                "use strict";
                for(var o = e("./utils"), h = e("./support"), r = e("./nodejsUtils"), n = e("./stream/GenericWorker"), u = new Array(256), i = 0; i < 256; i++)u[i] = 252 <= i ? 6 : 248 <= i ? 5 : 240 <= i ? 4 : 224 <= i ? 3 : 192 <= i ? 2 : 1;
                u[254] = u[254] = 1;
                function a() {
                    n.call(this, "utf-8 decode"), this.leftOver = null;
                }
                function l() {
                    n.call(this, "utf-8 encode");
                }
                s.utf8encode = function(e) {
                    return h.nodebuffer ? r.newBufferFrom(e, "utf-8") : function(e) {
                        var t, r, n, i, s, a = e.length, o = 0;
                        for(i = 0; i < a; i++)55296 == (64512 & (r = e.charCodeAt(i))) && i + 1 < a && 56320 == (64512 & (n = e.charCodeAt(i + 1))) && (r = 65536 + (r - 55296 << 10) + (n - 56320), i++), o += r < 128 ? 1 : r < 2048 ? 2 : r < 65536 ? 3 : 4;
                        for(t = h.uint8array ? new Uint8Array(o) : new Array(o), i = s = 0; s < o; i++)55296 == (64512 & (r = e.charCodeAt(i))) && i + 1 < a && 56320 == (64512 & (n = e.charCodeAt(i + 1))) && (r = 65536 + (r - 55296 << 10) + (n - 56320), i++), r < 128 ? t[s++] = r : (r < 2048 ? t[s++] = 192 | r >>> 6 : (r < 65536 ? t[s++] = 224 | r >>> 12 : (t[s++] = 240 | r >>> 18, t[s++] = 128 | r >>> 12 & 63), t[s++] = 128 | r >>> 6 & 63), t[s++] = 128 | 63 & r);
                        return t;
                    }(e);
                }, s.utf8decode = function(e) {
                    return h.nodebuffer ? o.transformTo("nodebuffer", e).toString("utf-8") : function(e) {
                        var t, r, n, i, s = e.length, a = new Array(2 * s);
                        for(t = r = 0; t < s;)if ((n = e[t++]) < 128) a[r++] = n;
                        else if (4 < (i = u[n])) a[r++] = 65533, t += i - 1;
                        else {
                            for(n &= 2 === i ? 31 : 3 === i ? 15 : 7; 1 < i && t < s;)n = n << 6 | 63 & e[t++], i--;
                            1 < i ? a[r++] = 65533 : n < 65536 ? a[r++] = n : (n -= 65536, a[r++] = 55296 | n >> 10 & 1023, a[r++] = 56320 | 1023 & n);
                        }
                        return a.length !== r && (a.subarray ? a = a.subarray(0, r) : a.length = r), o.applyFromCharCode(a);
                    }(e = o.transformTo(h.uint8array ? "uint8array" : "array", e));
                }, o.inherits(a, n), a.prototype.processChunk = function(e) {
                    var t = o.transformTo(h.uint8array ? "uint8array" : "array", e.data);
                    if (this.leftOver && this.leftOver.length) {
                        if (h.uint8array) {
                            var r = t;
                            (t = new Uint8Array(r.length + this.leftOver.length)).set(this.leftOver, 0), t.set(r, this.leftOver.length);
                        } else t = this.leftOver.concat(t);
                        this.leftOver = null;
                    }
                    var n = function(e, t) {
                        var r;
                        for((t = t || e.length) > e.length && (t = e.length), r = t - 1; 0 <= r && 128 == (192 & e[r]);)r--;
                        return r < 0 ? t : 0 === r ? t : r + u[e[r]] > t ? r : t;
                    }(t), i = t;
                    n !== t.length && (h.uint8array ? (i = t.subarray(0, n), this.leftOver = t.subarray(n, t.length)) : (i = t.slice(0, n), this.leftOver = t.slice(n, t.length))), this.push({
                        data: s.utf8decode(i),
                        meta: e.meta
                    });
                }, a.prototype.flush = function() {
                    this.leftOver && this.leftOver.length && (this.push({
                        data: s.utf8decode(this.leftOver),
                        meta: {}
                    }), this.leftOver = null);
                }, s.Utf8DecodeWorker = a, o.inherits(l, n), l.prototype.processChunk = function(e) {
                    this.push({
                        data: s.utf8encode(e.data),
                        meta: e.meta
                    });
                }, s.Utf8EncodeWorker = l;
            },
            {
                "./nodejsUtils": 14,
                "./stream/GenericWorker": 28,
                "./support": 30,
                "./utils": 32
            }
        ],
        32: [
            function(e, t, a) {
                "use strict";
                var o = e("./support"), h = e("./base64"), r = e("./nodejsUtils"), u = e("./external");
                function n(e) {
                    return e;
                }
                function l(e, t) {
                    for(var r = 0; r < e.length; ++r)t[r] = 255 & e.charCodeAt(r);
                    return t;
                }
                e("setimmediate"), a.newBlob = function(t, r) {
                    a.checkSupport("blob");
                    try {
                        return new Blob([
                            t
                        ], {
                            type: r
                        });
                    } catch (e) {
                        try {
                            var n = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder);
                            return n.append(t), n.getBlob(r);
                        } catch (e) {
                            throw new Error("Bug : can't construct the Blob.");
                        }
                    }
                };
                var i = {
                    stringifyByChunk: function(e, t, r) {
                        var n = [], i = 0, s = e.length;
                        if (s <= r) return String.fromCharCode.apply(null, e);
                        for(; i < s;)"array" === t || "nodebuffer" === t ? n.push(String.fromCharCode.apply(null, e.slice(i, Math.min(i + r, s)))) : n.push(String.fromCharCode.apply(null, e.subarray(i, Math.min(i + r, s)))), i += r;
                        return n.join("");
                    },
                    stringifyByChar: function(e) {
                        for(var t = "", r = 0; r < e.length; r++)t += String.fromCharCode(e[r]);
                        return t;
                    },
                    applyCanBeUsed: {
                        uint8array: function() {
                            try {
                                return o.uint8array && 1 === String.fromCharCode.apply(null, new Uint8Array(1)).length;
                            } catch (e) {
                                return !1;
                            }
                        }(),
                        nodebuffer: function() {
                            try {
                                return o.nodebuffer && 1 === String.fromCharCode.apply(null, r.allocBuffer(1)).length;
                            } catch (e) {
                                return !1;
                            }
                        }()
                    }
                };
                function s(e) {
                    var t = 65536, r = a.getTypeOf(e), n = !0;
                    if ("uint8array" === r ? n = i.applyCanBeUsed.uint8array : "nodebuffer" === r && (n = i.applyCanBeUsed.nodebuffer), n) for(; 1 < t;)try {
                        return i.stringifyByChunk(e, r, t);
                    } catch (e) {
                        t = Math.floor(t / 2);
                    }
                    return i.stringifyByChar(e);
                }
                function f(e, t) {
                    for(var r = 0; r < e.length; r++)t[r] = e[r];
                    return t;
                }
                a.applyFromCharCode = s;
                var c = {};
                c.string = {
                    string: n,
                    array: function(e) {
                        return l(e, new Array(e.length));
                    },
                    arraybuffer: function(e) {
                        return c.string.uint8array(e).buffer;
                    },
                    uint8array: function(e) {
                        return l(e, new Uint8Array(e.length));
                    },
                    nodebuffer: function(e) {
                        return l(e, r.allocBuffer(e.length));
                    }
                }, c.array = {
                    string: s,
                    array: n,
                    arraybuffer: function(e) {
                        return new Uint8Array(e).buffer;
                    },
                    uint8array: function(e) {
                        return new Uint8Array(e);
                    },
                    nodebuffer: function(e) {
                        return r.newBufferFrom(e);
                    }
                }, c.arraybuffer = {
                    string: function(e) {
                        return s(new Uint8Array(e));
                    },
                    array: function(e) {
                        return f(new Uint8Array(e), new Array(e.byteLength));
                    },
                    arraybuffer: n,
                    uint8array: function(e) {
                        return new Uint8Array(e);
                    },
                    nodebuffer: function(e) {
                        return r.newBufferFrom(new Uint8Array(e));
                    }
                }, c.uint8array = {
                    string: s,
                    array: function(e) {
                        return f(e, new Array(e.length));
                    },
                    arraybuffer: function(e) {
                        return e.buffer;
                    },
                    uint8array: n,
                    nodebuffer: function(e) {
                        return r.newBufferFrom(e);
                    }
                }, c.nodebuffer = {
                    string: s,
                    array: function(e) {
                        return f(e, new Array(e.length));
                    },
                    arraybuffer: function(e) {
                        return c.nodebuffer.uint8array(e).buffer;
                    },
                    uint8array: function(e) {
                        return f(e, new Uint8Array(e.length));
                    },
                    nodebuffer: n
                }, a.transformTo = function(e, t) {
                    if (t = t || "", !e) return t;
                    a.checkSupport(e);
                    var r = a.getTypeOf(t);
                    return c[r][e](t);
                }, a.resolve = function(e) {
                    for(var t = e.split("/"), r = [], n = 0; n < t.length; n++){
                        var i = t[n];
                        "." === i || "" === i && 0 !== n && n !== t.length - 1 || (".." === i ? r.pop() : r.push(i));
                    }
                    return r.join("/");
                }, a.getTypeOf = function(e) {
                    return "string" == typeof e ? "string" : "[object Array]" === Object.prototype.toString.call(e) ? "array" : o.nodebuffer && r.isBuffer(e) ? "nodebuffer" : o.uint8array && e instanceof Uint8Array ? "uint8array" : o.arraybuffer && e instanceof ArrayBuffer ? "arraybuffer" : void 0;
                }, a.checkSupport = function(e) {
                    if (!o[e.toLowerCase()]) throw new Error(e + " is not supported by this platform");
                }, a.MAX_VALUE_16BITS = 65535, a.MAX_VALUE_32BITS = -1, a.pretty = function(e) {
                    var t, r, n = "";
                    for(r = 0; r < (e || "").length; r++)n += "\\x" + ((t = e.charCodeAt(r)) < 16 ? "0" : "") + t.toString(16).toUpperCase();
                    return n;
                }, a.delay = function(e, t, r) {
                    setImmediate(function() {
                        e.apply(r || null, t || []);
                    });
                }, a.inherits = function(e, t) {
                    function r() {}
                    r.prototype = t.prototype, e.prototype = new r;
                }, a.extend = function() {
                    var e, t, r = {};
                    for(e = 0; e < arguments.length; e++)for(t in arguments[e])Object.prototype.hasOwnProperty.call(arguments[e], t) && void 0 === r[t] && (r[t] = arguments[e][t]);
                    return r;
                }, a.prepareContent = function(r, e, n, i, s) {
                    return u.Promise.resolve(e).then(function(n) {
                        return o.blob && (n instanceof Blob || -1 !== [
                            "[object File]",
                            "[object Blob]"
                        ].indexOf(Object.prototype.toString.call(n))) && "undefined" != typeof FileReader ? new u.Promise(function(t, r) {
                            var e = new FileReader;
                            e.onload = function(e) {
                                t(e.target.result);
                            }, e.onerror = function(e) {
                                r(e.target.error);
                            }, e.readAsArrayBuffer(n);
                        }) : n;
                    }).then(function(e) {
                        var t = a.getTypeOf(e);
                        return t ? ("arraybuffer" === t ? e = a.transformTo("uint8array", e) : "string" === t && (s ? e = h.decode(e) : n && !0 !== i && (e = function(e) {
                            return l(e, o.uint8array ? new Uint8Array(e.length) : new Array(e.length));
                        }(e))), e) : u.Promise.reject(new Error("Can't read the data of '" + r + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
                    });
                };
            },
            {
                "./base64": 1,
                "./external": 6,
                "./nodejsUtils": 14,
                "./support": 30,
                setimmediate: 54
            }
        ],
        33: [
            function(e, t, r) {
                "use strict";
                var n = e("./reader/readerFor"), i = e("./utils"), s = e("./signature"), a = e("./zipEntry"), o = e("./support");
                function h(e) {
                    this.files = [], this.loadOptions = e;
                }
                h.prototype = {
                    checkSignature: function(e) {
                        if (!this.reader.readAndCheckSignature(e)) {
                            this.reader.index -= 4;
                            var t = this.reader.readString(4);
                            throw new Error("Corrupted zip or bug: unexpected signature (" + i.pretty(t) + ", expected " + i.pretty(e) + ")");
                        }
                    },
                    isSignature: function(e, t) {
                        var r = this.reader.index;
                        this.reader.setIndex(e);
                        var n = this.reader.readString(4) === t;
                        return this.reader.setIndex(r), n;
                    },
                    readBlockEndOfCentral: function() {
                        this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
                        var e = this.reader.readData(this.zipCommentLength), t = o.uint8array ? "uint8array" : "array", r = i.transformTo(t, e);
                        this.zipComment = this.loadOptions.decodeFileName(r);
                    },
                    readBlockZip64EndOfCentral: function() {
                        this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
                        for(var e, t, r, n = this.zip64EndOfCentralSize - 44; 0 < n;)e = this.reader.readInt(2), t = this.reader.readInt(4), r = this.reader.readData(t), this.zip64ExtensibleData[e] = {
                            id: e,
                            length: t,
                            value: r
                        };
                    },
                    readBlockZip64EndOfCentralLocator: function() {
                        if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount) throw new Error("Multi-volumes zip are not supported");
                    },
                    readLocalFiles: function() {
                        var e, t;
                        for(e = 0; e < this.files.length; e++)t = this.files[e], this.reader.setIndex(t.localHeaderOffset), this.checkSignature(s.LOCAL_FILE_HEADER), t.readLocalPart(this.reader), t.handleUTF8(), t.processAttributes();
                    },
                    readCentralDir: function() {
                        var e;
                        for(this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(s.CENTRAL_FILE_HEADER);)(e = new a({
                            zip64: this.zip64
                        }, this.loadOptions)).readCentralPart(this.reader), this.files.push(e);
                        if (this.centralDirRecords !== this.files.length && 0 !== this.centralDirRecords && 0 === this.files.length) throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
                    },
                    readEndOfCentral: function() {
                        var e = this.reader.lastIndexOfSignature(s.CENTRAL_DIRECTORY_END);
                        if (e < 0) throw !this.isSignature(0, s.LOCAL_FILE_HEADER) ? new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html") : new Error("Corrupted zip: can't find end of central directory");
                        this.reader.setIndex(e);
                        var t = e;
                        if (this.checkSignature(s.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === i.MAX_VALUE_16BITS || this.diskWithCentralDirStart === i.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === i.MAX_VALUE_16BITS || this.centralDirRecords === i.MAX_VALUE_16BITS || this.centralDirSize === i.MAX_VALUE_32BITS || this.centralDirOffset === i.MAX_VALUE_32BITS) {
                            if (this.zip64 = !0, (e = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
                            if (this.reader.setIndex(e), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, s.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0)) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
                            this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
                        }
                        var r = this.centralDirOffset + this.centralDirSize;
                        this.zip64 && (r += 20, r += 12 + this.zip64EndOfCentralSize);
                        var n = t - r;
                        if (0 < n) this.isSignature(t, s.CENTRAL_FILE_HEADER) || (this.reader.zero = n);
                        else if (n < 0) throw new Error("Corrupted zip: missing " + Math.abs(n) + " bytes.");
                    },
                    prepareReader: function(e) {
                        this.reader = n(e);
                    },
                    load: function(e) {
                        this.prepareReader(e), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
                    }
                }, t.exports = h;
            },
            {
                "./reader/readerFor": 22,
                "./signature": 23,
                "./support": 30,
                "./utils": 32,
                "./zipEntry": 34
            }
        ],
        34: [
            function(e, t, r) {
                "use strict";
                var n = e("./reader/readerFor"), s = e("./utils"), i = e("./compressedObject"), a = e("./crc32"), o = e("./utf8"), h = e("./compressions"), u = e("./support");
                function l(e, t) {
                    this.options = e, this.loadOptions = t;
                }
                l.prototype = {
                    isEncrypted: function() {
                        return 1 == (1 & this.bitFlag);
                    },
                    useUTF8: function() {
                        return 2048 == (2048 & this.bitFlag);
                    },
                    readLocalPart: function(e) {
                        var t, r;
                        if (e.skip(22), this.fileNameLength = e.readInt(2), r = e.readInt(2), this.fileName = e.readData(this.fileNameLength), e.skip(r), -1 === this.compressedSize || -1 === this.uncompressedSize) throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
                        if (null === (t = function(e) {
                            for(var t in h)if (Object.prototype.hasOwnProperty.call(h, t) && h[t].magic === e) return h[t];
                            return null;
                        }(this.compressionMethod))) throw new Error("Corrupted zip : compression " + s.pretty(this.compressionMethod) + " unknown (inner file : " + s.transformTo("string", this.fileName) + ")");
                        this.decompressed = new i(this.compressedSize, this.uncompressedSize, this.crc32, t, e.readData(this.compressedSize));
                    },
                    readCentralPart: function(e) {
                        this.versionMadeBy = e.readInt(2), e.skip(2), this.bitFlag = e.readInt(2), this.compressionMethod = e.readString(2), this.date = e.readDate(), this.crc32 = e.readInt(4), this.compressedSize = e.readInt(4), this.uncompressedSize = e.readInt(4);
                        var t = e.readInt(2);
                        if (this.extraFieldsLength = e.readInt(2), this.fileCommentLength = e.readInt(2), this.diskNumberStart = e.readInt(2), this.internalFileAttributes = e.readInt(2), this.externalFileAttributes = e.readInt(4), this.localHeaderOffset = e.readInt(4), this.isEncrypted()) throw new Error("Encrypted zip are not supported");
                        e.skip(t), this.readExtraFields(e), this.parseZIP64ExtraField(e), this.fileComment = e.readData(this.fileCommentLength);
                    },
                    processAttributes: function() {
                        this.unixPermissions = null, this.dosPermissions = null;
                        var e = this.versionMadeBy >> 8;
                        this.dir = !!(16 & this.externalFileAttributes), 0 == e && (this.dosPermissions = 63 & this.externalFileAttributes), 3 == e && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || "/" !== this.fileNameStr.slice(-1) || (this.dir = !0);
                    },
                    parseZIP64ExtraField: function() {
                        if (this.extraFields[1]) {
                            var e = n(this.extraFields[1].value);
                            this.uncompressedSize === s.MAX_VALUE_32BITS && (this.uncompressedSize = e.readInt(8)), this.compressedSize === s.MAX_VALUE_32BITS && (this.compressedSize = e.readInt(8)), this.localHeaderOffset === s.MAX_VALUE_32BITS && (this.localHeaderOffset = e.readInt(8)), this.diskNumberStart === s.MAX_VALUE_32BITS && (this.diskNumberStart = e.readInt(4));
                        }
                    },
                    readExtraFields: function(e) {
                        var t, r, n, i = e.index + this.extraFieldsLength;
                        for(this.extraFields || (this.extraFields = {}); e.index + 4 < i;)t = e.readInt(2), r = e.readInt(2), n = e.readData(r), this.extraFields[t] = {
                            id: t,
                            length: r,
                            value: n
                        };
                        e.setIndex(i);
                    },
                    handleUTF8: function() {
                        var e = u.uint8array ? "uint8array" : "array";
                        if (this.useUTF8()) this.fileNameStr = o.utf8decode(this.fileName), this.fileCommentStr = o.utf8decode(this.fileComment);
                        else {
                            var t = this.findExtraFieldUnicodePath();
                            if (null !== t) this.fileNameStr = t;
                            else {
                                var r = s.transformTo(e, this.fileName);
                                this.fileNameStr = this.loadOptions.decodeFileName(r);
                            }
                            var n = this.findExtraFieldUnicodeComment();
                            if (null !== n) this.fileCommentStr = n;
                            else {
                                var i = s.transformTo(e, this.fileComment);
                                this.fileCommentStr = this.loadOptions.decodeFileName(i);
                            }
                        }
                    },
                    findExtraFieldUnicodePath: function() {
                        var e = this.extraFields[28789];
                        if (e) {
                            var t = n(e.value);
                            return 1 !== t.readInt(1) ? null : a(this.fileName) !== t.readInt(4) ? null : o.utf8decode(t.readData(e.length - 5));
                        }
                        return null;
                    },
                    findExtraFieldUnicodeComment: function() {
                        var e = this.extraFields[25461];
                        if (e) {
                            var t = n(e.value);
                            return 1 !== t.readInt(1) ? null : a(this.fileComment) !== t.readInt(4) ? null : o.utf8decode(t.readData(e.length - 5));
                        }
                        return null;
                    }
                }, t.exports = l;
            },
            {
                "./compressedObject": 2,
                "./compressions": 3,
                "./crc32": 4,
                "./reader/readerFor": 22,
                "./support": 30,
                "./utf8": 31,
                "./utils": 32
            }
        ],
        35: [
            function(e, t, r) {
                "use strict";
                function n(e, t, r) {
                    this.name = e, this.dir = r.dir, this.date = r.date, this.comment = r.comment, this.unixPermissions = r.unixPermissions, this.dosPermissions = r.dosPermissions, this._data = t, this._dataBinary = r.binary, this.options = {
                        compression: r.compression,
                        compressionOptions: r.compressionOptions
                    };
                }
                var s = e("./stream/StreamHelper"), i = e("./stream/DataWorker"), a = e("./utf8"), o = e("./compressedObject"), h = e("./stream/GenericWorker");
                n.prototype = {
                    internalStream: function(e) {
                        var t = null, r = "string";
                        try {
                            if (!e) throw new Error("No output type specified.");
                            var n = "string" === (r = e.toLowerCase()) || "text" === r;
                            "binarystring" !== r && "text" !== r || (r = "string"), t = this._decompressWorker();
                            var i = !this._dataBinary;
                            i && !n && (t = t.pipe(new a.Utf8EncodeWorker)), !i && n && (t = t.pipe(new a.Utf8DecodeWorker));
                        } catch (e) {
                            (t = new h("error")).error(e);
                        }
                        return new s(t, r, "");
                    },
                    async: function(e, t) {
                        return this.internalStream(e).accumulate(t);
                    },
                    nodeStream: function(e, t) {
                        return this.internalStream(e || "nodebuffer").toNodejsStream(t);
                    },
                    _compressWorker: function(e, t) {
                        if (this._data instanceof o && this._data.compression.magic === e.magic) return this._data.getCompressedWorker();
                        var r = this._decompressWorker();
                        return this._dataBinary || (r = r.pipe(new a.Utf8EncodeWorker)), o.createWorkerFrom(r, e, t);
                    },
                    _decompressWorker: function() {
                        return this._data instanceof o ? this._data.getContentWorker() : this._data instanceof h ? this._data : new i(this._data);
                    }
                };
                for(var u = [
                    "asText",
                    "asBinary",
                    "asNodeBuffer",
                    "asUint8Array",
                    "asArrayBuffer"
                ], l = function() {
                    throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
                }, f = 0; f < u.length; f++)n.prototype[u[f]] = l;
                t.exports = n;
            },
            {
                "./compressedObject": 2,
                "./stream/DataWorker": 27,
                "./stream/GenericWorker": 28,
                "./stream/StreamHelper": 29,
                "./utf8": 31
            }
        ],
        36: [
            function(e, l, t) {
                (function(t) {
                    "use strict";
                    var r, n, e = t.MutationObserver || t.WebKitMutationObserver;
                    if (e) {
                        var i = 0, s = new e(u), a = t.document.createTextNode("");
                        s.observe(a, {
                            characterData: !0
                        }), r = function() {
                            a.data = i = ++i % 2;
                        };
                    } else if (t.setImmediate || void 0 === t.MessageChannel) r = "document" in t && "onreadystatechange" in t.document.createElement("script") ? function() {
                        var e = t.document.createElement("script");
                        e.onreadystatechange = function() {
                            u(), e.onreadystatechange = null, e.parentNode.removeChild(e), e = null;
                        }, t.document.documentElement.appendChild(e);
                    } : function() {
                        setTimeout(u, 0);
                    };
                    else {
                        var o = new t.MessageChannel;
                        o.port1.onmessage = u, r = function() {
                            o.port2.postMessage(0);
                        };
                    }
                    var h = [];
                    function u() {
                        var e, t;
                        n = !0;
                        for(var r = h.length; r;){
                            for(t = h, h = [], e = -1; ++e < r;)t[e]();
                            r = h.length;
                        }
                        n = !1;
                    }
                    l.exports = function(e) {
                        1 !== h.push(e) || n || r();
                    };
                }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
            },
            {}
        ],
        37: [
            function(e, t, r) {
                "use strict";
                var i = e("immediate");
                function u() {}
                var l = {}, s = [
                    "REJECTED"
                ], a = [
                    "FULFILLED"
                ], n = [
                    "PENDING"
                ];
                function o(e) {
                    if ("function" != typeof e) throw new TypeError("resolver must be a function");
                    this.state = n, this.queue = [], this.outcome = void 0, e !== u && d(this, e);
                }
                function h(e, t, r) {
                    this.promise = e, "function" == typeof t && (this.onFulfilled = t, this.callFulfilled = this.otherCallFulfilled), "function" == typeof r && (this.onRejected = r, this.callRejected = this.otherCallRejected);
                }
                function f(t, r, n) {
                    i(function() {
                        var e;
                        try {
                            e = r(n);
                        } catch (e) {
                            return l.reject(t, e);
                        }
                        e === t ? l.reject(t, new TypeError("Cannot resolve promise with itself")) : l.resolve(t, e);
                    });
                }
                function c(e) {
                    var t = e && e.then;
                    if (e && ("object" == typeof e || "function" == typeof e) && "function" == typeof t) return function() {
                        t.apply(e, arguments);
                    };
                }
                function d(t, e) {
                    var r = !1;
                    function n(e) {
                        r || (r = !0, l.reject(t, e));
                    }
                    function i(e) {
                        r || (r = !0, l.resolve(t, e));
                    }
                    var s = p(function() {
                        e(i, n);
                    });
                    "error" === s.status && n(s.value);
                }
                function p(e, t) {
                    var r = {};
                    try {
                        r.value = e(t), r.status = "success";
                    } catch (e) {
                        r.status = "error", r.value = e;
                    }
                    return r;
                }
                (t.exports = o).prototype.finally = function(t) {
                    if ("function" != typeof t) return this;
                    var r = this.constructor;
                    return this.then(function(e) {
                        return r.resolve(t()).then(function() {
                            return e;
                        });
                    }, function(e) {
                        return r.resolve(t()).then(function() {
                            throw e;
                        });
                    });
                }, o.prototype.catch = function(e) {
                    return this.then(null, e);
                }, o.prototype.then = function(e, t) {
                    if ("function" != typeof e && this.state === a || "function" != typeof t && this.state === s) return this;
                    var r = new this.constructor(u);
                    this.state !== n ? f(r, this.state === a ? e : t, this.outcome) : this.queue.push(new h(r, e, t));
                    return r;
                }, h.prototype.callFulfilled = function(e) {
                    l.resolve(this.promise, e);
                }, h.prototype.otherCallFulfilled = function(e) {
                    f(this.promise, this.onFulfilled, e);
                }, h.prototype.callRejected = function(e) {
                    l.reject(this.promise, e);
                }, h.prototype.otherCallRejected = function(e) {
                    f(this.promise, this.onRejected, e);
                }, l.resolve = function(e, t) {
                    var r = p(c, t);
                    if ("error" === r.status) return l.reject(e, r.value);
                    var n = r.value;
                    if (n) d(e, n);
                    else {
                        e.state = a, e.outcome = t;
                        for(var i = -1, s = e.queue.length; ++i < s;)e.queue[i].callFulfilled(t);
                    }
                    return e;
                }, l.reject = function(e, t) {
                    e.state = s, e.outcome = t;
                    for(var r = -1, n = e.queue.length; ++r < n;)e.queue[r].callRejected(t);
                    return e;
                }, o.resolve = function(e) {
                    if (e instanceof this) return e;
                    return l.resolve(new this(u), e);
                }, o.reject = function(e) {
                    var t = new this(u);
                    return l.reject(t, e);
                }, o.all = function(e) {
                    var r = this;
                    if ("[object Array]" !== Object.prototype.toString.call(e)) return this.reject(new TypeError("must be an array"));
                    var n = e.length, i = !1;
                    if (!n) return this.resolve([]);
                    var s = new Array(n), a = 0, t = -1, o = new this(u);
                    for(; ++t < n;)h(e[t], t);
                    return o;
                    function h(e, t) {
                        r.resolve(e).then(function(e) {
                            s[t] = e, ++a !== n || i || (i = !0, l.resolve(o, s));
                        }, function(e) {
                            i || (i = !0, l.reject(o, e));
                        });
                    }
                }, o.race = function(e) {
                    var t = this;
                    if ("[object Array]" !== Object.prototype.toString.call(e)) return this.reject(new TypeError("must be an array"));
                    var r = e.length, n = !1;
                    if (!r) return this.resolve([]);
                    var i = -1, s = new this(u);
                    for(; ++i < r;)a = e[i], t.resolve(a).then(function(e) {
                        n || (n = !0, l.resolve(s, e));
                    }, function(e) {
                        n || (n = !0, l.reject(s, e));
                    });
                    var a;
                    return s;
                };
            },
            {
                immediate: 36
            }
        ],
        38: [
            function(e, t, r) {
                "use strict";
                var n = {};
                (0, e("./lib/utils/common").assign)(n, e("./lib/deflate"), e("./lib/inflate"), e("./lib/zlib/constants")), t.exports = n;
            },
            {
                "./lib/deflate": 39,
                "./lib/inflate": 40,
                "./lib/utils/common": 41,
                "./lib/zlib/constants": 44
            }
        ],
        39: [
            function(e, t, r) {
                "use strict";
                var a = e("./zlib/deflate"), o = e("./utils/common"), h = e("./utils/strings"), i = e("./zlib/messages"), s = e("./zlib/zstream"), u = Object.prototype.toString, l = 0, f = -1, c = 0, d = 8;
                function p(e) {
                    if (!(this instanceof p)) return new p(e);
                    this.options = o.assign({
                        level: f,
                        method: d,
                        chunkSize: 16384,
                        windowBits: 15,
                        memLevel: 8,
                        strategy: c,
                        to: ""
                    }, e || {});
                    var t = this.options;
                    t.raw && 0 < t.windowBits ? t.windowBits = -t.windowBits : t.gzip && 0 < t.windowBits && t.windowBits < 16 && (t.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new s, this.strm.avail_out = 0;
                    var r = a.deflateInit2(this.strm, t.level, t.method, t.windowBits, t.memLevel, t.strategy);
                    if (r !== l) throw new Error(i[r]);
                    if (t.header && a.deflateSetHeader(this.strm, t.header), t.dictionary) {
                        var n;
                        if (n = "string" == typeof t.dictionary ? h.string2buf(t.dictionary) : "[object ArrayBuffer]" === u.call(t.dictionary) ? new Uint8Array(t.dictionary) : t.dictionary, (r = a.deflateSetDictionary(this.strm, n)) !== l) throw new Error(i[r]);
                        this._dict_set = !0;
                    }
                }
                function n(e, t) {
                    var r = new p(t);
                    if (r.push(e, !0), r.err) throw r.msg || i[r.err];
                    return r.result;
                }
                p.prototype.push = function(e, t) {
                    var r, n, i = this.strm, s = this.options.chunkSize;
                    if (this.ended) return !1;
                    n = t === ~~t ? t : !0 === t ? 4 : 0, "string" == typeof e ? i.input = h.string2buf(e) : "[object ArrayBuffer]" === u.call(e) ? i.input = new Uint8Array(e) : i.input = e, i.next_in = 0, i.avail_in = i.input.length;
                    do {
                        if (0 === i.avail_out && (i.output = new o.Buf8(s), i.next_out = 0, i.avail_out = s), 1 !== (r = a.deflate(i, n)) && r !== l) return this.onEnd(r), this.ended = !0, false;
                        0 !== i.avail_out && (0 !== i.avail_in || 4 !== n && 2 !== n) || ("string" === this.options.to ? this.onData(h.buf2binstring(o.shrinkBuf(i.output, i.next_out))) : this.onData(o.shrinkBuf(i.output, i.next_out)));
                    }while ((0 < i.avail_in || 0 === i.avail_out) && 1 !== r);
                    return 4 === n ? (r = a.deflateEnd(this.strm), this.onEnd(r), this.ended = !0, r === l) : 2 !== n || (this.onEnd(l), i.avail_out = 0, true);
                }, p.prototype.onData = function(e) {
                    this.chunks.push(e);
                }, p.prototype.onEnd = function(e) {
                    e === l && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = e, this.msg = this.strm.msg;
                }, r.Deflate = p, r.deflate = n, r.deflateRaw = function(e, t) {
                    return (t = t || {}).raw = !0, n(e, t);
                }, r.gzip = function(e, t) {
                    return (t = t || {}).gzip = !0, n(e, t);
                };
            },
            {
                "./utils/common": 41,
                "./utils/strings": 42,
                "./zlib/deflate": 46,
                "./zlib/messages": 51,
                "./zlib/zstream": 53
            }
        ],
        40: [
            function(e, t, r) {
                "use strict";
                var c = e("./zlib/inflate"), d = e("./utils/common"), p = e("./utils/strings"), m = e("./zlib/constants"), n = e("./zlib/messages"), i = e("./zlib/zstream"), s = e("./zlib/gzheader"), _ = Object.prototype.toString;
                function a(e) {
                    if (!(this instanceof a)) return new a(e);
                    this.options = d.assign({
                        chunkSize: 16384,
                        windowBits: 0,
                        to: ""
                    }, e || {});
                    var t = this.options;
                    t.raw && 0 <= t.windowBits && t.windowBits < 16 && (t.windowBits = -t.windowBits, 0 === t.windowBits && (t.windowBits = -15)), !(0 <= t.windowBits && t.windowBits < 16) || e && e.windowBits || (t.windowBits += 32), 15 < t.windowBits && t.windowBits < 48 && 0 == (15 & t.windowBits) && (t.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new i, this.strm.avail_out = 0;
                    var r = c.inflateInit2(this.strm, t.windowBits);
                    if (r !== m.Z_OK) throw new Error(n[r]);
                    this.header = new s, c.inflateGetHeader(this.strm, this.header);
                }
                function o(e, t) {
                    var r = new a(t);
                    if (r.push(e, !0), r.err) throw r.msg || n[r.err];
                    return r.result;
                }
                a.prototype.push = function(e, t) {
                    var r, n, i, s, a, o, h = this.strm, u = this.options.chunkSize, l = this.options.dictionary, f = !1;
                    if (this.ended) return !1;
                    n = t === ~~t ? t : !0 === t ? m.Z_FINISH : m.Z_NO_FLUSH, "string" == typeof e ? h.input = p.binstring2buf(e) : "[object ArrayBuffer]" === _.call(e) ? h.input = new Uint8Array(e) : h.input = e, h.next_in = 0, h.avail_in = h.input.length;
                    do {
                        if (0 === h.avail_out && (h.output = new d.Buf8(u), h.next_out = 0, h.avail_out = u), (r = c.inflate(h, m.Z_NO_FLUSH)) === m.Z_NEED_DICT && l && (o = "string" == typeof l ? p.string2buf(l) : "[object ArrayBuffer]" === _.call(l) ? new Uint8Array(l) : l, r = c.inflateSetDictionary(this.strm, o)), r === m.Z_BUF_ERROR && !0 === f && (r = m.Z_OK, f = !1), r !== m.Z_STREAM_END && r !== m.Z_OK) return this.onEnd(r), this.ended = !0, false;
                        h.next_out && (0 !== h.avail_out && r !== m.Z_STREAM_END && (0 !== h.avail_in || n !== m.Z_FINISH && n !== m.Z_SYNC_FLUSH) || ("string" === this.options.to ? (i = p.utf8border(h.output, h.next_out), s = h.next_out - i, a = p.buf2string(h.output, i), h.next_out = s, h.avail_out = u - s, s && d.arraySet(h.output, h.output, i, s, 0), this.onData(a)) : this.onData(d.shrinkBuf(h.output, h.next_out)))), 0 === h.avail_in && 0 === h.avail_out && (f = !0);
                    }while ((0 < h.avail_in || 0 === h.avail_out) && r !== m.Z_STREAM_END);
                    return r === m.Z_STREAM_END && (n = m.Z_FINISH), n === m.Z_FINISH ? (r = c.inflateEnd(this.strm), this.onEnd(r), this.ended = !0, r === m.Z_OK) : n !== m.Z_SYNC_FLUSH || (this.onEnd(m.Z_OK), h.avail_out = 0, true);
                }, a.prototype.onData = function(e) {
                    this.chunks.push(e);
                }, a.prototype.onEnd = function(e) {
                    e === m.Z_OK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = d.flattenChunks(this.chunks)), this.chunks = [], this.err = e, this.msg = this.strm.msg;
                }, r.Inflate = a, r.inflate = o, r.inflateRaw = function(e, t) {
                    return (t = t || {}).raw = !0, o(e, t);
                }, r.ungzip = o;
            },
            {
                "./utils/common": 41,
                "./utils/strings": 42,
                "./zlib/constants": 44,
                "./zlib/gzheader": 47,
                "./zlib/inflate": 49,
                "./zlib/messages": 51,
                "./zlib/zstream": 53
            }
        ],
        41: [
            function(e, t, r) {
                "use strict";
                var n = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array;
                r.assign = function(e) {
                    for(var t = Array.prototype.slice.call(arguments, 1); t.length;){
                        var r = t.shift();
                        if (r) {
                            if ("object" != typeof r) throw new TypeError(r + "must be non-object");
                            for(var n in r)r.hasOwnProperty(n) && (e[n] = r[n]);
                        }
                    }
                    return e;
                }, r.shrinkBuf = function(e, t) {
                    return e.length === t ? e : e.subarray ? e.subarray(0, t) : (e.length = t, e);
                };
                var i = {
                    arraySet: function(e, t, r, n, i) {
                        if (t.subarray && e.subarray) e.set(t.subarray(r, r + n), i);
                        else for(var s = 0; s < n; s++)e[i + s] = t[r + s];
                    },
                    flattenChunks: function(e) {
                        var t, r, n, i, s, a;
                        for(t = n = 0, r = e.length; t < r; t++)n += e[t].length;
                        for(a = new Uint8Array(n), t = i = 0, r = e.length; t < r; t++)s = e[t], a.set(s, i), i += s.length;
                        return a;
                    }
                }, s = {
                    arraySet: function(e, t, r, n, i) {
                        for(var s = 0; s < n; s++)e[i + s] = t[r + s];
                    },
                    flattenChunks: function(e) {
                        return [].concat.apply([], e);
                    }
                };
                r.setTyped = function(e) {
                    e ? (r.Buf8 = Uint8Array, r.Buf16 = Uint16Array, r.Buf32 = Int32Array, r.assign(r, i)) : (r.Buf8 = Array, r.Buf16 = Array, r.Buf32 = Array, r.assign(r, s));
                }, r.setTyped(n);
            },
            {}
        ],
        42: [
            function(e, t, r) {
                "use strict";
                var h = e("./common"), i = !0, s = !0;
                try {
                    String.fromCharCode.apply(null, [
                        0
                    ]);
                } catch (e) {
                    i = !1;
                }
                try {
                    String.fromCharCode.apply(null, new Uint8Array(1));
                } catch (e) {
                    s = !1;
                }
                for(var u = new h.Buf8(256), n = 0; n < 256; n++)u[n] = 252 <= n ? 6 : 248 <= n ? 5 : 240 <= n ? 4 : 224 <= n ? 3 : 192 <= n ? 2 : 1;
                function l(e, t) {
                    if (t < 65537 && (e.subarray && s || !e.subarray && i)) return String.fromCharCode.apply(null, h.shrinkBuf(e, t));
                    for(var r = "", n = 0; n < t; n++)r += String.fromCharCode(e[n]);
                    return r;
                }
                u[254] = u[254] = 1, r.string2buf = function(e) {
                    var t, r, n, i, s, a = e.length, o = 0;
                    for(i = 0; i < a; i++)55296 == (64512 & (r = e.charCodeAt(i))) && i + 1 < a && 56320 == (64512 & (n = e.charCodeAt(i + 1))) && (r = 65536 + (r - 55296 << 10) + (n - 56320), i++), o += r < 128 ? 1 : r < 2048 ? 2 : r < 65536 ? 3 : 4;
                    for(t = new h.Buf8(o), i = s = 0; s < o; i++)55296 == (64512 & (r = e.charCodeAt(i))) && i + 1 < a && 56320 == (64512 & (n = e.charCodeAt(i + 1))) && (r = 65536 + (r - 55296 << 10) + (n - 56320), i++), r < 128 ? t[s++] = r : (r < 2048 ? t[s++] = 192 | r >>> 6 : (r < 65536 ? t[s++] = 224 | r >>> 12 : (t[s++] = 240 | r >>> 18, t[s++] = 128 | r >>> 12 & 63), t[s++] = 128 | r >>> 6 & 63), t[s++] = 128 | 63 & r);
                    return t;
                }, r.buf2binstring = function(e) {
                    return l(e, e.length);
                }, r.binstring2buf = function(e) {
                    for(var t = new h.Buf8(e.length), r = 0, n = t.length; r < n; r++)t[r] = e.charCodeAt(r);
                    return t;
                }, r.buf2string = function(e, t) {
                    var r, n, i, s, a = t || e.length, o = new Array(2 * a);
                    for(r = n = 0; r < a;)if ((i = e[r++]) < 128) o[n++] = i;
                    else if (4 < (s = u[i])) o[n++] = 65533, r += s - 1;
                    else {
                        for(i &= 2 === s ? 31 : 3 === s ? 15 : 7; 1 < s && r < a;)i = i << 6 | 63 & e[r++], s--;
                        1 < s ? o[n++] = 65533 : i < 65536 ? o[n++] = i : (i -= 65536, o[n++] = 55296 | i >> 10 & 1023, o[n++] = 56320 | 1023 & i);
                    }
                    return l(o, n);
                }, r.utf8border = function(e, t) {
                    var r;
                    for((t = t || e.length) > e.length && (t = e.length), r = t - 1; 0 <= r && 128 == (192 & e[r]);)r--;
                    return r < 0 ? t : 0 === r ? t : r + u[e[r]] > t ? r : t;
                };
            },
            {
                "./common": 41
            }
        ],
        43: [
            function(e, t, r) {
                "use strict";
                t.exports = function(e, t, r, n) {
                    for(var i = 65535 & e | 0, s = e >>> 16 & 65535 | 0, a = 0; 0 !== r;){
                        for(r -= a = 2e3 < r ? 2e3 : r; s = s + (i = i + t[n++] | 0) | 0, --a;);
                        i %= 65521, s %= 65521;
                    }
                    return i | s << 16 | 0;
                };
            },
            {}
        ],
        44: [
            function(e, t, r) {
                "use strict";
                t.exports = {
                    Z_NO_FLUSH: 0,
                    Z_PARTIAL_FLUSH: 1,
                    Z_SYNC_FLUSH: 2,
                    Z_FULL_FLUSH: 3,
                    Z_FINISH: 4,
                    Z_BLOCK: 5,
                    Z_TREES: 6,
                    Z_OK: 0,
                    Z_STREAM_END: 1,
                    Z_NEED_DICT: 2,
                    Z_ERRNO: -1,
                    Z_STREAM_ERROR: -2,
                    Z_DATA_ERROR: -3,
                    Z_BUF_ERROR: -5,
                    Z_NO_COMPRESSION: 0,
                    Z_BEST_SPEED: 1,
                    Z_BEST_COMPRESSION: 9,
                    Z_DEFAULT_COMPRESSION: -1,
                    Z_FILTERED: 1,
                    Z_HUFFMAN_ONLY: 2,
                    Z_RLE: 3,
                    Z_FIXED: 4,
                    Z_DEFAULT_STRATEGY: 0,
                    Z_BINARY: 0,
                    Z_TEXT: 1,
                    Z_UNKNOWN: 2,
                    Z_DEFLATED: 8
                };
            },
            {}
        ],
        45: [
            function(e, t, r) {
                "use strict";
                var o = function() {
                    for(var e, t = [], r = 0; r < 256; r++){
                        e = r;
                        for(var n = 0; n < 8; n++)e = 1 & e ? 3988292384 ^ e >>> 1 : e >>> 1;
                        t[r] = e;
                    }
                    return t;
                }();
                t.exports = function(e, t, r, n) {
                    var i = o, s = n + r;
                    e ^= -1;
                    for(var a = n; a < s; a++)e = e >>> 8 ^ i[255 & (e ^ t[a])];
                    return -1 ^ e;
                };
            },
            {}
        ],
        46: [
            function(e, t, r) {
                "use strict";
                var h, c = e("../utils/common"), u = e("./trees"), d = e("./adler32"), p = e("./crc32"), n = e("./messages"), l = 0, f = 4, m = 0, _ = -2, g = -1, b = 4, i = 2, v = 8, y = 9, s = 286, a = 30, o = 19, w = 2 * s + 1, k = 15, x = 3, S = 258, z = S + x + 1, C = 42, E = 113, A = 1, I = 2, O = 3, B = 4;
                function R(e, t) {
                    return e.msg = n[t], t;
                }
                function T(e) {
                    return (e << 1) - (4 < e ? 9 : 0);
                }
                function D(e) {
                    for(var t = e.length; 0 <= --t;)e[t] = 0;
                }
                function F(e) {
                    var t = e.state, r = t.pending;
                    r > e.avail_out && (r = e.avail_out), 0 !== r && (c.arraySet(e.output, t.pending_buf, t.pending_out, r, e.next_out), e.next_out += r, t.pending_out += r, e.total_out += r, e.avail_out -= r, t.pending -= r, 0 === t.pending && (t.pending_out = 0));
                }
                function N(e, t) {
                    u._tr_flush_block(e, 0 <= e.block_start ? e.block_start : -1, e.strstart - e.block_start, t), e.block_start = e.strstart, F(e.strm);
                }
                function U(e, t) {
                    e.pending_buf[e.pending++] = t;
                }
                function P(e, t) {
                    e.pending_buf[e.pending++] = t >>> 8 & 255, e.pending_buf[e.pending++] = 255 & t;
                }
                function L(e, t) {
                    var r, n, i = e.max_chain_length, s = e.strstart, a = e.prev_length, o = e.nice_match, h = e.strstart > e.w_size - z ? e.strstart - (e.w_size - z) : 0, u = e.window, l = e.w_mask, f = e.prev, c = e.strstart + S, d = u[s + a - 1], p = u[s + a];
                    e.prev_length >= e.good_match && (i >>= 2), o > e.lookahead && (o = e.lookahead);
                    do if (u[(r = t) + a] === p && u[r + a - 1] === d && u[r] === u[s] && u[++r] === u[s + 1]) {
                        s += 2, r++;
                        do ;
                        while (u[++s] === u[++r] && u[++s] === u[++r] && u[++s] === u[++r] && u[++s] === u[++r] && u[++s] === u[++r] && u[++s] === u[++r] && u[++s] === u[++r] && u[++s] === u[++r] && s < c);
                        if (n = S - (c - s), s = c - S, a < n) {
                            if (e.match_start = t, o <= (a = n)) break;
                            d = u[s + a - 1], p = u[s + a];
                        }
                    }
                    while ((t = f[t & l]) > h && 0 != --i);
                    return a <= e.lookahead ? a : e.lookahead;
                }
                function j(e) {
                    var t, r, n, i, s, a, o, h, u, l, f = e.w_size;
                    do {
                        if (i = e.window_size - e.lookahead - e.strstart, e.strstart >= f + (f - z)) {
                            for(c.arraySet(e.window, e.window, f, f, 0), e.match_start -= f, e.strstart -= f, e.block_start -= f, t = r = e.hash_size; n = e.head[--t], e.head[t] = f <= n ? n - f : 0, --r;);
                            for(t = r = f; n = e.prev[--t], e.prev[t] = f <= n ? n - f : 0, --r;);
                            i += f;
                        }
                        if (0 === e.strm.avail_in) break;
                        if (a = e.strm, o = e.window, h = e.strstart + e.lookahead, u = i, l = void 0, l = a.avail_in, u < l && (l = u), r = 0 === l ? 0 : (a.avail_in -= l, c.arraySet(o, a.input, a.next_in, l, h), 1 === a.state.wrap ? a.adler = d(a.adler, o, l, h) : 2 === a.state.wrap && (a.adler = p(a.adler, o, l, h)), a.next_in += l, a.total_in += l, l), e.lookahead += r, e.lookahead + e.insert >= x) for(s = e.strstart - e.insert, e.ins_h = e.window[s], e.ins_h = (e.ins_h << e.hash_shift ^ e.window[s + 1]) & e.hash_mask; e.insert && (e.ins_h = (e.ins_h << e.hash_shift ^ e.window[s + x - 1]) & e.hash_mask, e.prev[s & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = s, s++, e.insert--, !(e.lookahead + e.insert < x)););
                    }while (e.lookahead < z && 0 !== e.strm.avail_in);
                }
                function Z(e, t) {
                    for(var r, n;;){
                        if (e.lookahead < z) {
                            if (j(e), e.lookahead < z && t === l) return A;
                            if (0 === e.lookahead) break;
                        }
                        if (r = 0, e.lookahead >= x && (e.ins_h = (e.ins_h << e.hash_shift ^ e.window[e.strstart + x - 1]) & e.hash_mask, r = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), 0 !== r && e.strstart - r <= e.w_size - z && (e.match_length = L(e, r)), e.match_length >= x) {
                            if (n = u._tr_tally(e, e.strstart - e.match_start, e.match_length - x), e.lookahead -= e.match_length, e.match_length <= e.max_lazy_match && e.lookahead >= x) {
                                for(e.match_length--; e.strstart++, e.ins_h = (e.ins_h << e.hash_shift ^ e.window[e.strstart + x - 1]) & e.hash_mask, r = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart, 0 != --e.match_length;);
                                e.strstart++;
                            } else e.strstart += e.match_length, e.match_length = 0, e.ins_h = e.window[e.strstart], e.ins_h = (e.ins_h << e.hash_shift ^ e.window[e.strstart + 1]) & e.hash_mask;
                        } else n = u._tr_tally(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++;
                        if (n && (N(e, !1), 0 === e.strm.avail_out)) return A;
                    }
                    return e.insert = e.strstart < x - 1 ? e.strstart : x - 1, t === f ? (N(e, !0), 0 === e.strm.avail_out ? O : B) : e.last_lit && (N(e, !1), 0 === e.strm.avail_out) ? A : I;
                }
                function W(e, t) {
                    for(var r, n, i;;){
                        if (e.lookahead < z) {
                            if (j(e), e.lookahead < z && t === l) return A;
                            if (0 === e.lookahead) break;
                        }
                        if (r = 0, e.lookahead >= x && (e.ins_h = (e.ins_h << e.hash_shift ^ e.window[e.strstart + x - 1]) & e.hash_mask, r = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), e.prev_length = e.match_length, e.prev_match = e.match_start, e.match_length = x - 1, 0 !== r && e.prev_length < e.max_lazy_match && e.strstart - r <= e.w_size - z && (e.match_length = L(e, r), e.match_length <= 5 && (1 === e.strategy || e.match_length === x && 4096 < e.strstart - e.match_start) && (e.match_length = x - 1)), e.prev_length >= x && e.match_length <= e.prev_length) {
                            for(i = e.strstart + e.lookahead - x, n = u._tr_tally(e, e.strstart - 1 - e.prev_match, e.prev_length - x), e.lookahead -= e.prev_length - 1, e.prev_length -= 2; ++e.strstart <= i && (e.ins_h = (e.ins_h << e.hash_shift ^ e.window[e.strstart + x - 1]) & e.hash_mask, r = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), 0 != --e.prev_length;);
                            if (e.match_available = 0, e.match_length = x - 1, e.strstart++, n && (N(e, !1), 0 === e.strm.avail_out)) return A;
                        } else if (e.match_available) {
                            if ((n = u._tr_tally(e, 0, e.window[e.strstart - 1])) && N(e, !1), e.strstart++, e.lookahead--, 0 === e.strm.avail_out) return A;
                        } else e.match_available = 1, e.strstart++, e.lookahead--;
                    }
                    return e.match_available && (n = u._tr_tally(e, 0, e.window[e.strstart - 1]), e.match_available = 0), e.insert = e.strstart < x - 1 ? e.strstart : x - 1, t === f ? (N(e, !0), 0 === e.strm.avail_out ? O : B) : e.last_lit && (N(e, !1), 0 === e.strm.avail_out) ? A : I;
                }
                function M(e, t, r, n, i) {
                    this.good_length = e, this.max_lazy = t, this.nice_length = r, this.max_chain = n, this.func = i;
                }
                function H() {
                    this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = v, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new c.Buf16(2 * w), this.dyn_dtree = new c.Buf16(2 * (2 * a + 1)), this.bl_tree = new c.Buf16(2 * (2 * o + 1)), D(this.dyn_ltree), D(this.dyn_dtree), D(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new c.Buf16(k + 1), this.heap = new c.Buf16(2 * s + 1), D(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new c.Buf16(2 * s + 1), D(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
                }
                function G(e) {
                    var t;
                    return e && e.state ? (e.total_in = e.total_out = 0, e.data_type = i, (t = e.state).pending = 0, t.pending_out = 0, t.wrap < 0 && (t.wrap = -t.wrap), t.status = t.wrap ? C : E, e.adler = 2 === t.wrap ? 0 : 1, t.last_flush = l, u._tr_init(t), m) : R(e, _);
                }
                function K(e) {
                    var t = G(e);
                    return t === m && function(e) {
                        e.window_size = 2 * e.w_size, D(e.head), e.max_lazy_match = h[e.level].max_lazy, e.good_match = h[e.level].good_length, e.nice_match = h[e.level].nice_length, e.max_chain_length = h[e.level].max_chain, e.strstart = 0, e.block_start = 0, e.lookahead = 0, e.insert = 0, e.match_length = e.prev_length = x - 1, e.match_available = 0, e.ins_h = 0;
                    }(e.state), t;
                }
                function Y(e, t, r, n, i, s) {
                    if (!e) return _;
                    var a = 1;
                    if (t === g && (t = 6), n < 0 ? (a = 0, n = -n) : 15 < n && (a = 2, n -= 16), i < 1 || y < i || r !== v || n < 8 || 15 < n || t < 0 || 9 < t || s < 0 || b < s) return R(e, _);
                    8 === n && (n = 9);
                    var o = new H;
                    return (e.state = o).strm = e, o.wrap = a, o.gzhead = null, o.w_bits = n, o.w_size = 1 << o.w_bits, o.w_mask = o.w_size - 1, o.hash_bits = i + 7, o.hash_size = 1 << o.hash_bits, o.hash_mask = o.hash_size - 1, o.hash_shift = ~~((o.hash_bits + x - 1) / x), o.window = new c.Buf8(2 * o.w_size), o.head = new c.Buf16(o.hash_size), o.prev = new c.Buf16(o.w_size), o.lit_bufsize = 1 << i + 6, o.pending_buf_size = 4 * o.lit_bufsize, o.pending_buf = new c.Buf8(o.pending_buf_size), o.d_buf = 1 * o.lit_bufsize, o.l_buf = 3 * o.lit_bufsize, o.level = t, o.strategy = s, o.method = r, K(e);
                }
                h = [
                    new M(0, 0, 0, 0, function(e, t) {
                        var r = 65535;
                        for(r > e.pending_buf_size - 5 && (r = e.pending_buf_size - 5);;){
                            if (e.lookahead <= 1) {
                                if (j(e), 0 === e.lookahead && t === l) return A;
                                if (0 === e.lookahead) break;
                            }
                            e.strstart += e.lookahead, e.lookahead = 0;
                            var n = e.block_start + r;
                            if ((0 === e.strstart || e.strstart >= n) && (e.lookahead = e.strstart - n, e.strstart = n, N(e, !1), 0 === e.strm.avail_out)) return A;
                            if (e.strstart - e.block_start >= e.w_size - z && (N(e, !1), 0 === e.strm.avail_out)) return A;
                        }
                        return e.insert = 0, t === f ? (N(e, !0), 0 === e.strm.avail_out ? O : B) : (e.strstart > e.block_start && (N(e, !1), e.strm.avail_out), A);
                    }),
                    new M(4, 4, 8, 4, Z),
                    new M(4, 5, 16, 8, Z),
                    new M(4, 6, 32, 32, Z),
                    new M(4, 4, 16, 16, W),
                    new M(8, 16, 32, 32, W),
                    new M(8, 16, 128, 128, W),
                    new M(8, 32, 128, 256, W),
                    new M(32, 128, 258, 1024, W),
                    new M(32, 258, 258, 4096, W)
                ], r.deflateInit = function(e, t) {
                    return Y(e, t, v, 15, 8, 0);
                }, r.deflateInit2 = Y, r.deflateReset = K, r.deflateResetKeep = G, r.deflateSetHeader = function(e, t) {
                    return e && e.state ? 2 !== e.state.wrap ? _ : (e.state.gzhead = t, m) : _;
                }, r.deflate = function(e, t) {
                    var r, n, i, s;
                    if (!e || !e.state || 5 < t || t < 0) return e ? R(e, _) : _;
                    if (n = e.state, !e.output || !e.input && 0 !== e.avail_in || 666 === n.status && t !== f) return R(e, 0 === e.avail_out ? -5 : _);
                    if (n.strm = e, r = n.last_flush, n.last_flush = t, n.status === C) {
                        if (2 === n.wrap) e.adler = 0, U(n, 31), U(n, 139), U(n, 8), n.gzhead ? (U(n, (n.gzhead.text ? 1 : 0) + (n.gzhead.hcrc ? 2 : 0) + (n.gzhead.extra ? 4 : 0) + (n.gzhead.name ? 8 : 0) + (n.gzhead.comment ? 16 : 0)), U(n, 255 & n.gzhead.time), U(n, n.gzhead.time >> 8 & 255), U(n, n.gzhead.time >> 16 & 255), U(n, n.gzhead.time >> 24 & 255), U(n, 9 === n.level ? 2 : 2 <= n.strategy || n.level < 2 ? 4 : 0), U(n, 255 & n.gzhead.os), n.gzhead.extra && n.gzhead.extra.length && (U(n, 255 & n.gzhead.extra.length), U(n, n.gzhead.extra.length >> 8 & 255)), n.gzhead.hcrc && (e.adler = p(e.adler, n.pending_buf, n.pending, 0)), n.gzindex = 0, n.status = 69) : (U(n, 0), U(n, 0), U(n, 0), U(n, 0), U(n, 0), U(n, 9 === n.level ? 2 : 2 <= n.strategy || n.level < 2 ? 4 : 0), U(n, 3), n.status = E);
                        else {
                            var a = v + (n.w_bits - 8 << 4) << 8;
                            a |= (2 <= n.strategy || n.level < 2 ? 0 : n.level < 6 ? 1 : 6 === n.level ? 2 : 3) << 6, 0 !== n.strstart && (a |= 32), a += 31 - a % 31, n.status = E, P(n, a), 0 !== n.strstart && (P(n, e.adler >>> 16), P(n, 65535 & e.adler)), e.adler = 1;
                        }
                    }
                    if (69 === n.status) {
                        if (n.gzhead.extra) {
                            for(i = n.pending; n.gzindex < (65535 & n.gzhead.extra.length) && (n.pending !== n.pending_buf_size || (n.gzhead.hcrc && n.pending > i && (e.adler = p(e.adler, n.pending_buf, n.pending - i, i)), F(e), i = n.pending, n.pending !== n.pending_buf_size));)U(n, 255 & n.gzhead.extra[n.gzindex]), n.gzindex++;
                            n.gzhead.hcrc && n.pending > i && (e.adler = p(e.adler, n.pending_buf, n.pending - i, i)), n.gzindex === n.gzhead.extra.length && (n.gzindex = 0, n.status = 73);
                        } else n.status = 73;
                    }
                    if (73 === n.status) {
                        if (n.gzhead.name) {
                            i = n.pending;
                            do {
                                if (n.pending === n.pending_buf_size && (n.gzhead.hcrc && n.pending > i && (e.adler = p(e.adler, n.pending_buf, n.pending - i, i)), F(e), i = n.pending, n.pending === n.pending_buf_size)) {
                                    s = 1;
                                    break;
                                }
                                s = n.gzindex < n.gzhead.name.length ? 255 & n.gzhead.name.charCodeAt(n.gzindex++) : 0, U(n, s);
                            }while (0 !== s);
                            n.gzhead.hcrc && n.pending > i && (e.adler = p(e.adler, n.pending_buf, n.pending - i, i)), 0 === s && (n.gzindex = 0, n.status = 91);
                        } else n.status = 91;
                    }
                    if (91 === n.status) {
                        if (n.gzhead.comment) {
                            i = n.pending;
                            do {
                                if (n.pending === n.pending_buf_size && (n.gzhead.hcrc && n.pending > i && (e.adler = p(e.adler, n.pending_buf, n.pending - i, i)), F(e), i = n.pending, n.pending === n.pending_buf_size)) {
                                    s = 1;
                                    break;
                                }
                                s = n.gzindex < n.gzhead.comment.length ? 255 & n.gzhead.comment.charCodeAt(n.gzindex++) : 0, U(n, s);
                            }while (0 !== s);
                            n.gzhead.hcrc && n.pending > i && (e.adler = p(e.adler, n.pending_buf, n.pending - i, i)), 0 === s && (n.status = 103);
                        } else n.status = 103;
                    }
                    if (103 === n.status && (n.gzhead.hcrc ? (n.pending + 2 > n.pending_buf_size && F(e), n.pending + 2 <= n.pending_buf_size && (U(n, 255 & e.adler), U(n, e.adler >> 8 & 255), e.adler = 0, n.status = E)) : n.status = E), 0 !== n.pending) {
                        if (F(e), 0 === e.avail_out) return n.last_flush = -1, m;
                    } else if (0 === e.avail_in && T(t) <= T(r) && t !== f) return R(e, -5);
                    if (666 === n.status && 0 !== e.avail_in) return R(e, -5);
                    if (0 !== e.avail_in || 0 !== n.lookahead || t !== l && 666 !== n.status) {
                        var o = 2 === n.strategy ? function(e, t) {
                            for(var r;;){
                                if (0 === e.lookahead && (j(e), 0 === e.lookahead)) {
                                    if (t === l) return A;
                                    break;
                                }
                                if (e.match_length = 0, r = u._tr_tally(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++, r && (N(e, !1), 0 === e.strm.avail_out)) return A;
                            }
                            return e.insert = 0, t === f ? (N(e, !0), 0 === e.strm.avail_out ? O : B) : e.last_lit && (N(e, !1), 0 === e.strm.avail_out) ? A : I;
                        }(n, t) : 3 === n.strategy ? function(e, t) {
                            for(var r, n, i, s, a = e.window;;){
                                if (e.lookahead <= S) {
                                    if (j(e), e.lookahead <= S && t === l) return A;
                                    if (0 === e.lookahead) break;
                                }
                                if (e.match_length = 0, e.lookahead >= x && 0 < e.strstart && (n = a[i = e.strstart - 1]) === a[++i] && n === a[++i] && n === a[++i]) {
                                    s = e.strstart + S;
                                    do ;
                                    while (n === a[++i] && n === a[++i] && n === a[++i] && n === a[++i] && n === a[++i] && n === a[++i] && n === a[++i] && n === a[++i] && i < s);
                                    e.match_length = S - (s - i), e.match_length > e.lookahead && (e.match_length = e.lookahead);
                                }
                                if (e.match_length >= x ? (r = u._tr_tally(e, 1, e.match_length - x), e.lookahead -= e.match_length, e.strstart += e.match_length, e.match_length = 0) : (r = u._tr_tally(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++), r && (N(e, !1), 0 === e.strm.avail_out)) return A;
                            }
                            return e.insert = 0, t === f ? (N(e, !0), 0 === e.strm.avail_out ? O : B) : e.last_lit && (N(e, !1), 0 === e.strm.avail_out) ? A : I;
                        }(n, t) : h[n.level].func(n, t);
                        if (o !== O && o !== B || (n.status = 666), o === A || o === O) return 0 === e.avail_out && (n.last_flush = -1), m;
                        if (o === I && (1 === t ? u._tr_align(n) : 5 !== t && (u._tr_stored_block(n, 0, 0, !1), 3 === t && (D(n.head), 0 === n.lookahead && (n.strstart = 0, n.block_start = 0, n.insert = 0))), F(e), 0 === e.avail_out)) return n.last_flush = -1, m;
                    }
                    return t !== f ? m : n.wrap <= 0 ? 1 : (2 === n.wrap ? (U(n, 255 & e.adler), U(n, e.adler >> 8 & 255), U(n, e.adler >> 16 & 255), U(n, e.adler >> 24 & 255), U(n, 255 & e.total_in), U(n, e.total_in >> 8 & 255), U(n, e.total_in >> 16 & 255), U(n, e.total_in >> 24 & 255)) : (P(n, e.adler >>> 16), P(n, 65535 & e.adler)), F(e), 0 < n.wrap && (n.wrap = -n.wrap), 0 !== n.pending ? m : 1);
                }, r.deflateEnd = function(e) {
                    var t;
                    return e && e.state ? (t = e.state.status) !== C && 69 !== t && 73 !== t && 91 !== t && 103 !== t && t !== E && 666 !== t ? R(e, _) : (e.state = null, t === E ? R(e, -3) : m) : _;
                }, r.deflateSetDictionary = function(e, t) {
                    var r, n, i, s, a, o, h, u, l = t.length;
                    if (!e || !e.state) return _;
                    if (2 === (s = (r = e.state).wrap) || 1 === s && r.status !== C || r.lookahead) return _;
                    for(1 === s && (e.adler = d(e.adler, t, l, 0)), r.wrap = 0, l >= r.w_size && (0 === s && (D(r.head), r.strstart = 0, r.block_start = 0, r.insert = 0), u = new c.Buf8(r.w_size), c.arraySet(u, t, l - r.w_size, r.w_size, 0), t = u, l = r.w_size), a = e.avail_in, o = e.next_in, h = e.input, e.avail_in = l, e.next_in = 0, e.input = t, j(r); r.lookahead >= x;){
                        for(n = r.strstart, i = r.lookahead - (x - 1); r.ins_h = (r.ins_h << r.hash_shift ^ r.window[n + x - 1]) & r.hash_mask, r.prev[n & r.w_mask] = r.head[r.ins_h], r.head[r.ins_h] = n, n++, --i;);
                        r.strstart = n, r.lookahead = x - 1, j(r);
                    }
                    return r.strstart += r.lookahead, r.block_start = r.strstart, r.insert = r.lookahead, r.lookahead = 0, r.match_length = r.prev_length = x - 1, r.match_available = 0, e.next_in = o, e.input = h, e.avail_in = a, r.wrap = s, m;
                }, r.deflateInfo = "pako deflate (from Nodeca project)";
            },
            {
                "../utils/common": 41,
                "./adler32": 43,
                "./crc32": 45,
                "./messages": 51,
                "./trees": 52
            }
        ],
        47: [
            function(e, t, r) {
                "use strict";
                t.exports = function() {
                    this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
                };
            },
            {}
        ],
        48: [
            function(e, t, r) {
                "use strict";
                t.exports = function(e, t) {
                    var r, n, i, s, a, o, h, u, l, f, c, d, p, m, _, g, b, v, y, w, k, x, S, z, C;
                    r = e.state, n = e.next_in, z = e.input, i = n + (e.avail_in - 5), s = e.next_out, C = e.output, a = s - (t - e.avail_out), o = s + (e.avail_out - 257), h = r.dmax, u = r.wsize, l = r.whave, f = r.wnext, c = r.window, d = r.hold, p = r.bits, m = r.lencode, _ = r.distcode, g = (1 << r.lenbits) - 1, b = (1 << r.distbits) - 1;
                    e: do {
                        p < 15 && (d += z[n++] << p, p += 8, d += z[n++] << p, p += 8), v = m[d & g];
                        t: for(;;){
                            if (d >>>= y = v >>> 24, p -= y, 0 === (y = v >>> 16 & 255)) C[s++] = 65535 & v;
                            else {
                                if (!(16 & y)) {
                                    if (0 == (64 & y)) {
                                        v = m[(65535 & v) + (d & (1 << y) - 1)];
                                        continue t;
                                    }
                                    if (32 & y) {
                                        r.mode = 12;
                                        break e;
                                    }
                                    e.msg = "invalid literal/length code", r.mode = 30;
                                    break e;
                                }
                                w = 65535 & v, (y &= 15) && (p < y && (d += z[n++] << p, p += 8), w += d & (1 << y) - 1, d >>>= y, p -= y), p < 15 && (d += z[n++] << p, p += 8, d += z[n++] << p, p += 8), v = _[d & b];
                                r: for(;;){
                                    if (d >>>= y = v >>> 24, p -= y, !(16 & (y = v >>> 16 & 255))) {
                                        if (0 == (64 & y)) {
                                            v = _[(65535 & v) + (d & (1 << y) - 1)];
                                            continue r;
                                        }
                                        e.msg = "invalid distance code", r.mode = 30;
                                        break e;
                                    }
                                    if (k = 65535 & v, p < (y &= 15) && (d += z[n++] << p, (p += 8) < y && (d += z[n++] << p, p += 8)), h < (k += d & (1 << y) - 1)) {
                                        e.msg = "invalid distance too far back", r.mode = 30;
                                        break e;
                                    }
                                    if (d >>>= y, p -= y, (y = s - a) < k) {
                                        if (l < (y = k - y) && r.sane) {
                                            e.msg = "invalid distance too far back", r.mode = 30;
                                            break e;
                                        }
                                        if (S = c, (x = 0) === f) {
                                            if (x += u - y, y < w) {
                                                for(w -= y; C[s++] = c[x++], --y;);
                                                x = s - k, S = C;
                                            }
                                        } else if (f < y) {
                                            if (x += u + f - y, (y -= f) < w) {
                                                for(w -= y; C[s++] = c[x++], --y;);
                                                if (x = 0, f < w) {
                                                    for(w -= y = f; C[s++] = c[x++], --y;);
                                                    x = s - k, S = C;
                                                }
                                            }
                                        } else if (x += f - y, y < w) {
                                            for(w -= y; C[s++] = c[x++], --y;);
                                            x = s - k, S = C;
                                        }
                                        for(; 2 < w;)C[s++] = S[x++], C[s++] = S[x++], C[s++] = S[x++], w -= 3;
                                        w && (C[s++] = S[x++], 1 < w && (C[s++] = S[x++]));
                                    } else {
                                        for(x = s - k; C[s++] = C[x++], C[s++] = C[x++], C[s++] = C[x++], 2 < (w -= 3););
                                        w && (C[s++] = C[x++], 1 < w && (C[s++] = C[x++]));
                                    }
                                    break;
                                }
                            }
                            break;
                        }
                    }while (n < i && s < o);
                    n -= w = p >> 3, d &= (1 << (p -= w << 3)) - 1, e.next_in = n, e.next_out = s, e.avail_in = n < i ? i - n + 5 : 5 - (n - i), e.avail_out = s < o ? o - s + 257 : 257 - (s - o), r.hold = d, r.bits = p;
                };
            },
            {}
        ],
        49: [
            function(e, t, r) {
                "use strict";
                var I = e("../utils/common"), O = e("./adler32"), B = e("./crc32"), R = e("./inffast"), T = e("./inftrees"), D = 1, F = 2, N = 0, U = -2, P = 1, n = 852, i = 592;
                function L(e) {
                    return (e >>> 24 & 255) + (e >>> 8 & 65280) + ((65280 & e) << 8) + ((255 & e) << 24);
                }
                function s() {
                    this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new I.Buf16(320), this.work = new I.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
                }
                function a(e) {
                    var t;
                    return e && e.state ? (t = e.state, e.total_in = e.total_out = t.total = 0, e.msg = "", t.wrap && (e.adler = 1 & t.wrap), t.mode = P, t.last = 0, t.havedict = 0, t.dmax = 32768, t.head = null, t.hold = 0, t.bits = 0, t.lencode = t.lendyn = new I.Buf32(n), t.distcode = t.distdyn = new I.Buf32(i), t.sane = 1, t.back = -1, N) : U;
                }
                function o(e) {
                    var t;
                    return e && e.state ? ((t = e.state).wsize = 0, t.whave = 0, t.wnext = 0, a(e)) : U;
                }
                function h(e, t) {
                    var r, n;
                    return e && e.state ? (n = e.state, t < 0 ? (r = 0, t = -t) : (r = 1 + (t >> 4), t < 48 && (t &= 15)), t && (t < 8 || 15 < t) ? U : (null !== n.window && n.wbits !== t && (n.window = null), n.wrap = r, n.wbits = t, o(e))) : U;
                }
                function u(e, t) {
                    var r, n;
                    return e ? (n = new s, (e.state = n).window = null, (r = h(e, t)) !== N && (e.state = null), r) : U;
                }
                var l, f, c = !0;
                function j(e) {
                    if (c) {
                        var t;
                        for(l = new I.Buf32(512), f = new I.Buf32(32), t = 0; t < 144;)e.lens[t++] = 8;
                        for(; t < 256;)e.lens[t++] = 9;
                        for(; t < 280;)e.lens[t++] = 7;
                        for(; t < 288;)e.lens[t++] = 8;
                        for(T(D, e.lens, 0, 288, l, 0, e.work, {
                            bits: 9
                        }), t = 0; t < 32;)e.lens[t++] = 5;
                        T(F, e.lens, 0, 32, f, 0, e.work, {
                            bits: 5
                        }), c = !1;
                    }
                    e.lencode = l, e.lenbits = 9, e.distcode = f, e.distbits = 5;
                }
                function Z(e, t, r, n) {
                    var i, s = e.state;
                    return null === s.window && (s.wsize = 1 << s.wbits, s.wnext = 0, s.whave = 0, s.window = new I.Buf8(s.wsize)), n >= s.wsize ? (I.arraySet(s.window, t, r - s.wsize, s.wsize, 0), s.wnext = 0, s.whave = s.wsize) : (n < (i = s.wsize - s.wnext) && (i = n), I.arraySet(s.window, t, r - n, i, s.wnext), (n -= i) ? (I.arraySet(s.window, t, r - n, n, 0), s.wnext = n, s.whave = s.wsize) : (s.wnext += i, s.wnext === s.wsize && (s.wnext = 0), s.whave < s.wsize && (s.whave += i))), 0;
                }
                r.inflateReset = o, r.inflateReset2 = h, r.inflateResetKeep = a, r.inflateInit = function(e) {
                    return u(e, 15);
                }, r.inflateInit2 = u, r.inflate = function(e, t) {
                    var r, n, i, s, a, o, h, u, l, f, c, d, p, m, _, g, b, v, y, w, k, x, S, z, C = 0, E = new I.Buf8(4), A = [
                        16,
                        17,
                        18,
                        0,
                        8,
                        7,
                        9,
                        6,
                        10,
                        5,
                        11,
                        4,
                        12,
                        3,
                        13,
                        2,
                        14,
                        1,
                        15
                    ];
                    if (!e || !e.state || !e.output || !e.input && 0 !== e.avail_in) return U;
                    12 === (r = e.state).mode && (r.mode = 13), a = e.next_out, i = e.output, h = e.avail_out, s = e.next_in, n = e.input, o = e.avail_in, u = r.hold, l = r.bits, f = o, c = h, x = N;
                    e: for(;;)switch(r.mode){
                        case P:
                            if (0 === r.wrap) {
                                r.mode = 13;
                                break;
                            }
                            for(; l < 16;){
                                if (0 === o) break e;
                                o--, u += n[s++] << l, l += 8;
                            }
                            if (2 & r.wrap && 35615 === u) {
                                E[r.check = 0] = 255 & u, E[1] = u >>> 8 & 255, r.check = B(r.check, E, 2, 0), l = u = 0, r.mode = 2;
                                break;
                            }
                            if (r.flags = 0, r.head && (r.head.done = !1), !(1 & r.wrap) || (((255 & u) << 8) + (u >> 8)) % 31) {
                                e.msg = "incorrect header check", r.mode = 30;
                                break;
                            }
                            if (8 != (15 & u)) {
                                e.msg = "unknown compression method", r.mode = 30;
                                break;
                            }
                            if (l -= 4, k = 8 + (15 & (u >>>= 4)), 0 === r.wbits) r.wbits = k;
                            else if (k > r.wbits) {
                                e.msg = "invalid window size", r.mode = 30;
                                break;
                            }
                            r.dmax = 1 << k, e.adler = r.check = 1, r.mode = 512 & u ? 10 : 12, l = u = 0;
                            break;
                        case 2:
                            for(; l < 16;){
                                if (0 === o) break e;
                                o--, u += n[s++] << l, l += 8;
                            }
                            if (r.flags = u, 8 != (255 & r.flags)) {
                                e.msg = "unknown compression method", r.mode = 30;
                                break;
                            }
                            if (57344 & r.flags) {
                                e.msg = "unknown header flags set", r.mode = 30;
                                break;
                            }
                            r.head && (r.head.text = u >> 8 & 1), 512 & r.flags && (E[0] = 255 & u, E[1] = u >>> 8 & 255, r.check = B(r.check, E, 2, 0)), l = u = 0, r.mode = 3;
                        case 3:
                            for(; l < 32;){
                                if (0 === o) break e;
                                o--, u += n[s++] << l, l += 8;
                            }
                            r.head && (r.head.time = u), 512 & r.flags && (E[0] = 255 & u, E[1] = u >>> 8 & 255, E[2] = u >>> 16 & 255, E[3] = u >>> 24 & 255, r.check = B(r.check, E, 4, 0)), l = u = 0, r.mode = 4;
                        case 4:
                            for(; l < 16;){
                                if (0 === o) break e;
                                o--, u += n[s++] << l, l += 8;
                            }
                            r.head && (r.head.xflags = 255 & u, r.head.os = u >> 8), 512 & r.flags && (E[0] = 255 & u, E[1] = u >>> 8 & 255, r.check = B(r.check, E, 2, 0)), l = u = 0, r.mode = 5;
                        case 5:
                            if (1024 & r.flags) {
                                for(; l < 16;){
                                    if (0 === o) break e;
                                    o--, u += n[s++] << l, l += 8;
                                }
                                r.length = u, r.head && (r.head.extra_len = u), 512 & r.flags && (E[0] = 255 & u, E[1] = u >>> 8 & 255, r.check = B(r.check, E, 2, 0)), l = u = 0;
                            } else r.head && (r.head.extra = null);
                            r.mode = 6;
                        case 6:
                            if (1024 & r.flags && (o < (d = r.length) && (d = o), d && (r.head && (k = r.head.extra_len - r.length, r.head.extra || (r.head.extra = new Array(r.head.extra_len)), I.arraySet(r.head.extra, n, s, d, k)), 512 & r.flags && (r.check = B(r.check, n, d, s)), o -= d, s += d, r.length -= d), r.length)) break e;
                            r.length = 0, r.mode = 7;
                        case 7:
                            if (2048 & r.flags) {
                                if (0 === o) break e;
                                for(d = 0; k = n[s + d++], r.head && k && r.length < 65536 && (r.head.name += String.fromCharCode(k)), k && d < o;);
                                if (512 & r.flags && (r.check = B(r.check, n, d, s)), o -= d, s += d, k) break e;
                            } else r.head && (r.head.name = null);
                            r.length = 0, r.mode = 8;
                        case 8:
                            if (4096 & r.flags) {
                                if (0 === o) break e;
                                for(d = 0; k = n[s + d++], r.head && k && r.length < 65536 && (r.head.comment += String.fromCharCode(k)), k && d < o;);
                                if (512 & r.flags && (r.check = B(r.check, n, d, s)), o -= d, s += d, k) break e;
                            } else r.head && (r.head.comment = null);
                            r.mode = 9;
                        case 9:
                            if (512 & r.flags) {
                                for(; l < 16;){
                                    if (0 === o) break e;
                                    o--, u += n[s++] << l, l += 8;
                                }
                                if (u !== (65535 & r.check)) {
                                    e.msg = "header crc mismatch", r.mode = 30;
                                    break;
                                }
                                l = u = 0;
                            }
                            r.head && (r.head.hcrc = r.flags >> 9 & 1, r.head.done = !0), e.adler = r.check = 0, r.mode = 12;
                            break;
                        case 10:
                            for(; l < 32;){
                                if (0 === o) break e;
                                o--, u += n[s++] << l, l += 8;
                            }
                            e.adler = r.check = L(u), l = u = 0, r.mode = 11;
                        case 11:
                            if (0 === r.havedict) return e.next_out = a, e.avail_out = h, e.next_in = s, e.avail_in = o, r.hold = u, r.bits = l, 2;
                            e.adler = r.check = 1, r.mode = 12;
                        case 12:
                            if (5 === t || 6 === t) break e;
                        case 13:
                            if (r.last) {
                                u >>>= 7 & l, l -= 7 & l, r.mode = 27;
                                break;
                            }
                            for(; l < 3;){
                                if (0 === o) break e;
                                o--, u += n[s++] << l, l += 8;
                            }
                            switch(r.last = 1 & u, l -= 1, 3 & (u >>>= 1)){
                                case 0:
                                    r.mode = 14;
                                    break;
                                case 1:
                                    if (j(r), r.mode = 20, 6 !== t) break;
                                    u >>>= 2, l -= 2;
                                    break e;
                                case 2:
                                    r.mode = 17;
                                    break;
                                case 3:
                                    e.msg = "invalid block type", r.mode = 30;
                            }
                            u >>>= 2, l -= 2;
                            break;
                        case 14:
                            for(u >>>= 7 & l, l -= 7 & l; l < 32;){
                                if (0 === o) break e;
                                o--, u += n[s++] << l, l += 8;
                            }
                            if ((65535 & u) != (u >>> 16 ^ 65535)) {
                                e.msg = "invalid stored block lengths", r.mode = 30;
                                break;
                            }
                            if (r.length = 65535 & u, l = u = 0, r.mode = 15, 6 === t) break e;
                        case 15:
                            r.mode = 16;
                        case 16:
                            if (d = r.length) {
                                if (o < d && (d = o), h < d && (d = h), 0 === d) break e;
                                I.arraySet(i, n, s, d, a), o -= d, s += d, h -= d, a += d, r.length -= d;
                                break;
                            }
                            r.mode = 12;
                            break;
                        case 17:
                            for(; l < 14;){
                                if (0 === o) break e;
                                o--, u += n[s++] << l, l += 8;
                            }
                            if (r.nlen = 257 + (31 & u), u >>>= 5, l -= 5, r.ndist = 1 + (31 & u), u >>>= 5, l -= 5, r.ncode = 4 + (15 & u), u >>>= 4, l -= 4, 286 < r.nlen || 30 < r.ndist) {
                                e.msg = "too many length or distance symbols", r.mode = 30;
                                break;
                            }
                            r.have = 0, r.mode = 18;
                        case 18:
                            for(; r.have < r.ncode;){
                                for(; l < 3;){
                                    if (0 === o) break e;
                                    o--, u += n[s++] << l, l += 8;
                                }
                                r.lens[A[r.have++]] = 7 & u, u >>>= 3, l -= 3;
                            }
                            for(; r.have < 19;)r.lens[A[r.have++]] = 0;
                            if (r.lencode = r.lendyn, r.lenbits = 7, S = {
                                bits: r.lenbits
                            }, x = T(0, r.lens, 0, 19, r.lencode, 0, r.work, S), r.lenbits = S.bits, x) {
                                e.msg = "invalid code lengths set", r.mode = 30;
                                break;
                            }
                            r.have = 0, r.mode = 19;
                        case 19:
                            for(; r.have < r.nlen + r.ndist;){
                                for(; g = (C = r.lencode[u & (1 << r.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l);){
                                    if (0 === o) break e;
                                    o--, u += n[s++] << l, l += 8;
                                }
                                if (b < 16) u >>>= _, l -= _, r.lens[r.have++] = b;
                                else {
                                    if (16 === b) {
                                        for(z = _ + 2; l < z;){
                                            if (0 === o) break e;
                                            o--, u += n[s++] << l, l += 8;
                                        }
                                        if (u >>>= _, l -= _, 0 === r.have) {
                                            e.msg = "invalid bit length repeat", r.mode = 30;
                                            break;
                                        }
                                        k = r.lens[r.have - 1], d = 3 + (3 & u), u >>>= 2, l -= 2;
                                    } else if (17 === b) {
                                        for(z = _ + 3; l < z;){
                                            if (0 === o) break e;
                                            o--, u += n[s++] << l, l += 8;
                                        }
                                        l -= _, k = 0, d = 3 + (7 & (u >>>= _)), u >>>= 3, l -= 3;
                                    } else {
                                        for(z = _ + 7; l < z;){
                                            if (0 === o) break e;
                                            o--, u += n[s++] << l, l += 8;
                                        }
                                        l -= _, k = 0, d = 11 + (127 & (u >>>= _)), u >>>= 7, l -= 7;
                                    }
                                    if (r.have + d > r.nlen + r.ndist) {
                                        e.msg = "invalid bit length repeat", r.mode = 30;
                                        break;
                                    }
                                    for(; d--;)r.lens[r.have++] = k;
                                }
                            }
                            if (30 === r.mode) break;
                            if (0 === r.lens[256]) {
                                e.msg = "invalid code -- missing end-of-block", r.mode = 30;
                                break;
                            }
                            if (r.lenbits = 9, S = {
                                bits: r.lenbits
                            }, x = T(D, r.lens, 0, r.nlen, r.lencode, 0, r.work, S), r.lenbits = S.bits, x) {
                                e.msg = "invalid literal/lengths set", r.mode = 30;
                                break;
                            }
                            if (r.distbits = 6, r.distcode = r.distdyn, S = {
                                bits: r.distbits
                            }, x = T(F, r.lens, r.nlen, r.ndist, r.distcode, 0, r.work, S), r.distbits = S.bits, x) {
                                e.msg = "invalid distances set", r.mode = 30;
                                break;
                            }
                            if (r.mode = 20, 6 === t) break e;
                        case 20:
                            r.mode = 21;
                        case 21:
                            if (6 <= o && 258 <= h) {
                                e.next_out = a, e.avail_out = h, e.next_in = s, e.avail_in = o, r.hold = u, r.bits = l, R(e, c), a = e.next_out, i = e.output, h = e.avail_out, s = e.next_in, n = e.input, o = e.avail_in, u = r.hold, l = r.bits, 12 === r.mode && (r.back = -1);
                                break;
                            }
                            for(r.back = 0; g = (C = r.lencode[u & (1 << r.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l);){
                                if (0 === o) break e;
                                o--, u += n[s++] << l, l += 8;
                            }
                            if (g && 0 == (240 & g)) {
                                for(v = _, y = g, w = b; g = (C = r.lencode[w + ((u & (1 << v + y) - 1) >> v)]) >>> 16 & 255, b = 65535 & C, !(v + (_ = C >>> 24) <= l);){
                                    if (0 === o) break e;
                                    o--, u += n[s++] << l, l += 8;
                                }
                                u >>>= v, l -= v, r.back += v;
                            }
                            if (u >>>= _, l -= _, r.back += _, r.length = b, 0 === g) {
                                r.mode = 26;
                                break;
                            }
                            if (32 & g) {
                                r.back = -1, r.mode = 12;
                                break;
                            }
                            if (64 & g) {
                                e.msg = "invalid literal/length code", r.mode = 30;
                                break;
                            }
                            r.extra = 15 & g, r.mode = 22;
                        case 22:
                            if (r.extra) {
                                for(z = r.extra; l < z;){
                                    if (0 === o) break e;
                                    o--, u += n[s++] << l, l += 8;
                                }
                                r.length += u & (1 << r.extra) - 1, u >>>= r.extra, l -= r.extra, r.back += r.extra;
                            }
                            r.was = r.length, r.mode = 23;
                        case 23:
                            for(; g = (C = r.distcode[u & (1 << r.distbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l);){
                                if (0 === o) break e;
                                o--, u += n[s++] << l, l += 8;
                            }
                            if (0 == (240 & g)) {
                                for(v = _, y = g, w = b; g = (C = r.distcode[w + ((u & (1 << v + y) - 1) >> v)]) >>> 16 & 255, b = 65535 & C, !(v + (_ = C >>> 24) <= l);){
                                    if (0 === o) break e;
                                    o--, u += n[s++] << l, l += 8;
                                }
                                u >>>= v, l -= v, r.back += v;
                            }
                            if (u >>>= _, l -= _, r.back += _, 64 & g) {
                                e.msg = "invalid distance code", r.mode = 30;
                                break;
                            }
                            r.offset = b, r.extra = 15 & g, r.mode = 24;
                        case 24:
                            if (r.extra) {
                                for(z = r.extra; l < z;){
                                    if (0 === o) break e;
                                    o--, u += n[s++] << l, l += 8;
                                }
                                r.offset += u & (1 << r.extra) - 1, u >>>= r.extra, l -= r.extra, r.back += r.extra;
                            }
                            if (r.offset > r.dmax) {
                                e.msg = "invalid distance too far back", r.mode = 30;
                                break;
                            }
                            r.mode = 25;
                        case 25:
                            if (0 === h) break e;
                            if (d = c - h, r.offset > d) {
                                if ((d = r.offset - d) > r.whave && r.sane) {
                                    e.msg = "invalid distance too far back", r.mode = 30;
                                    break;
                                }
                                p = d > r.wnext ? (d -= r.wnext, r.wsize - d) : r.wnext - d, d > r.length && (d = r.length), m = r.window;
                            } else m = i, p = a - r.offset, d = r.length;
                            for(h < d && (d = h), h -= d, r.length -= d; i[a++] = m[p++], --d;);
                            0 === r.length && (r.mode = 21);
                            break;
                        case 26:
                            if (0 === h) break e;
                            i[a++] = r.length, h--, r.mode = 21;
                            break;
                        case 27:
                            if (r.wrap) {
                                for(; l < 32;){
                                    if (0 === o) break e;
                                    o--, u |= n[s++] << l, l += 8;
                                }
                                if (c -= h, e.total_out += c, r.total += c, c && (e.adler = r.check = r.flags ? B(r.check, i, c, a - c) : O(r.check, i, c, a - c)), c = h, (r.flags ? u : L(u)) !== r.check) {
                                    e.msg = "incorrect data check", r.mode = 30;
                                    break;
                                }
                                l = u = 0;
                            }
                            r.mode = 28;
                        case 28:
                            if (r.wrap && r.flags) {
                                for(; l < 32;){
                                    if (0 === o) break e;
                                    o--, u += n[s++] << l, l += 8;
                                }
                                if (u !== (4294967295 & r.total)) {
                                    e.msg = "incorrect length check", r.mode = 30;
                                    break;
                                }
                                l = u = 0;
                            }
                            r.mode = 29;
                        case 29:
                            x = 1;
                            break e;
                        case 30:
                            x = -3;
                            break e;
                        case 31:
                            return -4;
                        case 32:
                        default:
                            return U;
                    }
                    return e.next_out = a, e.avail_out = h, e.next_in = s, e.avail_in = o, r.hold = u, r.bits = l, (r.wsize || c !== e.avail_out && r.mode < 30 && (r.mode < 27 || 4 !== t)) && Z(e, e.output, e.next_out, c - e.avail_out) ? (r.mode = 31, -4) : (f -= e.avail_in, c -= e.avail_out, e.total_in += f, e.total_out += c, r.total += c, r.wrap && c && (e.adler = r.check = r.flags ? B(r.check, i, c, e.next_out - c) : O(r.check, i, c, e.next_out - c)), e.data_type = r.bits + (r.last ? 64 : 0) + (12 === r.mode ? 128 : 0) + (20 === r.mode || 15 === r.mode ? 256 : 0), (0 == f && 0 === c || 4 === t) && x === N && (x = -5), x);
                }, r.inflateEnd = function(e) {
                    if (!e || !e.state) return U;
                    var t = e.state;
                    return t.window && (t.window = null), e.state = null, N;
                }, r.inflateGetHeader = function(e, t) {
                    var r;
                    return e && e.state ? 0 == (2 & (r = e.state).wrap) ? U : ((r.head = t).done = !1, N) : U;
                }, r.inflateSetDictionary = function(e, t) {
                    var r, n = t.length;
                    return e && e.state ? 0 !== (r = e.state).wrap && 11 !== r.mode ? U : 11 === r.mode && O(1, t, n, 0) !== r.check ? -3 : Z(e, t, n, n) ? (r.mode = 31, -4) : (r.havedict = 1, N) : U;
                }, r.inflateInfo = "pako inflate (from Nodeca project)";
            },
            {
                "../utils/common": 41,
                "./adler32": 43,
                "./crc32": 45,
                "./inffast": 48,
                "./inftrees": 50
            }
        ],
        50: [
            function(e, t, r) {
                "use strict";
                var D = e("../utils/common"), F = [
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    10,
                    11,
                    13,
                    15,
                    17,
                    19,
                    23,
                    27,
                    31,
                    35,
                    43,
                    51,
                    59,
                    67,
                    83,
                    99,
                    115,
                    131,
                    163,
                    195,
                    227,
                    258,
                    0,
                    0
                ], N = [
                    16,
                    16,
                    16,
                    16,
                    16,
                    16,
                    16,
                    16,
                    17,
                    17,
                    17,
                    17,
                    18,
                    18,
                    18,
                    18,
                    19,
                    19,
                    19,
                    19,
                    20,
                    20,
                    20,
                    20,
                    21,
                    21,
                    21,
                    21,
                    16,
                    72,
                    78
                ], U = [
                    1,
                    2,
                    3,
                    4,
                    5,
                    7,
                    9,
                    13,
                    17,
                    25,
                    33,
                    49,
                    65,
                    97,
                    129,
                    193,
                    257,
                    385,
                    513,
                    769,
                    1025,
                    1537,
                    2049,
                    3073,
                    4097,
                    6145,
                    8193,
                    12289,
                    16385,
                    24577,
                    0,
                    0
                ], P = [
                    16,
                    16,
                    16,
                    16,
                    17,
                    17,
                    18,
                    18,
                    19,
                    19,
                    20,
                    20,
                    21,
                    21,
                    22,
                    22,
                    23,
                    23,
                    24,
                    24,
                    25,
                    25,
                    26,
                    26,
                    27,
                    27,
                    28,
                    28,
                    29,
                    29,
                    64,
                    64
                ];
                t.exports = function(e, t, r, n, i, s, a, o) {
                    var h, u, l, f, c, d, p, m, _, g = o.bits, b = 0, v = 0, y = 0, w = 0, k = 0, x = 0, S = 0, z = 0, C = 0, E = 0, A = null, I = 0, O = new D.Buf16(16), B = new D.Buf16(16), R = null, T = 0;
                    for(b = 0; b <= 15; b++)O[b] = 0;
                    for(v = 0; v < n; v++)O[t[r + v]]++;
                    for(k = g, w = 15; 1 <= w && 0 === O[w]; w--);
                    if (w < k && (k = w), 0 === w) return i[s++] = 20971520, i[s++] = 20971520, o.bits = 1, 0;
                    for(y = 1; y < w && 0 === O[y]; y++);
                    for(k < y && (k = y), b = z = 1; b <= 15; b++)if (z <<= 1, (z -= O[b]) < 0) return -1;
                    if (0 < z && (0 === e || 1 !== w)) return -1;
                    for(B[1] = 0, b = 1; b < 15; b++)B[b + 1] = B[b] + O[b];
                    for(v = 0; v < n; v++)0 !== t[r + v] && (a[B[t[r + v]]++] = v);
                    if (d = 0 === e ? (A = R = a, 19) : 1 === e ? (A = F, I -= 257, R = N, T -= 257, 256) : (A = U, R = P, -1), b = y, c = s, S = v = E = 0, l = -1, f = (C = 1 << (x = k)) - 1, 1 === e && 852 < C || 2 === e && 592 < C) return 1;
                    for(;;){
                        for(p = b - S, _ = a[v] < d ? (m = 0, a[v]) : a[v] > d ? (m = R[T + a[v]], A[I + a[v]]) : (m = 96, 0), h = 1 << b - S, y = u = 1 << x; i[c + (E >> S) + (u -= h)] = p << 24 | m << 16 | _ | 0, 0 !== u;);
                        for(h = 1 << b - 1; E & h;)h >>= 1;
                        if (0 !== h ? (E &= h - 1, E += h) : E = 0, v++, 0 == --O[b]) {
                            if (b === w) break;
                            b = t[r + a[v]];
                        }
                        if (k < b && (E & f) !== l) {
                            for(0 === S && (S = k), c += y, z = 1 << (x = b - S); x + S < w && !((z -= O[x + S]) <= 0);)x++, z <<= 1;
                            if (C += 1 << x, 1 === e && 852 < C || 2 === e && 592 < C) return 1;
                            i[l = E & f] = k << 24 | x << 16 | c - s | 0;
                        }
                    }
                    return 0 !== E && (i[c + E] = b - S << 24 | 4194304), o.bits = k, 0;
                };
            },
            {
                "../utils/common": 41
            }
        ],
        51: [
            function(e, t, r) {
                "use strict";
                t.exports = {
                    2: "need dictionary",
                    1: "stream end",
                    0: "",
                    "-1": "file error",
                    "-2": "stream error",
                    "-3": "data error",
                    "-4": "insufficient memory",
                    "-5": "buffer error",
                    "-6": "incompatible version"
                };
            },
            {}
        ],
        52: [
            function(e, t, r) {
                "use strict";
                var i = e("../utils/common"), o = 0, h = 1;
                function n(e) {
                    for(var t = e.length; 0 <= --t;)e[t] = 0;
                }
                var s = 0, a = 29, u = 256, l = u + 1 + a, f = 30, c = 19, _ = 2 * l + 1, g = 15, d = 16, p = 7, m = 256, b = 16, v = 17, y = 18, w = [
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    1,
                    1,
                    1,
                    1,
                    2,
                    2,
                    2,
                    2,
                    3,
                    3,
                    3,
                    3,
                    4,
                    4,
                    4,
                    4,
                    5,
                    5,
                    5,
                    5,
                    0
                ], k = [
                    0,
                    0,
                    0,
                    0,
                    1,
                    1,
                    2,
                    2,
                    3,
                    3,
                    4,
                    4,
                    5,
                    5,
                    6,
                    6,
                    7,
                    7,
                    8,
                    8,
                    9,
                    9,
                    10,
                    10,
                    11,
                    11,
                    12,
                    12,
                    13,
                    13
                ], x = [
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    2,
                    3,
                    7
                ], S = [
                    16,
                    17,
                    18,
                    0,
                    8,
                    7,
                    9,
                    6,
                    10,
                    5,
                    11,
                    4,
                    12,
                    3,
                    13,
                    2,
                    14,
                    1,
                    15
                ], z = new Array(2 * (l + 2));
                n(z);
                var C = new Array(2 * f);
                n(C);
                var E = new Array(512);
                n(E);
                var A = new Array(256);
                n(A);
                var I = new Array(a);
                n(I);
                var O, B, R, T = new Array(f);
                function D(e, t, r, n, i) {
                    this.static_tree = e, this.extra_bits = t, this.extra_base = r, this.elems = n, this.max_length = i, this.has_stree = e && e.length;
                }
                function F(e, t) {
                    this.dyn_tree = e, this.max_code = 0, this.stat_desc = t;
                }
                function N(e) {
                    return e < 256 ? E[e] : E[256 + (e >>> 7)];
                }
                function U(e, t) {
                    e.pending_buf[e.pending++] = 255 & t, e.pending_buf[e.pending++] = t >>> 8 & 255;
                }
                function P(e, t, r) {
                    e.bi_valid > d - r ? (e.bi_buf |= t << e.bi_valid & 65535, U(e, e.bi_buf), e.bi_buf = t >> d - e.bi_valid, e.bi_valid += r - d) : (e.bi_buf |= t << e.bi_valid & 65535, e.bi_valid += r);
                }
                function L(e, t, r) {
                    P(e, r[2 * t], r[2 * t + 1]);
                }
                function j(e, t) {
                    for(var r = 0; r |= 1 & e, e >>>= 1, r <<= 1, 0 < --t;);
                    return r >>> 1;
                }
                function Z(e, t, r) {
                    var n, i, s = new Array(g + 1), a = 0;
                    for(n = 1; n <= g; n++)s[n] = a = a + r[n - 1] << 1;
                    for(i = 0; i <= t; i++){
                        var o = e[2 * i + 1];
                        0 !== o && (e[2 * i] = j(s[o]++, o));
                    }
                }
                function W(e) {
                    var t;
                    for(t = 0; t < l; t++)e.dyn_ltree[2 * t] = 0;
                    for(t = 0; t < f; t++)e.dyn_dtree[2 * t] = 0;
                    for(t = 0; t < c; t++)e.bl_tree[2 * t] = 0;
                    e.dyn_ltree[2 * m] = 1, e.opt_len = e.static_len = 0, e.last_lit = e.matches = 0;
                }
                function M(e) {
                    8 < e.bi_valid ? U(e, e.bi_buf) : 0 < e.bi_valid && (e.pending_buf[e.pending++] = e.bi_buf), e.bi_buf = 0, e.bi_valid = 0;
                }
                function H(e, t, r, n) {
                    var i = 2 * t, s = 2 * r;
                    return e[i] < e[s] || e[i] === e[s] && n[t] <= n[r];
                }
                function G(e, t, r) {
                    for(var n = e.heap[r], i = r << 1; i <= e.heap_len && (i < e.heap_len && H(t, e.heap[i + 1], e.heap[i], e.depth) && i++, !H(t, n, e.heap[i], e.depth));)e.heap[r] = e.heap[i], r = i, i <<= 1;
                    e.heap[r] = n;
                }
                function K(e, t, r) {
                    var n, i, s, a, o = 0;
                    if (0 !== e.last_lit) for(; n = e.pending_buf[e.d_buf + 2 * o] << 8 | e.pending_buf[e.d_buf + 2 * o + 1], i = e.pending_buf[e.l_buf + o], o++, 0 === n ? L(e, i, t) : (L(e, (s = A[i]) + u + 1, t), 0 !== (a = w[s]) && P(e, i -= I[s], a), L(e, s = N(--n), r), 0 !== (a = k[s]) && P(e, n -= T[s], a)), o < e.last_lit;);
                    L(e, m, t);
                }
                function Y(e, t) {
                    var r, n, i, s = t.dyn_tree, a = t.stat_desc.static_tree, o = t.stat_desc.has_stree, h = t.stat_desc.elems, u = -1;
                    for(e.heap_len = 0, e.heap_max = _, r = 0; r < h; r++)0 !== s[2 * r] ? (e.heap[++e.heap_len] = u = r, e.depth[r] = 0) : s[2 * r + 1] = 0;
                    for(; e.heap_len < 2;)s[2 * (i = e.heap[++e.heap_len] = u < 2 ? ++u : 0)] = 1, e.depth[i] = 0, e.opt_len--, o && (e.static_len -= a[2 * i + 1]);
                    for(t.max_code = u, r = e.heap_len >> 1; 1 <= r; r--)G(e, s, r);
                    for(i = h; r = e.heap[1], e.heap[1] = e.heap[e.heap_len--], G(e, s, 1), n = e.heap[1], e.heap[--e.heap_max] = r, e.heap[--e.heap_max] = n, s[2 * i] = s[2 * r] + s[2 * n], e.depth[i] = (e.depth[r] >= e.depth[n] ? e.depth[r] : e.depth[n]) + 1, s[2 * r + 1] = s[2 * n + 1] = i, e.heap[1] = i++, G(e, s, 1), 2 <= e.heap_len;);
                    e.heap[--e.heap_max] = e.heap[1], function(e, t) {
                        var r, n, i, s, a, o, h = t.dyn_tree, u = t.max_code, l = t.stat_desc.static_tree, f = t.stat_desc.has_stree, c = t.stat_desc.extra_bits, d = t.stat_desc.extra_base, p = t.stat_desc.max_length, m = 0;
                        for(s = 0; s <= g; s++)e.bl_count[s] = 0;
                        for(h[2 * e.heap[e.heap_max] + 1] = 0, r = e.heap_max + 1; r < _; r++)p < (s = h[2 * h[2 * (n = e.heap[r]) + 1] + 1] + 1) && (s = p, m++), h[2 * n + 1] = s, u < n || (e.bl_count[s]++, a = 0, d <= n && (a = c[n - d]), o = h[2 * n], e.opt_len += o * (s + a), f && (e.static_len += o * (l[2 * n + 1] + a)));
                        if (0 !== m) {
                            do {
                                for(s = p - 1; 0 === e.bl_count[s];)s--;
                                e.bl_count[s]--, e.bl_count[s + 1] += 2, e.bl_count[p]--, m -= 2;
                            }while (0 < m);
                            for(s = p; 0 !== s; s--)for(n = e.bl_count[s]; 0 !== n;)u < (i = e.heap[--r]) || (h[2 * i + 1] !== s && (e.opt_len += (s - h[2 * i + 1]) * h[2 * i], h[2 * i + 1] = s), n--);
                        }
                    }(e, t), Z(s, u, e.bl_count);
                }
                function X(e, t, r) {
                    var n, i, s = -1, a = t[1], o = 0, h = 7, u = 4;
                    for(0 === a && (h = 138, u = 3), t[2 * (r + 1) + 1] = 65535, n = 0; n <= r; n++)i = a, a = t[2 * (n + 1) + 1], ++o < h && i === a || (o < u ? e.bl_tree[2 * i] += o : 0 !== i ? (i !== s && e.bl_tree[2 * i]++, e.bl_tree[2 * b]++) : o <= 10 ? e.bl_tree[2 * v]++ : e.bl_tree[2 * y]++, s = i, u = (o = 0) === a ? (h = 138, 3) : i === a ? (h = 6, 3) : (h = 7, 4));
                }
                function V(e, t, r) {
                    var n, i, s = -1, a = t[1], o = 0, h = 7, u = 4;
                    for(0 === a && (h = 138, u = 3), n = 0; n <= r; n++)if (i = a, a = t[2 * (n + 1) + 1], !(++o < h && i === a)) {
                        if (o < u) for(; L(e, i, e.bl_tree), 0 != --o;);
                        else 0 !== i ? (i !== s && (L(e, i, e.bl_tree), o--), L(e, b, e.bl_tree), P(e, o - 3, 2)) : o <= 10 ? (L(e, v, e.bl_tree), P(e, o - 3, 3)) : (L(e, y, e.bl_tree), P(e, o - 11, 7));
                        s = i, u = (o = 0) === a ? (h = 138, 3) : i === a ? (h = 6, 3) : (h = 7, 4);
                    }
                }
                n(T);
                var q = !1;
                function J(e, t, r, n) {
                    P(e, (s << 1) + (n ? 1 : 0), 3), function(e, t, r, n) {
                        M(e), n && (U(e, r), U(e, ~r)), i.arraySet(e.pending_buf, e.window, t, r, e.pending), e.pending += r;
                    }(e, t, r, !0);
                }
                r._tr_init = function(e) {
                    q || (function() {
                        var e, t, r, n, i, s = new Array(g + 1);
                        for(n = r = 0; n < a - 1; n++)for(I[n] = r, e = 0; e < 1 << w[n]; e++)A[r++] = n;
                        for(A[r - 1] = n, n = i = 0; n < 16; n++)for(T[n] = i, e = 0; e < 1 << k[n]; e++)E[i++] = n;
                        for(i >>= 7; n < f; n++)for(T[n] = i << 7, e = 0; e < 1 << k[n] - 7; e++)E[256 + i++] = n;
                        for(t = 0; t <= g; t++)s[t] = 0;
                        for(e = 0; e <= 143;)z[2 * e + 1] = 8, e++, s[8]++;
                        for(; e <= 255;)z[2 * e + 1] = 9, e++, s[9]++;
                        for(; e <= 279;)z[2 * e + 1] = 7, e++, s[7]++;
                        for(; e <= 287;)z[2 * e + 1] = 8, e++, s[8]++;
                        for(Z(z, l + 1, s), e = 0; e < f; e++)C[2 * e + 1] = 5, C[2 * e] = j(e, 5);
                        O = new D(z, w, u + 1, l, g), B = new D(C, k, 0, f, g), R = new D(new Array(0), x, 0, c, p);
                    }(), q = !0), e.l_desc = new F(e.dyn_ltree, O), e.d_desc = new F(e.dyn_dtree, B), e.bl_desc = new F(e.bl_tree, R), e.bi_buf = 0, e.bi_valid = 0, W(e);
                }, r._tr_stored_block = J, r._tr_flush_block = function(e, t, r, n) {
                    var i, s, a = 0;
                    0 < e.level ? (2 === e.strm.data_type && (e.strm.data_type = function(e) {
                        var t, r = 4093624447;
                        for(t = 0; t <= 31; t++, r >>>= 1)if (1 & r && 0 !== e.dyn_ltree[2 * t]) return o;
                        if (0 !== e.dyn_ltree[18] || 0 !== e.dyn_ltree[20] || 0 !== e.dyn_ltree[26]) return h;
                        for(t = 32; t < u; t++)if (0 !== e.dyn_ltree[2 * t]) return h;
                        return o;
                    }(e)), Y(e, e.l_desc), Y(e, e.d_desc), a = function(e) {
                        var t;
                        for(X(e, e.dyn_ltree, e.l_desc.max_code), X(e, e.dyn_dtree, e.d_desc.max_code), Y(e, e.bl_desc), t = c - 1; 3 <= t && 0 === e.bl_tree[2 * S[t] + 1]; t--);
                        return e.opt_len += 3 * (t + 1) + 5 + 5 + 4, t;
                    }(e), i = e.opt_len + 3 + 7 >>> 3, (s = e.static_len + 3 + 7 >>> 3) <= i && (i = s)) : i = s = r + 5, r + 4 <= i && -1 !== t ? J(e, t, r, n) : 4 === e.strategy || s === i ? (P(e, 2 + (n ? 1 : 0), 3), K(e, z, C)) : (P(e, 4 + (n ? 1 : 0), 3), function(e, t, r, n) {
                        var i;
                        for(P(e, t - 257, 5), P(e, r - 1, 5), P(e, n - 4, 4), i = 0; i < n; i++)P(e, e.bl_tree[2 * S[i] + 1], 3);
                        V(e, e.dyn_ltree, t - 1), V(e, e.dyn_dtree, r - 1);
                    }(e, e.l_desc.max_code + 1, e.d_desc.max_code + 1, a + 1), K(e, e.dyn_ltree, e.dyn_dtree)), W(e), n && M(e);
                }, r._tr_tally = function(e, t, r) {
                    return e.pending_buf[e.d_buf + 2 * e.last_lit] = t >>> 8 & 255, e.pending_buf[e.d_buf + 2 * e.last_lit + 1] = 255 & t, e.pending_buf[e.l_buf + e.last_lit] = 255 & r, e.last_lit++, 0 === t ? e.dyn_ltree[2 * r]++ : (e.matches++, t--, e.dyn_ltree[2 * (A[r] + u + 1)]++, e.dyn_dtree[2 * N(t)]++), e.last_lit === e.lit_bufsize - 1;
                }, r._tr_align = function(e) {
                    P(e, 2, 3), L(e, m, z), function(e) {
                        16 === e.bi_valid ? (U(e, e.bi_buf), e.bi_buf = 0, e.bi_valid = 0) : 8 <= e.bi_valid && (e.pending_buf[e.pending++] = 255 & e.bi_buf, e.bi_buf >>= 8, e.bi_valid -= 8);
                    }(e);
                };
            },
            {
                "../utils/common": 41
            }
        ],
        53: [
            function(e, t, r) {
                "use strict";
                t.exports = function() {
                    this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
                };
            },
            {}
        ],
        54: [
            function(e, t, r) {
                (function(e) {
                    !function(r, n) {
                        "use strict";
                        if (!r.setImmediate) {
                            var i, s, t, a, o = 1, h = {}, u = !1, l = r.document, e = Object.getPrototypeOf && Object.getPrototypeOf(r);
                            e = e && e.setTimeout ? e : r, i = "[object process]" === ({}).toString.call(r.process) ? function(e) {
                                process.nextTick(function() {
                                    c(e);
                                });
                            } : function() {
                                if (r.postMessage && !r.importScripts) {
                                    var e = !0, t = r.onmessage;
                                    return r.onmessage = function() {
                                        e = !1;
                                    }, r.postMessage("", "*"), r.onmessage = t, e;
                                }
                            }() ? (a = "setImmediate$" + Math.random() + "$", r.addEventListener ? r.addEventListener("message", d, !1) : r.attachEvent("onmessage", d), function(e) {
                                r.postMessage(a + e, "*");
                            }) : r.MessageChannel ? ((t = new MessageChannel).port1.onmessage = function(e) {
                                c(e.data);
                            }, function(e) {
                                t.port2.postMessage(e);
                            }) : l && "onreadystatechange" in l.createElement("script") ? (s = l.documentElement, function(e) {
                                var t = l.createElement("script");
                                t.onreadystatechange = function() {
                                    c(e), t.onreadystatechange = null, s.removeChild(t), t = null;
                                }, s.appendChild(t);
                            }) : function(e) {
                                setTimeout(c, 0, e);
                            }, e.setImmediate = function(e) {
                                "function" != typeof e && (e = new Function("" + e));
                                for(var t = new Array(arguments.length - 1), r = 0; r < t.length; r++)t[r] = arguments[r + 1];
                                var n = {
                                    callback: e,
                                    args: t
                                };
                                return h[o] = n, i(o), o++;
                            }, e.clearImmediate = f;
                        }
                        function f(e) {
                            delete h[e];
                        }
                        function c(e) {
                            if (u) setTimeout(c, 0, e);
                            else {
                                var t = h[e];
                                if (t) {
                                    u = !0;
                                    try {
                                        !function(e) {
                                            var t = e.callback, r = e.args;
                                            switch(r.length){
                                                case 0:
                                                    t();
                                                    break;
                                                case 1:
                                                    t(r[0]);
                                                    break;
                                                case 2:
                                                    t(r[0], r[1]);
                                                    break;
                                                case 3:
                                                    t(r[0], r[1], r[2]);
                                                    break;
                                                default:
                                                    t.apply(n, r);
                                            }
                                        }(t);
                                    } finally{
                                        f(e), u = !1;
                                    }
                                }
                            }
                        }
                        function d(e) {
                            e.source === r && "string" == typeof e.data && 0 === e.data.indexOf(a) && c(+e.data.slice(a.length));
                        }
                    }("undefined" == typeof self ? void 0 === e ? this : e : self);
                }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
            },
            {}
        ]
    }, {}, [
        10
    ])(10);
});

},{"4abb3f5ceb14a983":"jjbnd","268091f851e8cd54":"8MGn2"}],"jjbnd":[function(require,module,exports) {
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ /* eslint-disable no-proto */ "use strict";
const base64 = require("ce5249998143b152");
const ieee754 = require("9f9d08cd85b04282");
const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" // eslint-disable-line dot-notation
 ? Symbol["for"]("nodejs.util.inspect.custom") // eslint-disable-line dot-notation
 : null;
exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
const K_MAX_LENGTH = 0x7fffffff;
exports.kMaxLength = K_MAX_LENGTH;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */ Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
function typedArraySupport() {
    // Can typed array instances can be augmented?
    try {
        const arr = new Uint8Array(1);
        const proto = {
            foo: function() {
                return 42;
            }
        };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
    } catch (e) {
        return false;
    }
}
Object.defineProperty(Buffer.prototype, "parent", {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.buffer;
    }
});
Object.defineProperty(Buffer.prototype, "offset", {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.byteOffset;
    }
});
function createBuffer(length) {
    if (length > K_MAX_LENGTH) throw new RangeError('The value "' + length + '" is invalid for option "size"');
    // Return an augmented `Uint8Array` instance
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */ function Buffer(arg, encodingOrOffset, length) {
    // Common case.
    if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") throw new TypeError('The "string" argument must be of type string. Received type number');
        return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
}
Buffer.poolSize = 8192 // not used by this implementation
;
function from(value, encodingOrOffset, length) {
    if (typeof value === "string") return fromString(value, encodingOrOffset);
    if (ArrayBuffer.isView(value)) return fromArrayView(value);
    if (value == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof value === "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) return Buffer.from(valueOf, encodingOrOffset, length);
    const b = fromObject(value);
    if (b) return b;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") return Buffer.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/ Buffer.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
};
// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer, Uint8Array);
function assertSize(size) {
    if (typeof size !== "number") throw new TypeError('"size" argument must be of type number');
    else if (size < 0) throw new RangeError('The value "' + size + '" is invalid for option "size"');
}
function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) return createBuffer(size);
    if (fill !== undefined) // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    return createBuffer(size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/ Buffer.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
};
function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */ Buffer.allocUnsafe = function(size) {
    return allocUnsafe(size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */ Buffer.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
};
function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") encoding = "utf8";
    if (!Buffer.isEncoding(encoding)) throw new TypeError("Unknown encoding: " + encoding);
    const length = byteLength(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual);
    return buf;
}
function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for(let i = 0; i < length; i += 1)buf[i] = array[i] & 255;
    return buf;
}
function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
}
function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) throw new RangeError('"offset" is outside of buffer bounds');
    if (array.byteLength < byteOffset + (length || 0)) throw new RangeError('"length" is outside of buffer bounds');
    let buf;
    if (byteOffset === undefined && length === undefined) buf = new Uint8Array(array);
    else if (length === undefined) buf = new Uint8Array(array, byteOffset);
    else buf = new Uint8Array(array, byteOffset, length);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
function fromObject(obj) {
    if (Buffer.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) return buf;
        obj.copy(buf, 0, 0, len);
        return buf;
    }
    if (obj.length !== undefined) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) return createBuffer(0);
        return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) return fromArrayLike(obj.data);
}
function checked(length) {
    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= K_MAX_LENGTH) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    return length | 0;
}
function SlowBuffer(length) {
    if (+length != length) length = 0;
    return Buffer.alloc(+length);
}
Buffer.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
    ;
};
Buffer.compare = function compare(a, b) {
    if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
    if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (a === b) return 0;
    let x = a.length;
    let y = b.length;
    for(let i = 0, len = Math.min(x, y); i < len; ++i)if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
Buffer.isEncoding = function isEncoding(encoding) {
    switch(String(encoding).toLowerCase()){
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return true;
        default:
            return false;
    }
};
Buffer.concat = function concat(list, length) {
    if (!Array.isArray(list)) throw new TypeError('"list" argument must be an Array of Buffers');
    if (list.length === 0) return Buffer.alloc(0);
    let i;
    if (length === undefined) {
        length = 0;
        for(i = 0; i < list.length; ++i)length += list[i].length;
    }
    const buffer = Buffer.allocUnsafe(length);
    let pos = 0;
    for(i = 0; i < list.length; ++i){
        let buf = list[i];
        if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer.length) {
                if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
                buf.copy(buffer, pos);
            } else Uint8Array.prototype.set.call(buffer, buf, pos);
        } else if (!Buffer.isBuffer(buf)) throw new TypeError('"list" argument must be an Array of Buffers');
        else buf.copy(buffer, pos);
        pos += buf.length;
    }
    return buffer;
};
function byteLength(string, encoding) {
    if (Buffer.isBuffer(string)) return string.length;
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) return string.byteLength;
    if (typeof string !== "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) return 0;
    // Use a for loop to avoid recursion
    let loweredCase = false;
    for(;;)switch(encoding){
        case "ascii":
        case "latin1":
        case "binary":
            return len;
        case "utf8":
        case "utf-8":
            return utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return len * 2;
        case "hex":
            return len >>> 1;
        case "base64":
            return base64ToBytes(string).length;
        default:
            if (loweredCase) return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
            ;
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
    }
}
Buffer.byteLength = byteLength;
function slowToString(encoding, start, end) {
    let loweredCase = false;
    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.
    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) start = 0;
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) return "";
    if (end === undefined || end > this.length) end = this.length;
    if (end <= 0) return "";
    // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0;
    start >>>= 0;
    if (end <= start) return "";
    if (!encoding) encoding = "utf8";
    while(true)switch(encoding){
        case "hex":
            return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
            return utf8Slice(this, start, end);
        case "ascii":
            return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
            return latin1Slice(this, start, end);
        case "base64":
            return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return utf16leSlice(this, start, end);
        default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
    }
}
// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true;
function swap(b, n, m) {
    const i = b[n];
    b[n] = b[m];
    b[m] = i;
}
Buffer.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
    for(let i = 0; i < len; i += 2)swap(this, i, i + 1);
    return this;
};
Buffer.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
    for(let i = 0; i < len; i += 4){
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
    }
    return this;
};
Buffer.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
    for(let i = 0; i < len; i += 8){
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
    }
    return this;
};
Buffer.prototype.toString = function toString() {
    const length = this.length;
    if (length === 0) return "";
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
};
Buffer.prototype.toLocaleString = Buffer.prototype.toString;
Buffer.prototype.equals = function equals(b) {
    if (!Buffer.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
    if (this === b) return true;
    return Buffer.compare(this, b) === 0;
};
Buffer.prototype.inspect = function inspect() {
    let str = "";
    const max = exports.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max) str += " ... ";
    return "<Buffer " + str + ">";
};
if (customInspectSymbol) Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) target = Buffer.from(target, target.offset, target.byteLength);
    if (!Buffer.isBuffer(target)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
    if (start === undefined) start = 0;
    if (end === undefined) end = target ? target.length : 0;
    if (thisStart === undefined) thisStart = 0;
    if (thisEnd === undefined) thisEnd = this.length;
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) throw new RangeError("out of range index");
    if (thisStart >= thisEnd && start >= end) return 0;
    if (thisStart >= thisEnd) return -1;
    if (start >= end) return 1;
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    let x = thisEnd - thisStart;
    let y = end - start;
    const len = Math.min(x, y);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for(let i = 0; i < len; ++i)if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1;
    // Normalize byteOffset
    if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
    } else if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff;
    else if (byteOffset < -2147483648) byteOffset = -2147483648;
    byteOffset = +byteOffset // Coerce to Number.
    ;
    if (numberIsNaN(byteOffset)) // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
    }
    // Normalize val
    if (typeof val === "string") val = Buffer.from(val, encoding);
    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if (Buffer.isBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) return -1;
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
        val = val & 0xFF // Search for a byte value [0-255]
        ;
        if (typeof Uint8Array.prototype.indexOf === "function") {
            if (dir) return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            else return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
        }
        return arrayIndexOf(buffer, [
            val
        ], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) return -1;
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
        }
    }
    function read(buf, i) {
        if (indexSize === 1) return buf[i];
        else return buf.readUInt16BE(i * indexSize);
    }
    let i;
    if (dir) {
        let foundIndex = -1;
        for(i = byteOffset; i < arrLength; i++)if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
        }
    } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for(i = byteOffset; i >= 0; i--){
            let found = true;
            for(let j = 0; j < valLength; j++)if (read(arr, i + j) !== read(val, j)) {
                found = false;
                break;
            }
            if (found) return i;
        }
    }
    return -1;
}
Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    const remaining = buf.length - offset;
    if (!length) length = remaining;
    else {
        length = Number(length);
        if (length > remaining) length = remaining;
    }
    const strLen = string.length;
    if (length > strLen / 2) length = strLen / 2;
    let i;
    for(i = 0; i < length; ++i){
        const parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
    }
    return i;
}
function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
Buffer.prototype.write = function write(string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
    // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === undefined) encoding = "utf8";
        } else {
            encoding = length;
            length = undefined;
        }
    } else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    const remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) throw new RangeError("Attempt to write outside buffer bounds");
    if (!encoding) encoding = "utf8";
    let loweredCase = false;
    for(;;)switch(encoding){
        case "hex":
            return hexWrite(this, string, offset, length);
        case "utf8":
        case "utf-8":
            return utf8Write(this, string, offset, length);
        case "ascii":
        case "latin1":
        case "binary":
            return asciiWrite(this, string, offset, length);
        case "base64":
            // Warning: maxLength not taken into account in base64Write
            return base64Write(this, string, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return ucs2Write(this, string, offset, length);
        default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
    }
};
Buffer.prototype.toJSON = function toJSON() {
    return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
    };
};
function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) return base64.fromByteArray(buf);
    else return base64.fromByteArray(buf.slice(start, end));
}
function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i = start;
    while(i < end){
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;
        if (i + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch(bytesPerSequence){
                case 1:
                    if (firstByte < 0x80) codePoint = firstByte;
                    break;
                case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
                        if (tempCodePoint > 0x7F) codePoint = tempCodePoint;
                    }
                    break;
                case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
                        if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) codePoint = tempCodePoint;
                    }
                    break;
                case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
                        if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) codePoint = tempCodePoint;
                    }
            }
        }
        if (codePoint === null) {
            // we did not generate a valid codePoint so insert a
            // replacement char (U+FFFD) and advance only 1 byte
            codePoint = 0xFFFD;
            bytesPerSequence = 1;
        } else if (codePoint > 0xFFFF) {
            // encode to utf16 (surrogate pair dance)
            codePoint -= 0x10000;
            res.push(codePoint >>> 10 & 0x3FF | 0xD800);
            codePoint = 0xDC00 | codePoint & 0x3FF;
        }
        res.push(codePoint);
        i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
}
// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
const MAX_ARGUMENTS_LENGTH = 0x1000;
function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
    ;
    // Decode in chunks to avoid "call stack size exceeded".
    let res = "";
    let i = 0;
    while(i < len)res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    return res;
}
function asciiSlice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for(let i = start; i < end; ++i)ret += String.fromCharCode(buf[i] & 0x7F);
    return ret;
}
function latin1Slice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for(let i = start; i < end; ++i)ret += String.fromCharCode(buf[i]);
    return ret;
}
function hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    let out = "";
    for(let i = start; i < end; ++i)out += hexSliceLookupTable[buf[i]];
    return out;
}
function utf16leSlice(buf, start, end) {
    const bytes = buf.slice(start, end);
    let res = "";
    // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
    for(let i = 0; i < bytes.length - 1; i += 2)res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    return res;
}
Buffer.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;
    if (start < 0) {
        start += len;
        if (start < 0) start = 0;
    } else if (start > len) start = len;
    if (end < 0) {
        end += len;
        if (end < 0) end = 0;
    } else if (end > len) end = len;
    if (end < start) end = start;
    const newBuf = this.subarray(start, end);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(newBuf, Buffer.prototype);
    return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */ function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
    if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
}
Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;
    return val;
};
Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let val = this[offset + --byteLength];
    let mul = 1;
    while(byteLength > 0 && (mul *= 0x100))val += this[offset + --byteLength] * mul;
    return val;
};
Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
};
Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
};
Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
};
Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};
Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const lo = first + this[++offset] * 256 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 256 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
});
Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
});
Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let i = byteLength;
    let mul = 1;
    let val = this[offset + --i];
    while(i > 0 && (mul *= 0x100))val += this[offset + --i] * mul;
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return this[offset];
    return (0xff - this[offset] + 1) * -1;
};
Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const val = this[offset + 4] + this[offset + 5] * 256 + this[offset + 6] * 2 ** 16 + (last << 24 // Overflow
    );
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 256 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
});
Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 + this[++offset] * 256 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + last);
});
Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
};
Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
};
Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
};
Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
};
function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
}
Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    let mul = 1;
    let i = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;
    return offset + byteLength;
};
Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    let i = byteLength - 1;
    let mul = 1;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;
    return offset + byteLength;
};
Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
    this[offset] = value & 0xff;
    return offset + 1;
};
Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
    return offset + 4;
};
Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
function wrtBigUInt64LE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(0xffffffff));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
}
function wrtBigUInt64BE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(0xffffffff));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
}
Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    let i = 0;
    let mul = 1;
    let sub = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    let i = byteLength - 1;
    let mul = 1;
    let sub = 0;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -128);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = value & 0xff;
    return offset + 1;
};
Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
};
Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
    if (value < 0) value = 0xffffffff + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
    if (offset < 0) throw new RangeError("Index out of range");
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -340282346638528860000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
}
Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
};
Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
};
function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
}
Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
};
Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
};
// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer.isBuffer(target)) throw new TypeError("argument should be a Buffer");
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    // Copy 0 bytes; we're done
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    // Fatal error conditions
    if (targetStart < 0) throw new RangeError("targetStart out of bounds");
    if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
    if (end < 0) throw new RangeError("sourceEnd out of bounds");
    // Are we oob?
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) end = target.length - targetStart + start;
    const len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end);
    else Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    return len;
};
// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === "string") {
        if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
        } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
        }
        if (encoding !== undefined && typeof encoding !== "string") throw new TypeError("encoding must be a string");
        if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) throw new TypeError("Unknown encoding: " + encoding);
        if (val.length === 1) {
            const code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") // Fast path: If `val` fits into a single byte, use that numeric value.
            val = code;
        }
    } else if (typeof val === "number") val = val & 255;
    else if (typeof val === "boolean") val = Number(val);
    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) throw new RangeError("Out of range index");
    if (end <= start) return this;
    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;
    if (!val) val = 0;
    let i;
    if (typeof val === "number") for(i = start; i < end; ++i)this[i] = val;
    else {
        const bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
        const len = bytes.length;
        if (len === 0) throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        for(i = 0; i < end - start; ++i)this[i + start] = bytes[i % len];
    }
    return this;
};
// CUSTOM ERRORS
// =============
// Simplified versions from Node, changed for Buffer-only usage
const errors = {};
function E(sym, getMessage, Base) {
    errors[sym] = class NodeError extends Base {
        constructor(){
            super();
            Object.defineProperty(this, "message", {
                value: getMessage.apply(this, arguments),
                writable: true,
                configurable: true
            });
            // Add the error code to the name to include it in the stack trace.
            this.name = `${this.name} [${sym}]`;
            // Access the stack to generate the error message including the error code
            // from the name.
            this.stack // eslint-disable-line no-unused-expressions
            ;
            // Reset the name to the actual name.
            delete this.name;
        }
        get code() {
            return sym;
        }
        set code(value) {
            Object.defineProperty(this, "code", {
                configurable: true,
                enumerable: true,
                value,
                writable: true
            });
        }
        toString() {
            return `${this.name} [${sym}]: ${this.message}`;
        }
    };
}
E("ERR_BUFFER_OUT_OF_BOUNDS", function(name) {
    if (name) return `${name} is outside of buffer bounds`;
    return "Attempt to access memory outside buffer bounds";
}, RangeError);
E("ERR_INVALID_ARG_TYPE", function(name, actual) {
    return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
}, TypeError);
E("ERR_OUT_OF_RANGE", function(str, range, input) {
    let msg = `The value of "${str}" is out of range.`;
    let received = input;
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) received = addNumericalSeparator(String(input));
    else if (typeof input === "bigint") {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) received = addNumericalSeparator(received);
        received += "n";
    }
    msg += ` It must be ${range}. Received ${received}`;
    return msg;
}, RangeError);
function addNumericalSeparator(val) {
    let res = "";
    let i = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for(; i >= start + 4; i -= 3)res = `_${val.slice(i - 3, i)}${res}`;
    return `${val.slice(0, i)}${res}`;
}
// CHECK FUNCTIONS
// ===============
function checkBounds(buf, offset, byteLength) {
    validateNumber(offset, "offset");
    if (buf[offset] === undefined || buf[offset + byteLength] === undefined) boundsError(offset, buf.length - (byteLength + 1));
}
function checkIntBI(value, min, max, buf, offset, byteLength) {
    if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength > 3) {
            if (min === 0 || min === BigInt(0)) range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;
            else range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` + `${(byteLength + 1) * 8 - 1}${n}`;
        } else range = `>= ${min}${n} and <= ${max}${n}`;
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds(buf, offset, byteLength);
}
function validateNumber(value, name) {
    if (typeof value !== "number") throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
}
function boundsError(value, length, type) {
    if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
    }
    if (length < 0) throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
    throw new errors.ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length}`, value);
}
// HELPER FUNCTIONS
// ================
const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
function base64clean(str) {
    // Node takes equal signs as end of the Base64 encoding
    str = str.split("=")[0];
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = str.trim().replace(INVALID_BASE64_RE, "");
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return "";
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while(str.length % 4 !== 0)str = str + "=";
    return str;
}
function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for(let i = 0; i < length; ++i){
        codePoint = string.charCodeAt(i);
        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
            // last char was a lead
            if (!leadSurrogate) {
                // no lead yet
                if (codePoint > 0xDBFF) {
                    // unexpected trail
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                } else if (i + 1 === length) {
                    // unpaired lead
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                }
                // valid lead
                leadSurrogate = codePoint;
                continue;
            }
            // 2 leads in a row
            if (codePoint < 0xDC00) {
                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                leadSurrogate = codePoint;
                continue;
            }
            // valid surrogate pair
            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) // valid bmp char, but last char was a lead
        {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        }
        leadSurrogate = null;
        // encode utf8
        if (codePoint < 0x80) {
            if ((units -= 1) < 0) break;
            bytes.push(codePoint);
        } else if (codePoint < 0x800) {
            if ((units -= 2) < 0) break;
            bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x10000) {
            if ((units -= 3) < 0) break;
            bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x110000) {
            if ((units -= 4) < 0) break;
            bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else throw new Error("Invalid code point");
    }
    return bytes;
}
function asciiToBytes(str) {
    const byteArray = [];
    for(let i = 0; i < str.length; ++i)// Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
    return byteArray;
}
function utf16leToBytes(str, units) {
    let c, hi, lo;
    const byteArray = [];
    for(let i = 0; i < str.length; ++i){
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
    }
    return byteArray;
}
function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
    let i;
    for(i = 0; i < length; ++i){
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
    }
    return i;
}
// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}
function numberIsNaN(obj) {
    // For IE11 support
    return obj !== obj // eslint-disable-line no-self-compare
    ;
}
// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
const hexSliceLookupTable = function() {
    const alphabet = "0123456789abcdef";
    const table = new Array(256);
    for(let i = 0; i < 16; ++i){
        const i16 = i * 16;
        for(let j = 0; j < 16; ++j)table[i16 + j] = alphabet[i] + alphabet[j];
    }
    return table;
}();
// Return not function with Error if BigInt not supported
function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
}
function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
}

},{"ce5249998143b152":"j8XRz","9f9d08cd85b04282":"bCMPJ"}],"j8XRz":[function(require,module,exports) {
"use strict";
exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for(var i = 0, len = code.length; i < len; ++i){
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
}
// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
    var len = b64.length;
    if (len % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    // Trim off extra bytes after placeholder bytes are found
    // See: https://github.com/beatgammit/base64-js/issues/42
    var validLen = b64.indexOf("=");
    if (validLen === -1) validLen = len;
    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
    return [
        validLen,
        placeHoldersLen
    ];
}
// base64 is 4/3 + up to two characters of the original data
function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    // if there are placeholders, only get up to the last complete 4 chars
    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i;
    for(i = 0; i < len; i += 4){
        tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
        arr[curByte++] = tmp >> 16 & 0xFF;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    return arr;
}
function tripletToBase64(num) {
    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}
function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for(var i = start; i < end; i += 3){
        tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
        output.push(tripletToBase64(tmp));
    }
    return output.join("");
}
function fromByteArray(uint8) {
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
    ;
    var parts = [];
    var maxChunkLength = 16383 // must be multiple of 3
    ;
    // go through the array every three bytes, we'll deal with trailing stuff later
    for(var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength)parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
        tmp = uint8[len - 1];
        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + "==");
    } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + uint8[len - 1];
        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + "=");
    }
    return parts.join("");
}

},{}],"bCMPJ":[function(require,module,exports) {
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ exports.read = function(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for(; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for(; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);
    if (e === 0) e = 1 - eBias;
    else if (e === eMax) return m ? NaN : (s ? -1 : 1) * Infinity;
    else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
    } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
        }
        if (e + eBias >= 1) value += rt / c;
        else value += rt * Math.pow(2, 1 - eBias);
        if (value * c >= 2) {
            e++;
            c /= 2;
        }
        if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
        } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
        } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
        }
    }
    for(; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);
    e = e << mLen | m;
    eLen += mLen;
    for(; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);
    buffer[offset + i - d] |= s * 128;
};

},{}],"hWZ4e":[function(require,module,exports) {
"use strict";
const { obj, fn } = require("1123d4b4c46fa3fd");
const { context, set, isSet, isGet, schedule: _schedule, create: _create, connect: _connect, disconnect: _disconnect } = require("287735a63438f7b9");
const reverb = require("398de5d84657ea9c");
const lfo = require("4cd8d33c283acf49");
const adsr = require("fd1c29a366d383ab");
const create = (type, prefs = {}, ctx = context)=>Object.assign({}, obj.switch(type, {
        vco: ()=>({
                output: _create("oscillator")
            }),
        vca: ()=>({
                through: _create("gain")
            }),
        vcf: ()=>({
                through: _create("biquadFilter")
            }),
        lfo: ()=>lfo.create(prefs),
        reverb: ()=>reverb.create(prefs),
        adsr: ()=>adsr.create(prefs)
    })(), {
        type,
        out: []
    });
const cutoffToFreq = (cutoff)=>{
    const minValue = 40;
    const maxValue = context.sampleRate / 2;
    // Logarithm (base 2) to compute how many octaves fall in the range.
    var numberOfOctaves = Math.log(maxValue / minValue) / Math.LN2;
    // Compute a multiplier from 0 to 1 based on an exponential scale.
    var multiplier = Math.pow(2, numberOfOctaves * (cutoff - 1.0));
    // Get back to the frequency value between min and max.
    return maxValue * multiplier;
};
const update = (node, prefs)=>obj.switch(node.type, {
        vco: ()=>(isSet(prefs.type) && set(node.output, "type", prefs.type), isSet(prefs.freq) && set(node.output.frequency, "value", prefs.freq), isSet(prefs.detune) && set(node.output.detune, "value", prefs.detune), Object.assign(node, {
                prefs
            })),
        vca: ()=>(isSet(prefs.gain) && set(node.through.gain, "value", prefs.gain), Object.assign(node, {
                prefs
            })),
        vcf: ()=>(isSet(prefs.type) && set(node.through, "type", prefs.type), isSet(prefs.cutoff) && _schedule(node.through, "frequency", [
                cutoffToFreq(prefs.cutoff)
            ], [
                context.currentTime + 0.0001
            ]), // set(node.through.frequency, 'value', cutoffToFreq(prefs.cutoff)),
            isSet(prefs.resonance) && _schedule(node.through, "Q", [
                prefs.resonance * 30
            ], [
                context.currentTime + 0.0001
            ]), Object.assign(node, {
                prefs
            })),
        reverb: ()=>reverb.update(node, prefs),
        adsr: ()=>adsr.update(node, prefs),
        lfo: ()=>lfo.update(node, prefs)
    })();
const connect = (node1, node2)=>!(node1.out && node1.out.indexOf(node2) > -1) ? (_connect(// input
    isGet(node1.output) || isGet(node1.through) || isSet(node1.connect) && node1, // output
    node2 instanceof AudioParam && node2 || isGet(node2.input) || isGet(node2.through) || node2), Object.assign({}, node1, {
        out: [].concat(node1.out || [], [
            node2
        ])
    })) : node1;
const disconnect = (node1, node2)=>// (console.log('dissconnecting', node1, node2)),
    node1.out.indexOf(node2) > -1 ? (_disconnect(// input
    isGet(node1.output) || isGet(node1.through) || isSet(node1.connect) && node1, // output
    node2 instanceof AudioParam && node2 || isGet(node2.input) || isGet(node2.through) || node2), Object.assign({}, node1, {
        out: [].concat(node1.out.slice(0, node1.out.indexOf(node2)), node1.out.slice(node1.out.indexOf(node2) + 1))
    })) : typeof node2 === "undefined" ? node1.out.reduce((node1, prevNode)=>disconnect(node1, prevNode), node1) : node1;
const reroute = (node1, node2)=>node1.out && node1.out.indexOf(node2) === -1 ? connect(disconnect(node1), node2) : node1;
const chain = (...nodes)=>(nodes.forEach((n, i)=>isSet(n[i + 1]) && connect(n, nodes[i + 1])), nodes[0]);
const unchain = (...nodes)=>(nodes.slice().reverse().forEach((n, i)=>isSet(n[i - 1]) && disconnect(nodes[i - 1], n)), nodes[0]);
const start = (node, ...args)=>(node.type === "lfo" && lfo.start(node, ...args) || node.output.start(...args), node);
const stop = (node, ...args)=>(node.output.stop(...args), node);
const schedule = (node, pref, values, times)=>values.length === 1 ? node.through[pref].setValueAtTime(values[0], times[0]) : (node.through[pref].setValueCurveAtTime(new Float32Array(values.slice(0, 2)), times[0], times[1]), values.length > 2 && schedule(node, pref, values.slice(1), [
        times[0] + times[1]
    ].concat(times.slice(2))));
const noteToFrequency = function(note) {
    var notes = [
        "A",
        "A#",
        "B",
        "C",
        "C#",
        "D",
        "D#",
        "E",
        "F",
        "F#",
        "G",
        "G#"
    ];
    var keyNumber;
    var octave;
    if (note.length === 3) octave = note.charAt(2);
    else octave = note.charAt(1);
    keyNumber = notes.indexOf(note.slice(0, -1));
    if (keyNumber < 3) keyNumber = keyNumber + 12 + (octave - 1) * 12 + 1;
    else keyNumber = keyNumber + (octave - 1) * 12 + 1;
    return 440 * Math.pow(2, (keyNumber - 49) / 12);
};
module.exports = {
    context,
    create,
    update,
    schedule,
    connect,
    disconnect,
    reroute,
    chain,
    unchain,
    noteToFrequency,
    start,
    stop,
    vco: (prefs)=>update(create("vco", {}, context), prefs),
    vcf: (prefs)=>update(create("vcf", {}, context), prefs),
    lfo: (prefs)=>update(create("lfo", {}, context), prefs),
    vca: (prefs)=>update(create("vca", {}, context), prefs),
    adsr: (prefs)=>create("adsr", prefs, context),
    noteOn: adsr.noteOn,
    noteOff: adsr.noteOff
};

},{"1123d4b4c46fa3fd":"2lXuw","287735a63438f7b9":"ez43F","398de5d84657ea9c":"bS3Ri","4cd8d33c283acf49":"lVmqa","fd1c29a366d383ab":"9iP5U"}],"ez43F":[function(require,module,exports) {
"use strict";
const { obj, fn } = require("35791b99e399d28d");
const context = new (window.AudioContext || window.webkitAudioContext || window.mozAudioContext || window.oAudioContext || window.msAudioContext)();
const set = (o, k, v)=>o[k] = v;
const isSet = (v)=>v !== undefined;
const isGet = (v)=>isSet(v) ? v : null;
const apply = (o1, o2)=>Object.keys(o2).reduce((o, k)=>set(o, k, o2[k]), o1);
const create = (type, ...args)=>// console.log(type),
    obj.switch(type, {
        oscillator: ()=>context.createOscillator(...args),
        gain: ()=>context.createGain(...args),
        biquadFilter: ()=>context.createBiquadFilter(...args),
        convolver: ()=>context.createConvolver(...args),
        buffer: ()=>context.createBuffer(...args),
        bufferSource: ()=>context.createBufferSource(...args)
    })();
const update = (node, prefs)=>apply(node, prefs);
const connect = (n1, n2)=>// console.log(n1, n2),
    (n1.connect(n2), n1);
const disconnect = (n1, n2)=>{
    // since there is no way to determine if they are connected
    try {
        n1.disconnect(n2);
    } catch (err) {
        console.log(err);
    }
    return n1;
};
const chain = (...nodes)=>(nodes.forEach((n, i)=>isSet(nodes[i + 1]) && connect(n, nodes[i + 1])), nodes[0]);
const unchain = (...nodes)=>(nodes.slice().reverse().forEach((n, i)=>isSet(nodes[i - 1]) && disconnect(nodes[i - 1], n)), nodes[0]);
const duration = (seconds)=>context.sampleRate * seconds;
const chData = (node, ...args)=>// console.log(node, args),
    node.getChannelData(...args);
const schedule = (node, pref, values, times)=>values.length === 1 ? node[pref].setValueAtTime(values[0], times[0]) : (node[pref].setValueCurveAtTime(new Float32Array(values.slice(0, 2)), times[0], times[1]), values.length > 2 && schedule(node, pref, values.slice(1), [
        times[0] + times[1]
    ].concat(times.slice(2))));
module.exports = {
    context,
    set,
    isSet,
    isGet,
    create,
    update,
    connect,
    disconnect,
    chain,
    unchain,
    // util
    duration,
    chData,
    schedule
};

},{"35791b99e399d28d":"2lXuw"}],"bS3Ri":[function(require,module,exports) {
"use strict";
const { obj, fn } = require("83f181d91452597b");
const { context, create: _create, set, chain, duration, chData } = require("76ea236c92a02e63");
// const {context} = core;
const buildImpulse = ({ seconds, decay })=>{
    let impulse = _create("buffer", 2, duration(seconds), context.sampleRate);
    let channelData = [
        chData(impulse, 0),
        chData(impulse, 1)
    ];
    for(let i = 0; i < duration(seconds); i++){
        channelData[0][i] = (Math.random() * 2 - 1) * Math.pow(1 - i / duration(seconds), decay);
        channelData[1][i] = (Math.random() * 2 - 1) * Math.pow(1 - i / duration(seconds), decay);
    }
    return impulse;
};
const create = (prefs)=>[
        {
            prefs: Object.assign({
                seconds: 3,
                decay: 2,
                wet: 0,
                dry: 1
            }, prefs),
            input: _create("gain"),
            output: _create("gain"),
            effect: _create("convolver"),
            wet: _create("gain"),
            dry: _create("gain")
        }
    ].map((n)=>(chain(n.input, n.dry, n.output), chain(n.input, n.effect, n.wet, n.output), set(n.dry.gain, "value", n.prefs.dry), set(n.wet.gain, "value", n.prefs.wet), set(n.effect, "buffer", buildImpulse(n.prefs)), n)).pop();
const update = (n, prefs)=>(//	console.log(prefs, n.prefs),
    (n.prefs.seconds !== prefs.seconds || n.prefs.decay !== prefs.decay) && set(n.effect, "buffer", buildImpulse(n.prefs)), n.prefs.dry !== prefs.dry && set(n.dry.gain, "value", prefs.dry), n.prefs.wet !== prefs.wet && set(n.wet.gain, "value", prefs.wet), set(n, "prefs", Object.assign({}, n.prefs, prefs)), n);
module.exports = {
    create,
    update
};

},{"83f181d91452597b":"2lXuw","76ea236c92a02e63":"ez43F"}],"lVmqa":[function(require,module,exports) {
"use strict";
const { obj, fn } = require("492517b95d7fd417");
const { context, create: _create, set, chain, duration, chData } = require("f9c05f4f1f10ceec");
const create = (prefs)=>[
        {
            prefs: Object.assign({
                type: "sawtooth",
                frequency: 5,
                gain: 15
            }, prefs),
            effect: _create("oscillator"),
            output: _create("gain")
        }
    ].map((n)=>(chain(n.effect, n.output), set(n.effect.frequency, "value", n.prefs.frequency), set(n.output.gain, "value", n.prefs.gain), set(n.effect, "type", n.prefs.type), n)).pop();
const update = (n, prefs)=>(set(n, "prefs", Object.assign({}, n.prefs, prefs)), set(n.effect.frequency, "value", n.prefs.frequency), set(n.output.gain, "value", n.prefs.gain), set(n.effect, "type", n.prefs.type), n);
const start = (n, ...args)=>(n.effect.start(), n);
// const clone = n => create(null, n.output.buffer);
module.exports = {
    create,
    update,
    start
};

},{"492517b95d7fd417":"2lXuw","f9c05f4f1f10ceec":"ez43F"}],"9iP5U":[function(require,module,exports) {
"use strict";
const { obj, fn } = require("595903495d09b744");
const { context, create: _create, set, chain, duration, chData, schedule } = require("8c9bd187d6a8021f");
const create = (prefs)=>[
        {
            prefs: Object.assign({
                volume: 0.41,
                attack: 0.31,
                decay: 0.16,
                sustain: 0.8,
                release: 0.21
            }, prefs),
            through: _create("gain")
        }
    ].map((n)=>(set(n.through.gain, "value", 0), n)).pop();
const update = (n, prefs)=>(set(n, "prefs", Object.assign({}, n.prefs, prefs)), n);
const noteOn = (node, velocity, time)=>{
    const now = context.currentTime;
    time = (time || now) + 0.0001;
    node.through.gain.cancelScheduledValues(0);
    const changes = [].concat(// attack
    node.prefs.attack > 0 ? [
        [
            0,
            time
        ],
        [
            velocity * node.prefs.volume,
            node.prefs.attack
        ]
    ] : [
        [
            velocity * node.prefs.volume,
            time
        ]
    ], // decay
    node.prefs.decay > 0 ? [
        [
            node.prefs.sustain * velocity * node.prefs.volume,
            node.prefs.decay
        ]
    ] : []).reduce((a, c)=>[
            [].concat(a[0], c[0]),
            [].concat(a[1], c[1])
        ], [
        [],
        []
    ]);
    schedule(node.through, "gain", changes[0], changes[1]);
    return node;
};
const noteOff = (node, time)=>{
    const now = context.currentTime;
    time = time || now + 0.0001;
    setTimeout(()=>(node.through.gain.cancelScheduledValues(0), node.through.gain.setValueCurveAtTime(new Float32Array([
            node.through.gain.value,
            0
        ]), time, node.prefs.release > 0 && node.prefs.release || 0.00001)), (time - now) * 1000);
    return node;
};
module.exports = {
    create,
    update,
    noteOn,
    noteOff
};

},{"595903495d09b744":"2lXuw","8c9bd187d6a8021f":"ez43F"}],"52guS":[function(require,module,exports) {
"use strict";
const { obj, fn } = require("71fe2203fcf60023");
const { context, create: _create, set, chain, duration, chData } = require("648265360eef4d38");
const create = (file, buffer)=>[
        {
            output: _create("bufferSource")
        }
    ].map((n)=>(!buffer ? fetch(file).then((res)=>res.arrayBuffer()).then((buffer)=>context.decodeAudioData(buffer, (buffer)=>set(n.output, "buffer", buffer))) : set(n.output, "buffer", buffer), n)).pop();
const update = ()=>{};
const clone = (n)=>create(null, n.output.buffer);
module.exports = {
    create,
    update,
    clone
};

},{"71fe2203fcf60023":"2lXuw","648265360eef4d38":"ez43F"}],"kV9Wt":[function(require,module,exports) {
module.exports = JSON.parse('{"ui":{"mediaLibrary":true,"patches":true,"instrument":true,"sequencer":true,"midiMap":true},"myo":{"on":false,"reverse":false,"osc":{}},"wrlds":{"on":false,"port":8888,"mode":0,"threshold":50,"rotation":[]},"viewport":{"screen":{"width":1439,"height":718,"size":"xl"},"mouse":{"x":400,"y":300}},"layout":{"mediaLibrary":{"visible":false,"dim":{"width":280,"height":"100%"},"pos":{"col":0,"row":0}},"instrument":{"visible":true,"dim":{"width":320,"height":"100%"},"pos":{"col":1,"row":0}},"session":{"visible":true,"dim":{"width":560,"height":"100%"},"pos":{"col":2,"row":0}},"sequencer":{"visible":true,"dim":{"width":560},"pos":{"col":3,"row":0}},"pianoRoll":{"visible":true,"dim":{"width":560},"pos":{"col":3,"row":1}},"midiKeyboard":{"visible":true,"dim":{"width":600},"pos":{"col":3,"row":2}},"midiMap":{"visible":true,"dim":{"width":600,"height":"100%"},"pos":{"col":4,"row":0}}},"studio":{"bpm":"90","measure":"3/4","beatLength":12,"barsLength":1,"startAudioTime":false,"playing":false,"recording":false,"tick":{"index":-1,"time":0,"bar":0,"elapsed":-1,"tracks":[{"index":-1},{"index":-1},{"index":-1},{"index":-1}]},"volume":0.625,"channels":[{"instr":"sampler","name":"Sampler 1","volume":0.4,"props":{}},{"instr":"basicSynth","name":"Basic Synth 1","volume":0.4,"props":{}},{"instr":"basicSynth","name":"Basic Synth 2","volume":0.4,"props":{}}]},"instrument":{"vcaOn":1,"vca1":{"volume":0.29,"attack":0,"decay":0.16,"sustain":0.8,"release":0.21},"vca2":{"volume":0.25,"attack":0,"decay":0.16,"sustain":0.8,"release":0.19},"vca3":{"volume":0.7,"attack":0,"decay":0.04,"sustain":0.8,"release":0.08},"vca4":{"volume":0.7,"attack":0,"decay":0.04,"sustain":0.8,"release":0.08},"vco1":{"on":true,"type":"square","detune":-1},"vco2":{"on":true,"type":"sawtooth","detune":1},"lfo":{"on":true,"expanded":true,"type":"sawtooth","frequency":1.1,"gain":0.15},"vcf":{"on":true,"expanded":true,"type":"lowpass","cutoff":0.64,"resonance":0.15,"gain":0},"delay":{"on":false,"expanded":true,"time":1,"dry":1,"wet":0},"reverb":{"on":true,"expanded":true,"seconds":3,"decay":2,"reverse":false,"dry":0.54,"wet":0.86}},"mediaLibrary":{"files":["samples/kick01.ogg","samples/kick02.ogg","samples/kick03.ogg","samples/kick_hiphop01.ogg","samples/hihat_opened02.ogg","samples/hihat_opened03.ogg","samples/ride02.ogg","samples/rim01.ogg","samples/snare01.ogg","samples/snare02.ogg","samples/snare03.ogg","samples/snare04.ogg","samples/snare05.ogg","samples/clap01.ogg","samples/clap02.ogg","samples/clap03.ogg","samples/clap04.ogg","samples/shaker01.ogg","samples/shaker02.ogg","openpathmusic/maracas-dbl.wav","openpathmusic/maracas-roll.wav","openpathmusic/metal tray hit with medium tail.wav","openpathmusic/ratchet.wav","openpathmusic/sleighbells.wav","openpathmusic/triangle.wav","openpathmusic/triangle-classical.wav","openpathmusic/woodblock.wav","openpathmusic/afuche/afuche-long.wav","openpathmusic/afuche/afuche.wav","openpathmusic/tumba/tumba-slap-2.wav","openpathmusic/tumba/tumba-slap-1.wav","openpathmusic/tumba/tumba-open-2.wav","openpathmusic/tumba/tumba-open-1.wav","openpathmusic/tumba/tumba-muffled-2.wav","openpathmusic/tumba/tumba-muffled-1.wav","openpathmusic/timbale/timbaleloi-rim-2.wav","openpathmusic/timbale/timbaleloi-rim-1.wav","openpathmusic/timbale/timbale-side-2.wav","openpathmusic/timbale/timbale-side-1.wav","openpathmusic/timbale/timbale-lo-open-2.wav","openpathmusic/timbale/timbale-lo-open-1.wav","openpathmusic/timbale/timbale-hi-rim-2.wav","openpathmusic/timbale/timbale-hi-rim-1.wav","openpathmusic/timbale/timbale-hi-open-2.wav","openpathmusic/timbale/timbale-hi-open-1.wav","openpathmusic/timbale/timbale-hi-crosstick-2.wav","openpathmusic/timbale/timbale-hi-crosstick-1.wav","openpathmusic/tambourine/tambourine-rock-single.wav","openpathmusic/tambourine/tambourine-classical-thumbroll.wav","openpathmusic/tambourine/tambourine-classical-tap.wav","openpathmusic/tambourine/tambourine-classical-loud.wav","openpathmusic/tabla/tabla-lo-keh.wav","openpathmusic/tabla/tabla-lo-geh.wav","openpathmusic/tabla/tabla-lo-geh-gliss.wav","openpathmusic/tabla/tabla-hi-tuut.wav","openpathmusic/tabla/tabla-hi-tun.wav","openpathmusic/tabla/tabla-hi-tuh.wav","openpathmusic/tabla/tabla-hi-tin.wav","openpathmusic/tabla/tabla-hi-na.wav","openpathmusic/shaker/shaker.wav","openpathmusic/shaker/shaker-lo-up.wav","openpathmusic/shaker/shaker-lo-down.wav","openpathmusic/shaker/shaker-hi-up.wav","openpathmusic/shaker/shaker-hi-down.wav","openpathmusic/tom/drum-tom-hi-tap.wav","openpathmusic/tom/drum-tom-hi-mallet.wav","openpathmusic/tom/drum-tom-hi-brush.wav","openpathmusic/surdo/drum-surdo-large-open.wav","openpathmusic/surdo/drum-surdo-large-lick.wav","openpathmusic/surdo/drum-surdo-large-closed.wav","openpathmusic/surdo/drum-surdo-large-closed-short.wav","openpathmusic/snare/drum-snare-tap.wav","openpathmusic/snare/drum-snare-sidestick.wav","openpathmusic/snare/drum-snare-roll-short.wav","openpathmusic/snare/drum-snare-roll-long.wav","openpathmusic/snare/drum-snare-rim.wav","openpathmusic/snare/drum-snare-drag.wav","openpathmusic/snare/drum-snare-brush-tap.wav","openpathmusic/snare/drum-snare-brush-long.wav","openpathmusic/bass/drum-bass-lo-2.wav","openpathmusic/bass/drum-bass-lo-1.wav","openpathmusic/bass/drum-bass-hi-2.wav","openpathmusic/bass/drum-bass-hi-1.wav","openpathmusic/cymbal/fingercymbals.wav","openpathmusic/cymbal/fingercymbals-large.wav","openpathmusic/cymbal/cymbal-splash-stick.wav","openpathmusic/cymbal/cymbal-sizzle-stick.wav","openpathmusic/cymbal/cymbal-ride-stick.wav","openpathmusic/cymbal/cymbal-ride-roll-short.wav","openpathmusic/cymbal/cymbal-ride-bell.wav","openpathmusic/cymbal/cymbal-ride-bell-short.wav","openpathmusic/cymbal/cymbal-hihat-stick.wav","openpathmusic/cymbal/cymbal-hihat-openclose-stick.wav","openpathmusic/cymbal/cymbal-hihat-open-stick-2.wav","openpathmusic/cymbal/cymbal-hihat-open-stick-1.wav","openpathmusic/cymbal/cymbal-hihat-foot-open.wav","openpathmusic/cymbal/cymbal-hihat-foot-2.wav","openpathmusic/cymbal/cymbal-hihat-foot-1.wav","openpathmusic/cymbal/cymbal-china-stick.wav","openpathmusic/cymbal/cymbal-china-mallet.wav","openpathmusic/cowbell/cowbell-small-open.wav","openpathmusic/cowbell/cowbell-small-closed.wav","openpathmusic/cowbell/cowbell-large-open.wav","openpathmusic/cowbell/cowbell-large-closed.wav","openpathmusic/conga/conga-slap-2.wav","openpathmusic/conga/conga-slap-1.wav","openpathmusic/conga/conga-open-2.wav","openpathmusic/conga/conga-open-1.wav","openpathmusic/conga/conga-muffled-2.wav","openpathmusic/conga/conga-muffled-1.wav","junk-drum-kit/crash-single-hit.ogg","junk-drum-kit/hat-closed-single-hit.ogg","junk-drum-kit/hat-open-single-hit.ogg","junk-drum-kit/hi-tom-single-hit.ogg","junk-drum-kit/ride-single-hit.ogg","junk-drum-kit/single-hit.ogg","junk-drum-kit/snare-single-hit.ogg"],"samples":[{"name":"custom","items":[]},{"name":"samples","items":["kick01.ogg","kick02.ogg","kick03.ogg","kick_hiphop01.ogg","hihat_opened02.ogg","hihat_opened03.ogg","ride02.ogg","rim01.ogg","snare01.ogg","snare02.ogg","snare03.ogg","snare04.ogg","snare05.ogg","clap01.ogg","clap02.ogg","clap03.ogg","clap04.ogg","shaker01.ogg","shaker02.ogg"]},{"name":"openpathmusic","items":["maracas-dbl.wav","maracas-roll.wav","metal tray hit with medium tail.wav","ratchet.wav","sleighbells.wav","triangle.wav","triangle-classical.wav","woodblock.wav",{"name":"afuche","items":["afuche-long.wav","afuche.wav"]},{"name":"tumba","items":["tumba-slap-2.wav","tumba-slap-1.wav","tumba-open-2.wav","tumba-open-1.wav","tumba-muffled-2.wav","tumba-muffled-1.wav"]},{"name":"timbale","items":["timbaleloi-rim-2.wav","timbaleloi-rim-1.wav","timbale-side-2.wav","timbale-side-1.wav","timbale-lo-open-2.wav","timbale-lo-open-1.wav","timbale-hi-rim-2.wav","timbale-hi-rim-1.wav","timbale-hi-open-2.wav","timbale-hi-open-1.wav","timbale-hi-crosstick-2.wav","timbale-hi-crosstick-1.wav"]},{"name":"tambourine","items":["tambourine-rock-single.wav","tambourine-classical-thumbroll.wav","tambourine-classical-tap.wav","tambourine-classical-loud.wav"]},{"name":"tabla","items":["tabla-lo-keh.wav","tabla-lo-geh.wav","tabla-lo-geh-gliss.wav","tabla-hi-tuut.wav","tabla-hi-tun.wav","tabla-hi-tuh.wav","tabla-hi-tin.wav","tabla-hi-na.wav"]},{"name":"shaker","items":["shaker.wav","shaker-lo-up.wav","shaker-lo-down.wav","shaker-hi-up.wav","shaker-hi-down.wav"]},{"name":"tom","items":["drum-tom-hi-tap.wav","drum-tom-hi-mallet.wav","drum-tom-hi-brush.wav"]},{"name":"surdo","items":["drum-surdo-large-open.wav","drum-surdo-large-lick.wav","drum-surdo-large-closed.wav","drum-surdo-large-closed-short.wav"]},{"name":"snare","items":["drum-snare-tap.wav","drum-snare-sidestick.wav","drum-snare-roll-short.wav","drum-snare-roll-long.wav","drum-snare-rim.wav","drum-snare-drag.wav","drum-snare-brush-tap.wav","drum-snare-brush-long.wav"]},{"name":"bass","items":["drum-bass-lo-2.wav","drum-bass-lo-1.wav","drum-bass-hi-2.wav","drum-bass-hi-1.wav"]},{"name":"cymbal","items":["fingercymbals.wav","fingercymbals-large.wav","cymbal-splash-stick.wav","cymbal-sizzle-stick.wav","cymbal-ride-stick.wav","cymbal-ride-roll-short.wav","cymbal-ride-bell.wav","cymbal-ride-bell-short.wav","cymbal-hihat-stick.wav","cymbal-hihat-openclose-stick.wav","cymbal-hihat-open-stick-2.wav","cymbal-hihat-open-stick-1.wav","cymbal-hihat-foot-open.wav","cymbal-hihat-foot-2.wav","cymbal-hihat-foot-1.wav","cymbal-china-stick.wav","cymbal-china-mallet.wav"]},{"name":"cowbell","items":["cowbell-small-open.wav","cowbell-small-closed.wav","cowbell-large-open.wav","cowbell-large-closed.wav"]},{"name":"conga","items":["conga-slap-2.wav","conga-slap-1.wav","conga-open-2.wav","conga-open-1.wav","conga-muffled-2.wav","conga-muffled-1.wav"]}]},{"name":"junk-drum-kit","items":["crash-single-hit.ogg","hat-closed-single-hit.ogg","hat-open-single-hit.ogg","hi-tom-single-hit.ogg","ride-single-hit.ogg","single-hit.ogg","snare-single-hit.ogg"]}],"patches":[{"name":"default","patch":{"vcaOn":0,"vca1":{"volume":0.41,"attack":0.31,"decay":0.16,"sustain":0.8,"release":0.21},"vca2":{"volume":0.43,"attack":0,"decay":0.16,"sustain":0.8,"release":0.19},"vco1":{"on":true,"type":"square","detune":-1},"vco2":{"on":true,"type":"sawtooth","detune":1},"lfo":{"on":false,"type":"sawtooth","frequency":5,"gain":0.15},"vcf":{"on":true,"cutoff":0.64,"resonance":0,"gain":0}}},{"name":"fantasy bells","patch":{"vcaOn":1,"vca1":{"volume":0.21,"attack":0,"decay":0.16,"sustain":0.8,"release":0.52},"vca2":{"volume":0.17,"attack":0,"decay":0.16,"sustain":0.8,"release":0.55},"vco1":{"on":true,"type":"sawtooth","detune":-5},"vco2":{"on":true,"type":"sine","detune":8},"vcf":{"on":true,"cutoff":0.57,"resonance":0.37,"gain":0}}},{"name":"accordeon","patch":{"vcaOn":0,"vca1":{"volume":0.14,"attack":0.19,"decay":0.55,"sustain":0.5,"release":0.43},"vca2":{"volume":0.21,"attack":0.16,"decay":0.17,"sustain":0.47,"release":0.38},"vco1":{"on":true,"type":"square","detune":-3},"vco2":{"on":true,"type":"sawtooth","detune":3},"lfo":{"on":false,"type":"sawtooth","frequency":5,"gain":0.15},"vcf":{"on":true,"cutoff":0.51,"resonance":0.14,"gain":0}}}]},"session":{"title":"Untitled Piece","author":"Anonymous Author","bpm":104,"ticks":128,"selection":{"piano":[3,0],"seq":[0,0]},"rows":[{},{},{},{}],"active":[0,0,0,0],"tracks":[{"input":{"device":-1,"channel":10},"inst":{},"name":"Drums","type":"seq","output":{"device":-1,"channel":10},"measures":[{"name":"Sample Beat","row":0,"barsLength":1,"loop":true,"pattern":[[[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0]]],"bar":0,"channel":-1,"channels":[3,17,8,13,6]}]},{"input":{"device":-1,"channel":1},"inst":{"vcaOn":1,"vca1":{"volume":0.41,"attack":0,"decay":0.16,"sustain":0.8,"release":0.21},"vca2":{"volume":0.43,"attack":0,"decay":0.16,"sustain":0.8,"release":0.19},"vca3":{"volume":0.7,"attack":0,"decay":0.04,"sustain":0.8,"release":0.08},"vca4":{"volume":0.7,"attack":0,"decay":0.04,"sustain":0.8,"release":0.08},"vco1":{"on":true,"type":"square","detune":-1},"vco2":{"on":true,"type":"sawtooth","detune":1},"lfo":{"on":true,"expanded":true,"type":"sawtooth","frequency":0.35,"gain":76},"vcf":{"on":true,"expanded":true,"type":"lowpass","cutoff":0.43,"resonance":0.37,"gain":0},"delay":{"on":false,"expanded":true,"time":1,"dry":1,"wet":0},"reverb":{"on":true,"expanded":true,"seconds":3,"decay":2,"reverse":false,"dry":0.52,"wet":0.86}},"name":"Bassline","output":{"device":-1,"channel":1},"type":"piano","measures":[{"name":"Sample Baseline","row":0,"barsLength":"2","events":[{"note":"C4","start":12.25,"velocity":0.57,"duration":0.75,"startTime":1734.8673015873017},{"note":"C4","start":14.25,"velocity":0.63,"duration":0.75,"startTime":1735.1749659863945},{"note":"C4","start":16.25,"velocity":0.35,"duration":1,"startTime":1735.4884353741497},{"note":"C4","start":18.5,"velocity":0.37,"duration":1,"startTime":1735.8251247165533},{"note":"C4","start":20.75,"velocity":0.24,"duration":1,"startTime":1736.1560090702949},{"note":"C4","start":23,"velocity":0.44,"duration":1,"startTime":1736.4810884353742},{"note":"C4","start":1,"velocity":0.47,"duration":1,"startTime":1736.8003628117913},{"note":"C4","start":3,"velocity":0.43,"duration":1,"startTime":1737.1080272108843},{"note":"C4","start":5,"velocity":0.48,"duration":1,"startTime":1737.409886621315},{"note":"C4","start":7.25,"velocity":0.47,"duration":1,"startTime":1737.7233560090704},{"note":"C4","start":9.25,"velocity":0.5,"duration":1,"startTime":1738.019410430839},{"note":"C4","start":11.25,"velocity":0.45,"duration":1,"startTime":1738.327074829932}],"bar":0,"position":[0,60]}]},{"input":{"device":-1,"channel":1},"inst":{"vcaOn":1,"vca1":{"volume":0.41,"attack":0,"decay":0.16,"sustain":0.8,"release":0.21},"vca2":{"volume":0.43,"attack":0,"decay":0.16,"sustain":0.8,"release":0.19},"vca3":{"volume":0.7,"attack":0,"decay":0.04,"sustain":0.8,"release":0.08},"vca4":{"volume":0.7,"attack":0,"decay":0.04,"sustain":0.8,"release":0.08},"vco1":{"on":true,"type":"square","detune":-1},"vco2":{"on":true,"type":"sawtooth","detune":1},"lfo":{"on":true,"expanded":true,"type":"sawtooth","frequency":0.45,"gain":0.15},"vcf":{"on":true,"expanded":true,"type":"lowpass","cutoff":0.47,"resonance":0.6,"gain":0},"delay":{"on":false,"expanded":true,"time":1,"dry":1,"wet":0},"reverb":{"on":true,"expanded":true,"seconds":3,"decay":2,"reverse":false,"dry":0.8,"wet":0.7}},"name":"Comp 1","type":"piano","output":{"device":-1,"channel":1},"measures":[{"barsLength":"6","bar":0,"position":[0,60],"events":[{"note":"C3","start":0,"velocity":0.67,"duration":24.75,"startTime":1979.8668480725623},{"note":"D#3","start":24.5,"velocity":0.58,"duration":24.25,"startTime":1983.9419501133787},{"note":"F3","start":48.5,"velocity":0.6,"duration":23,"startTime":1987.9473922902494}]}]},{"input":{"device":-1,"channel":1},"inst":{"vcaOn":1,"vca1":{"volume":0.29,"attack":0,"decay":0.16,"sustain":0.8,"release":0.21},"vca2":{"volume":0.25,"attack":0,"decay":0.16,"sustain":0.8,"release":0.19},"vca3":{"volume":0.7,"attack":0,"decay":0.04,"sustain":0.8,"release":0.08},"vca4":{"volume":0.7,"attack":0,"decay":0.04,"sustain":0.8,"release":0.08},"vco1":{"on":true,"type":"square","detune":-1},"vco2":{"on":true,"type":"sawtooth","detune":1},"lfo":{"on":true,"expanded":true,"type":"sawtooth","frequency":1.1,"gain":0.15},"vcf":{"on":true,"expanded":true,"type":"lowpass","cutoff":0.64,"resonance":0.15,"gain":0},"delay":{"on":false,"expanded":true,"time":1,"dry":1,"wet":0},"reverb":{"on":true,"expanded":true,"seconds":3,"decay":2,"reverse":false,"dry":0.54,"wet":0.86}},"name":"Lead 1","type":"piano","output":{"device":-1,"channel":1},"measures":[{"barsLength":"6","bar":0,"position":[0,60],"events":[{"note":"C4","start":18,"velocity":0.7,"duration":0.75,"startTime":292.05478458049885},{"note":"C4","start":20,"velocity":0.7,"duration":0.5,"startTime":292.3798639455782},{"note":"C4","start":22.25,"velocity":0.7,"duration":0.5,"startTime":292.7513832199547},{"note":"C4","start":24.25,"velocity":0.7,"duration":0.5,"startTime":293.0938775510204},{"note":"C4","start":26.5,"velocity":0.7,"duration":0.5,"startTime":293.46539682539685},{"note":"C4","start":28.5,"velocity":0.7,"duration":0.5,"startTime":293.8078911564626},{"note":"C5","start":41,"velocity":0.7,"duration":0.5,"startTime":295.8918820861678},{"note":"A#4","start":51.5,"velocity":0.7,"duration":0.5,"startTime":297.61596371882086},{"note":"C5","start":53.75,"velocity":0.7,"duration":0.75,"startTime":298.01650793650794},{"note":"C5","start":56.5,"velocity":0.7,"duration":0.5,"startTime":298.4634920634921},{"note":"C6","start":0.5,"velocity":0.7,"duration":0.5,"startTime":301.1221768707483},{"note":"A#5","start":3,"velocity":0.7,"duration":0.5,"startTime":301.5691609977324},{"note":"C6","start":5.75,"velocity":0.7,"duration":0.75,"startTime":302.0103401360544}]}]}],"arrangement":[]},"sequencer":{"barsLength":1,"bar":0,"channel":-1,"channels":[3,17,8,13,6],"pattern":[[[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0]]]},"pianoRoll":{"barsLength":"6","bar":0,"position":[0,60],"events":[{"note":"C4","start":18,"velocity":0.7,"duration":0.75,"startTime":292.05478458049885},{"note":"C4","start":20,"velocity":0.7,"duration":0.5,"startTime":292.3798639455782},{"note":"C4","start":22.25,"velocity":0.7,"duration":0.5,"startTime":292.7513832199547},{"note":"C4","start":24.25,"velocity":0.7,"duration":0.5,"startTime":293.0938775510204},{"note":"C4","start":26.5,"velocity":0.7,"duration":0.5,"startTime":293.46539682539685},{"note":"C4","start":28.5,"velocity":0.7,"duration":0.5,"startTime":293.8078911564626},{"note":"C5","start":41,"velocity":0.7,"duration":0.5,"startTime":295.8918820861678},{"note":"A#4","start":51.5,"velocity":0.7,"duration":0.5,"startTime":297.61596371882086},{"note":"C5","start":53.75,"velocity":0.7,"duration":0.75,"startTime":298.01650793650794},{"note":"C5","start":56.5,"velocity":0.7,"duration":0.5,"startTime":298.4634920634921},{"note":"C6","start":0.5,"velocity":0.7,"duration":0.5,"startTime":301.1221768707483},{"note":"A#5","start":3,"velocity":0.7,"duration":0.5,"startTime":301.5691609977324},{"note":"C6","start":5.75,"velocity":0.7,"duration":0.75,"startTime":302.0103401360544}]},"midiMap":{"devices":{"access":{},"inputs":[{},{},{}],"outputs":[{},{},{}]},"settings":{"midiRouteToActive":true},"clock":{"in":[],"out":[]},"data":{"in":[-1],"out":[]},"pitch":0,"channels":{"-1":{"1":{}}},"map":[["controller",20,["instrument","vcf","cutoff"]],["controller",21,["instrument","vcf","resonance"]],["controller",22,["studio","bpm"],60,200,0],["controller",23,["studio","volume"]],["controller",24,["instrument","eg","attack"]],["controller",25,["instrument","eg","decay"]],["controller",26,["instrument","eg","sustain"]],["controller",27,["instrument","eg","release"]]]}}');

},{}],"6beJI":[function(require,module,exports) {
"use strict";
// lib
const { map, filter, distinctUntilChanged, withLatestFrom, share } = require("ec7611b0f5d52a13");
// util
const keyboard = require("5545823334eb637d");
const time = require("3226b2edd720630f");
const getDirection = (keys)=>[
        (keys.left || keys.a) && 1 || (keys.right || keys.d) && -1 || 0,
        0,
        (keys.up || keys.w) && 1 || (keys.down || keys.s) && -1 || 0
    ];
const getForce = (keys)=>(keys.shift && 0.2 || 0.1) * (keys.c && 0.5 || 1) * (keys.left || keys.right || keys.up || keys.down || keys.a || keys.d || keys.w || keys.s ? 1 : 0);
let unhook = ()=>{};
const hook = ({ state$, actions })=>{
    let subs = [];
    // Watch keyboard input
    const pressedKeys$ = keyboard.watch([
        "left",
        "right",
        "up",
        "down",
        "shift",
        "w",
        "a",
        "s",
        "d",
        "c"
    ]);
    const directionForce$ = pressedKeys$.pipe(map((keys)=>(console.log("keys", keys), keys)), map((keys)=>({
            direction: getDirection(keys),
            force: getForce(keys)
        })), share());
    // Crouch control
    subs.push(keyboard.watch([
        "c"
    ]).pipe(distinctUntilChanged((a, b)=>a.c === b.c)).subscribe((keys)=>actions.set([
            "player",
            "crouching"
        ], keys.c)));
    // Movement control
    subs.push(time.frame().pipe(withLatestFrom(directionForce$, (t, df)=>df), filter(({ force })=>force > 0)).subscribe(({ direction, force })=>actions.move(direction, force)));
    // Mouse rotation control
    subs.push(time.frame().pipe(withLatestFrom(state$, (t, state)=>state), distinctUntilChanged((a, b)=>a.viewport.mouse === b.viewport.mouse), filter((state)=>state.viewport.mouse.down)).subscribe((state)=>actions.set([
            "player",
            "rotation"
        ], Number((state.camera.range.h + state.player.rotation - state.viewport.mouse.changeX * 0.3) % state.camera.range.h))));
    // Force tracking
    subs.push(directionForce$.pipe(distinctUntilChanged((a, b)=>a.force === b.force)).subscribe(({ force })=>actions.set("player", {
            force
        })));
    unhook = ()=>subs.forEach((sub)=>sub.unsubscribe());
};
module.exports = {
    hook,
    unhook: ()=>unhook()
};

},{"ec7611b0f5d52a13":"1cs2r","5545823334eb637d":"9a2Wv","3226b2edd720630f":"1fT3w"}],"9a2Wv":[function(require,module,exports) {
"use strict";
const { fromEvent, merge } = require("c4c1bd5ebcee6945");
const { map, filter, scan, share, distinctUntilChanged } = require("4df81a3980bc04f1");
const { obj } = require("5762286dc92b7bbd");
const keyDown$ = fromEvent(document, "keydown");
const keyUp$ = fromEvent(document, "keyup");
const keyAction$ = merge(keyDown$, keyUp$);
// .map(ev => (console.log(ev), ev));
const keyAliases = {
    "ArrowUp": "up",
    "ArrowDown": "down",
    "ArrowLeft": "left",
    "ArrowRight": "right",
    " ": "space",
    "Shift": "shift"
};
const charCodes = {};
const parseKey = (ev)=>keyAliases[ev.key] || charCodes[ev.keyCode] || ev.key;
const watch = (keyList)=>keyAction$.pipe(distinctUntilChanged((a, b)=>a.type + (a.key || a.which) === b.type + (b.key || b.which)), map((ev)=>({
            type: ev.type,
            key: parseKey(ev)
        })), filter((ev)=>keyList.indexOf(ev.key) > -1), scan((keys, ev)=>obj.patch(keys, ev.key, ev.type === "keydown"), {}), share());
const on = (key)=>keyDown$.pipe(filter((ev)=>parseKey(ev) === key));
module.exports = {
    watch,
    on
};

},{"c4c1bd5ebcee6945":"hWUVi","4df81a3980bc04f1":"1cs2r","5762286dc92b7bbd":"2lXuw"}]},["5AHcD","ebWYT"], "ebWYT", "parcelRequire4e78")

//# sourceMappingURL=index.739bf03c.js.map
